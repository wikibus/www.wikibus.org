/*
 Copyright (C) Federico Zivolo 2019
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */
(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : e.Popper = t() })(this, () => {
  function e(e) { return e && {}.toString.call(e) === '[object Function]' } function t(e, t) { if (e.nodeType !== 1) return []; const o = e.ownerDocument.defaultView; const n = o.getComputedStyle(e, null); return t ? n[t] : n } function o(e) { return e.nodeName === 'HTML' ? e : e.parentNode || e.host } function n(e) { if (!e) return document.body; switch (e.nodeName) { case 'HTML':case 'BODY':return e.ownerDocument.body; case '#document':return e.body } const i = t(e); const r = i.overflow; const p = i.overflowX; const s = i.overflowY; return /(auto|scroll|overlay)/.test(r + s + p) ? e : n(o(e)) } function r(e) { return e === 11 ? pe : e === 10 ? se : pe || se } function p(e) { if (!e) return document.documentElement; for (var o = r(10) ? document.body : null, n = e.offsetParent || null; n === o && e.nextElementSibling;)n = (e = e.nextElementSibling).offsetParent; const i = n && n.nodeName; return i && i !== 'BODY' && i !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) !== -1 && t(n, 'position') === 'static' ? p(n) : n : e ? e.ownerDocument.documentElement : document.documentElement } function s(e) { const t = e.nodeName; return t !== 'BODY' && (t === 'HTML' || p(e.firstElementChild) === e) } function d(e) { return e.parentNode === null ? e : d(e.parentNode) } function a(e, t) { if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement; const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING; const n = o ? e : t; const i = o ? t : e; const r = document.createRange(); r.setStart(n, 0), r.setEnd(i, 0); const l = r.commonAncestorContainer; if (e !== l && t !== l || n.contains(i)) return s(l) ? l : p(l); const f = d(e); return f.host ? a(f.host, t) : a(e, d(t).host) } function l(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top'; const o = t === 'top' ? 'scrollTop' : 'scrollLeft'; const n = e.nodeName; if (n === 'BODY' || n === 'HTML') { const i = e.ownerDocument.documentElement; const r = e.ownerDocument.scrollingElement || i; return r[o] } return e[o] } function f(e, t) { const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const n = l(t, 'top'); const i = l(t, 'left'); const r = o ? -1 : 1; return e.top += n * r, e.bottom += n * r, e.left += i * r, e.right += i * r, e } function m(e, t) { const o = t === 'x' ? 'Left' : 'Top'; const n = o == 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${o}Width`], 10) + parseFloat(e[`border${n}Width`], 10) } function h(e, t, o, n) { return ee(t[`offset${e}`], t[`scroll${e}`], o[`client${e}`], o[`offset${e}`], o[`scroll${e}`], r(10) ? parseInt(o[`offset${e}`]) + parseInt(n[`margin${e === 'Height' ? 'Top' : 'Left'}`]) + parseInt(n[`margin${e === 'Height' ? 'Bottom' : 'Right'}`]) : 0) } function c(e) { const t = e.body; const o = e.documentElement; const n = r(10) && getComputedStyle(o); return { height: h('Height', t, o, n), width: h('Width', t, o, n) } } function g(e) { return fe({}, e, { right: e.left + e.width, bottom: e.top + e.height }) } function u(e) { let o = {}; try { if (r(10)) { o = e.getBoundingClientRect(); const n = l(e, 'top'); const i = l(e, 'left'); o.top += n, o.left += i, o.bottom += n, o.right += i } else o = e.getBoundingClientRect() } catch (t) {} const p = { left: o.left, top: o.top, width: o.right - o.left, height: o.bottom - o.top }; const s = e.nodeName === 'HTML' ? c(e.ownerDocument) : {}; const d = s.width || e.clientWidth || p.right - p.left; const a = s.height || e.clientHeight || p.bottom - p.top; let f = e.offsetWidth - d; let h = e.offsetHeight - a; if (f || h) { const u = t(e); f -= m(u, 'x'), h -= m(u, 'y'), p.width -= f, p.height -= h } return g(p) } function b(e, o) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const p = r(10); const s = o.nodeName === 'HTML'; const d = u(e); const a = u(o); const l = n(e); const m = t(o); const h = parseFloat(m.borderTopWidth, 10); const c = parseFloat(m.borderLeftWidth, 10); i && s && (a.top = ee(a.top, 0), a.left = ee(a.left, 0)); let b = g({ top: d.top - a.top - h, left: d.left - a.left - c, width: d.width, height: d.height }); if (b.marginTop = 0, b.marginLeft = 0, !p && s) { const w = parseFloat(m.marginTop, 10); const y = parseFloat(m.marginLeft, 10); b.top -= h - w, b.bottom -= h - w, b.left -= c - y, b.right -= c - y, b.marginTop = w, b.marginLeft = y } return (p && !i ? o.contains(l) : o === l && l.nodeName !== 'BODY') && (b = f(b, o)), b } function w(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const o = e.ownerDocument.documentElement; const n = b(e, o); const i = ee(o.clientWidth, window.innerWidth || 0); const r = ee(o.clientHeight, window.innerHeight || 0); const p = t ? 0 : l(o); const s = t ? 0 : l(o, 'left'); const d = { top: p - n.top + n.marginTop, left: s - n.left + n.marginLeft, width: i, height: r }; return g(d) } function y(e) { const n = e.nodeName; if (n === 'BODY' || n === 'HTML') return !1; if (t(e, 'position') === 'fixed') return !0; const i = o(e); return !!i && y(i) } function E(e) { if (!e || !e.parentElement || r()) return document.documentElement; for (var o = e.parentElement; o && t(o, 'transform') === 'none';)o = o.parentElement; return o || document.documentElement } function v(e, t, i, r) { const p = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let s = { top: 0, left: 0 }; const d = p ? E(e) : a(e, t); if (r === 'viewport')s = w(d, p); else { let l; r === 'scrollParent' ? (l = n(o(t)), l.nodeName === 'BODY' && (l = e.ownerDocument.documentElement)) : r === 'window' ? l = e.ownerDocument.documentElement : l = r; const f = b(l, d, p); if (l.nodeName === 'HTML' && !y(d)) { const m = c(e.ownerDocument); const h = m.height; const g = m.width; s.top += f.top - f.marginTop, s.bottom = h + f.top, s.left += f.left - f.marginLeft, s.right = g + f.left } else s = f }i = i || 0; const u = typeof i === 'number'; return s.left += u ? i : i.left || 0, s.top += u ? i : i.top || 0, s.right -= u ? i : i.right || 0, s.bottom -= u ? i : i.bottom || 0, s } function x(e) { const t = e.width; const o = e.height; return t * o } function O(e, t, o, n, i) { const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (e.indexOf('auto') === -1) return e; const p = v(o, n, r, i); const s = { top: { width: p.width, height: t.top - p.top }, right: { width: p.right - t.right, height: p.height }, bottom: { width: p.width, height: p.bottom - t.bottom }, left: { width: t.left - p.left, height: p.height } }; const d = Object.keys(s).map((e) => fe({ key: e }, s[e], { area: x(s[e]) })).sort((e, t) => t.area - e.area); const a = d.filter((e) => { const t = e.width; const n = e.height; return t >= o.clientWidth && n >= o.clientHeight }); const l = a.length > 0 ? a[0].key : d[0].key; const f = e.split('-')[1]; return l + (f ? `-${f}` : '') } function L(e, t, o) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const i = n ? E(t) : a(t, o); return b(o, i, n) } function S(e) { const t = e.ownerDocument.defaultView; const o = t.getComputedStyle(e); const n = parseFloat(o.marginTop || 0) + parseFloat(o.marginBottom || 0); const i = parseFloat(o.marginLeft || 0) + parseFloat(o.marginRight || 0); const r = { width: e.offsetWidth + i, height: e.offsetHeight + n }; return r } function T(e) { const t = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; return e.replace(/left|right|bottom|top/g, (e) => t[e]) } function D(e, t, o) { o = o.split('-')[0]; const n = S(e); const i = { width: n.width, height: n.height }; const r = ['right', 'left'].indexOf(o) !== -1; const p = r ? 'top' : 'left'; const s = r ? 'left' : 'top'; const d = r ? 'height' : 'width'; const a = r ? 'width' : 'height'; return i[p] = t[p] + t[d] / 2 - n[d] / 2, i[s] = o === s ? t[s] - n[a] : t[T(s)], i } function C(e, t) { return Array.prototype.find ? e.find(t) : e.filter(t)[0] } function N(e, t, o) { if (Array.prototype.findIndex) return e.findIndex((e) => e[t] === o); const n = C(e, (e) => e[t] === o); return e.indexOf(n) } function P(t, o, n) { const i = void 0 === n ? t : t.slice(0, N(t, 'name', n)); return i.forEach((t) => { t.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const n = t.function || t.fn; t.enabled && e(n) && (o.offsets.popper = g(o.offsets.popper), o.offsets.reference = g(o.offsets.reference), o = n(o, t)) }), o } function k() { if (!this.state.isDestroyed) { let e = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {} }; e.offsets.reference = L(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = D(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = P(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e)) } } function W(e, t) { return e.some((e) => { const o = e.name; const n = e.enabled; return n && o === t }) } function H(e) { for (let t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length; n++) { const i = t[n]; const r = i ? `${i}${o}` : e; if (typeof document.body.style[r] !== 'undefined') return r } return null } function B() { return this.state.isDestroyed = !0, W(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[H('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } function A(e) { const t = e.ownerDocument; return t ? t.defaultView : window } function M(e, t, o, i) { const r = e.nodeName === 'BODY'; const p = r ? e.ownerDocument.defaultView : e; p.addEventListener(t, o, { passive: !0 }), r || M(n(p.parentNode), t, o, i), i.push(p) } function F(e, t, o, i) { o.updateBound = i, A(e).addEventListener('resize', o.updateBound, { passive: !0 }); const r = n(e); return M(r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o } function I() { this.state.eventsEnabled || (this.state = F(this.reference, this.options, this.state, this.scheduleUpdate)) } function R(e, t) { return A(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.updateBound) }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t } function U() { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = R(this.reference, this.state)) } function Y(e) { return e !== '' && !isNaN(parseFloat(e)) && isFinite(e) } function j(e, t) { Object.keys(t).forEach((o) => { let n = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1 && Y(t[o]) && (n = 'px'), e.style[o] = t[o] + n }) } function V(e, t) { Object.keys(t).forEach((o) => { const n = t[o]; !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]) }) } function q(e, t) { const o = e.offsets; const n = o.popper; const i = o.reference; const r = $; const p = function (e) { return e }; const s = r(i.width); const d = r(n.width); const a = ['left', 'right'].indexOf(e.placement) !== -1; const l = e.placement.indexOf('-') !== -1; const f = t ? a || l || s % 2 == d % 2 ? r : Z : p; const m = t ? r : p; return { left: f(s % 2 == 1 && d % 2 == 1 && !l && t ? n.left - 1 : n.left), top: m(n.top), bottom: m(n.bottom), right: f(n.right) } } function K(e, t, o) { const n = C(e, (e) => { const o = e.name; return o === t }); const i = !!n && e.some((e) => e.name === o && e.enabled && e.order < n.order); if (!i) { const r = `\`${t}\``; console.warn(`\`${o}\`` + ` modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`) } return i } function z(e) { return e === 'end' ? 'start' : e === 'start' ? 'end' : e } function G(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const o = ce.indexOf(e); const n = ce.slice(o + 1).concat(ce.slice(0, o)); return t ? n.reverse() : n } function _(e, t, o, n) { const i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const r = +i[1]; const p = i[2]; if (!r) return e; if (p.indexOf('%') === 0) { let s; switch (p) { case '%p':s = o; break; case '%':case '%r':default:s = n } const d = g(s); return d[t] / 100 * r } if (p === 'vh' || p === 'vw') { let a; return a = p === 'vh' ? ee(document.documentElement.clientHeight, window.innerHeight || 0) : ee(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r } return r } function X(e, t, o, n) { const i = [0, 0]; const r = ['right', 'left'].indexOf(n) !== -1; const p = e.split(/(\+|\-)/).map((e) => e.trim()); const s = p.indexOf(C(p, (e) => e.search(/,|\s/) !== -1)); p[s] && p[s].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const d = /\s*,\s*|\s+/; let a = s === -1 ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))]; return a = a.map((e, n) => { const i = (n === 1 ? !r : r) ? 'height' : 'width'; let p = !1; return e.reduce((e, t) => e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1 ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t), []).map((e) => _(e, i, t, o)) }), a.forEach((e, t) => { e.forEach((o, n) => { Y(o) && (i[t] += o * (e[n - 1] === '-' ? -1 : 1)) }) }), i } function J(e, t) { let o; const n = t.offset; const i = e.placement; const r = e.offsets; const p = r.popper; const s = r.reference; const d = i.split('-')[0]; return o = Y(+n) ? [+n, 0] : X(n, p, s, d), d === 'left' ? (p.top += o[0], p.left -= o[1]) : d === 'right' ? (p.top += o[0], p.left += o[1]) : d === 'top' ? (p.left += o[0], p.top -= o[1]) : d === 'bottom' && (p.left += o[0], p.top += o[1]), e.popper = p, e } for (var Q = Math.min, Z = Math.floor, $ = Math.round, ee = Math.max, te = typeof window !== 'undefined' && typeof document !== 'undefined', oe = ['Edge', 'Trident', 'Firefox'], ne = 0, ie = 0; ie < oe.length; ie += 1) if (te && navigator.userAgent.indexOf(oe[ie]) >= 0) { ne = 1; break } const i = te && window.Promise; const re = i ? function (e) { let t = !1; return function () { t || (t = !0, window.Promise.resolve().then(() => { t = !1, e() })) } } : function (e) { let t = !1; return function () { t || (t = !0, setTimeout(() => { t = !1, e() }, ne)) } }; var pe = te && !!(window.MSInputMethodContext && document.documentMode); var se = te && /MSIE 10/.test(navigator.userAgent); const de = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }; const ae = (function () { function e(e, t) { for (var o, n = 0; n < t.length; n++)o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } return function (t, o, n) { return o && e(t.prototype, o), n && e(t, n), t } }()); const le = function (e, t, o) { return t in e ? Object.defineProperty(e, t, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = o, e }; var fe = Object.assign || function (e) { for (var t, o = 1; o < arguments.length; o++) for (const n in t = arguments[o], t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }; const me = te && /Firefox/i.test(navigator.userAgent); const he = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; var ce = he.slice(3); const ge = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise' }; const ue = (function () { function t(o, n) { const i = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; de(this, t), this.scheduleUpdate = function () { return requestAnimationFrame(i.update) }, this.update = re(this.update.bind(this)), this.options = fe({}, t.Defaults, r), this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = o && o.jquery ? o[0] : o, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys(fe({}, t.Defaults.modifiers, r.modifiers)).forEach((e) => { i.options.modifiers[e] = fe({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {}) }), this.modifiers = Object.keys(this.options.modifiers).map((e) => fe({ name: e }, i.options.modifiers[e])).sort((e, t) => e.order - t.order), this.modifiers.forEach((t) => { t.enabled && e(t.onLoad) && t.onLoad(i.reference, i.popper, i.options, t, i.state) }), this.update(); const p = this.options.eventsEnabled; p && this.enableEventListeners(), this.state.eventsEnabled = p } return ae(t, [{ key: 'update', value() { return k.call(this) } }, { key: 'destroy', value() { return B.call(this) } }, { key: 'enableEventListeners', value() { return I.call(this) } }, { key: 'disableEventListeners', value() { return U.call(this) } }]), t }()); return ue.Utils = (typeof window === 'undefined' ? global : window).PopperUtils, ue.placements = he, ue.Defaults = { placement: 'bottom', positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate() {}, onUpdate() {}, modifiers: { shift: { order: 100, enabled: !0, fn(e) { const t = e.placement; const o = t.split('-')[0]; const n = t.split('-')[1]; if (n) { const i = e.offsets; const r = i.reference; const p = i.popper; const s = ['bottom', 'top'].indexOf(o) !== -1; const d = s ? 'left' : 'top'; const a = s ? 'width' : 'height'; const l = { start: le({}, d, r[d]), end: le({}, d, r[d] + r[a] - p[a]) }; e.offsets.popper = fe({}, p, l[n]) } return e } }, offset: { order: 200, enabled: !0, fn: J, offset: 0 }, preventOverflow: { order: 300, enabled: !0, fn(e, t) { let o = t.boundariesElement || p(e.instance.popper); e.instance.reference === o && (o = p(o)); const n = H('transform'); const i = e.instance.popper.style; const r = i.top; const s = i.left; const d = i[n]; i.top = '', i.left = '', i[n] = ''; const a = v(e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = s, i[n] = d, t.boundaries = a; const l = t.priority; let f = e.offsets.popper; const m = { primary(e) { let o = f[e]; return f[e] < a[e] && !t.escapeWithReference && (o = ee(f[e], a[e])), le({}, e, o) }, secondary(e) { const o = e === 'right' ? 'left' : 'top'; let n = f[o]; return f[e] > a[e] && !t.escapeWithReference && (n = Q(f[o], a[e] - (e === 'right' ? f.width : f.height))), le({}, o, n) } }; return l.forEach((e) => { const t = ['left', 'top'].indexOf(e) === -1 ? 'secondary' : 'primary'; f = fe({}, f, m[t](e)) }), e.offsets.popper = f, e }, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent' }, keepTogether: { order: 400, enabled: !0, fn(e) { const t = e.offsets; const o = t.popper; const n = t.reference; const i = e.placement.split('-')[0]; const r = Z; const p = ['top', 'bottom'].indexOf(i) !== -1; const s = p ? 'right' : 'bottom'; const d = p ? 'left' : 'top'; const a = p ? 'width' : 'height'; return o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]), o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])), e } }, arrow: { order: 500, enabled: !0, fn(e, o) { let n; if (!K(e.instance.modifiers, 'arrow', 'keepTogether')) return e; let i = o.element; if (typeof i === 'string') { if (i = e.instance.popper.querySelector(i), !i) return e } else if (!e.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e; const r = e.placement.split('-')[0]; const p = e.offsets; const s = p.popper; const d = p.reference; const a = ['left', 'right'].indexOf(r) !== -1; const l = a ? 'height' : 'width'; const f = a ? 'Top' : 'Left'; const m = f.toLowerCase(); const h = a ? 'left' : 'top'; const c = a ? 'bottom' : 'right'; const u = S(i)[l]; d[c] - u < s[m] && (e.offsets.popper[m] -= s[m] - (d[c] - u)), d[m] + u > s[c] && (e.offsets.popper[m] += d[m] + u - s[c]), e.offsets.popper = g(e.offsets.popper); const b = d[m] + d[l] / 2 - u / 2; const w = t(e.instance.popper); const y = parseFloat(w[`margin${f}`], 10); const E = parseFloat(w[`border${f}Width`], 10); let v = b - e.offsets.popper[m] - y - E; return v = ee(Q(s[l] - u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, le(n, m, $(v)), le(n, h, ''), n), e }, element: '[x-arrow]' }, flip: { order: 600, enabled: !0, fn(e, t) { if (W(e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; const o = v(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed); let n = e.placement.split('-')[0]; let i = T(n); let r = e.placement.split('-')[1] || ''; let p = []; switch (t.behavior) { case ge.FLIP:p = [n, i]; break; case ge.CLOCKWISE:p = G(n); break; case ge.COUNTERCLOCKWISE:p = G(n, !0); break; default:p = t.behavior } return p.forEach((s, d) => { if (n !== s || p.length === d + 1) return e; n = e.placement.split('-')[0], i = T(n); const a = e.offsets.popper; const l = e.offsets.reference; const f = Z; const m = n === 'left' && f(a.right) > f(l.left) || n === 'right' && f(a.left) < f(l.right) || n === 'top' && f(a.bottom) > f(l.top) || n === 'bottom' && f(a.top) < f(l.bottom); const h = f(a.left) < f(o.left); const c = f(a.right) > f(o.right); const g = f(a.top) < f(o.top); const u = f(a.bottom) > f(o.bottom); const b = n === 'left' && h || n === 'right' && c || n === 'top' && g || n === 'bottom' && u; const w = ['top', 'bottom'].indexOf(n) !== -1; const y = !!t.flipVariations && (w && r === 'start' && h || w && r === 'end' && c || !w && r === 'start' && g || !w && r === 'end' && u); (m || b || y) && (e.flipped = !0, (m || b) && (n = p[d + 1]), y && (r = z(r)), e.placement = n + (r ? `-${r}` : ''), e.offsets.popper = fe({}, e.offsets.popper, D(e.instance.popper, e.offsets.reference, e.placement)), e = P(e.instance.modifiers, e, 'flip')) }), e }, behavior: 'flip', padding: 5, boundariesElement: 'viewport' }, inner: { order: 700, enabled: !1, fn(e) { const t = e.placement; const o = t.split('-')[0]; const n = e.offsets; const i = n.popper; const r = n.reference; const p = ['left', 'right'].indexOf(o) !== -1; const s = ['top', 'left'].indexOf(o) === -1; return i[p ? 'left' : 'top'] = r[o] - (s ? i[p ? 'width' : 'height'] : 0), e.placement = T(t), e.offsets.popper = g(i), e } }, hide: { order: 800, enabled: !0, fn(e) { if (!K(e.instance.modifiers, 'hide', 'preventOverflow')) return e; const t = e.offsets.reference; const o = C(e.instance.modifiers, (e) => e.name === 'preventOverflow').boundaries; if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) { if (!0 === e.hide) return e; e.hide = !0, e.attributes['x-out-of-boundaries'] = '' } else { if (!1 === e.hide) return e; e.hide = !1, e.attributes['x-out-of-boundaries'] = !1 } return e } }, computeStyle: { order: 850, enabled: !0, fn(e, t) { const o = t.x; const n = t.y; const i = e.offsets.popper; const r = C(e.instance.modifiers, (e) => e.name === 'applyStyle').gpuAcceleration; void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); let s; let d; const a = void 0 === r ? t.gpuAcceleration : r; const l = p(e.instance.popper); const f = u(l); const m = { position: i.position }; const h = q(e, window.devicePixelRatio < 2 || !me); const c = o === 'bottom' ? 'top' : 'bottom'; const g = n === 'right' ? 'left' : 'right'; const b = H('transform'); if (d = c == 'bottom' ? l.nodeName === 'HTML' ? -l.clientHeight + h.bottom : -f.height + h.bottom : h.top, s = g == 'right' ? l.nodeName === 'HTML' ? -l.clientWidth + h.right : -f.width + h.right : h.left, a && b)m[b] = `translate3d(${s}px, ${d}px, 0)`, m[c] = 0, m[g] = 0, m.willChange = 'transform'; else { const w = c == 'bottom' ? -1 : 1; const y = g == 'right' ? -1 : 1; m[c] = d * w, m[g] = s * y, m.willChange = `${c}, ${g}` } const E = { 'x-placement': e.placement }; return e.attributes = fe({}, E, e.attributes), e.styles = fe({}, m, e.styles), e.arrowStyles = fe({}, e.offsets.arrow, e.arrowStyles), e }, gpuAcceleration: !0, x: 'bottom', y: 'right' }, applyStyle: { order: 900, enabled: !0, fn(e) { return j(e.instance.popper, e.styles), V(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && j(e.arrowElement, e.arrowStyles), e }, onLoad(e, t, o, n, i) { const r = L(i, t, e, o.positionFixed); const p = O(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute('x-placement', p), j(t, { position: o.positionFixed ? 'fixed' : 'absolute' }), o }, gpuAcceleration: void 0 } } }, ue
})

/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports, require('jquery'), require('popper.js')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery', 'popper.js'], e) : e((t = t || self).bootstrap = {}, t.jQuery, t.Popper) }(this, (t, g, u) => {
  function i(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function s(t, e, n) { return e && i(t.prototype, e), n && i(t, n), t } function l(o) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; let e = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (e = e.concat(Object.getOwnPropertySymbols(r).filter((t) => Object.getOwnPropertyDescriptor(r, t).enumerable))), e.forEach((t) => { let e, n, i; e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = i }) } return o }g = g && g.hasOwnProperty('default') ? g.default : g, u = u && u.hasOwnProperty('default') ? u.default : u; const e = 'transitionend'; function n(t) { const e = this; let n = !1; return g(this).one(_.TRANSITION_END, () => { n = !0 }), setTimeout(() => { n || _.triggerTransitionEnd(e) }, t), this } var _ = { TRANSITION_END: 'bsTransitionEnd', getUID(t) { for (;t += ~~(1e6 * Math.random()), document.getElementById(t););return t }, getSelectorFromElement(t) { let e = t.getAttribute('data-target'); if (!e || e === '#') { const n = t.getAttribute('href'); e = n && n !== '#' ? n.trim() : '' } try { return document.querySelector(e) ? e : null } catch (t) { return null } }, getTransitionDurationFromElement(t) { if (!t) return 0; let e = g(t).css('transition-duration'); let n = g(t).css('transition-delay'); const i = parseFloat(e); const o = parseFloat(n); return i || o ? (e = e.split(',')[0], n = n.split(',')[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0 }, reflow(t) { return t.offsetHeight }, triggerTransitionEnd(t) { g(t).trigger(e) }, supportsTransitionEnd() { return Boolean(e) }, isElement(t) { return (t[0] || t).nodeType }, typeCheckConfig(t, e, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const o = n[i]; const r = e[i]; const s = r && _.isElement(r) ? 'element' : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase()); if (!new RegExp(o).test(s)) throw new Error(`${t.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${o}".`) } let a }, findShadowRoot(t) { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode !== 'function') return t instanceof ShadowRoot ? t : t.parentNode ? _.findShadowRoot(t.parentNode) : null; const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } }; g.fn.emulateTransitionEnd = n, g.event.special[_.TRANSITION_END] = { bindType: e, delegateType: e, handle(t) { if (g(t.target).is(this)) return t.handleObj.handler.apply(this, arguments) } }; const o = 'alert'; const r = 'bs.alert'; const a = `.${r}`; const c = g.fn[o]; const h = { CLOSE: `close${a}`, CLOSED: `closed${a}`, CLICK_DATA_API: `click${a}.data-api` }; const f = 'alert'; const d = 'fade'; const m = 'show'; const p = (function () { function i(t) { this._element = t } const t = i.prototype; return t.close = function (t) { let e = this._element; t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e) }, t.dispose = function () { g.removeData(this._element, r), this._element = null }, t._getRootElement = function (t) { const e = _.getSelectorFromElement(t); let n = !1; return e && (n = document.querySelector(e)), n || (n = g(t).closest(`.${f}`)[0]), n }, t._triggerCloseEvent = function (t) { const e = g.Event(h.CLOSE); return g(t).trigger(e), e }, t._removeElement = function (e) { const n = this; if (g(e).removeClass(m), g(e).hasClass(d)) { const t = _.getTransitionDurationFromElement(e); g(e).one(_.TRANSITION_END, (t) => n._destroyElement(e, t)).emulateTransitionEnd(t) } else this._destroyElement(e) }, t._destroyElement = function (t) { g(t).detach().trigger(h.CLOSED).remove() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(r); e || (e = new i(this), t.data(r, e)), n === 'close' && e[n](this) }) }, i._handleDismiss = function (e) { return function (t) { t && t.preventDefault(), e.close(this) } }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), i }()); g(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', p._handleDismiss(new p())), g.fn[o] = p._jQueryInterface, g.fn[o].Constructor = p, g.fn[o].noConflict = function () { return g.fn[o] = c, p._jQueryInterface }; const v = 'button'; const y = 'bs.button'; const E = `.${y}`; const C = '.data-api'; const T = g.fn[v]; const S = 'active'; const b = 'btn'; const I = 'focus'; const D = '[data-toggle^="button"]'; const w = '[data-toggle="buttons"]'; const A = 'input:not([type="hidden"])'; const N = '.active'; const O = '.btn'; const k = { CLICK_DATA_API: `click${E}${C}`, FOCUS_BLUR_DATA_API: `focus${E}${C} blur${E}${C}` }; const P = (function () { function n(t) { this._element = t } const t = n.prototype; return t.toggle = function () { let t = !0; let e = !0; const n = g(this._element).closest(w)[0]; if (n) { const i = this._element.querySelector(A); if (i) { if (i.type === 'radio') if (i.checked && this._element.classList.contains(S))t = !1; else { const o = n.querySelector(N); o && g(o).removeClass(S) } if (t) { if (i.hasAttribute('disabled') || n.hasAttribute('disabled') || i.classList.contains('disabled') || n.classList.contains('disabled')) return; i.checked = !this._element.classList.contains(S), g(i).trigger('change') }i.focus(), e = !1 } }e && this._element.setAttribute('aria-pressed', !this._element.classList.contains(S)), t && g(this._element).toggleClass(S) }, t.dispose = function () { g.removeData(this._element, y), this._element = null }, n._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(y); t || (t = new n(this), g(this).data(y, t)), e === 'toggle' && t[e]() }) }, s(n, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), n }()); g(document).on(k.CLICK_DATA_API, D, (t) => { t.preventDefault(); let e = t.target; g(e).hasClass(b) || (e = g(e).closest(O)), P._jQueryInterface.call(g(e), 'toggle') }).on(k.FOCUS_BLUR_DATA_API, D, (t) => { const e = g(t.target).closest(O)[0]; g(e).toggleClass(I, /^focus(in)?$/.test(t.type)) }), g.fn[v] = P._jQueryInterface, g.fn[v].Constructor = P, g.fn[v].noConflict = function () { return g.fn[v] = T, P._jQueryInterface }; const L = 'carousel'; const j = 'bs.carousel'; const H = `.${j}`; const R = '.data-api'; const x = g.fn[L]; const F = { interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0 }; const U = { interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean' }; const W = 'next'; const q = 'prev'; const M = 'left'; const K = 'right'; const Q = { SLIDE: `slide${H}`, SLID: `slid${H}`, KEYDOWN: `keydown${H}`, MOUSEENTER: `mouseenter${H}`, MOUSELEAVE: `mouseleave${H}`, TOUCHSTART: `touchstart${H}`, TOUCHMOVE: `touchmove${H}`, TOUCHEND: `touchend${H}`, POINTERDOWN: `pointerdown${H}`, POINTERUP: `pointerup${H}`, DRAG_START: `dragstart${H}`, LOAD_DATA_API: `load${H}${R}`, CLICK_DATA_API: `click${H}${R}` }; const B = 'carousel'; const V = 'active'; const Y = 'slide'; const z = 'carousel-item-right'; const X = 'carousel-item-left'; const $ = 'carousel-item-next'; const G = 'carousel-item-prev'; const J = 'pointer-event'; const Z = '.active'; const tt = '.active.carousel-item'; const et = '.carousel-item'; const nt = '.carousel-item img'; const it = '.carousel-item-next, .carousel-item-prev'; const ot = '.carousel-indicators'; const rt = '[data-slide], [data-slide-to]'; const st = '[data-ride="carousel"]'; const at = { TOUCH: 'touch', PEN: 'pen' }; const lt = (function () { function r(t, e) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(ot), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners() } const t = r.prototype; return t.next = function () { this._isSliding || this._slide(W) }, t.nextWhenVisible = function () { !document.hidden && g(this._element).is(':visible') && g(this._element).css('visibility') !== 'hidden' && this.next() }, t.prev = function () { this._isSliding || this._slide(q) }, t.pause = function (t) { t || (this._isPaused = !0), this._element.querySelector(it) && (_.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null }, t.cycle = function (t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) }, t.to = function (t) { const e = this; this._activeElement = this._element.querySelector(tt); const n = this._getItemIndex(this._activeElement); if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding)g(this._element).one(Q.SLID, () => e.to(t)); else { if (n === t) return this.pause(), void this.cycle(); const i = n < t ? W : q; this._slide(i, this._items[t]) } }, t.dispose = function () { g(this._element).off(H), g.removeData(this._element, j), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null }, t._getConfig = function (t) { return t = l({}, F, t), _.typeCheckConfig(L, t, U), t }, t._handleSwipe = function () { const t = Math.abs(this.touchDeltaX); if (!(t <= 40)) { const e = t / this.touchDeltaX; e > 0 && this.prev(), e < 0 && this.next() } }, t._addEventListeners = function () { const e = this; this._config.keyboard && g(this._element).on(Q.KEYDOWN, (t) => e._keydown(t)), this._config.pause === 'hover' && g(this._element).on(Q.MOUSEENTER, (t) => e.pause(t)).on(Q.MOUSELEAVE, (t) => e.cycle(t)), this._config.touch && this._addTouchEventListeners() }, t._addTouchEventListeners = function () { const n = this; if (this._touchSupported) { const e = function (t) { n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX) }; const i = function (t) { n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), n._config.pause === 'hover' && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout((t) => n.cycle(t), 500 + n._config.interval)) }; g(this._element.querySelectorAll(nt)).on(Q.DRAG_START, (t) => t.preventDefault()), this._pointerEvent ? (g(this._element).on(Q.POINTERDOWN, (t) => e(t)), g(this._element).on(Q.POINTERUP, (t) => i(t)), this._element.classList.add(J)) : (g(this._element).on(Q.TOUCHSTART, (t) => e(t)), g(this._element).on(Q.TOUCHMOVE, (t) => { let e; (e = t).originalEvent.touches && e.originalEvent.touches.length > 1 ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX }), g(this._element).on(Q.TOUCHEND, (t) => i(t))) } }, t._keydown = function (t) { if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) { case 37:t.preventDefault(), this.prev(); break; case 39:t.preventDefault(), this.next() } }, t._getItemIndex = function (t) { return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(et)) : [], this._items.indexOf(t) }, t._getItemByDirection = function (t, e) { const n = t === W; const i = t === q; const o = this._getItemIndex(e); const r = this._items.length - 1; if ((i && o === 0 || n && o === r) && !this._config.wrap) return e; const s = (o + (t === q ? -1 : 1)) % this._items.length; return s === -1 ? this._items[this._items.length - 1] : this._items[s] }, t._triggerSlideEvent = function (t, e) { const n = this._getItemIndex(t); const i = this._getItemIndex(this._element.querySelector(tt)); const o = g.Event(Q.SLIDE, { relatedTarget: t, direction: e, from: i, to: n }); return g(this._element).trigger(o), o }, t._setActiveIndicatorElement = function (t) { if (this._indicatorsElement) { const e = [].slice.call(this._indicatorsElement.querySelectorAll(Z)); g(e).removeClass(V); const n = this._indicatorsElement.children[this._getItemIndex(t)]; n && g(n).addClass(V) } }, t._slide = function (t, e) { let n; let i; let o; const r = this; const s = this._element.querySelector(tt); const a = this._getItemIndex(s); const l = e || s && this._getItemByDirection(t, s); const c = this._getItemIndex(l); const h = Boolean(this._interval); if (o = t === W ? (n = X, i = $, M) : (n = z, i = G, K), l && g(l).hasClass(V)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) { this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l); const u = g.Event(Q.SLID, { relatedTarget: l, direction: o, from: a, to: c }); if (g(this._element).hasClass(Y)) { g(l).addClass(i), _.reflow(l), g(s).addClass(n), g(l).addClass(n); const f = parseInt(l.getAttribute('data-interval'), 10); this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval; const d = _.getTransitionDurationFromElement(s); g(s).one(_.TRANSITION_END, () => { g(l).removeClass(`${n} ${i}`).addClass(V), g(s).removeClass(`${V} ${i} ${n}`), r._isSliding = !1, setTimeout(() => g(r._element).trigger(u), 0) }).emulateTransitionEnd(d) } else g(s).removeClass(V), g(l).addClass(V), this._isSliding = !1, g(this._element).trigger(u); h && this.cycle() } }, r._jQueryInterface = function (i) { return this.each(function () { let t = g(this).data(j); let e = l({}, F, g(this).data()); typeof i === 'object' && (e = l({}, e, i)); const n = typeof i === 'string' ? i : e.slide; if (t || (t = new r(this, e), g(this).data(j, t)), typeof i === 'number')t.to(i); else if (typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } else e.interval && e.ride && (t.pause(), t.cycle()) }) }, r._dataApiClickHandler = function (t) { const e = _.getSelectorFromElement(this); if (e) { const n = g(e)[0]; if (n && g(n).hasClass(B)) { const i = l({}, g(n).data(), g(this).data()); const o = this.getAttribute('data-slide-to'); o && (i.interval = !1), r._jQueryInterface.call(g(n), i), o && g(n).data(j).to(o), t.preventDefault() } } }, s(r, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return F } }]), r }()); g(document).on(Q.CLICK_DATA_API, rt, lt._dataApiClickHandler), g(window).on(Q.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(st)), e = 0, n = t.length; e < n; e++) { const i = g(t[e]); lt._jQueryInterface.call(i, i.data()) } }), g.fn[L] = lt._jQueryInterface, g.fn[L].Constructor = lt, g.fn[L].noConflict = function () { return g.fn[L] = x, lt._jQueryInterface }; const ct = 'collapse'; const ht = 'bs.collapse'; const ut = `.${ht}`; const ft = g.fn[ct]; const dt = { toggle: !0, parent: '' }; const gt = { toggle: 'boolean', parent: '(string|element)' }; const _t = { SHOW: `show${ut}`, SHOWN: `shown${ut}`, HIDE: `hide${ut}`, HIDDEN: `hidden${ut}`, CLICK_DATA_API: `click${ut}.data-api` }; const mt = 'show'; const pt = 'collapse'; const vt = 'collapsing'; const yt = 'collapsed'; const Et = 'width'; const Ct = 'height'; const Tt = '.show, .collapsing'; const St = '[data-toggle="collapse"]'; const bt = (function () { function a(e, t) { this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll(`[data-toggle="collapse"][href="#${e.id}"],[data-toggle="collapse"][data-target="#${e.id}"]`)); for (let n = [].slice.call(document.querySelectorAll(St)), i = 0, o = n.length; i < o; i++) { const r = n[i]; const s = _.getSelectorFromElement(r); const a = [].slice.call(document.querySelectorAll(s)).filter((t) => t === e); s !== null && a.length > 0 && (this._selector = s, this._triggerArray.push(r)) } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle() } const t = a.prototype; return t.toggle = function () { g(this._element).hasClass(mt) ? this.hide() : this.show() }, t.show = function () { let t; let e; const n = this; if (!this._isTransitioning && !g(this._element).hasClass(mt) && (this._parent && (t = [].slice.call(this._parent.querySelectorAll(Tt)).filter((t) => typeof n._config.parent === 'string' ? t.getAttribute('data-parent') === n._config.parent : t.classList.contains(pt))).length === 0 && (t = null), !(t && (e = g(t).not(this._selector).data(ht)) && e._isTransitioning))) { const i = g.Event(_t.SHOW); if (g(this._element).trigger(i), !i.isDefaultPrevented()) { t && (a._jQueryInterface.call(g(t).not(this._selector), 'hide'), e || g(t).data(ht, null)); const o = this._getDimension(); g(this._element).removeClass(pt).addClass(vt), this._element.style[o] = 0, this._triggerArray.length && g(this._triggerArray).removeClass(yt).attr('aria-expanded', !0), this.setTransitioning(!0); const r = `scroll${o[0].toUpperCase() + o.slice(1)}`; const s = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, () => { g(n._element).removeClass(vt).addClass(pt).addClass(mt), n._element.style[o] = '', n.setTransitioning(!1), g(n._element).trigger(_t.SHOWN) }).emulateTransitionEnd(s), this._element.style[o] = `${this._element[r]}px` } } }, t.hide = function () { const t = this; if (!this._isTransitioning && g(this._element).hasClass(mt)) { const e = g.Event(_t.HIDE); if (g(this._element).trigger(e), !e.isDefaultPrevented()) { const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, _.reflow(this._element), g(this._element).addClass(vt).removeClass(pt).removeClass(mt); const i = this._triggerArray.length; if (i > 0) for (let o = 0; o < i; o++) { const r = this._triggerArray[o]; const s = _.getSelectorFromElement(r); if (s !== null)g([].slice.call(document.querySelectorAll(s))).hasClass(mt) || g(r).addClass(yt).attr('aria-expanded', !1) } this.setTransitioning(!0); this._element.style[n] = ''; const a = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, () => { t.setTransitioning(!1), g(t._element).removeClass(vt).addClass(pt).trigger(_t.HIDDEN) }).emulateTransitionEnd(a) } } }, t.setTransitioning = function (t) { this._isTransitioning = t }, t.dispose = function () { g.removeData(this._element, ht), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null }, t._getConfig = function (t) { return (t = l({}, dt, t)).toggle = Boolean(t.toggle), _.typeCheckConfig(ct, t, gt), t }, t._getDimension = function () { return g(this._element).hasClass(Et) ? Et : Ct }, t._getParent = function () { let t; const n = this; _.isElement(this._config.parent) ? (t = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent); const e = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; const i = [].slice.call(t.querySelectorAll(e)); return g(i).each((t, e) => { n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]) }), t }, t._addAriaAndCollapsedClass = function (t, e) { const n = g(t).hasClass(mt); e.length && g(e).toggleClass(yt, !n).attr('aria-expanded', n) }, a._getTargetFromElement = function (t) { const e = _.getSelectorFromElement(t); return e ? document.querySelector(e) : null }, a._jQueryInterface = function (i) { return this.each(function () { const t = g(this); let e = t.data(ht); const n = l({}, dt, t.data(), typeof i === 'object' && i ? i : {}); if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ht, e)), typeof i === 'string') { if (typeof e[i] === 'undefined') throw new TypeError(`No method named "${i}"`); e[i]() } }) }, s(a, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return dt } }]), a }()); g(document).on(_t.CLICK_DATA_API, St, function (t) { t.currentTarget.tagName === 'A' && t.preventDefault(); const n = g(this); const e = _.getSelectorFromElement(this); const i = [].slice.call(document.querySelectorAll(e)); g(i).each(function () { const t = g(this); const e = t.data(ht) ? 'toggle' : n.data(); bt._jQueryInterface.call(t, e) }) }), g.fn[ct] = bt._jQueryInterface, g.fn[ct].Constructor = bt, g.fn[ct].noConflict = function () { return g.fn[ct] = ft, bt._jQueryInterface }; const It = 'dropdown'; const Dt = 'bs.dropdown'; const wt = `.${Dt}`; const At = '.data-api'; const Nt = g.fn[It]; const Ot = new RegExp('38|40|27'); const kt = { HIDE: `hide${wt}`, HIDDEN: `hidden${wt}`, SHOW: `show${wt}`, SHOWN: `shown${wt}`, CLICK: `click${wt}`, CLICK_DATA_API: `click${wt}${At}`, KEYDOWN_DATA_API: `keydown${wt}${At}`, KEYUP_DATA_API: `keyup${wt}${At}` }; const Pt = 'disabled'; const Lt = 'show'; const jt = 'dropup'; const Ht = 'dropright'; const Rt = 'dropleft'; const xt = 'dropdown-menu-right'; const Ft = 'position-static'; const Ut = '[data-toggle="dropdown"]'; const Wt = '.dropdown form'; const qt = '.dropdown-menu'; const Mt = '.navbar-nav'; const Kt = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'; const Qt = 'top-start'; const Bt = 'top-end'; const Vt = 'bottom-start'; const Yt = 'bottom-end'; const zt = 'right-start'; const Xt = 'left-start'; const $t = { offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic' }; const Gt = { offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string' }; const Jt = (function () { function c(t, e) { this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners() } const t = c.prototype; return t.toggle = function () { if (!this._element.disabled && !g(this._element).hasClass(Pt)) { const t = c._getParentFromElement(this._element); const e = g(this._menu).hasClass(Lt); if (c._clearMenus(), !e) { const n = { relatedTarget: this._element }; const i = g.Event(kt.SHOW, n); if (g(t).trigger(i), !i.isDefaultPrevented()) { if (!this._inNavbar) { if (typeof u === 'undefined') throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)"); let o = this._element; this._config.reference === 'parent' ? o = t : _.isElement(this._config.reference) && (o = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (o = this._config.reference[0])), this._config.boundary !== 'scrollParent' && g(t).addClass(Ft), this._popper = new u(o, this._menu, this._getPopperConfig()) }'ontouchstart' in document.documentElement && g(t).closest(Mt).length === 0 && g(document.body).children().on('mouseover', null, g.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), g(this._menu).toggleClass(Lt), g(t).toggleClass(Lt).trigger(g.Event(kt.SHOWN, n)) } } } }, t.show = function () { if (!(this._element.disabled || g(this._element).hasClass(Pt) || g(this._menu).hasClass(Lt))) { const t = { relatedTarget: this._element }; const e = g.Event(kt.SHOW, t); const n = c._getParentFromElement(this._element); g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.SHOWN, t))) } }, t.hide = function () { if (!this._element.disabled && !g(this._element).hasClass(Pt) && g(this._menu).hasClass(Lt)) { const t = { relatedTarget: this._element }; const e = g.Event(kt.HIDE, t); const n = c._getParentFromElement(this._element); g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.HIDDEN, t))) } }, t.dispose = function () { g.removeData(this._element, Dt), g(this._element).off(wt), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null) }, t.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate() }, t._addEventListeners = function () { const e = this; g(this._element).on(kt.CLICK, (t) => { t.preventDefault(), t.stopPropagation(), e.toggle() }) }, t._getConfig = function (t) { return t = l({}, this.constructor.Default, g(this._element).data(), t), _.typeCheckConfig(It, t, this.constructor.DefaultType), t }, t._getMenuElement = function () { if (!this._menu) { const t = c._getParentFromElement(this._element); t && (this._menu = t.querySelector(qt)) } return this._menu }, t._getPlacement = function () { const t = g(this._element.parentNode); let e = Vt; return t.hasClass(jt) ? (e = Qt, g(this._menu).hasClass(xt) && (e = Bt)) : t.hasClass(Ht) ? e = zt : t.hasClass(Rt) ? e = Xt : g(this._menu).hasClass(xt) && (e = Yt), e }, t._detectNavbar = function () { return g(this._element).closest('.navbar').length > 0 }, t._getOffset = function () { const e = this; const t = {}; return typeof this._config.offset === 'function' ? t.fn = function (t) { return t.offsets = l({}, t.offsets, e._config.offset(t.offsets, e._element) || {}), t } : t.offset = this._config.offset, t }, t._getPopperConfig = function () { const t = { placement: this._getPlacement(), modifiers: { offset: this._getOffset(), flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (t.modifiers.applyStyle = { enabled: !1 }), t }, c._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(Dt); if (t || (t = new c(this, typeof e === 'object' ? e : null), g(this).data(Dt, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e]() } }) }, c._clearMenus = function (t) { if (!t || t.which !== 3 && (t.type !== 'keyup' || t.which === 9)) for (let e = [].slice.call(document.querySelectorAll(Ut)), n = 0, i = e.length; n < i; n++) { const o = c._getParentFromElement(e[n]); const r = g(e[n]).data(Dt); const s = { relatedTarget: e[n] }; if (t && t.type === 'click' && (s.clickEvent = t), r) { const a = r._menu; if (g(o).hasClass(Lt) && !(t && (t.type === 'click' && /input|textarea/i.test(t.target.tagName) || t.type === 'keyup' && t.which === 9) && g.contains(o, t.target))) { const l = g.Event(kt.HIDE, s); g(o).trigger(l), l.isDefaultPrevented() || ('ontouchstart' in document.documentElement && g(document.body).children().off('mouseover', null, g.noop), e[n].setAttribute('aria-expanded', 'false'), g(a).removeClass(Lt), g(o).removeClass(Lt).trigger(g.Event(kt.HIDDEN, s))) } } } }, c._getParentFromElement = function (t) { let e; const n = _.getSelectorFromElement(t); return n && (e = document.querySelector(n)), e || t.parentNode }, c._dataApiKeydownHandler = function (t) { if ((/input|textarea/i.test(t.target.tagName) ? !(t.which === 32 || t.which !== 27 && (t.which !== 40 && t.which !== 38 || g(t.target).closest(qt).length)) : Ot.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !g(this).hasClass(Pt))) { const e = c._getParentFromElement(this); const n = g(e).hasClass(Lt); if (n && (!n || t.which !== 27 && t.which !== 32)) { const i = [].slice.call(e.querySelectorAll(Kt)); if (i.length !== 0) { let o = i.indexOf(t.target); t.which === 38 && o > 0 && o--, t.which === 40 && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus() } } else { if (t.which === 27) { const r = e.querySelector(Ut); g(r).trigger('focus') }g(this).trigger('click') } } }, s(c, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return $t } }, { key: 'DefaultType', get() { return Gt } }]), c }()); g(document).on(kt.KEYDOWN_DATA_API, Ut, Jt._dataApiKeydownHandler).on(kt.KEYDOWN_DATA_API, qt, Jt._dataApiKeydownHandler).on(`${kt.CLICK_DATA_API} ${kt.KEYUP_DATA_API}`, Jt._clearMenus).on(kt.CLICK_DATA_API, Ut, function (t) { t.preventDefault(), t.stopPropagation(), Jt._jQueryInterface.call(g(this), 'toggle') }).on(kt.CLICK_DATA_API, Wt, (t) => { t.stopPropagation() }), g.fn[It] = Jt._jQueryInterface, g.fn[It].Constructor = Jt, g.fn[It].noConflict = function () { return g.fn[It] = Nt, Jt._jQueryInterface }; const Zt = 'modal'; const te = 'bs.modal'; const ee = `.${te}`; const ne = g.fn[Zt]; const ie = { backdrop: !0, keyboard: !0, focus: !0, show: !0 }; const oe = { backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean' }; const re = { HIDE: `hide${ee}`, HIDDEN: `hidden${ee}`, SHOW: `show${ee}`, SHOWN: `shown${ee}`, FOCUSIN: `focusin${ee}`, RESIZE: `resize${ee}`, CLICK_DISMISS: `click.dismiss${ee}`, KEYDOWN_DISMISS: `keydown.dismiss${ee}`, MOUSEUP_DISMISS: `mouseup.dismiss${ee}`, MOUSEDOWN_DISMISS: `mousedown.dismiss${ee}`, CLICK_DATA_API: `click${ee}.data-api` }; const se = 'modal-dialog-scrollable'; const ae = 'modal-scrollbar-measure'; const le = 'modal-backdrop'; const ce = 'modal-open'; const he = 'fade'; const ue = 'show'; const fe = '.modal-dialog'; const de = '.modal-body'; const ge = '[data-toggle="modal"]'; const _e = '[data-dismiss="modal"]'; const me = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const pe = '.sticky-top'; const ve = (function () { function o(t, e) { this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(fe), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0 } const t = o.prototype; return t.toggle = function (t) { return this._isShown ? this.hide() : this.show(t) }, t.show = function (t) { const e = this; if (!this._isShown && !this._isTransitioning) { g(this._element).hasClass(he) && (this._isTransitioning = !0); const n = g.Event(re.SHOW, { relatedTarget: t }); g(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), g(this._element).on(re.CLICK_DISMISS, _e, (t) => e.hide(t)), g(this._dialog).on(re.MOUSEDOWN_DISMISS, () => { g(e._element).one(re.MOUSEUP_DISMISS, (t) => { g(t.target).is(e._element) && (e._ignoreBackdropClick = !0) }) }), this._showBackdrop(() => e._showElement(t))) } }, t.hide = function (t) { const e = this; if (t && t.preventDefault(), this._isShown && !this._isTransitioning) { const n = g.Event(re.HIDE); if (g(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const i = g(this._element).hasClass(he); if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), g(document).off(re.FOCUSIN), g(this._element).removeClass(ue), g(this._element).off(re.CLICK_DISMISS), g(this._dialog).off(re.MOUSEDOWN_DISMISS), i) { const o = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, (t) => e._hideModal(t)).emulateTransitionEnd(o) } else this._hideModal() } } }, t.dispose = function () { [window, this._element, this._dialog].forEach((t) => g(t).off(ee)), g(document).off(re.FOCUSIN), g.removeData(this._element, te), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null }, t.handleUpdate = function () { this._adjustDialog() }, t._getConfig = function (t) { return t = l({}, ie, t), _.typeCheckConfig(Zt, t, oe), t }, t._showElement = function (t) { const e = this; const n = g(this._element).hasClass(he); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), g(this._dialog).hasClass(se) ? this._dialog.querySelector(de).scrollTop = 0 : this._element.scrollTop = 0, n && _.reflow(this._element), g(this._element).addClass(ue), this._config.focus && this._enforceFocus(); const i = g.Event(re.SHOWN, { relatedTarget: t }); const o = function () { e._config.focus && e._element.focus(), e._isTransitioning = !1, g(e._element).trigger(i) }; if (n) { const r = _.getTransitionDurationFromElement(this._dialog); g(this._dialog).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o() }, t._enforceFocus = function () { const e = this; g(document).off(re.FOCUSIN).on(re.FOCUSIN, (t) => { document !== t.target && e._element !== t.target && g(e._element).has(t.target).length === 0 && e._element.focus() }) }, t._setEscapeEvent = function () { const e = this; this._isShown && this._config.keyboard ? g(this._element).on(re.KEYDOWN_DISMISS, (t) => { t.which === 27 && (t.preventDefault(), e.hide()) }) : this._isShown || g(this._element).off(re.KEYDOWN_DISMISS) }, t._setResizeEvent = function () { const e = this; this._isShown ? g(window).on(re.RESIZE, (t) => e.handleUpdate(t)) : g(window).off(re.RESIZE) }, t._hideModal = function () { const t = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._isTransitioning = !1, this._showBackdrop(() => { g(document.body).removeClass(ce), t._resetAdjustments(), t._resetScrollbar(), g(t._element).trigger(re.HIDDEN) }) }, t._removeBackdrop = function () { this._backdrop && (g(this._backdrop).remove(), this._backdrop = null) }, t._showBackdrop = function (t) { const e = this; const n = g(this._element).hasClass(he) ? he : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = le, n && this._backdrop.classList.add(n), g(this._backdrop).appendTo(document.body), g(this._element).on(re.CLICK_DISMISS, (t) => { e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && (e._config.backdrop === 'static' ? e._element.focus() : e.hide()) }), n && _.reflow(this._backdrop), g(this._backdrop).addClass(ue), !t) return; if (!n) return void t(); const i = _.getTransitionDurationFromElement(this._backdrop); g(this._backdrop).one(_.TRANSITION_END, t).emulateTransitionEnd(i) } else if (!this._isShown && this._backdrop) { g(this._backdrop).removeClass(ue); const o = function () { e._removeBackdrop(), t && t() }; if (g(this._element).hasClass(he)) { const r = _.getTransitionDurationFromElement(this._backdrop); g(this._backdrop).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o() } else t && t() }, t._adjustDialog = function () { const t = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && t && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !t && (this._element.style.paddingRight = `${this._scrollbarWidth}px`) }, t._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' }, t._checkScrollbar = function () { const t = document.body.getBoundingClientRect(); this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth() }, t._setScrollbar = function () { const o = this; if (this._isBodyOverflowing) { const t = [].slice.call(document.querySelectorAll(me)); const e = [].slice.call(document.querySelectorAll(pe)); g(t).each((t, e) => { const n = e.style.paddingRight; const i = g(e).css('padding-right'); g(e).data('padding-right', n).css('padding-right', `${parseFloat(i) + o._scrollbarWidth}px`) }), g(e).each((t, e) => { const n = e.style.marginRight; const i = g(e).css('margin-right'); g(e).data('margin-right', n).css('margin-right', `${parseFloat(i) - o._scrollbarWidth}px`) }); const n = document.body.style.paddingRight; const i = g(document.body).css('padding-right'); g(document.body).data('padding-right', n).css('padding-right', `${parseFloat(i) + this._scrollbarWidth}px`) }g(document.body).addClass(ce) }, t._resetScrollbar = function () { const t = [].slice.call(document.querySelectorAll(me)); g(t).each((t, e) => { const n = g(e).data('padding-right'); g(e).removeData('padding-right'), e.style.paddingRight = n || '' }); const e = [].slice.call(document.querySelectorAll(`${pe}`)); g(e).each((t, e) => { const n = g(e).data('margin-right'); typeof n !== 'undefined' && g(e).css('margin-right', n).removeData('margin-right') }); const n = g(document.body).data('padding-right'); g(document.body).removeData('padding-right'), document.body.style.paddingRight = n || '' }, t._getScrollbarWidth = function () { const t = document.createElement('div'); t.className = ae, document.body.appendChild(t); const e = t.getBoundingClientRect().width - t.clientWidth; return document.body.removeChild(t), e }, o._jQueryInterface = function (n, i) { return this.each(function () { let t = g(this).data(te); const e = l({}, ie, g(this).data(), typeof n === 'object' && n ? n : {}); if (t || (t = new o(this, e), g(this).data(te, t)), typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](i) } else e.show && t.show(i) }) }, s(o, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return ie } }]), o }()); g(document).on(re.CLICK_DATA_API, ge, function (t) { let e; const n = this; const i = _.getSelectorFromElement(this); i && (e = document.querySelector(i)); const o = g(e).data(te) ? 'toggle' : l({}, g(e).data(), g(this).data()); this.tagName !== 'A' && this.tagName !== 'AREA' || t.preventDefault(); var r = g(e).one(re.SHOW, (t) => { t.isDefaultPrevented() || r.one(re.HIDDEN, () => { g(n).is(':visible') && n.focus() }) }); ve._jQueryInterface.call(g(e), o, this) }), g.fn[Zt] = ve._jQueryInterface, g.fn[Zt].Constructor = ve, g.fn[Zt].noConflict = function () { return g.fn[Zt] = ne, ve._jQueryInterface }; const ye = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']; const Ee = { '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; const Ce = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi; const Te = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i; function Se(t, s, e) { if (t.length === 0) return t; if (e && typeof e === 'function') return e(t); for (var n = (new window.DOMParser()).parseFromString(t, 'text/html'), a = Object.keys(s), l = [].slice.call(n.body.querySelectorAll('*')), i = function (t, e) { const n = l[t]; const i = n.nodeName.toLowerCase(); if (a.indexOf(n.nodeName.toLowerCase()) === -1) return n.parentNode.removeChild(n), 'continue'; const o = [].slice.call(n.attributes); const r = [].concat(s['*'] || [], s[i] || []); o.forEach((t) => { (function (t, e) { const n = t.nodeName.toLowerCase(); if (e.indexOf(n) !== -1) return ye.indexOf(n) === -1 || Boolean(t.nodeValue.match(Ce) || t.nodeValue.match(Te)); for (let i = e.filter((t) => t instanceof RegExp), o = 0, r = i.length; o < r; o++) if (n.match(i[o])) return !0; return !1 })(t, r) || n.removeAttribute(t.nodeName) }) }, o = 0, r = l.length; o < r; o++)i(o); return n.body.innerHTML } const be = 'tooltip'; const Ie = 'bs.tooltip'; const De = `.${Ie}`; const we = g.fn[be]; const Ae = 'bs-tooltip'; const Ne = new RegExp(`(^|\\s)${Ae}\\S+`, 'g'); const Oe = ['sanitize', 'whiteList', 'sanitizeFn']; const ke = { animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string|function)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)', sanitize: 'boolean', sanitizeFn: '(null|function)', whiteList: 'object' }; const Pe = { AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left' }; const Le = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, selector: !1, placement: 'top', offset: 0, container: !1, fallbackPlacement: 'flip', boundary: 'scrollParent', sanitize: !0, sanitizeFn: null, whiteList: Ee }; const je = 'show'; const He = 'out'; const Re = { HIDE: `hide${De}`, HIDDEN: `hidden${De}`, SHOW: `show${De}`, SHOWN: `shown${De}`, INSERTED: `inserted${De}`, CLICK: `click${De}`, FOCUSIN: `focusin${De}`, FOCUSOUT: `focusout${De}`, MOUSEENTER: `mouseenter${De}`, MOUSELEAVE: `mouseleave${De}` }; const xe = 'fade'; const Fe = 'show'; const Ue = '.tooltip-inner'; const We = '.arrow'; const qe = 'hover'; const Me = 'focus'; const Ke = 'click'; const Qe = 'manual'; const Be = (function () { function i(t, e) { if (typeof u === 'undefined') throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)"); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners() } const t = i.prototype; return t.enable = function () { this._isEnabled = !0 }, t.disable = function () { this._isEnabled = !1 }, t.toggleEnabled = function () { this._isEnabled = !this._isEnabled }, t.toggle = function (t) { if (this._isEnabled) if (t) { const e = this.constructor.DATA_KEY; let n = g(t.currentTarget).data(e); n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n) } else { if (g(this.getTipElement()).hasClass(Fe)) return void this._leave(null, this); this._enter(null, this) } }, t.dispose = function () { clearTimeout(this._timeout), g.removeData(this.element, this.constructor.DATA_KEY), g(this.element).off(this.constructor.EVENT_KEY), g(this.element).closest('.modal').off('hide.bs.modal'), this.tip && g(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null }, t.show = function () { const e = this; if (g(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const t = g.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) { g(this.element).trigger(t); const n = _.findShadowRoot(this.element); const i = g.contains(n !== null ? n : this.element.ownerDocument.documentElement, this.element); if (t.isDefaultPrevented() || !i) return; const o = this.getTipElement(); const r = _.getUID(this.constructor.NAME); o.setAttribute('id', r), this.element.setAttribute('aria-describedby', r), this.setContent(), this.config.animation && g(o).addClass(xe); const s = typeof this.config.placement === 'function' ? this.config.placement.call(this, o, this.element) : this.config.placement; const a = this._getAttachment(s); this.addAttachmentClass(a); const l = this._getContainer(); g(o).data(this.constructor.DATA_KEY, this), g.contains(this.element.ownerDocument.documentElement, this.tip) || g(o).appendTo(l), g(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new u(this.element, o, { placement: a, modifiers: { offset: this._getOffset(), flip: { behavior: this.config.fallbackPlacement }, arrow: { element: We }, preventOverflow: { boundariesElement: this.config.boundary } }, onCreate(t) { t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t) }, onUpdate(t) { return e._handlePopperPlacementChange(t) } }), g(o).addClass(Fe), 'ontouchstart' in document.documentElement && g(document.body).children().on('mouseover', null, g.noop); const c = function () { e.config.animation && e._fixTransition(); const t = e._hoverState; e._hoverState = null, g(e.element).trigger(e.constructor.Event.SHOWN), t === He && e._leave(null, e) }; if (g(this.tip).hasClass(xe)) { const h = _.getTransitionDurationFromElement(this.tip); g(this.tip).one(_.TRANSITION_END, c).emulateTransitionEnd(h) } else c() } }, t.hide = function (t) { const e = this; const n = this.getTipElement(); const i = g.Event(this.constructor.Event.HIDE); const o = function () { e._hoverState !== je && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute('aria-describedby'), g(e.element).trigger(e.constructor.Event.HIDDEN), e._popper !== null && e._popper.destroy(), t && t() }; if (g(this.element).trigger(i), !i.isDefaultPrevented()) { if (g(n).removeClass(Fe), 'ontouchstart' in document.documentElement && g(document.body).children().off('mouseover', null, g.noop), this._activeTrigger[Ke] = !1, this._activeTrigger[Me] = !1, this._activeTrigger[qe] = !1, g(this.tip).hasClass(xe)) { const r = _.getTransitionDurationFromElement(n); g(n).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o(); this._hoverState = '' } }, t.update = function () { this._popper !== null && this._popper.scheduleUpdate() }, t.isWithContent = function () { return Boolean(this.getTitle()) }, t.addAttachmentClass = function (t) { g(this.getTipElement()).addClass(`${Ae}-${t}`) }, t.getTipElement = function () { return this.tip = this.tip || g(this.config.template)[0], this.tip }, t.setContent = function () { const t = this.getTipElement(); this.setElementContent(g(t.querySelectorAll(Ue)), this.getTitle()), g(t).removeClass(`${xe} ${Fe}`) }, t.setElementContent = function (t, e) { typeof e !== 'object' || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = Se(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? g(e).parent().is(t) || t.empty().append(e) : t.text(g(e).text()) }, t.getTitle = function () { let t = this.element.getAttribute('data-original-title'); return t || (t = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), t }, t._getOffset = function () { const e = this; const t = {}; return typeof this.config.offset === 'function' ? t.fn = function (t) { return t.offsets = l({}, t.offsets, e.config.offset(t.offsets, e.element) || {}), t } : t.offset = this.config.offset, t }, t._getContainer = function () { return !1 === this.config.container ? document.body : _.isElement(this.config.container) ? g(this.config.container) : g(document).find(this.config.container) }, t._getAttachment = function (t) { return Pe[t.toUpperCase()] }, t._setListeners = function () { const i = this; this.config.trigger.split(' ').forEach((t) => { if (t === 'click')g(i.element).on(i.constructor.Event.CLICK, i.config.selector, (t) => i.toggle(t)); else if (t !== Qe) { const e = t === qe ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN; const n = t === qe ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT; g(i.element).on(e, i.config.selector, (t) => i._enter(t)).on(n, i.config.selector, (t) => i._leave(t)) } }), g(this.element).closest('.modal').on('hide.bs.modal', () => { i.element && i.hide() }), this.config.selector ? this.config = l({}, this.config, { trigger: 'manual', selector: '' }) : this._fixTitle() }, t._fixTitle = function () { const t = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || t !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')) }, t._enter = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusin' ? Me : qe] = !0), g(e.getTipElement()).hasClass(Fe) || e._hoverState === je ? e._hoverState = je : (clearTimeout(e._timeout), e._hoverState = je, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(() => { e._hoverState === je && e.show() }, e.config.delay.show) : e.show()) }, t._leave = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusout' ? Me : qe] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = He, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(() => { e._hoverState === He && e.hide() }, e.config.delay.hide) : e.hide()) }, t._isWithActiveTrigger = function () { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1 }, t._getConfig = function (t) { const e = g(this.element).data(); return Object.keys(e).forEach((t) => { Oe.indexOf(t) !== -1 && delete e[t] }), typeof (t = l({}, this.constructor.Default, e, typeof t === 'object' && t ? t : {})).delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === 'number' && (t.title = t.title.toString()), typeof t.content === 'number' && (t.content = t.content.toString()), _.typeCheckConfig(be, t, this.constructor.DefaultType), t.sanitize && (t.template = Se(t.template, t.whiteList, t.sanitizeFn)), t }, t._getDelegateConfig = function () { const t = {}; if (this.config) for (const e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]); return t }, t._cleanTipClass = function () { const t = g(this.getTipElement()); const e = t.attr('class').match(Ne); e !== null && e.length && t.removeClass(e.join('')) }, t._handlePopperPlacementChange = function (t) { const e = t.instance; this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement)) }, t._fixTransition = function () { const t = this.getTipElement(); const e = this.config.animation; t.getAttribute('x-placement') === null && (g(t).removeClass(xe), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e) }, i._jQueryInterface = function (n) { return this.each(function () { let t = g(this).data(Ie); const e = typeof n === 'object' && n; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ie, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return Le } }, { key: 'NAME', get() { return be } }, { key: 'DATA_KEY', get() { return Ie } }, { key: 'Event', get() { return Re } }, { key: 'EVENT_KEY', get() { return De } }, { key: 'DefaultType', get() { return ke } }]), i }()); g.fn[be] = Be._jQueryInterface, g.fn[be].Constructor = Be, g.fn[be].noConflict = function () { return g.fn[be] = we, Be._jQueryInterface }; const Ve = 'popover'; const Ye = 'bs.popover'; const ze = `.${Ye}`; const Xe = g.fn[Ve]; const $e = 'bs-popover'; const Ge = new RegExp(`(^|\\s)${$e}\\S+`, 'g'); const Je = l({}, Be.Default, { placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }); const Ze = l({}, Be.DefaultType, { content: '(string|element|function)' }); const tn = 'fade'; const en = 'show'; const nn = '.popover-header'; const on = '.popover-body'; const rn = { HIDE: `hide${ze}`, HIDDEN: `hidden${ze}`, SHOW: `show${ze}`, SHOWN: `shown${ze}`, INSERTED: `inserted${ze}`, CLICK: `click${ze}`, FOCUSIN: `focusin${ze}`, FOCUSOUT: `focusout${ze}`, MOUSEENTER: `mouseenter${ze}`, MOUSELEAVE: `mouseleave${ze}` }; const sn = (function (t) { let e, n; function i() { return t.apply(this, arguments) || this }n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n; const o = i.prototype; return o.isWithContent = function () { return this.getTitle() || this._getContent() }, o.addAttachmentClass = function (t) { g(this.getTipElement()).addClass(`${$e}-${t}`) }, o.getTipElement = function () { return this.tip = this.tip || g(this.config.template)[0], this.tip }, o.setContent = function () { const t = g(this.getTipElement()); this.setElementContent(t.find(nn), this.getTitle()); let e = this._getContent(); typeof e === 'function' && (e = e.call(this.element)), this.setElementContent(t.find(on), e), t.removeClass(`${tn} ${en}`) }, o._getContent = function () { return this.element.getAttribute('data-content') || this.config.content }, o._cleanTipClass = function () { const t = g(this.getTipElement()); const e = t.attr('class').match(Ge); e !== null && e.length > 0 && t.removeClass(e.join('')) }, i._jQueryInterface = function (n) { return this.each(function () { let t = g(this).data(Ye); const e = typeof n === 'object' ? n : null; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ye, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return Je } }, { key: 'NAME', get() { return Ve } }, { key: 'DATA_KEY', get() { return Ye } }, { key: 'Event', get() { return rn } }, { key: 'EVENT_KEY', get() { return ze } }, { key: 'DefaultType', get() { return Ze } }]), i }(Be)); g.fn[Ve] = sn._jQueryInterface, g.fn[Ve].Constructor = sn, g.fn[Ve].noConflict = function () { return g.fn[Ve] = Xe, sn._jQueryInterface }; const an = 'scrollspy'; const ln = 'bs.scrollspy'; const cn = `.${ln}`; const hn = g.fn[an]; const un = { offset: 10, method: 'auto', target: '' }; const fn = { offset: 'number', method: 'string', target: '(string|element)' }; const dn = { ACTIVATE: `activate${cn}`, SCROLL: `scroll${cn}`, LOAD_DATA_API: `load${cn}.data-api` }; const gn = 'dropdown-item'; const _n = 'active'; const mn = '[data-spy="scroll"]'; const pn = '.nav, .list-group'; const vn = '.nav-link'; const yn = '.nav-item'; const En = '.list-group-item'; const Cn = '.dropdown'; const Tn = '.dropdown-item'; const Sn = '.dropdown-toggle'; const bn = 'offset'; const In = 'position'; const Dn = (function () { function n(t, e) { const n = this; this._element = t, this._scrollElement = t.tagName === 'BODY' ? window : t, this._config = this._getConfig(e), this._selector = `${this._config.target} ${vn},${this._config.target} ${En},${this._config.target} ${Tn}`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, g(this._scrollElement).on(dn.SCROLL, (t) => n._process(t)), this.refresh(), this._process() } const t = n.prototype; return t.refresh = function () { const e = this; const t = this._scrollElement === this._scrollElement.window ? bn : In; const o = this._config.method === 'auto' ? t : this._config.method; const r = o === In ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map((t) => { let e; const n = _.getSelectorFromElement(t); if (n && (e = document.querySelector(n)), e) { const i = e.getBoundingClientRect(); if (i.width || i.height) return [g(e)[o]().top + r, n] } return null }).filter((t) => t).sort((t, e) => t[0] - e[0]).forEach((t) => { e._offsets.push(t[0]), e._targets.push(t[1]) }) }, t.dispose = function () { g.removeData(this._element, ln), g(this._scrollElement).off(cn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null }, t._getConfig = function (t) { if (typeof (t = l({}, un, typeof t === 'object' && t ? t : {})).target !== 'string') { let e = g(t.target).attr('id'); e || (e = _.getUID(an), g(t.target).attr('id', e)), t.target = `#${e}` } return _.typeCheckConfig(an, t, fn), t }, t._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop }, t._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) }, t._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height }, t._process = function () { const t = this._getScrollTop() + this._config.offset; const e = this._getScrollHeight(); const n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), n <= t) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i) } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let o = this._offsets.length; o--;) { this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (typeof this._offsets[o + 1] === 'undefined' || t < this._offsets[o + 1]) && this._activate(this._targets[o]) } } }, t._activate = function (e) { this._activeTarget = e, this._clear(); const t = this._selector.split(',').map((t) => `${t}[data-target="${e}"],${t}[href="${e}"]`); const n = g([].slice.call(document.querySelectorAll(t.join(',')))); n.hasClass(gn) ? (n.closest(Cn).find(Sn).addClass(_n), n.addClass(_n)) : (n.addClass(_n), n.parents(pn).prev(`${vn}, ${En}`).addClass(_n), n.parents(pn).prev(yn).children(vn).addClass(_n)), g(this._scrollElement).trigger(dn.ACTIVATE, { relatedTarget: e }) }, t._clear = function () { [].slice.call(document.querySelectorAll(this._selector)).filter((t) => t.classList.contains(_n)).forEach((t) => t.classList.remove(_n)) }, n._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(ln); if (t || (t = new n(this, typeof e === 'object' && e), g(this).data(ln, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e]() } }) }, s(n, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return un } }]), n }()); g(window).on(dn.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(mn)), e = t.length; e--;) { const n = g(t[e]); Dn._jQueryInterface.call(n, n.data()) } }), g.fn[an] = Dn._jQueryInterface, g.fn[an].Constructor = Dn, g.fn[an].noConflict = function () { return g.fn[an] = hn, Dn._jQueryInterface }; const wn = 'bs.tab'; const An = `.${wn}`; const Nn = g.fn.tab; const On = { HIDE: `hide${An}`, HIDDEN: `hidden${An}`, SHOW: `show${An}`, SHOWN: `shown${An}`, CLICK_DATA_API: `click${An}.data-api` }; const kn = 'dropdown-menu'; const Pn = 'active'; const Ln = 'disabled'; const jn = 'fade'; const Hn = 'show'; const Rn = '.dropdown'; const xn = '.nav, .list-group'; const Fn = '.active'; const Un = '> li > .active'; const Wn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]'; const qn = '.dropdown-toggle'; const Mn = '> .dropdown-menu .active'; const Kn = (function () { function i(t) { this._element = t } const t = i.prototype; return t.show = function () { const n = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && g(this._element).hasClass(Pn) || g(this._element).hasClass(Ln))) { let t; let i; const e = g(this._element).closest(xn)[0]; const o = _.getSelectorFromElement(this._element); if (e) { const r = e.nodeName === 'UL' || e.nodeName === 'OL' ? Un : Fn; i = (i = g.makeArray(g(e).find(r)))[i.length - 1] } const s = g.Event(On.HIDE, { relatedTarget: this._element }); const a = g.Event(On.SHOW, { relatedTarget: i }); if (i && g(i).trigger(s), g(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) { o && (t = document.querySelector(o)), this._activate(this._element, e); const l = function () { const t = g.Event(On.HIDDEN, { relatedTarget: n._element }); const e = g.Event(On.SHOWN, { relatedTarget: i }); g(i).trigger(t), g(n._element).trigger(e) }; t ? this._activate(t, t.parentNode, l) : l() } } }, t.dispose = function () { g.removeData(this._element, wn), this._element = null }, t._activate = function (t, e, n) { const i = this; const o = (!e || e.nodeName !== 'UL' && e.nodeName !== 'OL' ? g(e).children(Fn) : g(e).find(Un))[0]; const r = n && o && g(o).hasClass(jn); const s = function () { return i._transitionComplete(t, o, n) }; if (o && r) { const a = _.getTransitionDurationFromElement(o); g(o).removeClass(Hn).one(_.TRANSITION_END, s).emulateTransitionEnd(a) } else s() }, t._transitionComplete = function (t, e, n) { if (e) { g(e).removeClass(Pn); const i = g(e.parentNode).find(Mn)[0]; i && g(i).removeClass(Pn), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !1) } if (g(t).addClass(Pn), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !0), _.reflow(t), t.classList.contains(jn) && t.classList.add(Hn), t.parentNode && g(t.parentNode).hasClass(kn)) { const o = g(t).closest(Rn)[0]; if (o) { const r = [].slice.call(o.querySelectorAll(qn)); g(r).addClass(Pn) }t.setAttribute('aria-expanded', !0) }n && n() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(wn); if (e || (e = new i(this), t.data(wn, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), i }()); g(document).on(On.CLICK_DATA_API, Wn, function (t) { t.preventDefault(), Kn._jQueryInterface.call(g(this), 'show') }), g.fn.tab = Kn._jQueryInterface, g.fn.tab.Constructor = Kn, g.fn.tab.noConflict = function () { return g.fn.tab = Nn, Kn._jQueryInterface }; const Qn = 'toast'; const Bn = 'bs.toast'; const Vn = `.${Bn}`; const Yn = g.fn[Qn]; const zn = { CLICK_DISMISS: `click.dismiss${Vn}`, HIDE: `hide${Vn}`, HIDDEN: `hidden${Vn}`, SHOW: `show${Vn}`, SHOWN: `shown${Vn}` }; const Xn = 'fade'; const $n = 'hide'; const Gn = 'show'; const Jn = 'showing'; const Zn = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const ti = { animation: !0, autohide: !0, delay: 500 }; const ei = '[data-dismiss="toast"]'; const ni = (function () { function i(t, e) { this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners() } const t = i.prototype; return t.show = function () { const t = this; g(this._element).trigger(zn.SHOW), this._config.animation && this._element.classList.add(Xn); const e = function () { t._element.classList.remove(Jn), t._element.classList.add(Gn), g(t._element).trigger(zn.SHOWN), t._config.autohide && t.hide() }; if (this._element.classList.remove($n), this._element.classList.add(Jn), this._config.animation) { const n = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n) } else e() }, t.hide = function (t) { const e = this; this._element.classList.contains(Gn) && (g(this._element).trigger(zn.HIDE), t ? this._close() : this._timeout = setTimeout(() => { e._close() }, this._config.delay)) }, t.dispose = function () { clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Gn) && this._element.classList.remove(Gn), g(this._element).off(zn.CLICK_DISMISS), g.removeData(this._element, Bn), this._element = null, this._config = null }, t._getConfig = function (t) { return t = l({}, ti, g(this._element).data(), typeof t === 'object' && t ? t : {}), _.typeCheckConfig(Qn, t, this.constructor.DefaultType), t }, t._setListeners = function () { const t = this; g(this._element).on(zn.CLICK_DISMISS, ei, () => t.hide(!0)) }, t._close = function () { const t = this; const e = function () { t._element.classList.add($n), g(t._element).trigger(zn.HIDDEN) }; if (this._element.classList.remove(Gn), this._config.animation) { const n = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n) } else e() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(Bn); if (e || (e = new i(this, typeof n === 'object' && n), t.data(Bn, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](this) } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'DefaultType', get() { return Zn } }, { key: 'Default', get() { return ti } }]), i }()); g.fn[Qn] = ni._jQueryInterface, g.fn[Qn].Constructor = ni, g.fn[Qn].noConflict = function () { return g.fn[Qn] = Yn, ni._jQueryInterface }, (function () { if (typeof g === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = g.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0") }()), t.Util = _, t.Alert = p, t.Button = P, t.Carousel = lt, t.Collapse = bt, t.Dropdown = Jt, t.Modal = ve, t.Popover = sn, t.Scrollspy = Dn, t.Tab = Kn, t.Toast = ni, t.Tooltip = Be, Object.defineProperty(t, '__esModule', { value: !0 })
}))
