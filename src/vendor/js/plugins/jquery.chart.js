/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.2
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function () {
  const t = this; const i = t.Chart; const e = function (t) { this.canvas = t.canvas, this.ctx = t; const i = function (t, i) { return t[`offset${i}`] ? t[`offset${i}`] : document.defaultView.getComputedStyle(t).getPropertyValue(i) }; var e = this.width = i(t.canvas, 'Width'); var n = this.height = i(t.canvas, 'Height'); t.canvas.width = e, t.canvas.height = n; var e = this.width = t.canvas.width; var n = this.height = t.canvas.height; return this.aspectRatio = this.width / this.height, s.retinaScale(this), this }; e.defaults = { global: { animation: !0, animationSteps: 60, animationEasing: 'easeOutQuart', showScale: !0, scaleOverride: !1, scaleSteps: null, scaleStepWidth: null, scaleStartValue: null, scaleLineColor: 'rgba(0,0,0,.1)', scaleLineWidth: 1, scaleShowLabels: !0, scaleLabel: '<%=value%>', scaleIntegersOnly: !0, scaleBeginAtZero: !1, scaleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", scaleFontSize: 12, scaleFontStyle: 'normal', scaleFontColor: '#666', responsive: !1, maintainAspectRatio: !0, showTooltips: !0, customTooltips: !1, tooltipEvents: ['mousemove', 'touchstart', 'touchmove', 'mouseout'], tooltipFillColor: 'rgba(0,0,0,0.8)', tooltipFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", tooltipFontSize: 14, tooltipFontStyle: 'normal', tooltipFontColor: '#fff', tooltipTitleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", tooltipTitleFontSize: 14, tooltipTitleFontStyle: 'bold', tooltipTitleFontColor: '#fff', tooltipYPadding: 6, tooltipXPadding: 6, tooltipCaretSize: 8, tooltipCornerRadius: 6, tooltipXOffset: 10, tooltipTemplate: '<%if (label){%><%=label%>: <%}%><%= value %>', multiTooltipTemplate: '<%= value %>', multiTooltipKeyBackground: '#fff', onAnimationProgress() {}, onAnimationComplete() {} } }, e.types = {}; var s = e.helpers = {}; const n = s.each = function (t, i, e) { const s = Array.prototype.slice.call(arguments, 3); if (t) if (t.length === +t.length) { let n; for (n = 0; n < t.length; n++)i.apply(e, [t[n], n].concat(s)) } else for (const o in t)i.apply(e, [t[o], o].concat(s)) }; const o = s.clone = function (t) { const i = {}; return n(t, (e, s) => { t.hasOwnProperty(s) && (i[s] = e) }), i }; const a = s.extend = function (t) { return n(Array.prototype.slice.call(arguments, 1), (i) => { n(i, (e, s) => { i.hasOwnProperty(s) && (t[s] = e) }) }), t }; const h = s.merge = function () { const t = Array.prototype.slice.call(arguments, 0); return t.unshift({}), a.apply(null, t) }; const l = s.indexOf = function (t, i) { if (Array.prototype.indexOf) return t.indexOf(i); for (let e = 0; e < t.length; e++) if (t[e] === i) return e; return -1 }; var r = (s.where = function (t, i) { const e = []; return s.each(t, (t) => { i(t) && e.push(t) }), e }, s.findNextWhere = function (t, i, e) { e || (e = -1); for (let s = e + 1; s < t.length; s++) { const n = t[s]; if (i(n)) return n } }, s.findPreviousWhere = function (t, i, e) { e || (e = t.length); for (let s = e - 1; s >= 0; s--) { const n = t[s]; if (i(n)) return n } }, s.inherits = function (t) { const i = this; const e = t && t.hasOwnProperty('constructor') ? t.constructor : function () { return i.apply(this, arguments) }; const s = function () { this.constructor = e }; return s.prototype = i.prototype, e.prototype = new s(), e.extend = r, t && a(e.prototype, t), e.__super__ = i.prototype, e }); const c = s.noop = function () {}; const u = s.uid = (function () { let t = 0; return function () { return `chart-${t++}` } }()); const d = s.warn = function (t) { window.console && typeof window.console.warn === 'function' && console.warn(t) }; const p = s.amd = typeof define === 'function' && define.amd; const f = s.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t) }; const g = s.max = function (t) { return Math.max.apply(Math, t) }; const m = s.min = function (t) { return Math.min.apply(Math, t) }; const v = (s.cap = function (t, i, e) { if (f(i)) { if (t > i) return i } else if (f(e) && e > t) return e; return t }, s.getDecimalPlaces = function (t) { return t % 1 !== 0 && f(t) ? t.toString().split('.')[1].length : 0 }); const S = s.radians = function (t) { return t * (Math.PI / 180) }; const x = (s.getAngleFromPoint = function (t, i) { const e = i.x - t.x; const s = i.y - t.y; const n = Math.sqrt(e * e + s * s); let o = 2 * Math.PI + Math.atan2(s, e); return e < 0 && s < 0 && (o += 2 * Math.PI), { angle: o, distance: n } }, s.aliasPixel = function (t) { return t % 2 === 0 ? 0 : 0.5 }); const y = (s.splineCurve = function (t, i, e, s) { const n = Math.sqrt(Math.pow(i.x - t.x, 2) + Math.pow(i.y - t.y, 2)); const o = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2)); const a = s * n / (n + o); const h = s * o / (n + o); return { inner: { x: i.x - a * (e.x - t.x), y: i.y - a * (e.y - t.y) }, outer: { x: i.x + h * (e.x - t.x), y: i.y + h * (e.y - t.y) } } }, s.calculateOrderOfMagnitude = function (t) { return Math.floor(Math.log(t) / Math.LN10) }); const C = (s.calculateScaleRange = function (t, i, e, s, n) { const o = 2; const a = Math.floor(i / (1.5 * e)); let h = o >= a; let l = g(t); let r = m(t); l === r && (l += 0.5, r >= 0.5 && !s ? r -= 0.5 : l += 0.5); for (var c = Math.abs(l - r), u = y(c), d = Math.ceil(l / (1 * Math.pow(10, u))) * Math.pow(10, u), p = s ? 0 : Math.floor(r / (1 * Math.pow(10, u))) * Math.pow(10, u), f = d - p, v = Math.pow(10, u), S = Math.round(f / v); (S > a || a > 2 * S) && !h;) if (S > a)v *= 2, S = Math.round(f / v), S % 1 !== 0 && (h = !0); else if (n && u >= 0) { if (v / 2 % 1 !== 0) break; v /= 2, S = Math.round(f / v) } else v /= 2, S = Math.round(f / v); return h && (S = o, v = f / S), { steps: S, stepValue: v, min: p, max: p + S * v } }, s.template = function (t, i) { function e(t, i) { const e = /\W/.test(t) ? new Function('obj', `var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('${t.replace(/[\r\t\n]/g, ' ').split('<%').join('	').replace(/((^|%>)[^\t]*)'/g, '$1\r').replace(/\t=(.*?)%>/g, "',$1,'").split('	').join("');").split('%>').join("p.push('").split('\r').join("\\'")}');}return p.join('');`) : s[t] = s[t]; return i ? e(i) : e } if (t instanceof Function) return t(i); var s = {}; return e(t, i) }); var w = (s.generateLabels = function (t, i, e, s) { const o = new Array(i); return labelTemplateString && n(o, (i, n) => { o[n] = C(t, { value: e + s * (n + 1) }) }), o }, s.easingEffects = { linear(t) { return t }, easeInQuad(t) { return t * t }, easeOutQuad(t) { return -1 * t * (t - 2) }, easeInOutQuad(t) { return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) }, easeInCubic(t) { return t * t * t }, easeOutCubic(t) { return 1 * ((t = t / 1 - 1) * t * t + 1) }, easeInOutCubic(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) }, easeInQuart(t) { return t * t * t * t }, easeOutQuart(t) { return -1 * ((t = t / 1 - 1) * t * t * t - 1) }, easeInOutQuart(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint(t) { return 1 * (t /= 1) * t * t * t * t }, easeOutQuint(t) { return 1 * ((t = t / 1 - 1) * t * t * t * t + 1) }, easeInOutQuint(t) { return (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine(t) { return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1 }, easeOutSine(t) { return 1 * Math.sin(t / 1 * (Math.PI / 2)) }, easeInOutSine(t) { return -0.5 * (Math.cos(Math.PI * t / 1) - 1) }, easeInExpo(t) { return t === 0 ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1)) }, easeOutExpo(t) { return t === 1 ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1) }, easeInOutExpo(t) { return t === 0 ? 0 : t === 1 ? 1 : (t /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (-Math.pow(2, -10 * --t) + 2) }, easeInCirc(t) { return t >= 1 ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1) }, easeOutCirc(t) { return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t) }, easeInOutCirc(t) { return (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic(t) { let i = 1.70158; let e = 0; let s = 1; return t === 0 ? 0 : (t /= 1) == 1 ? 1 : (e || (e = 0.3), s < Math.abs(1) ? (s = 1, i = e / 4) : i = e / (2 * Math.PI) * Math.asin(1 / s), -(s * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (1 * t - i) * Math.PI / e))) }, easeOutElastic(t) { let i = 1.70158; let e = 0; let s = 1; return t === 0 ? 0 : (t /= 1) == 1 ? 1 : (e || (e = 0.3), s < Math.abs(1) ? (s = 1, i = e / 4) : i = e / (2 * Math.PI) * Math.asin(1 / s), s * Math.pow(2, -10 * t) * Math.sin(2 * (1 * t - i) * Math.PI / e) + 1) }, easeInOutElastic(t) { let i = 1.70158; let e = 0; let s = 1; return t === 0 ? 0 : (t /= 0.5) == 2 ? 1 : (e || (e = 0.3 * 1.5), s < Math.abs(1) ? (s = 1, i = e / 4) : i = e / (2 * Math.PI) * Math.asin(1 / s), t < 1 ? -0.5 * s * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (1 * t - i) * Math.PI / e) : s * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (1 * t - i) * Math.PI / e) * 0.5 + 1) }, easeInBack(t) { const i = 1.70158; return 1 * (t /= 1) * t * ((i + 1) * t - i) }, easeOutBack(t) { const i = 1.70158; return 1 * ((t = t / 1 - 1) * t * ((i + 1) * t + i) + 1) }, easeInOutBack(t) { let i = 1.70158; return (t /= 0.5) < 1 ? 0.5 * t * t * (((i *= 1.525) + 1) * t - i) : 0.5 * ((t -= 2) * t * (((i *= 1.525) + 1) * t + i) + 2) }, easeInBounce(t) { return 1 - w.easeOutBounce(1 - t) }, easeOutBounce(t) { return (t /= 1) < 1 / 2.75 ? 7.5625 * t * t : 2 / 2.75 > t ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : 2.5 / 2.75 > t ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) }, easeInOutBounce(t) { return t < 0.5 ? 0.5 * w.easeInBounce(2 * t) : 0.5 * w.easeOutBounce(2 * t - 1) + 0.5 } }); const b = s.requestAnimFrame = (function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) } }()); const P = s.cancelAnimFrame = (function () { return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (t) { return window.clearTimeout(t, 1e3 / 60) } }()); const L = (s.animationLoop = function (t, i, e, s, n, o) { let a = 0; const h = w[e] || w.linear; var l = function () { a++; const e = a / i; const r = h(e); t.call(o, r, e, a), s.call(o, r, e), i > a ? o.animationFrame = b(l) : n.apply(o) }; b(l) }, s.getRelativePosition = function (t) { let i; let e; const s = t.originalEvent || t; const n = t.currentTarget || t.srcElement; const o = n.getBoundingClientRect(); return s.touches ? (i = s.touches[0].clientX - o.left, e = s.touches[0].clientY - o.top) : (i = s.clientX - o.left, e = s.clientY - o.top), { x: i, y: e } }, s.addEvent = function (t, i, e) { t.addEventListener ? t.addEventListener(i, e) : t.attachEvent ? t.attachEvent(`on${i}`, e) : t[`on${i}`] = e }); const k = s.removeEvent = function (t, i, e) { t.removeEventListener ? t.removeEventListener(i, e, !1) : t.detachEvent ? t.detachEvent(`on${i}`, e) : t[`on${i}`] = c }; const F = (s.bindEvents = function (t, i, e) { t.events || (t.events = {}), n(i, (i) => { t.events[i] = function () { e.apply(t, arguments) }, L(t.chart.canvas, i, t.events[i]) }) }, s.unbindEvents = function (t, i) { n(i, (i, e) => { k(t.chart.canvas, e, i) }) }); const R = s.getMaximumWidth = function (t) { const i = t.parentNode; return i.clientWidth }; const T = s.getMaximumHeight = function (t) { const i = t.parentNode; return i.clientHeight }; const A = (s.getMaximumSize = s.getMaximumWidth, s.retinaScale = function (t) { const i = t.ctx; const e = t.canvas.width; const s = t.canvas.height; window.devicePixelRatio && (i.canvas.style.width = `${e}px`, i.canvas.style.height = `${s}px`, i.canvas.height = s * window.devicePixelRatio, i.canvas.width = e * window.devicePixelRatio, i.scale(window.devicePixelRatio, window.devicePixelRatio)) }); const M = s.clear = function (t) { t.ctx.clearRect(0, 0, t.width, t.height) }; const W = s.fontString = function (t, i, e) { return `${i} ${t}px ${e}` }; const z = s.longestText = function (t, i, e) { t.font = i; let s = 0; return n(e, (i) => { const e = t.measureText(i).width; s = e > s ? e : s }), s }; const B = s.drawRoundedRectangle = function (t, i, e, s, n, o) { t.beginPath(), t.moveTo(i + o, e), t.lineTo(i + s - o, e), t.quadraticCurveTo(i + s, e, i + s, e + o), t.lineTo(i + s, e + n - o), t.quadraticCurveTo(i + s, e + n, i + s - o, e + n), t.lineTo(i + o, e + n), t.quadraticCurveTo(i, e + n, i, e + n - o), t.lineTo(i, e + o), t.quadraticCurveTo(i, e, i + o, e), t.closePath() }; e.instances = {}, e.Type = function (t, i, s) { this.options = i, this.chart = s, this.id = u(), e.instances[this.id] = this, i.responsive && this.resize(), this.initialize.call(this, t) }, a(e.Type.prototype, { initialize() { return this }, clear() { return M(this.chart), this }, stop() { return P(this.animationFrame), this }, resize(t) { this.stop(); const i = this.chart.canvas; const e = R(this.chart.canvas); const s = this.options.maintainAspectRatio ? e / this.chart.aspectRatio : T(this.chart.canvas); return i.width = this.chart.width = e, i.height = this.chart.height = s, A(this.chart), typeof t === 'function' && t.apply(this, Array.prototype.slice.call(arguments, 1)), this }, reflow: c, render(t) { return t && this.reflow(), this.options.animation && !t ? s.animationLoop(this.draw, this.options.animationSteps, this.options.animationEasing, this.options.onAnimationProgress, this.options.onAnimationComplete, this) : (this.draw(), this.options.onAnimationComplete.call(this)), this }, generateLegend() { return C(this.options.legendTemplate, this) }, destroy() { this.clear(), F(this, this.events); const t = this.chart.canvas; t.width = this.chart.width, t.height = this.chart.height, t.style.removeProperty ? (t.style.removeProperty('width'), t.style.removeProperty('height')) : (t.style.removeAttribute('width'), t.style.removeAttribute('height')), delete e.instances[this.id] }, showTooltip(t, i) { typeof this.activeElements === 'undefined' && (this.activeElements = []); const o = (function (t) { let i = !1; return t.length !== this.activeElements.length ? i = !0 : (n(t, function (t, e) { t !== this.activeElements[e] && (i = !0) }, this), i) }.call(this, t)); if (o || i) { if (this.activeElements = t, this.draw(), this.options.customTooltips && this.options.customTooltips(!1), t.length > 0) if (this.datasets && this.datasets.length > 1) { for (var a, h, r = this.datasets.length - 1; r >= 0 && (a = this.datasets[r].points || this.datasets[r].bars || this.datasets[r].segments, h = l(a, t[0]), h === -1); r--);const c = []; const u = []; const d = (function () { let t; let i; let e; let n; let o; const a = []; const l = []; const r = []; return s.each(this.datasets, (i) => { t = i.points || i.bars || i.segments, t[h] && t[h].hasValue() && a.push(t[h]) }), s.each(a, function (t) { l.push(t.x), r.push(t.y), c.push(s.template(this.options.multiTooltipTemplate, t)), u.push({ fill: t._saved.fillColor || t.fillColor, stroke: t._saved.strokeColor || t.strokeColor }) }, this), o = m(r), e = g(r), n = m(l), i = g(l), { x: n > this.chart.width / 2 ? n : i, y: (o + e) / 2 } }.call(this, h)); new e.MultiTooltip({ x: d.x, y: d.y, xPadding: this.options.tooltipXPadding, yPadding: this.options.tooltipYPadding, xOffset: this.options.tooltipXOffset, fillColor: this.options.tooltipFillColor, textColor: this.options.tooltipFontColor, fontFamily: this.options.tooltipFontFamily, fontStyle: this.options.tooltipFontStyle, fontSize: this.options.tooltipFontSize, titleTextColor: this.options.tooltipTitleFontColor, titleFontFamily: this.options.tooltipTitleFontFamily, titleFontStyle: this.options.tooltipTitleFontStyle, titleFontSize: this.options.tooltipTitleFontSize, cornerRadius: this.options.tooltipCornerRadius, labels: c, legendColors: u, legendColorBackground: this.options.multiTooltipKeyBackground, title: t[0].label, chart: this.chart, ctx: this.chart.ctx, custom: this.options.customTooltips }).draw() } else n(t, function (t) { const i = t.tooltipPosition(); new e.Tooltip({ x: Math.round(i.x), y: Math.round(i.y), xPadding: this.options.tooltipXPadding, yPadding: this.options.tooltipYPadding, fillColor: this.options.tooltipFillColor, textColor: this.options.tooltipFontColor, fontFamily: this.options.tooltipFontFamily, fontStyle: this.options.tooltipFontStyle, fontSize: this.options.tooltipFontSize, caretHeight: this.options.tooltipCaretSize, cornerRadius: this.options.tooltipCornerRadius, text: C(this.options.tooltipTemplate, t), chart: this.chart, custom: this.options.customTooltips }).draw() }, this); return this } }, toBase64Image() { return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments) } }), e.Type.extend = function (t) { const i = this; const s = function () { return i.apply(this, arguments) }; if (s.prototype = o(i.prototype), a(s.prototype, t), s.extend = e.Type.extend, t.name || i.prototype.name) { const n = t.name || i.prototype.name; const l = e.defaults[i.prototype.name] ? o(e.defaults[i.prototype.name]) : {}; e.defaults[n] = a(l, t.defaults), e.types[n] = s, e.prototype[n] = function (t, i) { const o = h(e.defaults.global, e.defaults[n], i || {}); return new s(t, o, this) } } else d("Name not provided for this chart, so it hasn't been registered"); return i }, e.Element = function (t) { a(this, t), this.initialize.apply(this, arguments), this.save() }, a(e.Element.prototype, { initialize() {}, restore(t) { return t ? n(t, function (t) { this[t] = this._saved[t] }, this) : a(this, this._saved), this }, save() { return this._saved = o(this), delete this._saved._saved, this }, update(t) { return n(t, function (t, i) { this._saved[i] = this[i], this[i] = t }, this), this }, transition(t, i) { return n(t, function (t, e) { this[e] = (t - this._saved[e]) * i + this._saved[e] }, this), this }, tooltipPosition() { return { x: this.x, y: this.y } }, hasValue() { return f(this.value) } }), e.Element.extend = r, e.Point = e.Element.extend({ display: !0, inRange(t, i) { const e = this.hitDetectionRadius + this.radius; return Math.pow(t - this.x, 2) + Math.pow(i - this.y, 2) < Math.pow(e, 2) }, draw() { if (this.display) { const t = this.ctx; t.beginPath(), t.arc(this.x, this.y, this.radius, 0, 2 * Math.PI), t.closePath(), t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth, t.fillStyle = this.fillColor, t.fill(), t.stroke() } } }), e.Arc = e.Element.extend({ inRange(t, i) { const e = s.getAngleFromPoint(this, { x: t, y: i }); const n = e.angle >= this.startAngle && e.angle <= this.endAngle; const o = e.distance >= this.innerRadius && e.distance <= this.outerRadius; return n && o }, tooltipPosition() { const t = this.startAngle + (this.endAngle - this.startAngle) / 2; const i = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius; return { x: this.x + Math.cos(t) * i, y: this.y + Math.sin(t) * i } }, draw(t) { const i = this.ctx; i.beginPath(), i.arc(this.x, this.y, this.outerRadius, this.startAngle, this.endAngle), i.arc(this.x, this.y, this.innerRadius, this.endAngle, this.startAngle, !0), i.closePath(), i.strokeStyle = this.strokeColor, i.lineWidth = this.strokeWidth, i.fillStyle = this.fillColor, i.fill(), i.lineJoin = 'bevel', this.showStroke && i.stroke() } }), e.Rectangle = e.Element.extend({ draw() { const t = this.ctx; const i = this.width / 2; let e = this.x - i; let s = this.x + i; let n = this.base - (this.base - this.y); const o = this.strokeWidth / 2; this.showStroke && (e += o, s -= o, n += o), t.beginPath(), t.fillStyle = this.fillColor, t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth, t.moveTo(e, this.base), t.lineTo(e, n), t.lineTo(s, n), t.lineTo(s, this.base), t.fill(), this.showStroke && t.stroke() }, height() { return this.base - this.y }, inRange(t, i) { return t >= this.x - this.width / 2 && t <= this.x + this.width / 2 && i >= this.y && i <= this.base } }), e.Tooltip = e.Element.extend({ draw() { const t = this.chart.ctx; t.font = W(this.fontSize, this.fontStyle, this.fontFamily), this.xAlign = 'center', this.yAlign = 'above'; const i = this.caretPadding = 2; const e = t.measureText(this.text).width + 2 * this.xPadding; const s = this.fontSize + 2 * this.yPadding; const n = s + this.caretHeight + i; this.x + e / 2 > this.chart.width ? this.xAlign = 'left' : this.x - e / 2 < 0 && (this.xAlign = 'right'), this.y - n < 0 && (this.yAlign = 'below'); let o = this.x - e / 2; let a = this.y - n; if (t.fillStyle = this.fillColor, this.custom) this.custom(this); else { switch (this.yAlign) { case 'above':t.beginPath(), t.moveTo(this.x, this.y - i), t.lineTo(this.x + this.caretHeight, this.y - (i + this.caretHeight)), t.lineTo(this.x - this.caretHeight, this.y - (i + this.caretHeight)), t.closePath(), t.fill(); break; case 'below':a = this.y + i + this.caretHeight, t.beginPath(), t.moveTo(this.x, this.y + i), t.lineTo(this.x + this.caretHeight, this.y + i + this.caretHeight), t.lineTo(this.x - this.caretHeight, this.y + i + this.caretHeight), t.closePath(), t.fill() } switch (this.xAlign) { case 'left':o = this.x - e + (this.cornerRadius + this.caretHeight); break; case 'right':o = this.x - (this.cornerRadius + this.caretHeight) }B(t, o, a, e, s, this.cornerRadius), t.fill(), t.fillStyle = this.textColor, t.textAlign = 'center', t.textBaseline = 'middle', t.fillText(this.text, o + e / 2, a + s / 2) } } }), e.MultiTooltip = e.Element.extend({ initialize() { this.font = W(this.fontSize, this.fontStyle, this.fontFamily), this.titleFont = W(this.titleFontSize, this.titleFontStyle, this.titleFontFamily), this.height = this.labels.length * this.fontSize + (this.labels.length - 1) * (this.fontSize / 2) + 2 * this.yPadding + 1.5 * this.titleFontSize, this.ctx.font = this.titleFont; const t = this.ctx.measureText(this.title).width; const i = z(this.ctx, this.font, this.labels) + this.fontSize + 3; const e = g([i, t]); this.width = e + 2 * this.xPadding; const s = this.height / 2; this.y - s < 0 ? this.y = s : this.y + s > this.chart.height && (this.y = this.chart.height - s), this.x > this.chart.width / 2 ? this.x -= this.xOffset + this.width : this.x += this.xOffset }, getLineHeight(t) { const i = this.y - this.height / 2 + this.yPadding; const e = t - 1; return t === 0 ? i + this.titleFontSize / 2 : i + (1.5 * this.fontSize * e + this.fontSize / 2) + 1.5 * this.titleFontSize }, draw() { if (this.custom) this.custom(this); else { B(this.ctx, this.x, this.y - this.height / 2, this.width, this.height, this.cornerRadius); const t = this.ctx; t.fillStyle = this.fillColor, t.fill(), t.closePath(), t.textAlign = 'left', t.textBaseline = 'middle', t.fillStyle = this.titleTextColor, t.font = this.titleFont, t.fillText(this.title, this.x + this.xPadding, this.getLineHeight(0)), t.font = this.font, s.each(this.labels, function (i, e) { t.fillStyle = this.textColor, t.fillText(i, this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(e + 1)), t.fillStyle = this.legendColorBackground, t.fillRect(this.x + this.xPadding, this.getLineHeight(e + 1) - this.fontSize / 2, this.fontSize, this.fontSize), t.fillStyle = this.legendColors[e].fill, t.fillRect(this.x + this.xPadding, this.getLineHeight(e + 1) - this.fontSize / 2, this.fontSize, this.fontSize) }, this) } } }), e.Scale = e.Element.extend({ initialize() { this.fit() }, buildYLabels() { this.yLabels = []; for (let t = v(this.stepValue), i = 0; i <= this.steps; i++) this.yLabels.push(C(this.templateString, { value: (this.min + i * this.stepValue).toFixed(t) })); this.yLabelWidth = this.display && this.showLabels ? z(this.ctx, this.font, this.yLabels) : 0 }, addXLabel(t) { this.xLabels.push(t), this.valuesCount++, this.fit() }, removeXLabel() { this.xLabels.shift(), this.valuesCount--, this.fit() }, fit() { this.startPoint = this.display ? this.fontSize : 0, this.endPoint = this.display ? this.height - 1.5 * this.fontSize - 5 : this.height, this.startPoint += this.padding, this.endPoint -= this.padding; let t; let i = this.endPoint - this.startPoint; for (this.calculateYRange(i), this.buildYLabels(), this.calculateXLabelRotation(); i > this.endPoint - this.startPoint;)i = this.endPoint - this.startPoint, t = this.yLabelWidth, this.calculateYRange(i), this.buildYLabels(), t < this.yLabelWidth && this.calculateXLabelRotation() }, calculateXLabelRotation() { this.ctx.font = this.font; let t; let i; const e = this.ctx.measureText(this.xLabels[0]).width; const s = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width; if (this.xScalePaddingRight = s / 2 + 3, this.xScalePaddingLeft = e / 2 > this.yLabelWidth + 10 ? e / 2 : this.yLabelWidth + 10, this.xLabelRotation = 0, this.display) { let n; const o = z(this.ctx, this.font, this.xLabels); this.xLabelWidth = o; for (let a = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6; this.xLabelWidth > a && this.xLabelRotation === 0 || this.xLabelWidth > a && this.xLabelRotation <= 90 && this.xLabelRotation > 0;)n = Math.cos(S(this.xLabelRotation)), t = n * e, i = n * s, t + this.fontSize / 2 > this.yLabelWidth + 8 && (this.xScalePaddingLeft = t + this.fontSize / 2), this.xScalePaddingRight = this.fontSize / 2, this.xLabelRotation++, this.xLabelWidth = n * o; this.xLabelRotation > 0 && (this.endPoint -= Math.sin(S(this.xLabelRotation)) * o + 3) } else this.xLabelWidth = 0, this.xScalePaddingRight = this.padding, this.xScalePaddingLeft = this.padding }, calculateYRange: c, drawingArea() { return this.startPoint - this.endPoint }, calculateY(t) { const i = this.drawingArea() / (this.min - this.max); return this.endPoint - i * (t - this.min) }, calculateX(t) { const i = (this.xLabelRotation > 0, this.width - (this.xScalePaddingLeft + this.xScalePaddingRight)); const e = i / Math.max(this.valuesCount - (this.offsetGridLines ? 0 : 1), 1); let s = e * t + this.xScalePaddingLeft; return this.offsetGridLines && (s += e / 2), Math.round(s) }, update(t) { s.extend(this, t), this.fit() }, draw() { const t = this.ctx; const i = (this.endPoint - this.startPoint) / this.steps; const e = Math.round(this.xScalePaddingLeft); this.display && (t.fillStyle = this.textColor, t.font = this.font, n(this.yLabels, function (n, o) { const a = this.endPoint - i * o; let h = Math.round(a); let l = this.showHorizontalLines; t.textAlign = 'right', t.textBaseline = 'middle', this.showLabels && t.fillText(n, e - 10, a), o !== 0 || l || (l = !0), l && t.beginPath(), o > 0 ? (t.lineWidth = this.gridLineWidth, t.strokeStyle = this.gridLineColor) : (t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor), h += s.aliasPixel(t.lineWidth), l && (t.moveTo(e, h), t.lineTo(this.width, h), t.stroke(), t.closePath()), t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor, t.beginPath(), t.moveTo(e - 5, h), t.lineTo(e, h), t.stroke(), t.closePath() }, this), n(this.xLabels, function (i, e) { const s = this.calculateX(e) + x(this.lineWidth); const n = this.calculateX(e - (this.offsetGridLines ? 0.5 : 0)) + x(this.lineWidth); const o = this.xLabelRotation > 0; let a = this.showVerticalLines; e !== 0 || a || (a = !0), a && t.beginPath(), e > 0 ? (t.lineWidth = this.gridLineWidth, t.strokeStyle = this.gridLineColor) : (t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor), a && (t.moveTo(n, this.endPoint), t.lineTo(n, this.startPoint - 3), t.stroke(), t.closePath()), t.lineWidth = this.lineWidth, t.strokeStyle = this.lineColor, t.beginPath(), t.moveTo(n, this.endPoint), t.lineTo(n, this.endPoint + 5), t.stroke(), t.closePath(), t.save(), t.translate(s, o ? this.endPoint + 12 : this.endPoint + 8), t.rotate(-1 * S(this.xLabelRotation)), t.font = this.font, t.textAlign = o ? 'right' : 'center', t.textBaseline = o ? 'middle' : 'top', t.fillText(i, 0, 0), t.restore() }, this)) } }), e.RadialScale = e.Element.extend({ initialize() { this.size = m([this.height, this.width]), this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2 }, calculateCenterOffset(t) { const i = this.drawingArea / (this.max - this.min); return (t - this.min) * i }, update() { this.lineArc ? this.drawingArea = this.display ? this.size / 2 - (this.fontSize / 2 + this.backdropPaddingY) : this.size / 2 : this.setScaleSize(), this.buildYLabels() }, buildYLabels() { this.yLabels = []; for (let t = v(this.stepValue), i = 0; i <= this.steps; i++) this.yLabels.push(C(this.templateString, { value: (this.min + i * this.stepValue).toFixed(t) })) }, getCircumference() { return 2 * Math.PI / this.valuesCount }, setScaleSize() { let t; let i; let e; let s; let n; let o; let a; let h; let l; let r; let c; let u; const d = m([this.height / 2 - this.pointLabelFontSize - 5, this.width / 2]); let p = this.width; let g = 0; for (this.ctx.font = W(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily), i = 0; i < this.valuesCount; i++)t = this.getPointPosition(i, d), e = this.ctx.measureText(C(this.templateString, { value: this.labels[i] })).width + 5, i === 0 || i === this.valuesCount / 2 ? (s = e / 2, t.x + s > p && (p = t.x + s, n = i), t.x - s < g && (g = t.x - s, a = i)) : i < this.valuesCount / 2 ? t.x + e > p && (p = t.x + e, n = i) : i > this.valuesCount / 2 && t.x - e < g && (g = t.x - e, a = i); l = g, r = Math.ceil(p - this.width), o = this.getIndexAngle(n), h = this.getIndexAngle(a), c = r / Math.sin(o + Math.PI / 2), u = l / Math.sin(h + Math.PI / 2), c = f(c) ? c : 0, u = f(u) ? u : 0, this.drawingArea = d - (u + c) / 2, this.setCenterPoint(u, c) }, setCenterPoint(t, i) { const e = this.width - i - this.drawingArea; const s = t + this.drawingArea; this.xCenter = (s + e) / 2, this.yCenter = this.height / 2 }, getIndexAngle(t) { const i = 2 * Math.PI / this.valuesCount; return t * i - Math.PI / 2 }, getPointPosition(t, i) { const e = this.getIndexAngle(t); return { x: Math.cos(e) * i + this.xCenter, y: Math.sin(e) * i + this.yCenter } }, draw() { if (this.display) { const t = this.ctx; if (n(this.yLabels, function (i, e) { if (e > 0) { let s; const n = e * (this.drawingArea / this.steps); const o = this.yCenter - n; if (this.lineWidth > 0) if (t.strokeStyle = this.lineColor, t.lineWidth = this.lineWidth, this.lineArc)t.beginPath(), t.arc(this.xCenter, this.yCenter, n, 0, 2 * Math.PI), t.closePath(), t.stroke(); else { t.beginPath(); for (let a = 0; a < this.valuesCount; a++)s = this.getPointPosition(a, this.calculateCenterOffset(this.min + e * this.stepValue)), a === 0 ? t.moveTo(s.x, s.y) : t.lineTo(s.x, s.y); t.closePath(), t.stroke() } if (this.showLabels) { if (t.font = W(this.fontSize, this.fontStyle, this.fontFamily), this.showLabelBackdrop) { const h = t.measureText(i).width; t.fillStyle = this.backdropColor, t.fillRect(this.xCenter - h / 2 - this.backdropPaddingX, o - this.fontSize / 2 - this.backdropPaddingY, h + 2 * this.backdropPaddingX, this.fontSize + 2 * this.backdropPaddingY) }t.textAlign = 'center', t.textBaseline = 'middle', t.fillStyle = this.fontColor, t.fillText(i, this.xCenter, o) } } }, this), !this.lineArc) { t.lineWidth = this.angleLineWidth, t.strokeStyle = this.angleLineColor; for (let i = this.valuesCount - 1; i >= 0; i--) { if (this.angleLineWidth > 0) { const e = this.getPointPosition(i, this.calculateCenterOffset(this.max)); t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(e.x, e.y), t.stroke(), t.closePath() } const s = this.getPointPosition(i, this.calculateCenterOffset(this.max) + 5); t.font = W(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily), t.fillStyle = this.pointLabelFontColor; const o = this.labels.length; const a = this.labels.length / 2; const h = a / 2; const l = h > i || i > o - h; const r = i === h || i === o - h; t.textAlign = i === 0 ? 'center' : i === a ? 'center' : a > i ? 'left' : 'right', t.textBaseline = r ? 'middle' : l ? 'bottom' : 'top', t.fillText(this.labels[i], s.x, s.y) } } } } }), s.addEvent(window, 'resize', (function () { let t; return function () { clearTimeout(t), t = setTimeout(() => { n(e.instances, (t) => { t.options.responsive && t.resize(t.render, !0) }) }, 50) } }())), p ? define(() => e) : typeof module === 'object' && module.exports && (module.exports = e), t.Chart = e, e.noConflict = function () { return t.Chart = i, e }
}).call(this), (function () {
  const t = this; const i = t.Chart; const e = i.helpers; const s = { scaleBeginAtZero: !0, scaleShowGridLines: !0, scaleGridLineColor: 'rgba(0,0,0,.05)', scaleGridLineWidth: 1, scaleShowHorizontalLines: !0, scaleShowVerticalLines: !0, barShowStroke: !0, barStrokeWidth: 2, barValueSpacing: 5, barDatasetSpacing: 1, legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>' }; i.Type.extend({ name: 'Bar', defaults: s, initialize(t) { const s = this.options; this.ScaleClass = i.Scale.extend({ offsetGridLines: !0, calculateBarX(t, i, e) { const n = this.calculateBaseWidth(); const o = this.calculateX(e) - n / 2; const a = this.calculateBarWidth(t); return o + a * i + i * s.barDatasetSpacing + a / 2 }, calculateBaseWidth() { return this.calculateX(1) - this.calculateX(0) - 2 * s.barValueSpacing }, calculateBarWidth(t) { const i = this.calculateBaseWidth() - (t - 1) * s.barDatasetSpacing; return i / t } }), this.datasets = [], this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function (t) { const i = t.type !== 'mouseout' ? this.getBarsAtEvent(t) : []; this.eachBars((t) => { t.restore(['fillColor', 'strokeColor']) }), e.each(i, (t) => { t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke }), this.showTooltip(i) }), this.BarClass = i.Rectangle.extend({ strokeWidth: this.options.barStrokeWidth, showStroke: this.options.barShowStroke, ctx: this.chart.ctx }), e.each(t.datasets, function (i) { const s = { label: i.label || null, fillColor: i.fillColor, strokeColor: i.strokeColor, bars: [] }; this.datasets.push(s), e.each(i.data, function (e, n) { s.bars.push(new this.BarClass({ value: e, label: t.labels[n], datasetLabel: i.label, strokeColor: i.strokeColor, fillColor: i.fillColor, highlightFill: i.highlightFill || i.fillColor, highlightStroke: i.highlightStroke || i.strokeColor })) }, this) }, this), this.buildScale(t.labels), this.BarClass.prototype.base = this.scale.endPoint, this.eachBars(function (t, i, s) { e.extend(t, { width: this.scale.calculateBarWidth(this.datasets.length), x: this.scale.calculateBarX(this.datasets.length, s, i), y: this.scale.endPoint }), t.save() }, this), this.render() }, update() { this.scale.update(), e.each(this.activeElements, (t) => { t.restore(['fillColor', 'strokeColor']) }), this.eachBars((t) => { t.save() }), this.render() }, eachBars(t) { e.each(this.datasets, function (i, s) { e.each(i.bars, t, this, s) }, this) }, getBarsAtEvent(t) { for (var i, s = [], n = e.getRelativePosition(t), o = function (t) { s.push(t.bars[i]) }, a = 0; a < this.datasets.length; a++) for (i = 0; i < this.datasets[a].bars.length; i++) if (this.datasets[a].bars[i].inRange(n.x, n.y)) return e.each(this.datasets, o), s; return s }, buildScale(t) { const i = this; const s = function () { const t = []; return i.eachBars((i) => { t.push(i.value) }), t }; const n = { templateString: this.options.scaleLabel, height: this.chart.height, width: this.chart.width, ctx: this.chart.ctx, textColor: this.options.scaleFontColor, fontSize: this.options.scaleFontSize, fontStyle: this.options.scaleFontStyle, fontFamily: this.options.scaleFontFamily, valuesCount: t.length, beginAtZero: this.options.scaleBeginAtZero, integersOnly: this.options.scaleIntegersOnly, calculateYRange(t) { const i = e.calculateScaleRange(s(), t, this.fontSize, this.beginAtZero, this.integersOnly); e.extend(this, i) }, xLabels: t, font: e.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily), lineWidth: this.options.scaleLineWidth, lineColor: this.options.scaleLineColor, showHorizontalLines: this.options.scaleShowHorizontalLines, showVerticalLines: this.options.scaleShowVerticalLines, gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0, gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : 'rgba(0,0,0,0)', padding: this.options.showScale ? 0 : this.options.barShowStroke ? this.options.barStrokeWidth : 0, showLabels: this.options.scaleShowLabels, display: this.options.showScale }; this.options.scaleOverride && e.extend(n, { calculateYRange: e.noop, steps: this.options.scaleSteps, stepValue: this.options.scaleStepWidth, min: this.options.scaleStartValue, max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth }), this.scale = new this.ScaleClass(n) }, addData(t, i) { e.each(t, function (t, e) { this.datasets[e].bars.push(new this.BarClass({ value: t, label: i, x: this.scale.calculateBarX(this.datasets.length, e, this.scale.valuesCount + 1), y: this.scale.endPoint, width: this.scale.calculateBarWidth(this.datasets.length), base: this.scale.endPoint, strokeColor: this.datasets[e].strokeColor, fillColor: this.datasets[e].fillColor })) }, this), this.scale.addXLabel(i), this.update() }, removeData() { this.scale.removeXLabel(), e.each(this.datasets, (t) => { t.bars.shift() }, this), this.update() }, reflow() { e.extend(this.BarClass.prototype, { y: this.scale.endPoint, base: this.scale.endPoint }); const t = e.extend({ height: this.chart.height, width: this.chart.width }); this.scale.update(t) }, draw(t) { const i = t || 1; this.clear(); this.chart.ctx; this.scale.draw(i), e.each(this.datasets, function (t, s) { e.each(t.bars, function (t, e) { t.hasValue() && (t.base = this.scale.endPoint, t.transition({ x: this.scale.calculateBarX(this.datasets.length, s, e), y: this.scale.calculateY(t.value), width: this.scale.calculateBarWidth(this.datasets.length) }, i).draw()) }, this) }, this) } })
}.call(this)), (function () {
  const t = this; const i = t.Chart; const e = i.helpers; const s = { segmentShowStroke: !0, segmentStrokeColor: '#fff', segmentStrokeWidth: 2, percentageInnerCutout: 50, animationSteps: 100, animationEasing: 'easeOutBounce', animateRotate: !0, animateScale: !1, legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>' }; i.Type.extend({ name: 'Doughnut', defaults: s, initialize(t) { this.segments = [], this.outerRadius = (e.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2, this.SegmentArc = i.Arc.extend({ ctx: this.chart.ctx, x: this.chart.width / 2, y: this.chart.height / 2 }), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function (t) { const i = t.type !== 'mouseout' ? this.getSegmentsAtEvent(t) : []; e.each(this.segments, (t) => { t.restore(['fillColor']) }), e.each(i, (t) => { t.fillColor = t.highlightColor }), this.showTooltip(i) }), this.calculateTotal(t), e.each(t, function (t, i) { this.addData(t, i, !0) }, this), this.render() }, getSegmentsAtEvent(t) { const i = []; const s = e.getRelativePosition(t); return e.each(this.segments, (t) => { t.inRange(s.x, s.y) && i.push(t) }, this), i }, addData(t, i, e) { const s = i || this.segments.length; this.segments.splice(s, 0, new this.SegmentArc({ value: t.value, outerRadius: this.options.animateScale ? 0 : this.outerRadius, innerRadius: this.options.animateScale ? 0 : this.outerRadius / 100 * this.options.percentageInnerCutout, fillColor: t.color, highlightColor: t.highlight || t.color, showStroke: this.options.segmentShowStroke, strokeWidth: this.options.segmentStrokeWidth, strokeColor: this.options.segmentStrokeColor, startAngle: 1.5 * Math.PI, circumference: this.options.animateRotate ? 0 : this.calculateCircumference(t.value), label: t.label })), e || (this.reflow(), this.update()) }, calculateCircumference(t) { return 2 * Math.PI * (Math.abs(t) / this.total) }, calculateTotal(t) { this.total = 0, e.each(t, function (t) { this.total += Math.abs(t.value) }, this) }, update() { this.calculateTotal(this.segments), e.each(this.activeElements, (t) => { t.restore(['fillColor']) }), e.each(this.segments, (t) => { t.save() }), this.render() }, removeData(t) { const i = e.isNumber(t) ? t : this.segments.length - 1; this.segments.splice(i, 1), this.reflow(), this.update() }, reflow() { e.extend(this.SegmentArc.prototype, { x: this.chart.width / 2, y: this.chart.height / 2 }), this.outerRadius = (e.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2, e.each(this.segments, function (t) { t.update({ outerRadius: this.outerRadius, innerRadius: this.outerRadius / 100 * this.options.percentageInnerCutout }) }, this) }, draw(t) { const i = t || 1; this.clear(), e.each(this.segments, function (t, e) { t.transition({ circumference: this.calculateCircumference(t.value), outerRadius: this.outerRadius, innerRadius: this.outerRadius / 100 * this.options.percentageInnerCutout }, i), t.endAngle = t.startAngle + t.circumference, t.draw(), e === 0 && (t.startAngle = 1.5 * Math.PI), e < this.segments.length - 1 && (this.segments[e + 1].startAngle = t.endAngle) }, this) } }), i.types.Doughnut.extend({ name: 'Pie', defaults: e.merge(s, { percentageInnerCutout: 0 }) })
}.call(this)), (function () {
  const t = this; const i = t.Chart; const e = i.helpers; const s = { scaleShowGridLines: !0, scaleGridLineColor: 'rgba(0,0,0,.05)', scaleGridLineWidth: 1, scaleShowHorizontalLines: !0, scaleShowVerticalLines: !0, bezierCurve: !0, bezierCurveTension: 0.4, pointDot: !0, pointDotRadius: 4, pointDotStrokeWidth: 1, pointHitDetectionRadius: 20, datasetStroke: !0, datasetStrokeWidth: 2, datasetFill: !0, legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>' }; i.Type.extend({ name: 'Line', defaults: s, initialize(t) { this.PointClass = i.Point.extend({ strokeWidth: this.options.pointDotStrokeWidth, radius: this.options.pointDotRadius, display: this.options.pointDot, hitDetectionRadius: this.options.pointHitDetectionRadius, ctx: this.chart.ctx, inRange(t) { return Math.pow(t - this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius, 2) } }), this.datasets = [], this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function (t) { const i = t.type !== 'mouseout' ? this.getPointsAtEvent(t) : []; this.eachPoints((t) => { t.restore(['fillColor', 'strokeColor']) }), e.each(i, (t) => { t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke }), this.showTooltip(i) }), e.each(t.datasets, function (i) { const s = { label: i.label || null, fillColor: i.fillColor, strokeColor: i.strokeColor, pointColor: i.pointColor, pointStrokeColor: i.pointStrokeColor, points: [] }; this.datasets.push(s), e.each(i.data, function (e, n) { s.points.push(new this.PointClass({ value: e, label: t.labels[n], datasetLabel: i.label, strokeColor: i.pointStrokeColor, fillColor: i.pointColor, highlightFill: i.pointHighlightFill || i.pointColor, highlightStroke: i.pointHighlightStroke || i.pointStrokeColor })) }, this), this.buildScale(t.labels), this.eachPoints(function (t, i) { e.extend(t, { x: this.scale.calculateX(i), y: this.scale.endPoint }), t.save() }, this) }, this), this.render() }, update() { this.scale.update(), e.each(this.activeElements, (t) => { t.restore(['fillColor', 'strokeColor']) }), this.eachPoints((t) => { t.save() }), this.render() }, eachPoints(t) { e.each(this.datasets, function (i) { e.each(i.points, t, this) }, this) }, getPointsAtEvent(t) { const i = []; const s = e.getRelativePosition(t); return e.each(this.datasets, (t) => { e.each(t.points, (t) => { t.inRange(s.x, s.y) && i.push(t) }) }, this), i }, buildScale(t) { const s = this; const n = function () { const t = []; return s.eachPoints((i) => { t.push(i.value) }), t }; const o = { templateString: this.options.scaleLabel, height: this.chart.height, width: this.chart.width, ctx: this.chart.ctx, textColor: this.options.scaleFontColor, fontSize: this.options.scaleFontSize, fontStyle: this.options.scaleFontStyle, fontFamily: this.options.scaleFontFamily, valuesCount: t.length, beginAtZero: this.options.scaleBeginAtZero, integersOnly: this.options.scaleIntegersOnly, calculateYRange(t) { const i = e.calculateScaleRange(n(), t, this.fontSize, this.beginAtZero, this.integersOnly); e.extend(this, i) }, xLabels: t, font: e.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily), lineWidth: this.options.scaleLineWidth, lineColor: this.options.scaleLineColor, showHorizontalLines: this.options.scaleShowHorizontalLines, showVerticalLines: this.options.scaleShowVerticalLines, gridLineWidth: this.options.scaleShowGridLines ? this.options.scaleGridLineWidth : 0, gridLineColor: this.options.scaleShowGridLines ? this.options.scaleGridLineColor : 'rgba(0,0,0,0)', padding: this.options.showScale ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth, showLabels: this.options.scaleShowLabels, display: this.options.showScale }; this.options.scaleOverride && e.extend(o, { calculateYRange: e.noop, steps: this.options.scaleSteps, stepValue: this.options.scaleStepWidth, min: this.options.scaleStartValue, max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth }), this.scale = new i.Scale(o) }, addData(t, i) { e.each(t, function (t, e) { this.datasets[e].points.push(new this.PointClass({ value: t, label: i, x: this.scale.calculateX(this.scale.valuesCount + 1), y: this.scale.endPoint, strokeColor: this.datasets[e].pointStrokeColor, fillColor: this.datasets[e].pointColor })) }, this), this.scale.addXLabel(i), this.update() }, removeData() { this.scale.removeXLabel(), e.each(this.datasets, (t) => { t.points.shift() }, this), this.update() }, reflow() { const t = e.extend({ height: this.chart.height, width: this.chart.width }); this.scale.update(t) }, draw(t) { const i = t || 1; this.clear(); const s = this.chart.ctx; const n = function (t) { return t.value !== null }; const o = function (t, i, s) { return e.findNextWhere(i, n, s) || t }; const a = function (t, i, s) { return e.findPreviousWhere(i, n, s) || t }; this.scale.draw(i), e.each(this.datasets, function (t) { const h = e.where(t.points, n); e.each(t.points, function (t, e) { t.hasValue() && t.transition({ y: this.scale.calculateY(t.value), x: this.scale.calculateX(e) }, i) }, this), this.options.bezierCurve && e.each(h, function (t, i) { const s = i > 0 && i < h.length - 1 ? this.options.bezierCurveTension : 0; t.controlPoints = e.splineCurve(a(t, h, i), t, o(t, h, i), s), t.controlPoints.outer.y > this.scale.endPoint ? t.controlPoints.outer.y = this.scale.endPoint : t.controlPoints.outer.y < this.scale.startPoint && (t.controlPoints.outer.y = this.scale.startPoint), t.controlPoints.inner.y > this.scale.endPoint ? t.controlPoints.inner.y = this.scale.endPoint : t.controlPoints.inner.y < this.scale.startPoint && (t.controlPoints.inner.y = this.scale.startPoint) }, this), s.lineWidth = this.options.datasetStrokeWidth, s.strokeStyle = t.strokeColor, s.beginPath(), e.each(h, function (t, i) { if (i === 0)s.moveTo(t.x, t.y); else if (this.options.bezierCurve) { const e = a(t, h, i); s.bezierCurveTo(e.controlPoints.outer.x, e.controlPoints.outer.y, t.controlPoints.inner.x, t.controlPoints.inner.y, t.x, t.y) } else s.lineTo(t.x, t.y) }, this), s.stroke(), this.options.datasetFill && h.length > 0 && (s.lineTo(h[h.length - 1].x, this.scale.endPoint), s.lineTo(h[0].x, this.scale.endPoint), s.fillStyle = t.fillColor, s.closePath(), s.fill()), e.each(h, (t) => { t.draw() }) }, this) } })
}.call(this)), (function () {
  const t = this; const i = t.Chart; const e = i.helpers; const s = { scaleShowLabelBackdrop: !0, scaleBackdropColor: 'rgba(255,255,255,0.75)', scaleBeginAtZero: !0, scaleBackdropPaddingY: 2, scaleBackdropPaddingX: 2, scaleShowLine: !0, segmentShowStroke: !0, segmentStrokeColor: '#fff', segmentStrokeWidth: 2, animationSteps: 100, animationEasing: 'easeOutBounce', animateRotate: !0, animateScale: !1, legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>' }; i.Type.extend({ name: 'PolarArea', defaults: s, initialize(t) { this.segments = [], this.SegmentArc = i.Arc.extend({ showStroke: this.options.segmentShowStroke, strokeWidth: this.options.segmentStrokeWidth, strokeColor: this.options.segmentStrokeColor, ctx: this.chart.ctx, innerRadius: 0, x: this.chart.width / 2, y: this.chart.height / 2 }), this.scale = new i.RadialScale({ display: this.options.showScale, fontStyle: this.options.scaleFontStyle, fontSize: this.options.scaleFontSize, fontFamily: this.options.scaleFontFamily, fontColor: this.options.scaleFontColor, showLabels: this.options.scaleShowLabels, showLabelBackdrop: this.options.scaleShowLabelBackdrop, backdropColor: this.options.scaleBackdropColor, backdropPaddingY: this.options.scaleBackdropPaddingY, backdropPaddingX: this.options.scaleBackdropPaddingX, lineWidth: this.options.scaleShowLine ? this.options.scaleLineWidth : 0, lineColor: this.options.scaleLineColor, lineArc: !0, width: this.chart.width, height: this.chart.height, xCenter: this.chart.width / 2, yCenter: this.chart.height / 2, ctx: this.chart.ctx, templateString: this.options.scaleLabel, valuesCount: t.length }), this.updateScaleRange(t), this.scale.update(), e.each(t, function (t, i) { this.addData(t, i, !0) }, this), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function (t) { const i = t.type !== 'mouseout' ? this.getSegmentsAtEvent(t) : []; e.each(this.segments, (t) => { t.restore(['fillColor']) }), e.each(i, (t) => { t.fillColor = t.highlightColor }), this.showTooltip(i) }), this.render() }, getSegmentsAtEvent(t) { const i = []; const s = e.getRelativePosition(t); return e.each(this.segments, (t) => { t.inRange(s.x, s.y) && i.push(t) }, this), i }, addData(t, i, e) { const s = i || this.segments.length; this.segments.splice(s, 0, new this.SegmentArc({ fillColor: t.color, highlightColor: t.highlight || t.color, label: t.label, value: t.value, outerRadius: this.options.animateScale ? 0 : this.scale.calculateCenterOffset(t.value), circumference: this.options.animateRotate ? 0 : this.scale.getCircumference(), startAngle: 1.5 * Math.PI })), e || (this.reflow(), this.update()) }, removeData(t) { const i = e.isNumber(t) ? t : this.segments.length - 1; this.segments.splice(i, 1), this.reflow(), this.update() }, calculateTotal(t) { this.total = 0, e.each(t, function (t) { this.total += t.value }, this), this.scale.valuesCount = this.segments.length }, updateScaleRange(t) { const i = []; e.each(t, (t) => { i.push(t.value) }); const s = this.options.scaleOverride ? { steps: this.options.scaleSteps, stepValue: this.options.scaleStepWidth, min: this.options.scaleStartValue, max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth } : e.calculateScaleRange(i, e.min([this.chart.width, this.chart.height]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly); e.extend(this.scale, s, { size: e.min([this.chart.width, this.chart.height]), xCenter: this.chart.width / 2, yCenter: this.chart.height / 2 }) }, update() { this.calculateTotal(this.segments), e.each(this.segments, (t) => { t.save() }), this.reflow(), this.render() }, reflow() { e.extend(this.SegmentArc.prototype, { x: this.chart.width / 2, y: this.chart.height / 2 }), this.updateScaleRange(this.segments), this.scale.update(), e.extend(this.scale, { xCenter: this.chart.width / 2, yCenter: this.chart.height / 2 }), e.each(this.segments, function (t) { t.update({ outerRadius: this.scale.calculateCenterOffset(t.value) }) }, this) }, draw(t) { const i = t || 1; this.clear(), e.each(this.segments, function (t, e) { t.transition({ circumference: this.scale.getCircumference(), outerRadius: this.scale.calculateCenterOffset(t.value) }, i), t.endAngle = t.startAngle + t.circumference, e === 0 && (t.startAngle = 1.5 * Math.PI), e < this.segments.length - 1 && (this.segments[e + 1].startAngle = t.endAngle), t.draw() }, this), this.scale.draw() } })
}.call(this)), (function () {
  const t = this; const i = t.Chart; const e = i.helpers; i.Type.extend({ name: 'Radar', defaults: { scaleShowLine: !0, angleShowLineOut: !0, scaleShowLabels: !1, scaleBeginAtZero: !0, angleLineColor: 'rgba(0,0,0,.1)', angleLineWidth: 1, pointLabelFontFamily: "'Arial'", pointLabelFontStyle: 'normal', pointLabelFontSize: 10, pointLabelFontColor: '#666', pointDot: !0, pointDotRadius: 3, pointDotStrokeWidth: 1, pointHitDetectionRadius: 20, datasetStroke: !0, datasetStrokeWidth: 2, datasetFill: !0, legendTemplate: '<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>' }, initialize(t) { this.PointClass = i.Point.extend({ strokeWidth: this.options.pointDotStrokeWidth, radius: this.options.pointDotRadius, display: this.options.pointDot, hitDetectionRadius: this.options.pointHitDetectionRadius, ctx: this.chart.ctx }), this.datasets = [], this.buildScale(t), this.options.showTooltips && e.bindEvents(this, this.options.tooltipEvents, function (t) { const i = t.type !== 'mouseout' ? this.getPointsAtEvent(t) : []; this.eachPoints((t) => { t.restore(['fillColor', 'strokeColor']) }), e.each(i, (t) => { t.fillColor = t.highlightFill, t.strokeColor = t.highlightStroke }), this.showTooltip(i) }), e.each(t.datasets, function (i) { const s = { label: i.label || null, fillColor: i.fillColor, strokeColor: i.strokeColor, pointColor: i.pointColor, pointStrokeColor: i.pointStrokeColor, points: [] }; this.datasets.push(s), e.each(i.data, function (e, n) { let o; this.scale.animation || (o = this.scale.getPointPosition(n, this.scale.calculateCenterOffset(e))), s.points.push(new this.PointClass({ value: e, label: t.labels[n], datasetLabel: i.label, x: this.options.animation ? this.scale.xCenter : o.x, y: this.options.animation ? this.scale.yCenter : o.y, strokeColor: i.pointStrokeColor, fillColor: i.pointColor, highlightFill: i.pointHighlightFill || i.pointColor, highlightStroke: i.pointHighlightStroke || i.pointStrokeColor })) }, this) }, this), this.render() }, eachPoints(t) { e.each(this.datasets, function (i) { e.each(i.points, t, this) }, this) }, getPointsAtEvent(t) { const i = e.getRelativePosition(t); const s = e.getAngleFromPoint({ x: this.scale.xCenter, y: this.scale.yCenter }, i); const n = 2 * Math.PI / this.scale.valuesCount; let o = Math.round((s.angle - 1.5 * Math.PI) / n); const a = []; return (o >= this.scale.valuesCount || o < 0) && (o = 0), s.distance <= this.scale.drawingArea && e.each(this.datasets, (t) => { a.push(t.points[o]) }), a }, buildScale(t) { this.scale = new i.RadialScale({ display: this.options.showScale, fontStyle: this.options.scaleFontStyle, fontSize: this.options.scaleFontSize, fontFamily: this.options.scaleFontFamily, fontColor: this.options.scaleFontColor, showLabels: this.options.scaleShowLabels, showLabelBackdrop: this.options.scaleShowLabelBackdrop, backdropColor: this.options.scaleBackdropColor, backdropPaddingY: this.options.scaleBackdropPaddingY, backdropPaddingX: this.options.scaleBackdropPaddingX, lineWidth: this.options.scaleShowLine ? this.options.scaleLineWidth : 0, lineColor: this.options.scaleLineColor, angleLineColor: this.options.angleLineColor, angleLineWidth: this.options.angleShowLineOut ? this.options.angleLineWidth : 0, pointLabelFontColor: this.options.pointLabelFontColor, pointLabelFontSize: this.options.pointLabelFontSize, pointLabelFontFamily: this.options.pointLabelFontFamily, pointLabelFontStyle: this.options.pointLabelFontStyle, height: this.chart.height, width: this.chart.width, xCenter: this.chart.width / 2, yCenter: this.chart.height / 2, ctx: this.chart.ctx, templateString: this.options.scaleLabel, labels: t.labels, valuesCount: t.datasets[0].data.length }), this.scale.setScaleSize(), this.updateScaleRange(t.datasets), this.scale.buildYLabels() }, updateScaleRange(t) { const i = (function () { let i = []; return e.each(t, (t) => { t.data ? i = i.concat(t.data) : e.each(t.points, (t) => { i.push(t.value) }) }), i }()); const s = this.options.scaleOverride ? { steps: this.options.scaleSteps, stepValue: this.options.scaleStepWidth, min: this.options.scaleStartValue, max: this.options.scaleStartValue + this.options.scaleSteps * this.options.scaleStepWidth } : e.calculateScaleRange(i, e.min([this.chart.width, this.chart.height]) / 2, this.options.scaleFontSize, this.options.scaleBeginAtZero, this.options.scaleIntegersOnly); e.extend(this.scale, s) }, addData(t, i) { this.scale.valuesCount++, e.each(t, function (t, e) { const s = this.scale.getPointPosition(this.scale.valuesCount, this.scale.calculateCenterOffset(t)); this.datasets[e].points.push(new this.PointClass({ value: t, label: i, x: s.x, y: s.y, strokeColor: this.datasets[e].pointStrokeColor, fillColor: this.datasets[e].pointColor })) }, this), this.scale.labels.push(i), this.reflow(), this.update() }, removeData() { this.scale.valuesCount--, this.scale.labels.shift(), e.each(this.datasets, (t) => { t.points.shift() }, this), this.reflow(), this.update() }, update() { this.eachPoints((t) => { t.save() }), this.reflow(), this.render() }, reflow() { e.extend(this.scale, { width: this.chart.width, height: this.chart.height, size: e.min([this.chart.width, this.chart.height]), xCenter: this.chart.width / 2, yCenter: this.chart.height / 2 }), this.updateScaleRange(this.datasets), this.scale.setScaleSize(), this.scale.buildYLabels() }, draw(t) { const i = t || 1; const s = this.chart.ctx; this.clear(), this.scale.draw(), e.each(this.datasets, function (t) { e.each(t.points, function (t, e) { t.hasValue() && t.transition(this.scale.getPointPosition(e, this.scale.calculateCenterOffset(t.value)), i) }, this), s.lineWidth = this.options.datasetStrokeWidth, s.strokeStyle = t.strokeColor, s.beginPath(), e.each(t.points, (t, i) => { i === 0 ? s.moveTo(t.x, t.y) : s.lineTo(t.x, t.y) }, this), s.closePath(), s.stroke(), s.fillStyle = t.fillColor, s.fill(), e.each(t.points, (t) => { t.hasValue() && t.draw() }) }, this) } })
}.call(this))
window.Modernizr = (function (e, t, n) { function r(e) { p.cssText = e } function i(e, t) { return r(prefixes.join(`${e};`) + (t || '')) } function s(e, t) { return typeof e === t } function o(e, t) { return !!~(`${e}`).indexOf(t) } function u(e, t, r) { for (const i in e) { const o = t[e[i]]; if (o !== n) return r === !1 ? e[i] : s(o, 'function') ? o.bind(r || t) : o } return !1 } const a = '2.6.2'; const f = {}; const l = t.documentElement; const c = 'modernizr'; let h = t.createElement(c); var p = h.style; let d; const v = {}.toString; const m = {}; const g = {}; const y = {}; const b = []; const w = b.slice; let E; const S = {}.hasOwnProperty; let x; !s(S, 'undefined') && !s(S.call, 'undefined') ? x = function (e, t) { return S.call(e, t) } : x = function (e, t) { return t in e && s(e.constructor.prototype[t], 'undefined') }, Function.prototype.bind || (Function.prototype.bind = function (e) { const t = this; if (typeof t !== 'function') throw new TypeError(); const n = w.call(arguments, 1); var r = function () { if (this instanceof r) { const i = function () {}; i.prototype = t.prototype; const s = new i(); const o = t.apply(s, n.concat(w.call(arguments))); return Object(o) === o ? o : s } return t.apply(e, n.concat(w.call(arguments))) }; return r }), m.canvas = function () { const e = t.createElement('canvas'); return !!e.getContext && !!e.getContext('2d') }; for (const T in m)x(m, T) && (E = T.toLowerCase(), f[E] = m[T](), b.push((f[E] ? '' : 'no-') + E)); return f.addTest = function (e, t) { if (typeof e === 'object') for (const r in e)x(e, r) && f.addTest(r, e[r]); else { e = e.toLowerCase(); if (f[e] !== n) return f; t = typeof t === 'function' ? t() : t, typeof enableClasses !== 'undefined' && enableClasses && (l.className += ` ${t ? '' : 'no-'}${e}`), f[e] = t } return f }, r(''), h = d = null, (function (e, t) { function n(e, t) { const n = e.createElement('p'); const r = e.getElementsByTagName('head')[0] || e.documentElement; return n.innerHTML = `x<style>${t}</style>`, r.insertBefore(n.lastChild, r.firstChild) } function r() { const e = g.elements; return typeof e === 'string' ? e.split(' ') : e } function i(e) { let t = v[e[p]]; return t || (t = {}, d++, e[p] = d, v[d] = t), t } function s(e, n, r) { n || (n = t); if (m) return n.createElement(e); r || (r = i(n)); let s; return r.cache[e] ? s = r.cache[e].cloneNode() : c.test(e) ? s = (r.cache[e] = r.createElem(e)).cloneNode() : s = r.createElem(e), s.canHaveChildren && !l.test(e) ? r.frag.appendChild(s) : s } function o(e, n) { e || (e = t); if (m) return e.createDocumentFragment(); n = n || i(e); const s = n.frag.cloneNode(); let o = 0; const u = r(); const a = u.length; for (;o < a; o++)s.createElement(u[o]); return s } function u(e, t) { t.cache || (t.cache = {}, t.createElem = e.createElement, t.createFrag = e.createDocumentFragment, t.frag = t.createFrag()), e.createElement = function (n) { return g.shivMethods ? s(n, e, t) : t.createElem(n) }, e.createDocumentFragment = Function('h,f', `return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(${r().join().replace(/\w+/g, (e) => t.createElem(e), t.frag.createElement(e), `c("${e}")`)});return n}`)(g, t.frag) } function a(e) { e || (e = t); const r = i(e); return g.shivCSS && !h && !r.hasCSS && (r.hasCSS = !!n(e, 'article,aside,figcaption,figure,footer,header,hgroup,nav,section{display:block}mark{background:#FF0;color:#000}')), m || u(e, r), e } const f = e.html5 || {}; var l = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i; var c = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i; let h; var p = '_html5shiv'; var d = 0; var v = {}; let m; (function () { try { const e = t.createElement('a'); e.innerHTML = '<xyz></xyz>', h = 'hidden' in e, m = e.childNodes.length == 1 || (function () { t.createElement('a'); const e = t.createDocumentFragment(); return typeof e.cloneNode === 'undefined' || typeof e.createDocumentFragment === 'undefined' || typeof e.createElement === 'undefined' }()) } catch (n) { h = !0, m = !0 } })(); var g = { elements: f.elements || 'abbr article aside audio bdi canvas data datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video', shivCSS: f.shivCSS !== !1, supportsUnknownElements: m, shivMethods: f.shivMethods !== !1, type: 'default', shivDocument: a, createElement: s, createDocumentFragment: o }; e.html5 = g, a(t) }(this, t)), f._version = a, f }(this, this.document)), (function (e, t, n) { function r(e) { return d.call(e) == '[object Function]' } function i(e) { return typeof e === 'string' } function s() {} function o(e) { return !e || e == 'loaded' || e == 'complete' || e == 'uninitialized' } function u() { const e = v.shift(); m = 1, e ? e.t ? h(() => { (e.t == 'c' ? k.injectCss : k.injectJs)(e.s, 0, e.a, e.x, e.e, 1) }, 0) : (e(), u()) : m = 0 } function a(e, n, r, i, s, a, f) { function l(t) { if (!d && o(c.readyState) && (w.r = d = 1, !m && u(), c.onload = c.onreadystatechange = null, t)) { e != 'img' && h(() => { b.removeChild(c) }, 50); for (const r in T[n])T[n].hasOwnProperty(r) && T[n][r].onload() } } var f = f || k.errorTimeout; var c = t.createElement(e); var d = 0; let g = 0; var w = { t: r, s: n, e: s, a, x: f }; T[n] === 1 && (g = 1, T[n] = []), e == 'object' ? c.data = n : (c.src = n, c.type = e), c.width = c.height = '0', c.onerror = c.onload = c.onreadystatechange = function () { l.call(this, g) }, v.splice(i, 0, w), e != 'img' && (g || T[n] === 2 ? (b.insertBefore(c, y ? null : p), h(l, f)) : T[n].push(c)) } function f(e, t, n, r, s) { return m = 0, t = t || 'j', i(e) ? a(t == 'c' ? E : w, e, t, this.i++, n, r, s) : (v.splice(this.i++, 0, e), v.length == 1 && u()), this } function l() { const e = k; return e.loader = { load: f, i: 0 }, e } var c = t.documentElement; var h = e.setTimeout; var p = t.getElementsByTagName('script')[0]; var d = {}.toString; var v = []; var m = 0; const g = 'MozAppearance' in c.style; var y = g && !!t.createRange().compareNode; var b = y ? c : p.parentNode; var c = e.opera && d.call(e.opera) == '[object Opera]'; var c = !!t.attachEvent && !c; var w = g ? 'object' : c ? 'script' : 'img'; var E = c ? 'script' : w; const S = Array.isArray || function (e) { return d.call(e) == '[object Array]' }; const x = []; var T = {}; const N = { timeout(e, t) { return t.length && (e.timeout = t[0]), e } }; let C; let k; k = function (e) { function t(e) { var e = e.split('!'); const t = x.length; var n = e.pop(); const r = e.length; var n = { url: n, origUrl: n, prefixes: e }; let i; let s; let o; for (s = 0; s < r; s++)o = e[s].split('='), (i = N[o.shift()]) && (n = i(n, o)); for (s = 0; s < t; s++)n = x[s](n); return n } function o(e, i, s, o, u) { const a = t(e); const f = a.autoCallback; a.url.split('.').pop().split('?').shift(), a.bypass || (i && (i = r(i) ? i : i[e] || i[o] || i[e.split('/').pop().split('?')[0]]), a.instead ? a.instead(e, i, s, o, u) : (T[a.url] ? a.noexec = !0 : T[a.url] = 1, s.load(a.url, a.forceCSS || !a.forceJS && a.url.split('.').pop().split('?').shift() == 'css' ? 'c' : n, a.noexec, a.attrs, a.timeout), (r(i) || r(f)) && s.load(() => { l(), i && i(a.origUrl, u, o), f && f(a.origUrl, u, o), T[a.url] = 2 }))) } function u(e, t) { function n(e, n) { if (e) { if (i(e))n || (f = function () { const e = [].slice.call(arguments); l.apply(this, e), c() }), o(e, f, t, 0, u); else if (Object(e) === e) for (p in h = (function () { let t = 0; let n; for (n in e)e.hasOwnProperty(n) && t++; return t }()), e)e.hasOwnProperty(p) && (!n && !--h && (r(f) ? f = function () { const e = [].slice.call(arguments); l.apply(this, e), c() } : f[p] = (function (e) { return function () { const t = [].slice.call(arguments); e && e.apply(this, t), c() } }(l[p]))), o(e[p], f, t, p, u)) } else !n && c() } var u = !!e.test; const a = e.load || e.both; var f = e.callback || s; var l = f; var c = e.complete || s; let h; let p; n(u ? e.yep : e.nope, !!a), a && n(a) } let a; let f; const c = this.yepnope.loader; if (i(e))o(e, 0, c, 0); else if (S(e)) for (a = 0; a < e.length; a++)f = e[a], i(f) ? o(f, 0, c, 0) : S(f) ? k(f) : Object(f) === f && u(f, c); else Object(e) === e && u(e, c) }, k.addPrefix = function (e, t) { N[e] = t }, k.addFilter = function (e) { x.push(e) }, k.errorTimeout = 1e4, t.readyState == null && t.addEventListener && (t.readyState = 'loading', t.addEventListener('DOMContentLoaded', C = function () { t.removeEventListener('DOMContentLoaded', C, 0), t.readyState = 'complete' }, 0)), e.yepnope = l(), e.yepnope.executeStack = u, e.yepnope.injectJs = function (e, n, r, i, a, f) { const l = t.createElement('script'); let c; let d; var i = i || k.errorTimeout; l.src = e; for (d in r)l.setAttribute(d, r[d]); n = f ? u : n || s, l.onreadystatechange = l.onload = function () { !c && o(l.readyState) && (c = 1, n(), l.onload = l.onreadystatechange = null) }, h(() => { c || (c = 1, n(1)) }, i), a ? l.onload() : p.parentNode.insertBefore(l, p) }, e.yepnope.injectCss = function (e, n, r, i, o, a) { var i = t.createElement('link'); let f; var n = a ? u : n || s; i.href = e, i.rel = 'stylesheet', i.type = 'text/css'; for (f in r)i.setAttribute(f, r[f]); o || (p.parentNode.insertBefore(i, p), h(n, 0)) } }(this, document)), Modernizr.load = function () { yepnope.apply(window, [].slice.call(arguments, 0)) }
