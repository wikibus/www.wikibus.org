/*!
 * animsition v4.0.2
 * A simple and easy jQuery plugin for CSS animated page transitions.
 * http://blivesta.github.io/animsition
 * License : MIT
 * Author : blivesta (http://blivesta.com/)
 */
!(function (t) {
  typeof define === 'function' && define.amd ? define(['jquery'], t) : typeof exports === 'object' ? module.exports = t(require('jquery')) : t(jQuery)
}((t) => {
  let n = !1; t(window).on('load', () => { n = !0 }); const i = 'animsition'; var a = { init(o) { o = t.extend({ inClass: 'fade-in', outClass: 'fade-out', inDuration: 1500, outDuration: 800, linkElement: '.animsition-link', loading: !0, loadingParentElement: 'body', loadingClass: 'animsition-loading', loadingInner: '', timeout: !1, timeoutCountdown: 5e3, onLoadEvent: !0, browser: ['animation-duration', '-webkit-animation-duration'], overlay: !1, overlayClass: 'animsition-overlay-slide', overlayParentElement: 'body', transition(t) { window.location.href = t } }, o), a.settings = { timer: !1, data: { inClass: 'animsition-in-class', inDuration: 'animsition-in-duration', outClass: 'animsition-out-class', outDuration: 'animsition-out-duration', overlay: 'animsition-overlay' }, events: { inStart: 'animsition.inStart', inEnd: 'animsition.inEnd', outStart: 'animsition.outStart', outEnd: 'animsition.outEnd' } }; const e = a.supportCheck.call(this, o); if (!e && o.browser.length > 0 && (!e || !this.length)) return 'console' in window || (window.console = {}, window.console.log = function (t) { return t }), this.length || console.log('Animsition: Element does not exist on page.'), e || console.log('Animsition: Does not support this browser.'), a.destroy.call(this); const s = a.optionCheck.call(this, o); return s && t(`.${o.overlayClass}`).length <= 0 && a.addOverlay.call(this, o), o.loading && t(`.${o.loadingClass}`).length <= 0 && a.addLoading.call(this, o), this.each(function () { const e = this; const s = t(this); const r = t(window); const l = t(document); const d = s.data(i); d || (o = t.extend({}, o), s.data(i, { options: o }), o.timeout && a.addTimer.call(e), o.onLoadEvent && (n ? (a.settings.timer && clearTimeout(a.settings.timer), a.in.call(e)) : r.on(`load.${i}`, () => { a.settings.timer && clearTimeout(a.settings.timer), a.in.call(e) })), r.on(`pageshow.${i}`, (t) => { t.originalEvent.persisted && a.in.call(e) }), r.on(`unload.${i}`, () => {}), l.on(`click.${i}`, o.linkElement, function (n) { n.preventDefault(); const i = t(this); const o = i.attr('href'); n.which === 2 || n.metaKey || n.shiftKey || navigator.platform.toUpperCase().indexOf('WIN') !== -1 && n.ctrlKey ? window.open(o, '_blank') : a.out.call(e, i, o) })) }) }, addOverlay(n) { t(n.overlayParentElement).prepend(`<div class="${n.overlayClass}"></div>`) }, addLoading(n) { t(n.loadingParentElement).append(`<div class="${n.loadingClass}">${n.loadingInner}</div>`) }, removeLoading() { const n = t(this); const a = n.data(i).options; const o = t(a.loadingParentElement).children(`.${a.loadingClass}`); o.fadeOut().remove() }, addTimer() { const n = this; const o = t(this); const e = o.data(i).options; a.settings.timer = setTimeout(() => { a.in.call(n), t(window).off(`load.${i}`) }, e.timeoutCountdown) }, supportCheck(n) { const i = t(this); const a = n.browser; const o = a.length; let e = !1; o === 0 && (e = !0); for (let s = 0; o > s; s++) if (typeof i.css(a[s]) === 'string') { e = !0; break } return e }, optionCheck(n) { let i; const o = t(this); return i = n.overlay || o.data(a.settings.data.overlay) ? !0 : !1 }, animationCheck(n, a, o) { const e = t(this); const s = e.data(i).options; const r = typeof n; const l = !a && r === 'number'; const d = a && r === 'string' && n.length > 0; return l || d ? n = n : a && o ? n = s.inClass : !a && o ? n = s.inDuration : a && !o ? n = s.outClass : a || o || (n = s.outDuration), n }, in() { const n = this; const o = t(this); const e = o.data(i).options; const s = o.data(a.settings.data.inDuration); const r = o.data(a.settings.data.inClass); const l = a.animationCheck.call(n, s, !1, !0); const d = a.animationCheck.call(n, r, !0, !0); const u = a.optionCheck.call(n, e); const c = o.data(i).outClass; e.loading && a.removeLoading.call(n), c && o.removeClass(c), u ? a.inOverlay.call(n, d, l) : a.inDefault.call(n, d, l) }, inDefault(n, i) { const o = t(this); o.css({ 'animation-duration': `${i}ms` }).addClass(n).trigger(a.settings.events.inStart).animateCallback(() => { o.removeClass(n).css({ opacity: 1 }).trigger(a.settings.events.inEnd) }) }, inOverlay(n, o) { const e = t(this); const s = e.data(i).options; e.css({ opacity: 1 }).trigger(a.settings.events.inStart), t(s.overlayParentElement).children(`.${s.overlayClass}`).css({ 'animation-duration': `${o}ms` }).addClass(n).animateCallback(() => { e.trigger(a.settings.events.inEnd) }) }, out(n, o) { const e = this; const s = t(this); const r = s.data(i).options; const l = n.data(a.settings.data.outClass); const d = s.data(a.settings.data.outClass); const u = n.data(a.settings.data.outDuration); const c = s.data(a.settings.data.outDuration); const m = l || d; const g = u || c; const f = a.animationCheck.call(e, m, !0, !1); const v = a.animationCheck.call(e, g, !1, !1); const h = a.optionCheck.call(e, r); s.data(i).outClass = f, h ? a.outOverlay.call(e, f, v, o) : a.outDefault.call(e, f, v, o) }, outDefault(n, o, e) { const s = t(this); const r = s.data(i).options; s.css({ 'animation-duration': `${o + 1}ms` }).addClass(n).trigger(a.settings.events.outStart).animateCallback(() => { s.trigger(a.settings.events.outEnd), r.transition(e) }) }, outOverlay(n, o, e) { const s = this; const r = t(this); const l = r.data(i).options; const d = r.data(a.settings.data.inClass); const u = a.animationCheck.call(s, d, !0, !0); t(l.overlayParentElement).children(`.${l.overlayClass}`).css({ 'animation-duration': `${o + 1}ms` }).removeClass(u).addClass(n).trigger(a.settings.events.outStart).animateCallback(() => { r.trigger(a.settings.events.outEnd), l.transition(e) }) }, destroy() { return this.each(function () { const n = t(this); t(window).off(`.${i}`), n.css({ opacity: 1 }).removeData(i) }) } }; t.fn.animateCallback = function (n) { const i = 'animationend webkitAnimationEnd'; return this.each(function () { const a = t(this); a.on(i, function () { return a.off(i), n.call(this) }) }) }, t.fn.animsition = function (n) { return a[n] ? a[n].apply(this, Array.prototype.slice.call(arguments, 1)) : typeof n !== 'object' && n ? void t.error(`Method ${n} does not exist on jQuery.${i}`) : a.init.apply(this, arguments) }
}))
