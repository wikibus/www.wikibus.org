/*!
 * Theia Sticky Sidebar v1.7.0
 * https://github.com/WeCodePixels/theia-sticky-sidebar
 */
!(function (i) { i.fn.scwStickySidebar = function (t) { function e(t, e) { const a = o(t, e); a || (console.log('TSS: Body width smaller than options.minWidth. Init is delayed.'), i(document).on(`scroll.${t.namespace}`, (function (t, e) { return function (a) { const n = o(t, e); n && i(this).unbind(a) } }(t, e))), i(window).on(`resize.${t.namespace}`, (function (t, e) { return function (a) { const n = o(t, e); n && i(this).unbind(a) } }(t, e)))) } function o(t, e) { return t.initialized === !0 || !(i('body').width() < t.minWidth) && (a(t, e), !0) } function a(t, e) { t.initialized = !0; const o = i(`#scw-sticky-sidebar-stylesheet-${t.namespace}`); o.length === 0 && i('head').append(i(`<style id="scw-sticky-sidebar-stylesheet-${t.namespace}">.scwStickySidebar:after {content: ""; display: table; clear: both;}</style>`)), e.each(function () { function e() { a.fixedScrollTop = 0, a.sidebar.css({ 'min-height': '1px' }), a.stickySidebar.css({ position: 'static', width: '', transform: 'none' }) } function o(t) { let e = t.height(); return t.children().each(function () { e = Math.max(e, i(this).height()) }), e } var a = {}; if (a.sidebar = i(this), a.options = t || {}, a.container = i(a.options.containerSelector), a.container.length == 0 && (a.container = a.sidebar.parent()), a.sidebar.parents().css('-webkit-transform', 'none'), a.sidebar.css({ position: a.options.defaultPosition, overflow: 'visible', '-webkit-box-sizing': 'border-box', '-moz-box-sizing': 'border-box', 'box-sizing': 'border-box' }), a.stickySidebar = a.sidebar.find('.scwStickySidebar'), a.stickySidebar.length == 0) { const s = /(?:text|application)\/(?:x-)?(?:javascript|ecmascript)/i; a.sidebar.find('script').filter((i, t) => t.type.length === 0 || t.type.match(s)).remove(), a.stickySidebar = i('<div>').addClass('scwStickySidebar').append(a.sidebar.children()), a.sidebar.append(a.stickySidebar) }a.marginBottom = parseInt(a.sidebar.css('margin-bottom')), a.paddingTop = parseInt(a.sidebar.css('padding-top')), a.paddingBottom = parseInt(a.sidebar.css('padding-bottom')); let r = a.stickySidebar.offset().top; let d = a.stickySidebar.outerHeight(); a.stickySidebar.css('padding-top', 1), a.stickySidebar.css('padding-bottom', 1), r -= a.stickySidebar.offset().top, d = a.stickySidebar.outerHeight() - d - r, r == 0 ? (a.stickySidebar.css('padding-top', 0), a.stickySidebarPaddingTop = 0) : a.stickySidebarPaddingTop = 1, d == 0 ? (a.stickySidebar.css('padding-bottom', 0), a.stickySidebarPaddingBottom = 0) : a.stickySidebarPaddingBottom = 1, a.previousScrollTop = null, a.fixedScrollTop = 0, e(), a.onScroll = function (a) { if (a.stickySidebar.is(':visible')) { if (i('body').width() < a.options.minWidth) return void e(); if (a.options.disableOnResponsiveLayouts) { const s = a.sidebar.outerWidth(a.sidebar.css('float') == 'none'); if (s + 50 > a.container.width()) return void e() } const r = i(document).scrollTop(); let d = 'static'; if (r >= a.sidebar.offset().top + (a.paddingTop - a.options.additionalMarginTop)) { let c; const p = a.paddingTop + t.additionalMarginTop; const b = a.paddingBottom + a.marginBottom + t.additionalMarginBottom; const l = a.sidebar.offset().top; const f = a.sidebar.offset().top + o(a.container); const h = 0 + t.additionalMarginTop; const g = a.stickySidebar.outerHeight() + p + b < i(window).height(); c = g ? h + a.stickySidebar.outerHeight() : i(window).height() - a.marginBottom - a.paddingBottom - t.additionalMarginBottom; const u = l - r + a.paddingTop; const S = f - r - a.paddingBottom - a.marginBottom; var y = a.stickySidebar.offset().top - r; const m = a.previousScrollTop - r; a.stickySidebar.css('position') == 'fixed' && a.options.sidebarBehavior == 'modern' && (y += m), a.options.sidebarBehavior == 'stick-to-top' && (y = t.additionalMarginTop), a.options.sidebarBehavior == 'stick-to-bottom' && (y = c - a.stickySidebar.outerHeight()), y = m > 0 ? Math.min(y, h) : Math.max(y, c - a.stickySidebar.outerHeight()), y = Math.max(y, u), y = Math.min(y, S - a.stickySidebar.outerHeight()); const k = a.container.height() == a.stickySidebar.outerHeight(); d = (k || y != h) && (k || y != c - a.stickySidebar.outerHeight()) ? r + y - a.sidebar.offset().top - a.paddingTop <= t.additionalMarginTop ? 'static' : 'absolute' : 'fixed' } if (d == 'fixed') { const v = i(document).scrollLeft(); a.stickySidebar.css({ position: 'fixed', width: `${n(a.stickySidebar)}px`, transform: `translateY(${y}px)`, left: `${a.sidebar.offset().left + parseInt(a.sidebar.css('padding-left')) - v}px`, top: '0px' }) } else if (d == 'absolute') { const x = {}; a.stickySidebar.css('position') != 'absolute' && (x.position = 'absolute', x.transform = `translateY(${r + y - a.sidebar.offset().top - a.stickySidebarPaddingTop - a.stickySidebarPaddingBottom}px)`, x.top = '0px'), x.width = `${n(a.stickySidebar)}px`, x.left = '', a.stickySidebar.css(x) } else d == 'static' && e(); d != 'static' && a.options.updateSidebarHeight == 1 && a.sidebar.css({ 'min-height': a.stickySidebar.outerHeight() + a.stickySidebar.offset().top - a.sidebar.offset().top + a.paddingBottom }), a.previousScrollTop = r } }, a.onScroll(a), i(document).on(`scroll.${a.options.namespace}`, (function (i) { return function () { i.onScroll(i) } }(a))), i(window).on(`resize.${a.options.namespace}`, (function (i) { return function () { i.stickySidebar.css({ position: 'static' }), i.onScroll(i) } }(a))), typeof ResizeSensor !== 'undefined' && new ResizeSensor(a.stickySidebar[0], (function (i) { return function () { i.onScroll(i) } }(a))) }) } function n(i) { let t; try { t = i[0].getBoundingClientRect().width } catch (i) {} return typeof t === 'undefined' && (t = i.width()), t } const s = { containerSelector: '', additionalMarginTop: 0, additionalMarginBottom: 0, updateSidebarHeight: !0, minWidth: 0, disableOnResponsiveLayouts: !0, sidebarBehavior: 'modern', defaultPosition: 'relative', namespace: 'TSS' }; return t = i.extend(s, t), t.additionalMarginTop = parseInt(t.additionalMarginTop) || 0, t.additionalMarginBottom = parseInt(t.additionalMarginBottom) || 0, e(t, this), this } }(jQuery))
!(function () { var e = function (t, i) { function s() { this.q = [], this.add = function (e) { this.q.push(e) }; let e, t; this.call = function () { for (e = 0, t = this.q.length; e < t; e++) this.q[e].call() } } function o(e, t) { return e.currentStyle ? e.currentStyle[t] : window.getComputedStyle ? window.getComputedStyle(e, null).getPropertyValue(t) : e.style[t] } function n(e, t) { if (e.resizedAttached) { if (e.resizedAttached) return void e.resizedAttached.add(t) } else e.resizedAttached = new s(), e.resizedAttached.add(t); e.resizeSensor = document.createElement('div'), e.resizeSensor.className = 'resize-sensor'; const i = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;'; const n = 'position: absolute; left: 0; top: 0; transition: 0s;'; e.resizeSensor.style.cssText = i, e.resizeSensor.innerHTML = `<div class="resize-sensor-expand" style="${i}"><div style="${n}"></div></div><div class="resize-sensor-shrink" style="${i}"><div style="${n} width: 200%; height: 200%"></div></div>`, e.appendChild(e.resizeSensor), { fixed: 1, absolute: 1 }[o(e, 'position')] || (e.style.position = 'relative'); let d; let r; const l = e.resizeSensor.childNodes[0]; const c = l.childNodes[0]; const h = e.resizeSensor.childNodes[1]; const a = (h.childNodes[0], function () { c.style.width = `${l.offsetWidth + 10}px`, c.style.height = `${l.offsetHeight + 10}px`, l.scrollLeft = l.scrollWidth, l.scrollTop = l.scrollHeight, h.scrollLeft = h.scrollWidth, h.scrollTop = h.scrollHeight, d = e.offsetWidth, r = e.offsetHeight }); a(); const f = function () { e.resizedAttached && e.resizedAttached.call() }; const u = function (e, t, i) { e.attachEvent ? e.attachEvent(`on${t}`, i) : e.addEventListener(t, i) }; const p = function () { e.offsetWidth == d && e.offsetHeight == r || f(), a() }; u(l, 'scroll', p), u(h, 'scroll', p) } const d = Object.prototype.toString.call(t); const r = d === '[object Array]' || d === '[object NodeList]' || d === '[object HTMLCollection]' || typeof jQuery !== 'undefined' && t instanceof jQuery || typeof Elements !== 'undefined' && t instanceof Elements; if (r) for (let l = 0, c = t.length; l < c; l++)n(t[l], i); else n(t, i); this.detach = function () { if (r) for (let i = 0, s = t.length; i < s; i++)e.detach(t[i]); else e.detach(t) } }; e.detach = function (e) { e.resizeSensor && (e.removeChild(e.resizeSensor), delete e.resizeSensor, delete e.resizedAttached) }, typeof module !== 'undefined' && typeof module.exports !== 'undefined' ? module.exports = e : window.ResizeSensor = e }())
