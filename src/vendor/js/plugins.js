/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright © 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing.jswing = jQuery.easing.swing

jQuery.extend(jQuery.easing,
  {
    def: 'easeOutQuad',
    swing(x, t, b, c, d) {
      // alert(jQuery.easing.default);
      return jQuery.easing[jQuery.easing.def](x, t, b, c, d)
    },
    easeInQuad(x, t, b, c, d) {
      return c * (t /= d) * t + b
    },
    easeOutQuad(x, t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b
    },
    easeInOutQuad(x, t, b, c, d) {
      if ((t /= d / 2) < 1) return c / 2 * t * t + b
      return -c / 2 * ((--t) * (t - 2) - 1) + b
    },
    easeInCubic(x, t, b, c, d) {
      return c * (t /= d) * t * t + b
    },
    easeOutCubic(x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b
    },
    easeInOutCubic(x, t, b, c, d) {
      if ((t /= d / 2) < 1) return c / 2 * t * t * t + b
      return c / 2 * ((t -= 2) * t * t + 2) + b
    },
    easeInQuart(x, t, b, c, d) {
      return c * (t /= d) * t * t * t + b
    },
    easeOutQuart(x, t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b
    },
    easeInOutQuart(x, t, b, c, d) {
      if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b
    },
    easeInQuint(x, t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b
    },
    easeOutQuint(x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b
    },
    easeInOutQuint(x, t, b, c, d) {
      if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b
    },
    easeInSine(x, t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b
    },
    easeOutSine(x, t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b
    },
    easeInOutSine(x, t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b
    },
    easeInExpo(x, t, b, c, d) {
      return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b
    },
    easeOutExpo(x, t, b, c, d) {
      return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b
    },
    easeInOutExpo(x, t, b, c, d) {
      if (t == 0) return b
      if (t == d) return b + c
      if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b
    },
    easeInCirc(x, t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b
    },
    easeOutCirc(x, t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b
    },
    easeInOutCirc(x, t, b, c, d) {
      if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b
    },
    easeInElastic(x, t, b, c, d) {
      var s = 1.70158; let p = 0; let a = c
      if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * 0.3
      if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a)
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b
    },
    easeOutElastic(x, t, b, c, d) {
      var s = 1.70158; let p = 0; let a = c
      if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * 0.3
      if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a)
      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b
    },
    easeInOutElastic(x, t, b, c, d) {
      var s = 1.70158; let p = 0; let a = c
      if (t == 0) return b; if ((t /= d / 2) == 2) return b + c; if (!p) p = d * (0.3 * 1.5)
      if (a < Math.abs(c)) { a = c; var s = p / 4 } else var s = p / (2 * Math.PI) * Math.asin(c / a)
      if (t < 1) return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b
    },
    easeInBack(x, t, b, c, d, s) {
      if (s == undefined) s = 1.70158
      return c * (t /= d) * t * ((s + 1) * t - s) + b
    },
    easeOutBack(x, t, b, c, d, s) {
      if (s == undefined) s = 1.70158
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b
    },
    easeInOutBack(x, t, b, c, d, s) {
      if (s == undefined) s = 1.70158
      if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b
    },
    easeInBounce(x, t, b, c, d) {
      return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b
    },
    easeOutBounce(x, t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b
      } if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b
      } if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b
      }
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b
    },
    easeInOutBounce(x, t, b, c, d) {
      if (t < d / 2) return jQuery.easing.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b
      return jQuery.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
    },
  })

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright © 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*!
* FitVids 1.1
*
* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
* Released under the WTFPL license - http://sam.zoy.org/wtfpl/
*
*/
!(function (t) {
  t.fn.fitVids = function (e) { const i = { customSelector: null, ignore: null }; if (!document.getElementById('fit-vids-style')) { const r = document.head || document.getElementsByTagName('head')[0]; const a = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}'; const d = document.createElement('div'); d.innerHTML = `<p>x</p><style id="fit-vids-style">${a}</style>`, r.appendChild(d.childNodes[1]) } return e && t.extend(i, e), this.each(function () { const e = ['iframe[src*="player.vimeo.com"]', 'iframe[src*="youtube.com"]', 'iframe[src*="youtube-nocookie.com"]', 'iframe[src*="kickstarter.com"][src*="video.html"]', 'object', 'embed']; i.customSelector && e.push(i.customSelector); let r = '.fitvidsignore'; i.ignore && (r = `${r}, ${i.ignore}`); let a = t(this).find(e.join(',')); a = a.not('object object'), a = a.not(r), a.each(function (e) { const i = t(this); if (!(i.parents(r).length > 0 || this.tagName.toLowerCase() === 'embed' && i.parent('object').length || i.parent('.fluid-width-video-wrapper').length)) { i.css('height') || i.css('width') || !isNaN(i.attr('height')) && !isNaN(i.attr('width')) || (i.attr('height', 9), i.attr('width', 16)); const a = this.tagName.toLowerCase() === 'object' || i.attr('height') && !isNaN(parseInt(i.attr('height'), 10)) ? parseInt(i.attr('height'), 10) : i.height(); const d = isNaN(parseInt(i.attr('width'), 10)) ? i.width() : parseInt(i.attr('width'), 10); const o = a / d; if (!i.attr('id')) { const h = `fitvid${e}`; i.attr('id', h) }i.wrap('<div class="fluid-width-video-wrapper"></div>').parent('.fluid-width-video-wrapper').css('padding-top', `${100 * o}%`), i.removeAttr('height').removeAttr('width') } }) }) }
}(window.jQuery || window.Zepto))

/*
 * jQuery Superfish Menu Plugin - v1.7.10
 * Copyright (c) 2018 Joel Birch
 *
 * Dual licensed under the MIT and GPL licenses:
 *	http://www.opensource.org/licenses/mit-license.php
 *	http://www.gnu.org/licenses/gpl.html
 */
!(function (a, b) {
  const c = (function () { const c = { bcClass: 'sf-breadcrumb', menuClass: 'sf-js-enabled', anchorClass: 'sf-with-ul', menuArrowClass: 'sf-arrows' }; const d = (function () { const b = /^(?![\w\W]*Windows Phone)[\w\W]*(iPhone|iPad|iPod)/i.test(navigator.userAgent); return b && a('html').css('cursor', 'pointer').on('click', a.noop), b }()); const e = (function () { const a = document.documentElement.style; return 'behavior' in a && 'fill' in a && /iemobile/i.test(navigator.userAgent) }()); const f = (function () { return !!b.PointerEvent }()); const g = function (a, b, d) { let e; let f = c.menuClass; b.cssArrows && (f += ` ${c.menuArrowClass}`), e = d ? 'addClass' : 'removeClass', a[e](f) }; const h = function (b, d) { return b.find(`li.${d.pathClass}`).slice(0, d.pathLevels).addClass(`${d.hoverClass} ${c.bcClass}`).filter(function () { return a(this).children(d.popUpSelector).hide().show().length }).removeClass(d.pathClass) }; const i = function (a, b) { const d = b ? 'addClass' : 'removeClass'; a.children('a')[d](c.anchorClass) }; const j = function (a) { const b = a.css('ms-touch-action'); let c = a.css('touch-action'); c = c || b, c = c === 'pan-y' ? 'auto' : 'pan-y', a.css({ 'ms-touch-action': c, 'touch-action': c }) }; const k = function (a) { return a.closest(`.${c.menuClass}`) }; const l = function (a) { return k(a).data('sfOptions') }; const m = function () { const b = a(this); const c = l(b); clearTimeout(c.sfTimer), b.siblings().superfish('hide').end().superfish('show') }; const n = function (b) { b.retainPath = a.inArray(this[0], b.$path) > -1, this.superfish('hide'), this.parents(`.${b.hoverClass}`).length || (b.onIdle.call(k(this)), b.$path.length && a.proxy(m, b.$path)()) }; const o = function () { const b = a(this); const c = l(b); d ? a.proxy(n, b, c)() : (clearTimeout(c.sfTimer), c.sfTimer = setTimeout(a.proxy(n, b, c), c.delay)) }; const p = function (b) { const c = a(this); const d = l(c); const e = c.siblings(b.data.popUpSelector); return d.onHandleTouch.call(e) === !1 ? this : void (e.length > 0 && e.is(':hidden') && (c.one('click.superfish', !1), b.type === 'MSPointerDown' || b.type === 'pointerdown' ? c.trigger('focus') : a.proxy(m, c.parent('li'))())) }; const q = function (b, c) { const g = `li:has(${c.popUpSelector})`; a.fn.hoverIntent && !c.disableHI ? b.hoverIntent(m, o, g) : b.on('mouseenter.superfish', g, m).on('mouseleave.superfish', g, o); let h = 'MSPointerDown.superfish'; f && (h = 'pointerdown.superfish'), d || (h += ' touchend.superfish'), e && (h += ' mousedown.superfish'), b.on('focusin.superfish', 'li', m).on('focusout.superfish', 'li', o).on(h, 'a', c, p) }; return { hide(b) { if (this.length) { const c = this; const d = l(c); if (!d) return this; const e = d.retainPath === !0 ? d.$path : ''; const f = c.find(`li.${d.hoverClass}`).add(this).not(e).removeClass(d.hoverClass).children(d.popUpSelector); let g = d.speedOut; if (b && (f.show(), g = 0), d.retainPath = !1, d.onBeforeHide.call(f) === !1) return this; f.stop(!0, !0).animate(d.animationOut, g, function () { const b = a(this); d.onHide.call(b) }) } return this }, show() { const a = l(this); if (!a) return this; const b = this.addClass(a.hoverClass); const c = b.children(a.popUpSelector); return a.onBeforeShow.call(c) === !1 ? this : (c.stop(!0, !0).animate(a.animation, a.speed, () => { a.onShow.call(c) }), this) }, destroy() { return this.each(function () { let b; const d = a(this); const e = d.data('sfOptions'); return !!e && (b = d.find(e.popUpSelector).parent('li'), clearTimeout(e.sfTimer), g(d, e), i(b), j(d), d.off('.superfish').off('.hoverIntent'), b.children(e.popUpSelector).attr('style', (a, b) => { if (typeof b !== 'undefined') return b.replace(/display[^;]+;?/g, '') }), e.$path.removeClass(`${e.hoverClass} ${c.bcClass}`).addClass(e.pathClass), d.find(`.${e.hoverClass}`).removeClass(e.hoverClass), e.onDestroy.call(d), void d.removeData('sfOptions')) }) }, init(b) { return this.each(function () { const d = a(this); if (d.data('sfOptions')) return !1; const e = a.extend({}, a.fn.superfish.defaults, b); const f = d.find(e.popUpSelector).parent('li'); e.$path = h(d, e), d.data('sfOptions', e), g(d, e, !0), i(f, !0), j(d), q(d, e), f.not(`.${c.bcClass}`).superfish('hide', !0), e.onInit.call(this) }) } } }()); a.fn.superfish = function (b, d) { return c[b] ? c[b].apply(this, Array.prototype.slice.call(arguments, 1)) : typeof b !== 'object' && b ? a.error(`Method ${b} does not exist on jQuery.fn.superfish`) : c.init.apply(this, arguments) }, a.fn.superfish.defaults = { popUpSelector: 'ul,.sf-mega', hoverClass: 'sfHover', pathClass: 'overrideThisToUse', pathLevels: 1, delay: 800, animation: { opacity: 'show' }, animationOut: { opacity: 'hide' }, speed: 'normal', speedOut: 'fast', cssArrows: !0, disableHI: !1, onInit: a.noop, onBeforeShow: a.noop, onShow: a.noop, onBeforeHide: a.noop, onHide: a.noop, onIdle: a.noop, onDestroy: a.noop, onHandleTouch: a.noop }
}(jQuery, window))

/*!
 * hoverIntent v1.9.0 // 2017.09.01 // jQuery v1.7.0+
 * http://briancherne.github.io/jquery-hoverIntent/
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007-2017 Brian Cherne
 */
!(function (factory) {
  typeof define === 'function' && define.amd ? define(['jquery'], factory) : jQuery && !jQuery.fn.hoverIntent && factory(jQuery)
}(($) => {
  let cX; let cY; const _cfg = { interval: 100, sensitivity: 6, timeout: 0 }; let INSTANCE_COUNT = 0; const track = function (ev) { cX = ev.pageX, cY = ev.pageY }; var compare = function (ev, $el, s, cfg) { if (Math.sqrt((s.pX - cX) * (s.pX - cX) + (s.pY - cY) * (s.pY - cY)) < cfg.sensitivity) return $el.off(s.event, track), delete s.timeoutId, s.isActive = !0, ev.pageX = cX, ev.pageY = cY, delete s.pX, delete s.pY, cfg.over.apply($el[0], [ev]); s.pX = cX, s.pY = cY, s.timeoutId = setTimeout(() => { compare(ev, $el, s, cfg) }, cfg.interval) }; const delay = function (ev, $el, s, out) { return delete $el.data('hoverIntent')[s.id], out.apply($el[0], [ev]) }; $.fn.hoverIntent = function (handlerIn, handlerOut, selector) { const instanceId = INSTANCE_COUNT++; let cfg = $.extend({}, _cfg); $.isPlainObject(handlerIn) ? (cfg = $.extend(cfg, handlerIn), $.isFunction(cfg.out) || (cfg.out = cfg.over)) : cfg = $.isFunction(handlerOut) ? $.extend(cfg, { over: handlerIn, out: handlerOut, selector }) : $.extend(cfg, { over: handlerIn, out: handlerIn, selector: handlerOut }); const handleHover = function (e) { const ev = $.extend({}, e); const $el = $(this); let hoverIntentData = $el.data('hoverIntent'); hoverIntentData || $el.data('hoverIntent', hoverIntentData = {}); let state = hoverIntentData[instanceId]; state || (hoverIntentData[instanceId] = state = { id: instanceId }), state.timeoutId && (state.timeoutId = clearTimeout(state.timeoutId)); const mousemove = state.event = `mousemove.hoverIntent.hoverIntent${instanceId}`; if (e.type === 'mouseenter') { if (state.isActive) return; state.pX = ev.pageX, state.pY = ev.pageY, $el.off(mousemove, track).on(mousemove, track), state.timeoutId = setTimeout(() => { compare(ev, $el, state, cfg) }, cfg.interval) } else { if (!state.isActive) return; $el.off(mousemove, track), state.timeoutId = setTimeout(() => { delay(ev, $el, state, cfg.out) }, cfg.timeout) } }; return this.on({ 'mouseenter.hoverIntent': handleHover, 'mouseleave.hoverIntent': handleHover }, cfg.selector) }
}))

/**
 *
 * Twitter Feed Fetcher
 *
 */

function sm_format_twitter(twitters) {
  const statusHTML = []
  for (let i = 0; i < twitters.length; i++) {
    const username = twitters[i].user.screen_name
    const { name } = twitters[i].user
    const username_avatar = twitters[i].user.profile_image_url_https
    const status = twitters[i].text.replace(/((https?|s?ftp|ssh)\:\/\/[^"\s\<\>]*[^.,;'">\:\s\<\>\)\]\!])/g, (url) => `<a href="${url}" target="_blank">${url}</a>`).replace(/\B@([_a-z0-9]+)/ig, (reply) => `${reply.charAt(0)}<a href="https://twitter.com/${reply.substring(1)}" target="_blank">${reply.substring(1)}</a>`)
    statusHTML.push(`<li><i class="icon-twitter"></i><a href="https://twitter.com/${username}" class="twitter-avatar" target="_blank"><img src="${username_avatar}" alt="${name}" title="${name}"></a><span>${status}</span><small><a href="https://twitter.com/${username}/statuses/${twitters[i].id_str}" target="_blank">${relative_time(twitters[i].created_at)}</a></small></li>`)
  }
  return statusHTML.join('')
}

function sm_format_twitter2(twitters) {
  const statusHTML = []
  for (let i = 0; i < twitters.length; i++) {
    const username = twitters[i].user.screen_name
    const status = twitters[i].text.replace(/((https?|s?ftp|ssh)\:\/\/[^"\s\<\>]*[^.,;'">\:\s\<\>\)\]\!])/g, (url) => `<a href="${url}" target="_blank">${url}</a>`).replace(/\B@([_a-z0-9]+)/ig, (reply) => `${reply.charAt(0)}<a href="https://twitter.com/${reply.substring(1)}" target="_blank">${reply.substring(1)}</a>`)
    statusHTML.push(`<div class="slide"><span>${status}</span><small><a href="https://twitter.com/${username}/statuses/${twitters[i].id_str}" target="_blank">${relative_time(twitters[i].created_at)}</a></small></div>`)
  }
  return statusHTML.join('')
}

function sm_format_twitter3(twitters) {
  const statusHTML = []
  for (let i = 0; i < twitters.length; i++) {
    const username = twitters[i].user.screen_name
    const status = twitters[i].text.replace(/((https?|s?ftp|ssh)\:\/\/[^"\s\<\>]*[^.,;'">\:\s\<\>\)\]\!])/g, (url) => `<a href="${url}" target="_blank">${url}</a>`).replace(/\B@([_a-z0-9]+)/ig, (reply) => `${reply.charAt(0)}<a href="https://twitter.com/${reply.substring(1)}" target="_blank">${reply.substring(1)}</a>`)
    statusHTML.push(`<div class="slide"><div class="testi-content"><p>${status}</p><div class="testi-meta"><span><a href="https://twitter.com/${username}/statuses/${twitters[i].id_str}" target="_blank">${relative_time(twitters[i].created_at)}</a></span></div></div></div>`)
  }
  return statusHTML.join('')
}

function relative_time(time_value) {
  const values = time_value.split(' ')
  time_value = `${values[1]} ${values[2]}, ${values[5]} ${values[3]}`
  const parsed_date = Date.parse(time_value)
  const relative_to = (arguments.length > 1) ? arguments[1] : new Date()
  let delta = parseInt((relative_to.getTime() - parsed_date) / 1000)
  delta += (relative_to.getTimezoneOffset() * 60)

  if (delta < 60) {
    return 'less than a minute ago'
  } if (delta < 120) {
    return 'about a minute ago'
  } if (delta < (60 * 60)) {
    return `${(parseInt(delta / 60)).toString()} minutes ago`
  } if (delta < (120 * 60)) {
    return 'about an hour ago'
  } if (delta < (24 * 60 * 60)) {
    return `about ${(parseInt(delta / 3600)).toString()} hours ago`
  } if (delta < (48 * 60 * 60)) {
    return '1 day ago'
  }
  return `${(parseInt(delta / 86400)).toString()} days ago`
}

/*! jRespond.js v 0.10 | Author: Jeremy Fields [jeremy.fields@viget.com], 2013 | License: MIT */
!(function (a, b, c) { typeof module === 'object' && module && typeof module.exports === 'object' ? module.exports = c : (a[b] = c, typeof define === 'function' && define.amd && define(b, [], () => c)) }(this, 'jRespond', (function (a, b, c) {
  return function (a) { const b = []; const d = []; const e = a; let f = ''; let g = ''; let i = 0; const j = 100; const k = 500; let l = k; const m = function () { let a = 0; return a = typeof window.innerWidth !== 'number' ? document.documentElement.clientWidth !== 0 ? document.documentElement.clientWidth : document.body.clientWidth : window.innerWidth }; const n = function (a) { if (a.length === c)o(a); else for (let b = 0; b < a.length; b++)o(a[b]) }; var o = function (a) { const e = a.breakpoint; const h = a.enter || c; b.push(a), d.push(!1), r(e) && (h !== c && h.call(null, { entering: f, exiting: g }), d[b.length - 1] = !0) }; const p = function () { for (var a = [], e = [], h = 0; h < b.length; h++) { const i = b[h].breakpoint; const j = b[h].enter || c; const k = b[h].exit || c; i === '*' ? (j !== c && a.push(j), k !== c && e.push(k)) : r(i) ? (j === c || d[h] || a.push(j), d[h] = !0) : (k !== c && d[h] && e.push(k), d[h] = !1) } for (var l = { entering: f, exiting: g }, m = 0; m < e.length; m++)e[m].call(null, l); for (let n = 0; n < a.length; n++)a[n].call(null, l) }; const q = function (a) { for (var b = !1, c = 0; c < e.length; c++) if (a >= e[c].enter && a <= e[c].exit) { b = !0; break }b && f !== e[c].label ? (g = f, f = e[c].label, p()) : b || f === '' || (f = '', p()) }; var r = function (a) { if (typeof a === 'object') { if (a.join().indexOf(f) >= 0) return !0 } else { if (a === '*') return !0; if (typeof a === 'string' && f === a) return !0 } }; var s = function () { const a = m(); a !== i ? (l = j, q(a)) : l = k, i = a, setTimeout(s, l) }; return s(), { addFunc(a) { n(a) }, getBreakpoint() { return f } } }
}(this, this.document))))

!(function (t) { let o = 0; t.fn.scrolled = function (a, n) { typeof a === 'function' && (n = a, a = 300); const c = `scrollTimer${o++}`; this.scroll(function () { const o = t(this); let e = o.data(c); e && clearTimeout(e), e = setTimeout(() => { o.removeData(c), n.call(o[0]) }, a), o.data(c, e) }) } }(jQuery))

/*!
 * Original copyright:
 *
 * Copyright (C) 2009 Joel Sutherland
 * Licenced under the MIT license
 * http://www.newmediacampaigns.com/page/jquery-flickr-plugin
 *
 * Available tags for templates:
 * title, link, date_taken, description, published, author, author_id, tags, image*
 */
!(function (a) { a.fn.jflickrfeed = function (b, c) { b = a.extend(!0, { flickrbase: 'https://api.flickr.com/services/feeds/', feedapi: 'photos_public.gne', limit: 20, qstrings: { lang: 'en-us', format: 'json', jsoncallback: '?' }, cleanDescription: !0, useTemplate: !0, itemTemplate: '', itemCallback() {} }, b); let d; let e = `${b.flickrbase + b.feedapi}?`; let f = !0; for (d in b.qstrings)f || (e += '&'), e += `${d}=${b.qstrings[d]}`, f = !1; return a(this).each(function () { const d = a(this); const f = this; a.getJSON(e, (e) => { a.each(e.items, (a, c) => { let e, g, h, i; if (a < b.limit) { if (b.cleanDescription && (e = /<p>(.*?)<\/p>/g, g = c.description, e.test(g) && (c.description = g.match(e)[2], void 0 !== c.description && (c.description = c.description.replace('<p>', '').replace('</p>', '')))), c.image_s = c.media.m.replace('_m', '_s'), c.image_t = c.media.m.replace('_m', '_t'), c.image_m = c.media.m.replace('_m', '_m'), c.image = c.media.m.replace('_m', ''), c.image_b = c.media.m.replace('_m', '_b'), c.image_q = c.media.m.replace('_m', '_q'), delete c.media, b.useTemplate) { i = b.itemTemplate; for (h in c)e = new RegExp(`{{${h}}}`, 'g'), i = i.replace(e, c[h]); d.append(i) }b.itemCallback.call(f, c) } }), a.isFunction(c) && c.call(f, e) }) }) } }(jQuery));

/*!
 * Instafeed 1.4.1
 */
(function () { let e; e = (function () { function e(e, t) { let n, r; this.options = { target: 'instafeed', get: 'popular', resolution: 'thumbnail', sortBy: 'none', links: !0, mock: !1, useHttp: !1 }; if (typeof e === 'object') for (n in e)r = e[n], this.options[n] = r; this.context = t != null ? t : this, this.unique = this._genKey() } return e.prototype.hasNext = function () { return typeof this.context.nextUrl === 'string' && this.context.nextUrl.length > 0 }, e.prototype.next = function () { return this.hasNext() ? this.run(this.context.nextUrl) : !1 }, e.prototype.run = function (t) { let n, r, i; if (typeof this.options.clientId !== 'string' && typeof this.options.accessToken !== 'string') throw new Error('Missing clientId or accessToken.'); if (typeof this.options.accessToken !== 'string' && typeof this.options.clientId !== 'string') throw new Error('Missing clientId or accessToken.'); return this.options.before != null && typeof this.options.before === 'function' && this.options.before.call(this), typeof document !== 'undefined' && document !== null && (i = document.createElement('script'), i.id = 'instafeed-fetcher', i.src = t || this._buildUrl(), n = document.getElementsByTagName('head'), n[0].appendChild(i), r = `instafeedCache${this.unique}`, window[r] = new e(this.options, this), window[r].unique = this.unique), !0 }, e.prototype.parse = function (e) { let t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A, O, M, _, D; if (typeof e !== 'object') { if (this.options.error != null && typeof this.options.error === 'function') return this.options.error.call(this, 'Invalid JSON data'), !1; throw new Error('Invalid JSON response') } if (e.meta.code !== 200) { if (this.options.error != null && typeof this.options.error === 'function') return this.options.error.call(this, e.meta.error_message), !1; throw new Error(`Error from Instagram: ${e.meta.error_message}`) } if (e.data.length === 0) { if (this.options.error != null && typeof this.options.error === 'function') return this.options.error.call(this, 'No images were returned from Instagram'), !1; throw new Error('No images were returned from Instagram') } this.options.success != null && typeof this.options.success === 'function' && this.options.success.call(this, e), this.context.nextUrl = '', e.pagination != null && (this.context.nextUrl = e.pagination.next_url); if (this.options.sortBy !== 'none') { this.options.sortBy === 'random' ? M = ['', 'random'] : M = this.options.sortBy.split('-'), O = M[0] === 'least' ? !0 : !1; switch (M[1]) { case 'random':e.data.sort(() => 0.5 - Math.random()); break; case 'recent':e.data = this._sortBy(e.data, 'created_time', O); break; case 'liked':e.data = this._sortBy(e.data, 'likes.count', O); break; case 'commented':e.data = this._sortBy(e.data, 'comments.count', O); break; default:throw new Error(`Invalid option for sortBy: '${this.options.sortBy}'.`) } } if (typeof document !== 'undefined' && document !== null && this.options.mock === !1) { m = e.data, A = parseInt(this.options.limit, 10), this.options.limit != null && m.length > A && (m = m.slice(0, A)), u = document.createDocumentFragment(), this.options.filter != null && typeof this.options.filter === 'function' && (m = this._filter(m, this.options.filter)); if (this.options.template != null && typeof this.options.template === 'string') { f = '', d = '', w = '', D = document.createElement('div'); for (c = 0, N = m.length; c < N; c++) { h = m[c], p = h.images[this.options.resolution]; if (typeof p !== 'object') throw o = `No image found for resolution: ${this.options.resolution}.`, new Error(o); E = p.width, y = p.height, b = 'square', E > y && (b = 'landscape'), E < y && (b = 'portrait'), v = p.url, l = window.location.protocol.indexOf('http') >= 0, l && !this.options.useHttp && (v = v.replace(/https?:\/\//, '//')), d = this._makeTemplate(this.options.template, { model: h, id: h.id, link: h.link, type: h.type, image: v, width: E, height: y, orientation: b, caption: this._getObjectProperty(h, 'caption.text'), likes: h.likes.count, comments: h.comments.count, location: this._getObjectProperty(h, 'location.name') }), f += d }D.innerHTML = f, i = [], r = 0, n = D.childNodes.length; while (r < n)i.push(D.childNodes[r]), r += 1; for (x = 0, C = i.length; x < C; x++)L = i[x], u.appendChild(L) } else for (T = 0, k = m.length; T < k; T++) { h = m[T], g = document.createElement('img'), p = h.images[this.options.resolution]; if (typeof p !== 'object') throw o = `No image found for resolution: ${this.options.resolution}.`, new Error(o); v = p.url, l = window.location.protocol.indexOf('http') >= 0, l && !this.options.useHttp && (v = v.replace(/https?:\/\//, '//')), g.src = v, this.options.links === !0 ? (t = document.createElement('a'), t.href = h.link, t.appendChild(g), u.appendChild(t)) : u.appendChild(g) }_ = this.options.target, typeof _ === 'string' && (_ = document.getElementById(_)); if (_ == null) throw o = `No element with id="${this.options.target}" on page.`, new Error(o); _.appendChild(u), a = document.getElementsByTagName('head')[0], a.removeChild(document.getElementById('instafeed-fetcher')), S = `instafeedCache${this.unique}`, window[S] = void 0; try { delete window[S] } catch (P) { s = P } } return this.options.after != null && typeof this.options.after === 'function' && this.options.after.call(this), !0 }, e.prototype._buildUrl = function () { let e, t, n; e = 'https://api.instagram.com/v1'; switch (this.options.get) { case 'popular':t = 'media/popular'; break; case 'tagged':if (!this.options.tagName) throw new Error("No tag name specified. Use the 'tagName' option."); t = `tags/${this.options.tagName}/media/recent`; break; case 'location':if (!this.options.locationId) throw new Error("No location specified. Use the 'locationId' option."); t = `locations/${this.options.locationId}/media/recent`; break; case 'user':if (!this.options.userId) throw new Error("No user specified. Use the 'userId' option."); t = `users/${this.options.userId}/media/recent`; break; default:throw new Error(`Invalid option for get: '${this.options.get}'.`) } return n = `${e}/${t}`, this.options.accessToken != null ? n += `?access_token=${this.options.accessToken}` : n += `?client_id=${this.options.clientId}`, this.options.limit != null && (n += `&count=${this.options.limit}`), n += `&callback=instafeedCache${this.unique}.parse`, n }, e.prototype._genKey = function () { let e; return e = function () { return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1) }, `${e()}${e()}${e()}${e()}` }, e.prototype._makeTemplate = function (e, t) { let n, r, i, s, o; r = /(?:\{{2})([\w\[\]\.]+)(?:\}{2})/, n = e; while (r.test(n))s = n.match(r)[1], o = (i = this._getObjectProperty(t, s)) != null ? i : '', n = n.replace(r, () => `${o}`); return n }, e.prototype._getObjectProperty = function (e, t) { let n, r; t = t.replace(/\[(\w+)\]/g, '.$1'), r = t.split('.'); while (r.length) { n = r.shift(); if (!(e != null && n in e)) return null; e = e[n] } return e }, e.prototype._sortBy = function (e, t, n) { let r; return r = function (e, r) { let i, s; return i = this._getObjectProperty(e, t), s = this._getObjectProperty(r, t), n ? i > s ? 1 : -1 : i < s ? 1 : -1 }, e.sort(r.bind(this)), e }, e.prototype._filter = function (e, t) { let n, r, i, s, o; n = [], r = function (e) { if (t(e)) return n.push(e) }; for (i = 0, o = e.length; i < o; i++)s = e[i], r(s); return n }, e }()), (function (e, t) { return typeof define === 'function' && define.amd ? define([], t) : typeof module === 'object' && module.exports ? module.exports = t() : e.Instafeed = t() }(this, () => e)) }).call(this)

/**
 * @preserve
 * Jribbble v2.0.4 | Thu Jun 4 01:49:29 2015 -0400
 * Copyright (c) 2015, Tyler Gaw me@tylergaw.com
 * Released under the ISC-LICENSE
 */
!(function (e, t, r, s) {
  e.jribbble = {}; let n = null; const o = 'https://api.dribbble.com/v1'; const i = ['animated', 'attachments', 'debuts', 'playoffs', 'rebounds', 'teams']; const u = { token: 'Jribbble: Missing Dribbble access token. Set one with $.jribbble.accessToken = YOUR_ACCESS_TOKEN. If you do not have an access token, you must register a new application at https://dribbble.com/account/applications/new', singular(e) { return e.substr(0, e.length - 1) }, idRequired(e) { return `Jribbble: You have to provide a ${this.singular(e)}${' ID. ex: $.jribbble.%@("1234").'.replace(/%@/g, e)}` }, subResource(e) { return `Jribbble: You have to provide a ${this.singular(e)}${' ID to get %@. ex: $.jribbble.%@("1234").%@()'.replace(/%@/g, e)}` }, shotId(e) { return `Jribbble: You have to provide a shot ID to get %@. ex: ${' $.jribbble.shots("1234").%@()'.replace(/%@/g, e)}` }, commentLikes: 'Jribbble: You have to provide a comment ID to get likes. ex:  $.jribbble.shots("1234").comments("456").likes()' }; const c = function (e, t) { if (e && typeof e !== 'object') return e; throw new Error(u.idRequired(t)) }; const l = function (e) { const t = {}; return e.forEach((e) => { t[e] = d.call(this, e) }), t }; const h = function (t) { const r = e.param(t); return r ? `?${r}` : '' }; const a = function (e) { if (e.length !== 0) { const t = e[0]; const r = typeof t; let s = {}; if (r === 'number' || r === 'string') { const n = i.indexOf(t); n > -1 ? s.list = t : s.resource = t } else r === 'object' && (s = t); return s } }; const b = function () { const t = e.extend({}, e.Deferred()); const r = function () { return this.methods = [], this.response = null, this.flushed = !1, this.add = function (e) { this.flushed ? e(this.scope) : this.methods.push(e) }, this.flush = function (e) { if (!this.flushed) { for (this.scope = e, this.flushed = !0; this.methods[0];) this.methods.shift()(e); return e } }, this }; return t.queue = new r(), t.url = o, t.get = function () { return n ? (e.ajax({ type: 'GET', url: this.url, beforeSend(e) { e.setRequestHeader('Authorization', `Bearer ${n}`) }, success: function (e) { this.resolve(e) }.bind(this), error: function (e) { this.reject(e) }.bind(this) }), this) : (console.error(u.token), !1) }, t }; const f = function (t) { return function (r) { return e.extend(this, b()), this.queue.add((e) => { e.url += `/${t}/${r}` }), setTimeout(() => { this.queue.flush(this).get() }), this } }; var d = function (e) { return function (t) { return this.queue.add((r) => { r.url += `/${e}/${h(t || {})}` }), this } }; e.jribbble.shots = function (t, r) { const s = a([].slice.call(arguments)) || {}; const n = r || {}; const o = function (t) { return function (r, s) { const n = a([].slice.call(arguments)) || {}; const o = s || {}; return this.queue.add((r) => { if (!r.shotId) throw new Error(u.shotId(t)); r.url += `/${t}/`, n.resource && (r.url += n.resource, delete n.resource), r.url += h(e.extend(n, o)) }), this } }; const i = function () { return e.extend(this, b()), this.url += '/shots/', this.queue.add((t) => { s.resource && (t.shotId = s.resource, t.url += s.resource, delete s.resource), t.url += h(e.extend(s, n)) }), setTimeout(() => { this.queue.flush(this).get() }), this }; return i.prototype.attachments = o('attachments'), i.prototype.buckets = o('buckets'), i.prototype.likes = o('likes'), i.prototype.projects = o('projects'), i.prototype.rebounds = o('rebounds'), i.prototype.comments = function (t, r) { const s = a([].slice.call(arguments)) || {}; const n = r || {}; return this.queue.add((t) => { if (!t.shotId) throw new Error(u.shotId('comments')); t.url += '/comments/', s.resource && (t.commentId = s.resource, t.url += `${s.resource}/`, delete s.resource), t.url += h(e.extend(s, n)) }), this.likes = function (e) { const t = e || {}; return this.queue.add((e) => { if (!e.commentId) throw new Error(u.commentLikes); e.url += `likes/${h(t)}` }), this }, this }, new i() }, e.jribbble.teams = function (e) { const t = 'teams'; const r = c(e, t); const s = f.call(this, t); return s.prototype = l.call(this, ['members', 'shots']), new s(r) }, e.jribbble.users = function (e) { const t = 'users'; const r = c(e, t); const s = f.call(this, t); return s.prototype = l.call(this, ['buckets', 'followers', 'following', 'likes', 'projects', 'shots', 'teams']), s.prototype.isFollowing = function (e) { return this.queue.add((t) => { t.url += `/following/${e}` }), this }, new s(r) }, e.jribbble.buckets = function (e) { const t = 'buckets'; const r = c(e, t); const s = f.call(this, t); return s.prototype = l.call(this, ['shots']), new s(r) }, e.jribbble.projects = function (e) { const t = 'projects'; const r = c(e, t); const s = f.call(this, t); return s.prototype = l.call(this, ['shots']), new s(r) }, e.jribbble.setToken = function (e) { return n = e, this }
}(jQuery, window, document))

/*!
 * JavaScript Cookie v2.2.0
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
!(function (e) { let n; if (typeof define === 'function' && define.amd && (define(e), n = !0), typeof exports === 'object' && (module.exports = e(), n = !0), !n) { const t = window.Cookies; const o = window.Cookies = e(); o.noConflict = function () { return window.Cookies = t, o } } }(() => { function e() { for (var e = 0, n = {}; e < arguments.length; e++) { const t = arguments[e]; for (const o in t)n[o] = t[o] } return n } function n(e) { return e.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent) } return (function t(o) { function r() {} function i(n, t, i) { if (typeof document !== 'undefined') { typeof (i = e({ path: '/' }, r.defaults, i)).expires === 'number' && (i.expires = new Date(1 * new Date() + 864e5 * i.expires)), i.expires = i.expires ? i.expires.toUTCString() : ''; try { const c = JSON.stringify(t); /^[\{\[]/.test(c) && (t = c) } catch (e) {}t = o.write ? o.write(t, n) : encodeURIComponent(String(t)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), n = encodeURIComponent(String(n)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape); let f = ''; for (const u in i)i[u] && (f += `; ${u}`, !0 !== i[u] && (f += `=${i[u].split(';')[0]}`)); return document.cookie = `${n}=${t}${f}` } } function c(e, t) { if (typeof document !== 'undefined') { for (var r = {}, i = document.cookie ? document.cookie.split('; ') : [], c = 0; c < i.length; c++) { const f = i[c].split('='); let u = f.slice(1).join('='); t || u.charAt(0) !== '"' || (u = u.slice(1, -1)); try { const a = n(f[0]); if (u = (o.read || o)(u, a) || n(u), t) try { u = JSON.parse(u) } catch (e) {} if (r[a] = u, e === a) break } catch (e) {} } return e ? r[e] : r } } return r.set = i, r.get = function (e) { return c(e, !1) }, r.getJSON = function (e) { return c(e, !0) }, r.remove = function (n, t) { i(n, '', e(t, { expires: -1 })) }, r.defaults = {}, r.withConverter = t, r }(() => {})) }))

/** !
 * easy-pie-chart
 * Lightweight plugin to render simple, animated and retina optimized pie charts
 *
 * @license
 * @author Robert Fleischmann <rendro87@gmail.com> (http://robert-fleischmann.de)
 * @version 2.1.7
 **/
!(function (a, b) { typeof define === 'function' && define.amd ? define(['jquery'], (a) => b(a)) : typeof exports === 'object' ? module.exports = b(require('jquery')) : b(jQuery) }(this, (a) => { const b = function (a, b) { let c; const d = document.createElement('canvas'); a.appendChild(d), typeof G_vmlCanvasManager === 'object' && G_vmlCanvasManager.initElement(d); const e = d.getContext('2d'); d.width = d.height = b.size; let f = 1; window.devicePixelRatio > 1 && (f = window.devicePixelRatio, d.style.width = d.style.height = [b.size, 'px'].join(''), d.width = d.height = b.size * f, e.scale(f, f)), e.translate(b.size / 2, b.size / 2), e.rotate((-0.5 + b.rotate / 180) * Math.PI); let g = (b.size - b.lineWidth) / 2; b.scaleColor && b.scaleLength && (g -= b.scaleLength + 2), Date.now = Date.now || function () { return +new Date() }; const h = function (a, b, c) { c = Math.min(Math.max(-1, c || 0), 1); const d = c <= 0 ? !0 : !1; e.beginPath(), e.arc(0, 0, g, 0, 2 * Math.PI * c, d), e.strokeStyle = a, e.lineWidth = b, e.stroke() }; const i = function () { let a, c; e.lineWidth = 1, e.fillStyle = b.scaleColor, e.save(); for (let d = 24; d > 0; --d)d % 6 === 0 ? (c = b.scaleLength, a = 0) : (c = 0.6 * b.scaleLength, a = b.scaleLength - c), e.fillRect(-b.size / 2 + a, 0, c, 1), e.rotate(Math.PI / 12); e.restore() }; const j = (function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (a) { window.setTimeout(a, 1e3 / 60) } }()); const k = function () { b.scaleColor && i(), b.trackColor && h(b.trackColor, b.trackWidth || b.lineWidth, 1) }; this.getCanvas = function () { return d }, this.getCtx = function () { return e }, this.clear = function () { e.clearRect(b.size / -2, b.size / -2, b.size, b.size) }, this.draw = function (a) { b.scaleColor || b.trackColor ? e.getImageData && e.putImageData ? c ? e.putImageData(c, 0, 0) : (k(), c = e.getImageData(0, 0, b.size * f, b.size * f)) : (this.clear(), k()) : this.clear(), e.lineCap = b.lineCap; let d; d = typeof b.barColor === 'function' ? b.barColor(a) : b.barColor, h(d, b.lineWidth, a / 100) }.bind(this), this.animate = function (a, c) { const d = Date.now(); b.onStart(a, c); var e = function () { const f = Math.min(Date.now() - d, b.animate.duration); const g = b.easing(this, f, a, c - a, b.animate.duration); this.draw(g), b.onStep(a, c, g), f >= b.animate.duration ? b.onStop(a, c) : j(e) }.bind(this); j(e) }.bind(this) }; const c = function (a, c) { const d = { barColor: '#ef1e25', trackColor: '#f9f9f9', scaleColor: '#dfe0e0', scaleLength: 5, lineCap: 'round', lineWidth: 3, trackWidth: void 0, size: 110, rotate: 0, animate: { duration: 1e3, enabled: !0 }, easing(a, b, c, d, e) { return b /= e / 2, b < 1 ? d / 2 * b * b + c : -d / 2 * (--b * (b - 2) - 1) + c }, onStart(a, b) {}, onStep(a, b, c) {}, onStop(a, b) {} }; if (typeof b !== 'undefined')d.renderer = b; else { if (typeof SVGRenderer === 'undefined') throw new Error('Please load either the SVG- or the CanvasRenderer'); d.renderer = SVGRenderer } const e = {}; let f = 0; const g = function () { this.el = a, this.options = e; for (const b in d)d.hasOwnProperty(b) && (e[b] = c && typeof c[b] !== 'undefined' ? c[b] : d[b], typeof e[b] === 'function' && (e[b] = e[b].bind(this))); typeof e.easing === 'string' && typeof jQuery !== 'undefined' && jQuery.isFunction(jQuery.easing[e.easing]) ? e.easing = jQuery.easing[e.easing] : e.easing = d.easing, typeof e.animate === 'number' && (e.animate = { duration: e.animate, enabled: !0 }), typeof e.animate !== 'boolean' || e.animate || (e.animate = { duration: 1e3, enabled: e.animate }), this.renderer = new e.renderer(a, e), this.renderer.draw(f), a.dataset && a.dataset.percent ? this.update(parseFloat(a.dataset.percent)) : a.getAttribute && a.getAttribute('data-percent') && this.update(parseFloat(a.getAttribute('data-percent'))) }.bind(this); this.update = function (a) { return a = parseFloat(a), e.animate.enabled ? this.renderer.animate(f, a) : this.renderer.draw(a), f = a, this }.bind(this), this.disableAnimation = function () { return e.animate.enabled = !1, this }, this.enableAnimation = function () { return e.animate.enabled = !0, this }, g() }; a.fn.easyPieChart = function (b) { return this.each(function () { let d; a.data(this, 'easyPieChart') || (d = a.extend({}, b, a(this).data()), a.data(this, 'easyPieChart', new c(this, d))) }) } }));

/*
 * jQuery.appear
 * https://github.com/bas2k/jquery.appear/
 * http://code.google.com/p/jquery-appear/
 *
 * Copyright (c) 2009 Michael Hixson
 * Copyright (c) 2012 Alexander Brovikov
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 */
(function (e) { e.fn.appear = function (t, n) { const r = e.extend({ data: undefined, one: true, accX: 0, accY: 0 }, n); return this.each(function () { const n = e(this); n.appeared = false; if (!t) { n.trigger('appear', r.data); return } const i = e(window); const s = function () { if (!n.is(':visible')) { n.appeared = false; return } const e = i.scrollLeft(); const t = i.scrollTop(); const s = n.offset(); const o = s.left; const u = s.top; const a = r.accX; const f = r.accY; const l = n.height(); const c = i.height(); const h = n.width(); const p = i.width(); if (u + l + f >= t && u <= t + c + f && o + h + a >= e && o <= e + p + a) { if (!n.appeared)n.trigger('appear', r.data) } else { n.appeared = false } }; const o = function () { n.appeared = true; if (r.one) { i.unbind('scroll', s); const o = e.inArray(s, e.fn.appear.checks); if (o >= 0)e.fn.appear.checks.splice(o, 1) }t.apply(this, arguments) }; if (r.one)n.one('appear', r.data, o); else n.bind('appear', r.data, o); i.scroll(s); e.fn.appear.checks.push(s); s() }) }; e.extend(e.fn.appear, { checks: [], timeout: null, checkAll() { let t = e.fn.appear.checks.length; if (t > 0) while (t--)e.fn.appear.checks[t]() }, run() { if (e.fn.appear.timeout)clearTimeout(e.fn.appear.timeout); e.fn.appear.timeout = setTimeout(e.fn.appear.checkAll, 20) } }); e.each(['append', 'prepend', 'after', 'before', 'attr', 'removeAttr', 'addClass', 'removeClass', 'toggleClass', 'remove', 'css', 'show', 'hide'], (t, n) => { const r = e.fn[n]; if (r) { e.fn[n] = function () { const t = r.apply(this, arguments); e.fn.appear.run(); return t } } }) })(jQuery)

/*!
 * animsition v4.0.2
 * A simple and easy jQuery plugin for CSS animated page transitions.
 * http://blivesta.github.io/animsition
 * License : MIT
 * Author : blivesta (http://blivesta.com/)
 */
!(function (t) {
  typeof define === 'function' && define.amd ? define(['jquery'], t) : typeof exports === 'object' ? module.exports = t(require('jquery')) : t(jQuery)
}((t) => {
  let n = !1; t(window).on('load', () => { n = !0 }); const i = 'animsition'; var a = { init(o) { o = t.extend({ inClass: 'fade-in', outClass: 'fade-out', inDuration: 1500, outDuration: 800, linkElement: '.animsition-link', loading: !0, loadingParentElement: 'body', loadingClass: 'animsition-loading', loadingInner: '', timeout: !1, timeoutCountdown: 5e3, onLoadEvent: !0, browser: ['animation-duration', '-webkit-animation-duration'], overlay: !1, overlayClass: 'animsition-overlay-slide', overlayParentElement: 'body', transition(t) { window.location.href = t } }, o), a.settings = { timer: !1, data: { inClass: 'animsition-in-class', inDuration: 'animsition-in-duration', outClass: 'animsition-out-class', outDuration: 'animsition-out-duration', overlay: 'animsition-overlay' }, events: { inStart: 'animsition.inStart', inEnd: 'animsition.inEnd', outStart: 'animsition.outStart', outEnd: 'animsition.outEnd' } }; const e = a.supportCheck.call(this, o); if (!e && o.browser.length > 0 && (!e || !this.length)) return 'console' in window || (window.console = {}, window.console.log = function (t) { return t }), this.length || console.log('Animsition: Element does not exist on page.'), e || console.log('Animsition: Does not support this browser.'), a.destroy.call(this); const s = a.optionCheck.call(this, o); return s && t(`.${o.overlayClass}`).length <= 0 && a.addOverlay.call(this, o), o.loading && t(`.${o.loadingClass}`).length <= 0 && a.addLoading.call(this, o), this.each(function () { const e = this; const s = t(this); const r = t(window); const l = t(document); const d = s.data(i); d || (o = t.extend({}, o), s.data(i, { options: o }), o.timeout && a.addTimer.call(e), o.onLoadEvent && (n ? (a.settings.timer && clearTimeout(a.settings.timer), a.in.call(e)) : r.on(`load.${i}`, () => { a.settings.timer && clearTimeout(a.settings.timer), a.in.call(e) })), r.on(`pageshow.${i}`, (t) => { t.originalEvent.persisted && a.in.call(e) }), r.on(`unload.${i}`, () => {}), l.on(`click.${i}`, o.linkElement, function (n) { n.preventDefault(); const i = t(this); const o = i.attr('href'); n.which === 2 || n.metaKey || n.shiftKey || navigator.platform.toUpperCase().indexOf('WIN') !== -1 && n.ctrlKey ? window.open(o, '_blank') : a.out.call(e, i, o) })) }) }, addOverlay(n) { t(n.overlayParentElement).prepend(`<div class="${n.overlayClass}"></div>`) }, addLoading(n) { t(n.loadingParentElement).append(`<div class="${n.loadingClass}">${n.loadingInner}</div>`) }, removeLoading() { const n = t(this); const a = n.data(i).options; const o = t(a.loadingParentElement).children(`.${a.loadingClass}`); o.fadeOut().remove() }, addTimer() { const n = this; const o = t(this); const e = o.data(i).options; a.settings.timer = setTimeout(() => { a.in.call(n), t(window).off(`load.${i}`) }, e.timeoutCountdown) }, supportCheck(n) { const i = t(this); const a = n.browser; const o = a.length; let e = !1; o === 0 && (e = !0); for (let s = 0; o > s; s++) if (typeof i.css(a[s]) === 'string') { e = !0; break } return e }, optionCheck(n) { let i; const o = t(this); return i = n.overlay || o.data(a.settings.data.overlay) ? !0 : !1 }, animationCheck(n, a, o) { const e = t(this); const s = e.data(i).options; const r = typeof n; const l = !a && r === 'number'; const d = a && r === 'string' && n.length > 0; return l || d ? n = n : a && o ? n = s.inClass : !a && o ? n = s.inDuration : a && !o ? n = s.outClass : a || o || (n = s.outDuration), n }, in() { const n = this; const o = t(this); const e = o.data(i).options; const s = o.data(a.settings.data.inDuration); const r = o.data(a.settings.data.inClass); const l = a.animationCheck.call(n, s, !1, !0); const d = a.animationCheck.call(n, r, !0, !0); const u = a.optionCheck.call(n, e); const c = o.data(i).outClass; e.loading && a.removeLoading.call(n), c && o.removeClass(c), u ? a.inOverlay.call(n, d, l) : a.inDefault.call(n, d, l) }, inDefault(n, i) { const o = t(this); o.css({ 'animation-duration': `${i}ms` }).addClass(n).trigger(a.settings.events.inStart).animateCallback(() => { o.removeClass(n).css({ opacity: 1 }).trigger(a.settings.events.inEnd) }) }, inOverlay(n, o) { const e = t(this); const s = e.data(i).options; e.css({ opacity: 1 }).trigger(a.settings.events.inStart), t(s.overlayParentElement).children(`.${s.overlayClass}`).css({ 'animation-duration': `${o}ms` }).addClass(n).animateCallback(() => { e.trigger(a.settings.events.inEnd) }) }, out(n, o) { const e = this; const s = t(this); const r = s.data(i).options; const l = n.data(a.settings.data.outClass); const d = s.data(a.settings.data.outClass); const u = n.data(a.settings.data.outDuration); const c = s.data(a.settings.data.outDuration); const m = l || d; const g = u || c; const f = a.animationCheck.call(e, m, !0, !1); const v = a.animationCheck.call(e, g, !1, !1); const h = a.optionCheck.call(e, r); s.data(i).outClass = f, h ? a.outOverlay.call(e, f, v, o) : a.outDefault.call(e, f, v, o) }, outDefault(n, o, e) { const s = t(this); const r = s.data(i).options; s.css({ 'animation-duration': `${o + 1}ms` }).addClass(n).trigger(a.settings.events.outStart).animateCallback(() => { s.trigger(a.settings.events.outEnd), r.transition(e) }) }, outOverlay(n, o, e) { const s = this; const r = t(this); const l = r.data(i).options; const d = r.data(a.settings.data.inClass); const u = a.animationCheck.call(s, d, !0, !0); t(l.overlayParentElement).children(`.${l.overlayClass}`).css({ 'animation-duration': `${o + 1}ms` }).removeClass(u).addClass(n).trigger(a.settings.events.outStart).animateCallback(() => { r.trigger(a.settings.events.outEnd), l.transition(e) }) }, destroy() { return this.each(function () { const n = t(this); t(window).off(`.${i}`), n.css({ opacity: 1 }).removeData(i) }) } }; t.fn.animateCallback = function (n) { const i = 'animationend webkitAnimationEnd'; return this.each(function () { const a = t(this); a.on(i, function () { return a.off(i), n.call(this) }) }) }, t.fn.animsition = function (n) { return a[n] ? a[n].apply(this, Array.prototype.slice.call(arguments, 1)) : typeof n !== 'object' && n ? void t.error(`Method ${n} does not exist on jQuery.${i}`) : a.init.apply(this, arguments) }
}))

/*! skrollr 0.6.30 (2015-06-19) | Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr | Free to use under terms of MIT license */
!(function (a, b, c) {
  function d(c) { if (e = b.documentElement, f = b.body, T(), ha = this, c = c || {}, ma = c.constants || {}, c.easing) for (const d in c.easing)W[d] = c.easing[d]; ta = c.edgeStrategy || 'set', ka = { beforerender: c.beforerender, render: c.render, keyframe: c.keyframe }, la = c.forceHeight !== !1, la && (Ka = c.scale || 1), na = c.mobileDeceleration || y, pa = c.smoothScrolling !== !1, qa = c.smoothScrollingDuration || A, ra = { targetTop: ha.getScrollTop() }, Sa = (c.mobileCheck || function () { return /Android|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent || navigator.vendor || a.opera) })(), Sa ? (ja = b.getElementById(c.skrollrBody || z), ja && ga(), X(), Ea(e, [s, v], [t])) : Ea(e, [s, u], [t]), ha.refresh(), wa(a, 'resize orientationchange', () => { const a = e.clientWidth; const b = e.clientHeight; (b !== Pa || a !== Oa) && (Pa = b, Oa = a, Qa = !0) }); const g = U(); return (function h() { $(), va = g(h) }()), ha } let e; let f; const g = { get() { return ha }, init(a) { return ha || new d(a) }, VERSION: '0.6.29' }; const h = Object.prototype.hasOwnProperty; const i = a.Math; const j = a.getComputedStyle; const k = 'touchstart'; const l = 'touchmove'; const m = 'touchcancel'; const n = 'touchend'; const o = 'skrollable'; const p = `${o}-before`; const q = `${o}-between`; const r = `${o}-after`; var s = 'skrollr'; var t = `no-${s}`; var u = `${s}-desktop`; var v = `${s}-mobile`; const w = 'linear'; const x = 1e3; var y = 0.004; var z = 'skrollr-body'; var A = 200; const B = 'start'; const C = 'end'; const D = 'center'; const E = 'bottom'; const F = '___skrollable_id'; const G = /^(?:input|textarea|button|select)$/i; const H = /^\s+|\s+$/g; const I = /^data(?:-(_\w+))?(?:-?(-?\d*\.?\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/; const J = /\s*(@?[\w\-\[\]]+)\s*:\s*(.+?)\s*(?:;|$)/gi; const K = /^(@?[a-z\-]+)\[(\w+)\]$/; const L = /-([a-z0-9_])/g; const M = function (a, b) { return b.toUpperCase() }; const N = /[\-+]?[\d]*\.?[\d]+/g; const O = /\{\?\}/g; const P = /rgba?\(\s*-?\d+\s*,\s*-?\d+\s*,\s*-?\d+/g; const Q = /[a-z\-]+-gradient/g; let R = ''; let S = ''; var T = function () { const a = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/; if (j) { const b = j(f, null); for (const c in b) if (R = c.match(a) || +c == c && b[c].match(a)) break; if (!R) return void (R = S = ''); R = R[0], R.slice(0, 1) === '-' ? (S = R, R = { '-webkit-': 'webkit', '-moz-': 'Moz', '-ms-': 'ms', '-o-': 'O' }[R]) : S = `-${R.toLowerCase()}-` } }; var U = function () { let b = a.requestAnimationFrame || a[`${R.toLowerCase()}RequestAnimationFrame`]; let c = Ha(); return (Sa || !b) && (b = function (b) { const d = Ha() - c; const e = i.max(0, 1e3 / 60 - d); return a.setTimeout(() => { c = Ha(), b() }, e) }), b }; const V = function () { let b = a.cancelAnimationFrame || a[`${R.toLowerCase()}CancelAnimationFrame`]; return (Sa || !b) && (b = function (b) { return a.clearTimeout(b) }), b }; var W = { begin() { return 0 }, end() { return 1 }, linear(a) { return a }, quadratic(a) { return a * a }, cubic(a) { return a * a * a }, swing(a) { return -i.cos(a * i.PI) / 2 + 0.5 }, sqrt(a) { return i.sqrt(a) }, outCubic(a) { return i.pow(a - 1, 3) + 1 }, bounce(a) { let b; if (a <= 0.5083)b = 3; else if (a <= 0.8489)b = 9; else if (a <= 0.96208)b = 27; else { if (!(a <= 0.99981)) return 1; b = 91 } return 1 - i.abs(3 * i.cos(a * b * 1.028) / b) } }; d.prototype.refresh = function (a) { let d; let e; let f = !1; for (a === c ? (f = !0, ia = [], Ra = 0, a = b.getElementsByTagName('*')) : a.length === c && (a = [a]), d = 0, e = a.length; e > d; d++) { const g = a[d]; let h = g; const i = []; let j = pa; let k = ta; let l = !1; if (f && F in g && delete g[F], g.attributes) { for (let m = 0, n = g.attributes.length; n > m; m++) { const p = g.attributes[m]; if (p.name !== 'data-anchor-target') if (p.name !== 'data-smooth-scrolling') if (p.name !== 'data-edge-strategy') if (p.name !== 'data-emit-events') { const q = p.name.match(I); if (q !== null) { const r = { props: p.value, element: g, eventType: p.name.replace(L, M) }; i.push(r); const s = q[1]; s && (r.constant = s.substr(1)); const t = q[2]; /p$/.test(t) ? (r.isPercentage = !0, r.offset = (0 | t.slice(0, -1)) / 100) : r.offset = 0 | t; const u = q[3]; const v = q[4] || u; u && u !== B && u !== C ? (r.mode = 'relative', r.anchors = [u, v]) : (r.mode = 'absolute', u === C ? r.isEnd = !0 : r.isPercentage || (r.offset *= Ka)) } } else l = !0; else k = p.value; else j = p.value !== 'off'; else if (h = b.querySelector(p.value), h === null) throw `Unable to find anchor target "${p.value}"` } if (i.length) { var w, x, y; !f && F in g ? (y = g[F], w = ia[y].styleAttr, x = ia[y].classAttr) : (y = g[F] = Ra++, w = g.style.cssText, x = Da(g)), ia[y] = { element: g, styleAttr: w, classAttr: x, anchorTarget: h, keyFrames: i, smoothScrolling: j, edgeStrategy: k, emitEvents: l, lastFrameIndex: -1 }, Ea(g, [o], []) } } } for (Aa(), d = 0, e = a.length; e > d; d++) { const z = ia[a[d][F]]; z !== c && (_(z), ba(z)) } return ha }, d.prototype.relativeToAbsolute = function (a, b, c) { const d = e.clientHeight; const f = a.getBoundingClientRect(); let g = f.top; const h = f.bottom - f.top; return b === E ? g -= d : b === D && (g -= d / 2), c === E ? g += h : c === D && (g += h / 2), g += ha.getScrollTop(), g + 0.5 | 0 }, d.prototype.animateTo = function (a, b) { b = b || {}; const d = Ha(); const e = ha.getScrollTop(); const f = b.duration === c ? x : b.duration; return oa = { startTop: e, topDiff: a - e, targetTop: a, duration: f, startTime: d, endTime: d + f, easing: W[b.easing || w], done: b.done }, oa.topDiff || (oa.done && oa.done.call(ha, !1), oa = c), ha }, d.prototype.stopAnimateTo = function () { oa && oa.done && oa.done.call(ha, !0), oa = c }, d.prototype.isAnimatingTo = function () { return !!oa }, d.prototype.isMobile = function () { return Sa }, d.prototype.setScrollTop = function (b, c) { return sa = c === !0, Sa ? Ta = i.min(i.max(b, 0), Ja) : a.scrollTo(0, b), ha }, d.prototype.getScrollTop = function () { return Sa ? Ta : a.pageYOffset || e.scrollTop || f.scrollTop || 0 }, d.prototype.getMaxScrollTop = function () { return Ja }, d.prototype.on = function (a, b) { return ka[a] = b, ha }, d.prototype.off = function (a) { return delete ka[a], ha }, d.prototype.destroy = function () { const a = V(); a(va), ya(), Ea(e, [t], [s, u, v]); for (let b = 0, d = ia.length; d > b; b++)fa(ia[b].element); e.style.overflow = f.style.overflow = '', e.style.height = f.style.height = '', ja && g.setStyle(ja, 'transform', 'none'), ha = c, ja = c, ka = c, la = c, Ja = 0, Ka = 1, ma = c, na = c, La = 'down', Ma = -1, Oa = 0, Pa = 0, Qa = !1, oa = c, pa = c, qa = c, ra = c, sa = c, Ra = 0, ta = c, Sa = !1, Ta = 0, ua = c }; var X = function () { let d, g, h, j, o, p, q, r, s, t, u, v; wa(e, [k, l, m, n].join(' '), (a) => { const e = a.changedTouches[0]; for (j = a.target; j.nodeType === 3;)j = j.parentNode; switch (o = e.clientY, p = e.clientX, t = a.timeStamp, G.test(j.tagName) || a.preventDefault(), a.type) { case k:d && d.blur(), ha.stopAnimateTo(), d = j, g = q = o, h = p, s = t; break; case l:G.test(j.tagName) && b.activeElement !== j && a.preventDefault(), r = o - q, v = t - u, ha.setScrollTop(Ta - r, !0), q = o, u = t; break; default:case m:case n:var f = g - o; var w = h - p; var x = w * w + f * f; if (x < 49) { if (!G.test(d.tagName)) { d.focus(); const y = b.createEvent('MouseEvents'); y.initMouseEvent('click', !0, !0, a.view, 1, e.screenX, e.screenY, e.clientX, e.clientY, a.ctrlKey, a.altKey, a.shiftKey, a.metaKey, 0, null), d.dispatchEvent(y) } return }d = c; var z = r / v; z = i.max(i.min(z, 3), -3); var A = i.abs(z / na); var B = z * A + 0.5 * na * A * A; var C = ha.getScrollTop() - B; var D = 0; C > Ja ? (D = (Ja - C) / B, C = Ja) : C < 0 && (D = -C / B, C = 0), A *= 1 - D, ha.animateTo(C + 0.5 | 0, { easing: 'outCubic', duration: A }) } }), a.scrollTo(0, 0), e.style.overflow = f.style.overflow = 'hidden' }; const Y = function () { let a; let b; let c; let d; let f; let g; let h; let j; let k; let l; let m; const n = e.clientHeight; const o = Ba(); for (j = 0, k = ia.length; k > j; j++) for (a = ia[j], b = a.element, c = a.anchorTarget, d = a.keyFrames, f = 0, g = d.length; g > f; f++)h = d[f], l = h.offset, m = o[h.constant] || 0, h.frame = l, h.isPercentage && (l *= n, h.frame = l), h.mode === 'relative' && (fa(b), h.frame = ha.relativeToAbsolute(c, h.anchors[0], h.anchors[1]) - l, fa(b, !0)), h.frame += m, la && !h.isEnd && h.frame > Ja && (Ja = h.frame); for (Ja = i.max(Ja, Ca()), j = 0, k = ia.length; k > j; j++) { for (a = ia[j], d = a.keyFrames, f = 0, g = d.length; g > f; f++)h = d[f], m = o[h.constant] || 0, h.isEnd && (h.frame = Ja - h.offset + m); a.keyFrames.sort(Ia) } }; const Z = function (a, b) { for (let c = 0, d = ia.length; d > c; c++) { var e; var f; const i = ia[c]; const j = i.element; let k = i.smoothScrolling ? a : b; const l = i.keyFrames; const m = l.length; const n = l[0]; const s = l[l.length - 1]; const t = k < n.frame; const u = k > s.frame; const v = t ? n : s; const w = i.emitEvents; const x = i.lastFrameIndex; if (t || u) { if (t && i.edge === -1 || u && i.edge === 1) continue; switch (t ? (Ea(j, [p], [r, q]), w && x > -1 && (za(j, n.eventType, La), i.lastFrameIndex = -1)) : (Ea(j, [r], [p, q]), w && m > x && (za(j, s.eventType, La), i.lastFrameIndex = m)), i.edge = t ? -1 : 1, i.edgeStrategy) { case 'reset':fa(j); continue; case 'ease':k = v.frame; break; default:case 'set':var y = v.props; for (e in y)h.call(y, e) && (f = ea(y[e].value), e.indexOf('@') === 0 ? j.setAttribute(e.substr(1), f) : g.setStyle(j, e, f)); continue } } else i.edge !== 0 && (Ea(j, [o, q], [p, r]), i.edge = 0); for (let z = 0; m - 1 > z; z++) if (k >= l[z].frame && k <= l[z + 1].frame) { const A = l[z]; const B = l[z + 1]; for (e in A.props) if (h.call(A.props, e)) { let C = (k - A.frame) / (B.frame - A.frame); C = A.props[e].easing(C), f = da(A.props[e].value, B.props[e].value, C), f = ea(f), e.indexOf('@') === 0 ? j.setAttribute(e.substr(1), f) : g.setStyle(j, e, f) }w && x !== z && (La === 'down' ? za(j, A.eventType, La) : za(j, B.eventType, La), i.lastFrameIndex = z); break } } }; var $ = function () { Qa && (Qa = !1, Aa()); let a; let b; let d = ha.getScrollTop(); const e = Ha(); if (oa)e >= oa.endTime ? (d = oa.targetTop, a = oa.done, oa = c) : (b = oa.easing((e - oa.startTime) / oa.duration), d = oa.startTop + b * oa.topDiff | 0), ha.setScrollTop(d, !0); else if (!sa) { const f = ra.targetTop - d; f && (ra = { startTop: Ma, topDiff: d - Ma, targetTop: d, startTime: Na, endTime: Na + qa }), e <= ra.endTime && (b = W.sqrt((e - ra.startTime) / qa), d = ra.startTop + b * ra.topDiff | 0) } if (sa || Ma !== d) { La = d > Ma ? 'down' : Ma > d ? 'up' : La, sa = !1; const h = { curTop: d, lastTop: Ma, maxTop: Ja, direction: La }; const i = ka.beforerender && ka.beforerender.call(ha, h); i !== !1 && (Z(d, ha.getScrollTop()), Sa && ja && g.setStyle(ja, 'transform', `translate(0, ${-Ta}px) ${ua}`), Ma = d, ka.render && ka.render.call(ha, h)), a && a.call(ha, !1) }Na = e }; var _ = function (a) { for (let b = 0, c = a.keyFrames.length; c > b; b++) { for (var d, e, f, g, h = a.keyFrames[b], i = {}; (g = J.exec(h.props)) !== null;)f = g[1], e = g[2], d = f.match(K), d !== null ? (f = d[1], d = d[2]) : d = w, e = e.indexOf('!') ? aa(e) : [e.slice(1)], i[f] = { value: e, easing: W[d] }; h.props = i } }; var aa = function (a) { const b = []; return P.lastIndex = 0, a = a.replace(P, (a) => a.replace(N, (a) => `${a / 255 * 100}%`)), S && (Q.lastIndex = 0, a = a.replace(Q, (a) => S + a)), a = a.replace(N, (a) => b.push(+a), '{?}'), b.unshift(a), b }; var ba = function (a) { let b; let c; let d = {}; for (b = 0, c = a.keyFrames.length; c > b; b++)ca(a.keyFrames[b], d); for (d = {}, b = a.keyFrames.length - 1; b >= 0; b--)ca(a.keyFrames[b], d) }; var ca = function (a, b) { let c; for (c in b)h.call(a.props, c) || (a.props[c] = b[c]); for (c in a.props)b[c] = a.props[c] }; var da = function (a, b, c) { let d; const e = a.length; if (e !== b.length) throw `Can't interpolate between "${a[0]}" and "${b[0]}"`; const f = [a[0]]; for (d = 1; e > d; d++)f[d] = a[d] + (b[d] - a[d]) * c; return f }; var ea = function (a) { let b = 1; return O.lastIndex = 0, a[0].replace(O, () => a[b++]) }; var fa = function (a, b) { a = [].concat(a); for (var c, d, e = 0, f = a.length; f > e; e++)d = a[e], c = ia[d[F]], c && (b ? (d.style.cssText = c.dirtyStyleAttr, Ea(d, c.dirtyClassAttr)) : (c.dirtyStyleAttr = d.style.cssText, c.dirtyClassAttr = Da(d), d.style.cssText = c.styleAttr, Ea(d, c.classAttr))) }; var ga = function () { ua = 'translateZ(0)', g.setStyle(ja, 'transform', ua); const a = j(ja); const b = a.getPropertyValue('transform'); const c = a.getPropertyValue(`${S}transform`); const d = b && b !== 'none' || c && c !== 'none'; d || (ua = '') }; g.setStyle = function (a, b, c) { const d = a.style; if (b = b.replace(L, M).replace('-', ''), b === 'zIndex')isNaN(c) ? d[b] = c : d[b] = `${0 | c}`; else if (b === 'float')d.styleFloat = d.cssFloat = c; else try { R && (d[R + b.slice(0, 1).toUpperCase() + b.slice(1)] = c), d[b] = c } catch (e) {} }; let ha; let ia; let ja; let ka; let la; let ma; let na; let oa; let pa; let qa; let ra; let sa; let ta; let ua; let va; var wa = g.addEvent = function (b, c, d) { const e = function (b) { return b = b || a.event, b.target || (b.target = b.srcElement), b.preventDefault || (b.preventDefault = function () { b.returnValue = !1, b.defaultPrevented = !0 }), d.call(this, b) }; c = c.split(' '); for (var f, g = 0, h = c.length; h > g; g++)f = c[g], b.addEventListener ? b.addEventListener(f, d, !1) : b.attachEvent(`on${f}`, e), Ua.push({ element: b, name: f, listener: d }) }; const xa = g.removeEvent = function (a, b, c) { b = b.split(' '); for (let d = 0, e = b.length; e > d; d++)a.removeEventListener ? a.removeEventListener(b[d], c, !1) : a.detachEvent(`on${b[d]}`, c) }; var ya = function () { for (var a, b = 0, c = Ua.length; c > b; b++)a = Ua[b], xa(a.element, a.name, a.listener); Ua = [] }; var za = function (a, b, c) { ka.keyframe && ka.keyframe.call(ha, a, b, c) }; var Aa = function () { const a = ha.getScrollTop(); Ja = 0, la && !Sa && (f.style.height = ''), Y(), la && !Sa && (f.style.height = `${Ja + e.clientHeight}px`), Sa ? ha.setScrollTop(i.min(ha.getScrollTop(), Ja)) : ha.setScrollTop(a, !0), sa = !0 }; var Ba = function () { let a; let b; const c = e.clientHeight; const d = {}; for (a in ma)b = ma[a], typeof b === 'function' ? b = b.call(ha) : /p$/.test(b) && (b = b.slice(0, -1) / 100 * c), d[a] = b; return d }; var Ca = function () { let a; let b = 0; return ja && (b = i.max(ja.offsetHeight, ja.scrollHeight)), a = i.max(b, f.scrollHeight, f.offsetHeight, e.scrollHeight, e.offsetHeight, e.clientHeight), a - e.clientHeight }; var Da = function (b) { let c = 'className'; return a.SVGElement && b instanceof a.SVGElement && (b = b[c], c = 'baseVal'), b[c] }; var Ea = function (b, d, e) { let f = 'className'; if (a.SVGElement && b instanceof a.SVGElement && (b = b[f], f = 'baseVal'), e === c) return void (b[f] = d); for (var g = b[f], h = 0, i = e.length; i > h; h++)g = Ga(g).replace(Ga(e[h]), ' '); g = Fa(g); for (let j = 0, k = d.length; k > j; j++)Ga(g).indexOf(Ga(d[j])) === -1 && (g += ` ${d[j]}`); b[f] = Fa(g) }; var Fa = function (a) { return a.replace(H, '') }; var Ga = function (a) { return ` ${a} ` }; var Ha = Date.now || function () { return +new Date() }; var Ia = function (a, b) { return a.frame - b.frame }; var Ja = 0; var Ka = 1; var La = 'down'; var Ma = -1; var Na = Ha(); var Oa = 0; var Pa = 0; var Qa = !1; var Ra = 0; var Sa = !1; var Ta = 0; var Ua = []; typeof define === 'function' && define.amd ? define([], () => g) : typeof module !== 'undefined' && module.exports ? module.exports = g : a.skrollr = g
}(window, document));

/** Abstract base class for collection plugins.
 Written by Keith Wood (kbwood{at}iinet.com.au) December 2013.
 Licensed under the MIT (https://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt) license. */
(function () { let j = false; window.JQClass = function () {}; JQClass.classes = {}; JQClass.extend = function extender(f) { const g = this.prototype; j = true; const h = new this(); j = false; for (const i in f) { h[i] = typeof f[i] === 'function' && typeof g[i] === 'function' ? (function (d, e) { return function () { const b = this._super; this._super = function (a) { return g[d].apply(this, a) }; const c = e.apply(this, arguments); this._super = b; return c } })(i, f[i]) : f[i] } function JQClass() { if (!j && this._init) { this._init.apply(this, arguments) } }JQClass.prototype = h; JQClass.prototype.constructor = JQClass; JQClass.extend = extender; return JQClass } })(); (function ($) { JQClass.classes.JQPlugin = JQClass.extend({ name: 'plugin', defaultOptions: {}, regionalOptions: {}, _getters: [], _getMarker() { return `is-${this.name}` }, _init() { $.extend(this.defaultOptions, (this.regionalOptions && this.regionalOptions['']) || {}); const c = camelCase(this.name); $[c] = this; $.fn[c] = function (a) { const b = Array.prototype.slice.call(arguments, 1); if ($[c]._isNotChained(a, b)) { return $[c][a].apply($[c], [this[0]].concat(b)) } return this.each(function () { if (typeof a === 'string') { if (a[0] === '_' || !$[c][a]) { throw `Unknown method: ${a}` }$[c][a].apply($[c], [this].concat(b)) } else { $[c]._attach(this, a) } }) } }, setDefaults(a) { $.extend(this.defaultOptions, a || {}) }, _isNotChained(a, b) { if (a === 'option' && (b.length === 0 || (b.length === 1 && typeof b[0] === 'string'))) { return true } return $.inArray(a, this._getters) > -1 }, _attach(a, b) { a = $(a); if (a.hasClass(this._getMarker())) { return }a.addClass(this._getMarker()); b = $.extend({}, this.defaultOptions, this._getMetadata(a), b || {}); const c = $.extend({ name: this.name, elem: a, options: b }, this._instSettings(a, b)); a.data(this.name, c); this._postAttach(a, c); this.option(a, b) }, _instSettings(a, b) { return {} }, _postAttach(a, b) {}, _getMetadata(d) { try { let f = d.data(this.name.toLowerCase()) || ''; f = f.replace(/'/g, '"'); f = f.replace(/([a-zA-Z0-9]+):/g, (a, b, i) => { const c = f.substring(0, i).match(/"/g); return (!c || c.length % 2 === 0 ? `"${b}":` : `${b}:`) }); f = $.parseJSON(`{${f}}`); for (const g in f) { const h = f[g]; if (typeof h === 'string' && h.match(/^new Date\((.*)\)$/)) { f[g] = eval(h) } } return f } catch (e) { return {} } }, _getInst(a) { return $(a).data(this.name) || {} }, option(a, b, c) { a = $(a); const d = a.data(this.name); if (!b || (typeof b === 'string' && c == null)) { var e = (d || {}).options; return (e && b ? e[b] : e) } if (!a.hasClass(this._getMarker())) { return } var e = b || {}; if (typeof b === 'string') { e = {}; e[b] = c } this._optionsChanged(a, d, e); $.extend(d.options, e) }, _optionsChanged(a, b, c) {}, destroy(a) { a = $(a); if (!a.hasClass(this._getMarker())) { return } this._preDestroy(a, this._getInst(a)); a.removeData(this.name).removeClass(this._getMarker()) }, _preDestroy(a, b) {} }); function camelCase(c) { return c.replace(/-([a-z])/g, (a, b) => b.toUpperCase()) }$.JQPlugin = { createPlugin(a, b) { if (typeof a === 'object') { b = a; a = 'JQPlugin' }a = camelCase(a); const c = camelCase(b.name); JQClass.classes[c] = JQClass.classes[a].extend(b); new JQClass.classes[c]() } } })(jQuery)

/*! http://keith-wood.name/countdown.html
	Countdown for jQuery v2.1.0.
	Written by Keith Wood (wood.keith{at}optusnet.com.au) January 2008.
	Available under the MIT (http://keith-wood.name/licence.html) license.
	Please attribute the author if you use it.
*/
!(function (a) {
  const b = 'countdown'; const c = 0; const d = 1; const e = 2; const f = 3; const g = 4; const h = 5; const i = 6; a.JQPlugin.createPlugin({ name: b, defaultOptions: { until: null, since: null, timezone: null, serverSync: null, format: 'dHMS', layout: '', compact: !1, padZeroes: !1, significant: 0, description: '', expiryUrl: '', expiryText: '', alwaysExpire: !1, onExpiry: null, onTick: null, tickInterval: 1 }, regionalOptions: { '': { labels: ['Years', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'], labels1: ['Year', 'Month', 'Week', 'Day', 'Hour', 'Minute', 'Second'], compactLabels: ['y', 'm', 'w', 'd'], whichLabels: null, digits: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], timeSeparator: ':', isRTL: !1 } }, _rtlClass: `${b}-rtl`, _sectionClass: `${b}-section`, _amountClass: `${b}-amount`, _periodClass: `${b}-period`, _rowClass: `${b}-row`, _holdingClass: `${b}-holding`, _showClass: `${b}-show`, _descrClass: `${b}-descr`, _timerElems: [], _init() { function b(a) { const h = a < 1e12 ? e ? window.performance.now() + window.performance.timing.navigationStart : d() : a || d(); h - g >= 1e3 && (c._updateElems(), g = h), f(b) } var c = this; this._super(), this._serverSyncs = []; var d = typeof Date.now === 'function' ? Date.now : function () { return (new Date()).getTime() }; var e = window.performance && typeof window.performance.now === 'function'; var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || null; var g = 0; !f || a.noRequestAnimationFrame ? (a.noRequestAnimationFrame = null, a.countdown._timer = setInterval(() => { c._updateElems() }, 1e3)) : (g = window.animationStartTime || window.webkitAnimationStartTime || window.mozAnimationStartTime || window.oAnimationStartTime || window.msAnimationStartTime || d(), f(b)) }, UTCDate(a, b, c, d, e, f, g, h) { typeof b === 'object' && b instanceof Date && (h = b.getMilliseconds(), g = b.getSeconds(), f = b.getMinutes(), e = b.getHours(), d = b.getDate(), c = b.getMonth(), b = b.getFullYear()); const i = new Date(); return i.setUTCFullYear(b), i.setUTCDate(1), i.setUTCMonth(c || 0), i.setUTCDate(d || 1), i.setUTCHours(e || 0), i.setUTCMinutes((f || 0) - (Math.abs(a) < 30 ? 60 * a : a)), i.setUTCSeconds(g || 0), i.setUTCMilliseconds(h || 0), i }, periodsToSeconds(a) { return 31557600 * a[0] + 2629800 * a[1] + 604800 * a[2] + 86400 * a[3] + 3600 * a[4] + 60 * a[5] + a[6] }, resync() { const b = this; a(`.${this._getMarker()}`).each(function () { const c = a.data(this, b.name); if (c.options.serverSync) { for (var d = null, e = 0; e < b._serverSyncs.length; e++) if (b._serverSyncs[e][0] === c.options.serverSync) { d = b._serverSyncs[e]; break } if (b._eqNull(d[2])) { const f = a.isFunction(c.options.serverSync) ? c.options.serverSync.apply(this, []) : null; d[2] = (f ? (new Date()).getTime() - f.getTime() : 0) - d[1] }c._since && c._since.setMilliseconds(c._since.getMilliseconds() + d[2]), c._until.setMilliseconds(c._until.getMilliseconds() + d[2]) } }); for (let c = 0; c < b._serverSyncs.length; c++)b._eqNull(b._serverSyncs[c][2]) || (b._serverSyncs[c][1] += b._serverSyncs[c][2], delete b._serverSyncs[c][2]) }, _instSettings(a, b) { return { _periods: [0, 0, 0, 0, 0, 0, 0] } }, _addElem(a) { this._hasElem(a) || this._timerElems.push(a) }, _hasElem(b) { return a.inArray(b, this._timerElems) > -1 }, _removeElem(b) { this._timerElems = a.map(this._timerElems, (a) => a === b ? null : a) }, _updateElems() { for (let a = this._timerElems.length - 1; a >= 0; a--) this._updateCountdown(this._timerElems[a]) }, _optionsChanged(b, c, d) { d.layout && (d.layout = d.layout.replace(/&lt;/g, '<').replace(/&gt;/g, '>')), this._resetExtraLabels(c.options, d); const e = c.options.timezone !== d.timezone; a.extend(c.options, d), this._adjustSettings(b, c, !this._eqNull(d.until) || !this._eqNull(d.since) || e); const f = new Date(); (c._since && c._since < f || c._until && c._until > f) && this._addElem(b[0]), this._updateCountdown(b, c) }, _updateCountdown(b, c) { if (b = b.jquery ? b : a(b), c = c || this._getInst(b)) { if (b.html(this._generateHTML(c)).toggleClass(this._rtlClass, c.options.isRTL), c._hold !== 'pause' && a.isFunction(c.options.onTick)) { const d = c._hold !== 'lap' ? c._periods : this._calculatePeriods(c, c._show, c.options.significant, new Date()); c.options.tickInterval !== 1 && this.periodsToSeconds(d) % c.options.tickInterval !== 0 || c.options.onTick.apply(b[0], [d]) } const e = c._hold !== 'pause' && (c._since ? c._now.getTime() < c._since.getTime() : c._now.getTime() >= c._until.getTime()); if (e && !c._expiring) { if (c._expiring = !0, this._hasElem(b[0]) || c.options.alwaysExpire) { if (this._removeElem(b[0]), a.isFunction(c.options.onExpiry) && c.options.onExpiry.apply(b[0], []), c.options.expiryText) { const f = c.options.layout; c.options.layout = c.options.expiryText, this._updateCountdown(b[0], c), c.options.layout = f }c.options.expiryUrl && (window.location = c.options.expiryUrl) }c._expiring = !1 } else c._hold === 'pause' && this._removeElem(b[0]) } }, _resetExtraLabels(a, b) { let c = null; for (c in b)c.match(/[Ll]abels[02-9]|compactLabels1/) && (a[c] = b[c]); for (c in a)c.match(/[Ll]abels[02-9]|compactLabels1/) && typeof b[c] === 'undefined' && (a[c] = null) }, _eqNull(a) { return typeof a === 'undefined' || a === null }, _adjustSettings(b, c, d) { for (var e = null, f = 0; f < this._serverSyncs.length; f++) if (this._serverSyncs[f][0] === c.options.serverSync) { e = this._serverSyncs[f][1]; break } let g = null; let h = null; if (this._eqNull(e)) { const i = a.isFunction(c.options.serverSync) ? c.options.serverSync.apply(b[0], []) : null; g = new Date(), h = i ? g.getTime() - i.getTime() : 0, this._serverSyncs.push([c.options.serverSync, h]) } else g = new Date(), h = c.options.serverSync ? e : 0; let j = c.options.timezone; j = this._eqNull(j) ? -g.getTimezoneOffset() : j, (d || !d && this._eqNull(c._until) && this._eqNull(c._since)) && (c._since = c.options.since, this._eqNull(c._since) || (c._since = this.UTCDate(j, this._determineTime(c._since, null)), c._since && h && c._since.setMilliseconds(c._since.getMilliseconds() + h)), c._until = this.UTCDate(j, this._determineTime(c.options.until, g)), h && c._until.setMilliseconds(c._until.getMilliseconds() + h)), c._show = this._determineShow(c) }, _preDestroy(a, b) { this._removeElem(a[0]), a.empty() }, pause(a) { this._hold(a, 'pause') }, lap(a) { this._hold(a, 'lap') }, resume(a) { this._hold(a, null) }, toggle(b) { const c = a.data(b, this.name) || {}; this[c._hold ? 'resume' : 'pause'](b) }, toggleLap(b) { const c = a.data(b, this.name) || {}; this[c._hold ? 'resume' : 'lap'](b) }, _hold(b, c) { const d = a.data(b, this.name); if (d) { if (d._hold === 'pause' && !c) { d._periods = d._savePeriods; const e = d._since ? '-' : '+'; d[d._since ? '_since' : '_until'] = this._determineTime(`${e + d._periods[0]}y${e}${d._periods[1]}o${e}${d._periods[2]}w${e}${d._periods[3]}d${e}${d._periods[4]}h${e}${d._periods[5]}m${e}${d._periods[6]}s`), this._addElem(b) }d._hold = c, d._savePeriods = c === 'pause' ? d._periods : null, a.data(b, this.name, d), this._updateCountdown(b, d) } }, getTimes(b) { const c = a.data(b, this.name); return c ? c._hold === 'pause' ? c._savePeriods : c._hold ? this._calculatePeriods(c, c._show, c.options.significant, new Date()) : c._periods : null }, _determineTime(a, b) { const c = this; const d = function (a) { const b = new Date(); return b.setTime(b.getTime() + 1e3 * a), b }; const e = function (a) { a = a.toLowerCase(); for (var b = new Date(), d = b.getFullYear(), e = b.getMonth(), f = b.getDate(), g = b.getHours(), h = b.getMinutes(), i = b.getSeconds(), j = /([+-]?[0-9]+)\s*(s|m|h|d|w|o|y)?/g, k = j.exec(a); k;) { switch (k[2] || 's') { case 's':i += parseInt(k[1], 10); break; case 'm':h += parseInt(k[1], 10); break; case 'h':g += parseInt(k[1], 10); break; case 'd':f += parseInt(k[1], 10); break; case 'w':f += 7 * parseInt(k[1], 10); break; case 'o':e += parseInt(k[1], 10), f = Math.min(f, c._getDaysInMonth(d, e)); break; case 'y':d += parseInt(k[1], 10), f = Math.min(f, c._getDaysInMonth(d, e)) }k = j.exec(a) } return new Date(d, e, f, g, h, i, 0) }; const f = this._eqNull(a) ? b : typeof a === 'string' ? e(a) : typeof a === 'number' ? d(a) : a; return f && f.setMilliseconds(0), f }, _getDaysInMonth(a, b) { return 32 - new Date(a, b, 32).getDate() }, _normalLabels(a) { return a }, _generateHTML(b) { const j = this; b._periods = b._hold ? b._periods : this._calculatePeriods(b, b._show, b.options.significant, new Date()); let k = !1; let l = 0; let m = b.options.significant; const n = a.extend({}, b._show); let o = null; for (o = c; o <= i; o++)k = k || b._show[o] === '?' && b._periods[o] > 0, n[o] = b._show[o] !== '?' || k ? b._show[o] : null, l += n[o] ? 1 : 0, m -= b._periods[o] > 0 ? 1 : 0; const p = [!1, !1, !1, !1, !1, !1, !1]; for (o = i; o >= c; o--)b._show[o] && (b._periods[o] ? p[o] = !0 : (p[o] = m > 0, m--)); const q = b.options.compact ? b.options.compactLabels : b.options.labels; const r = b.options.whichLabels || this._normalLabels; const s = function (a) { const c = b.options[`compactLabels${r(b._periods[a])}`]; return n[a] ? `${j._translateDigits(b, b._periods[a]) + (c ? c[a] : q[a])} ` : '' }; const t = b.options.padZeroes ? 2 : 1; const u = function (a) { const c = b.options[`labels${r(b._periods[a])}`]; return !b.options.significant && n[a] || b.options.significant && p[a] ? `<span class="${j._sectionClass}"><span class="${j._amountClass}">${j._minDigits(b, b._periods[a], t)}</span><span class="${j._periodClass}">${c ? c[a] : q[a]}</span></span>` : '' }; return b.options.layout ? this._buildLayout(b, n, b.options.layout, b.options.compact, b.options.significant, p) : `${b.options.compact ? `<span class="${this._rowClass} ${this._amountClass}${b._hold ? ` ${this._holdingClass}` : ''}">${s(c)}${s(d)}${s(e)}${s(f)}${n[g] ? this._minDigits(b, b._periods[g], 2) : ''}${n[h] ? (n[g] ? b.options.timeSeparator : '') + this._minDigits(b, b._periods[h], 2) : ''}${n[i] ? (n[g] || n[h] ? b.options.timeSeparator : '') + this._minDigits(b, b._periods[i], 2) : ''}` : `<span class="${this._rowClass} ${this._showClass}${b.options.significant || l}${b._hold ? ` ${this._holdingClass}` : ''}">${u(c)}${u(d)}${u(e)}${u(f)}${u(g)}${u(h)}${u(i)}`}</span>${b.options.description ? `<span class="${this._rowClass} ${this._descrClass}">${b.options.description}</span>` : ''}` }, _buildLayout(b, j, k, l, m, n) { for (var o = b.options[l ? 'compactLabels' : 'labels'], p = b.options.whichLabels || this._normalLabels, q = function (a) { return (b.options[(l ? 'compactLabels' : 'labels') + p(b._periods[a])] || o)[a] }, r = function (a, c) { return b.options.digits[Math.floor(a / c) % 10] }, s = { desc: b.options.description, sep: b.options.timeSeparator, yl: q(c), yn: this._minDigits(b, b._periods[c], 1), ynn: this._minDigits(b, b._periods[c], 2), ynnn: this._minDigits(b, b._periods[c], 3), y1: r(b._periods[c], 1), y10: r(b._periods[c], 10), y100: r(b._periods[c], 100), y1000: r(b._periods[c], 1e3), ol: q(d), on: this._minDigits(b, b._periods[d], 1), onn: this._minDigits(b, b._periods[d], 2), onnn: this._minDigits(b, b._periods[d], 3), o1: r(b._periods[d], 1), o10: r(b._periods[d], 10), o100: r(b._periods[d], 100), o1000: r(b._periods[d], 1e3), wl: q(e), wn: this._minDigits(b, b._periods[e], 1), wnn: this._minDigits(b, b._periods[e], 2), wnnn: this._minDigits(b, b._periods[e], 3), w1: r(b._periods[e], 1), w10: r(b._periods[e], 10), w100: r(b._periods[e], 100), w1000: r(b._periods[e], 1e3), dl: q(f), dn: this._minDigits(b, b._periods[f], 1), dnn: this._minDigits(b, b._periods[f], 2), dnnn: this._minDigits(b, b._periods[f], 3), d1: r(b._periods[f], 1), d10: r(b._periods[f], 10), d100: r(b._periods[f], 100), d1000: r(b._periods[f], 1e3), hl: q(g), hn: this._minDigits(b, b._periods[g], 1), hnn: this._minDigits(b, b._periods[g], 2), hnnn: this._minDigits(b, b._periods[g], 3), h1: r(b._periods[g], 1), h10: r(b._periods[g], 10), h100: r(b._periods[g], 100), h1000: r(b._periods[g], 1e3), ml: q(h), mn: this._minDigits(b, b._periods[h], 1), mnn: this._minDigits(b, b._periods[h], 2), mnnn: this._minDigits(b, b._periods[h], 3), m1: r(b._periods[h], 1), m10: r(b._periods[h], 10), m100: r(b._periods[h], 100), m1000: r(b._periods[h], 1e3), sl: q(i), sn: this._minDigits(b, b._periods[i], 1), snn: this._minDigits(b, b._periods[i], 2), snnn: this._minDigits(b, b._periods[i], 3), s1: r(b._periods[i], 1), s10: r(b._periods[i], 10), s100: r(b._periods[i], 100), s1000: r(b._periods[i], 1e3) }, t = k, u = c; u <= i; u++) { const v = 'yowdhms'.charAt(u); const w = new RegExp(`\\{${v}<\\}([\\s\\S]*)\\{${v}>\\}`, 'g'); t = t.replace(w, !m && j[u] || m && n[u] ? '$1' : '') } return a.each(s, (a, b) => { const c = new RegExp(`\\{${a}\\}`, 'g'); t = t.replace(c, b) }), t }, _minDigits(a, b, c) { return b = `${b}`, b.length >= c ? this._translateDigits(a, b) : (b = `0000000000${b}`, this._translateDigits(a, b.substr(b.length - c))) }, _translateDigits(a, b) { return (`${b}`).replace(/[0-9]/g, (b) => a.options.digits[b]) }, _determineShow(a) { const b = a.options.format; const j = []; return j[c] = b.match('y') ? '?' : b.match('Y') ? '!' : null, j[d] = b.match('o') ? '?' : b.match('O') ? '!' : null, j[e] = b.match('w') ? '?' : b.match('W') ? '!' : null, j[f] = b.match('d') ? '?' : b.match('D') ? '!' : null, j[g] = b.match('h') ? '?' : b.match('H') ? '!' : null, j[h] = b.match('m') ? '?' : b.match('M') ? '!' : null, j[i] = b.match('s') ? '?' : b.match('S') ? '!' : null, j }, _calculatePeriods(a, b, j, k) { a._now = k, a._now.setMilliseconds(0); const l = new Date(a._now.getTime()); a._since ? k.getTime() < a._since.getTime() ? a._now = k = l : k = a._since : (l.setTime(a._until.getTime()), k.getTime() > a._until.getTime() && (a._now = k = l)); const m = [0, 0, 0, 0, 0, 0, 0]; if (b[c] || b[d]) { const n = this._getDaysInMonth(k.getFullYear(), k.getMonth()); const o = this._getDaysInMonth(l.getFullYear(), l.getMonth()); const p = l.getDate() === k.getDate() || l.getDate() >= Math.min(n, o) && k.getDate() >= Math.min(n, o); const q = function (a) { return 60 * (60 * a.getHours() + a.getMinutes()) + a.getSeconds() }; const r = Math.max(0, 12 * (l.getFullYear() - k.getFullYear()) + l.getMonth() - k.getMonth() + (l.getDate() < k.getDate() && !p || p && q(l) < q(k) ? -1 : 0)); m[c] = b[c] ? Math.floor(r / 12) : 0, m[d] = b[d] ? r - 12 * m[c] : 0, k = new Date(k.getTime()); const s = k.getDate() === n; const t = this._getDaysInMonth(k.getFullYear() + m[c], k.getMonth() + m[d]); k.getDate() > t && k.setDate(t), k.setFullYear(k.getFullYear() + m[c]), k.setMonth(k.getMonth() + m[d]), s && k.setDate(t) } let u = Math.floor((l.getTime() - k.getTime()) / 1e3); let v = null; const w = function (a, c) { m[a] = b[a] ? Math.floor(u / c) : 0, u -= m[a] * c }; if (w(e, 604800), w(f, 86400), w(g, 3600), w(h, 60), w(i, 1), u > 0 && !a._since) { const x = [1, 12, 4.3482, 7, 24, 60, 60]; let y = i; let z = 1; for (v = i; v >= c; v--)b[v] && (m[y] >= z && (m[y] = 0, u = 1), u > 0 && (m[v]++, u = 0, y = v, z = 1)), z *= x[v] } if (j) for (v = c; v <= i; v++)j && m[v] ? j-- : j || (m[v] = 0); return m } })
}(jQuery));

/* https://github.com/mhuggins/jquery-countTo
   CountTo */
(function (e) { function t(e, t) { return e.toFixed(t.decimals) }e.fn.countTo = function (t) { t = t || {}; return e(this).each(function () { function l() { a += i; u++; c(a); if (typeof n.onUpdate === 'function') { n.onUpdate.call(s, a) } if (u >= r) { o.removeData('countTo'); clearInterval(f.interval); a = n.to; if (typeof n.onComplete === 'function') { n.onComplete.call(s, a) } } } function c(e) { const t = n.formatter.call(s, e, n); o.text(t) } var n = e.extend({}, e.fn.countTo.defaults, { from: e(this).data('from'), to: e(this).data('to'), speed: e(this).data('speed'), refreshInterval: e(this).data('refresh-interval'), decimals: e(this).data('decimals') }, t); var r = Math.ceil(n.speed / n.refreshInterval); var i = (n.to - n.from) / r; var s = this; var o = e(this); var u = 0; var a = n.from; var f = o.data('countTo') || {}; o.data('countTo', f); if (f.interval) { clearInterval(f.interval) }f.interval = setInterval(l, n.refreshInterval); c(a) }) }; e.fn.countTo.defaults = { from: 0, to: 0, speed: 1e3, refreshInterval: 100, decimals: 0, formatter: t, onUpdate: null, onComplete: null } })(jQuery)

/**
 * Owl Carousel v2.3.4
 * Copyright 2013-2018 David Deutsch
 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
 */
!(function (a, b, c, d) { function e(b, c) { this.settings = null, this.options = a.extend({}, e.Defaults, c), this.$element = a(b), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = { time: null, target: null, pointer: null, stage: { start: null, current: null }, direction: null }, this._states = { current: {}, tags: { initializing: ['busy'], animating: ['busy'], dragging: ['interacting'] } }, a.each(['onResize', 'onThrottledResize'], a.proxy(function (b, c) { this._handlers[c] = a.proxy(this[c], this) }, this)), a.each(e.Plugins, a.proxy(function (a, b) { this._plugins[a.charAt(0).toLowerCase() + a.slice(1)] = new b(this) }, this)), a.each(e.Workers, a.proxy(function (b, c) { this._pipe.push({ filter: c.filter, run: a.proxy(c.run, this) }) }, this)), this.setup(), this.initialize() }e.Defaults = { items: 3, loop: !1, center: !1, rewind: !1, checkVisibility: !0, mouseDrag: !0, touchDrag: !0, pullDrag: !0, freeDrag: !1, margin: 0, stagePadding: 0, merge: !1, mergeFit: !0, autoWidth: !1, startPosition: 0, rtl: !1, smartSpeed: 250, fluidSpeed: !1, dragEndSpeed: !1, responsive: {}, responsiveRefreshRate: 200, responsiveBaseElement: b, fallbackEasing: 'swing', slideTransition: '', info: !1, nestedItemSelector: !1, itemElement: 'div', stageElement: 'div', refreshClass: 'owl-refresh', loadedClass: 'owl-loaded', loadingClass: 'owl-loading', rtlClass: 'owl-rtl', responsiveClass: 'owl-responsive', dragClass: 'owl-drag', itemClass: 'owl-item', stageClass: 'owl-stage', stageOuterClass: 'owl-stage-outer', grabClass: 'owl-grab' }, e.Width = { Default: 'default', Inner: 'inner', Outer: 'outer' }, e.Type = { Event: 'event', State: 'state' }, e.Plugins = {}, e.Workers = [{ filter: ['width', 'settings'], run() { this._width = this.$element.width() } }, { filter: ['width', 'items', 'settings'], run(a) { a.current = this._items && this._items[this.relative(this._current)] } }, { filter: ['items', 'settings'], run() { this.$stage.children('.cloned').remove() } }, { filter: ['width', 'items', 'settings'], run(a) { const b = this.settings.margin || ''; const c = !this.settings.autoWidth; const d = this.settings.rtl; const e = { width: 'auto', 'margin-left': d ? b : '', 'margin-right': d ? '' : b }; !c && this.$stage.children().css(e), a.css = e } }, { filter: ['width', 'items', 'settings'], run(a) { const b = (this.width() / this.settings.items).toFixed(3) - this.settings.margin; let c = null; let d = this._items.length; const e = !this.settings.autoWidth; const f = []; for (a.items = { merge: !1, width: b }; d--;)c = this._mergers[d], c = this.settings.mergeFit && Math.min(c, this.settings.items) || c, a.items.merge = c > 1 || a.items.merge, f[d] = e ? b * c : this._items[d].width(); this._widths = f } }, { filter: ['items', 'settings'], run() { const b = []; const c = this._items; const d = this.settings; const e = Math.max(2 * d.items, 4); const f = 2 * Math.ceil(c.length / 2); let g = d.loop && c.length ? d.rewind ? e : Math.max(e, f) : 0; let h = ''; let i = ''; for (g /= 2; g > 0;)b.push(this.normalize(b.length / 2, !0)), h += c[b[b.length - 1]][0].outerHTML, b.push(this.normalize(c.length - 1 - (b.length - 1) / 2, !0)), i = c[b[b.length - 1]][0].outerHTML + i, g -= 1; this._clones = b, a(h).addClass('cloned').appendTo(this.$stage), a(i).addClass('cloned').prependTo(this.$stage) } }, { filter: ['width', 'items', 'settings'], run() { for (var a = this.settings.rtl ? 1 : -1, b = this._clones.length + this._items.length, c = -1, d = 0, e = 0, f = []; ++c < b;)d = f[c - 1] || 0, e = this._widths[this.relative(c)] + this.settings.margin, f.push(d + e * a); this._coordinates = f } }, { filter: ['width', 'items', 'settings'], run() { const a = this.settings.stagePadding; const b = this._coordinates; const c = { width: Math.ceil(Math.abs(b[b.length - 1])) + 2 * a, 'padding-left': a || '', 'padding-right': a || '' }; this.$stage.css(c) } }, { filter: ['width', 'items', 'settings'], run(a) { let b = this._coordinates.length; const c = !this.settings.autoWidth; const d = this.$stage.children(); if (c && a.items.merge) for (;b--;)a.css.width = this._widths[this.relative(b)], d.eq(b).css(a.css); else c && (a.css.width = a.items.width, d.css(a.css)) } }, { filter: ['items'], run() { this._coordinates.length < 1 && this.$stage.removeAttr('style') } }, { filter: ['width', 'items', 'settings'], run(a) { a.current = a.current ? this.$stage.children().index(a.current) : 0, a.current = Math.max(this.minimum(), Math.min(this.maximum(), a.current)), this.reset(a.current) } }, { filter: ['position'], run() { this.animate(this.coordinates(this._current)) } }, { filter: ['width', 'position', 'items', 'settings'], run() { let a; let b; let c; let d; const e = this.settings.rtl ? 1 : -1; const f = 2 * this.settings.stagePadding; const g = this.coordinates(this.current()) + f; const h = g + this.width() * e; const i = []; for (c = 0, d = this._coordinates.length; c < d; c++)a = this._coordinates[c - 1] || 0, b = Math.abs(this._coordinates[c]) + f * e, (this.op(a, '<=', g) && this.op(a, '>', h) || this.op(b, '<', g) && this.op(b, '>', h)) && i.push(c); this.$stage.children('.active').removeClass('active'), this.$stage.children(`:eq(${i.join('), :eq(')})`).addClass('active'), this.$stage.children('.center').removeClass('center'), this.settings.center && this.$stage.children().eq(this.current()).addClass('center') } }], e.prototype.initializeStage = function () { this.$stage = this.$element.find(`.${this.settings.stageClass}`), this.$stage.length || (this.$element.addClass(this.options.loadingClass), this.$stage = a(`<${this.settings.stageElement}>`, { class: this.settings.stageClass }).wrap(a('<div/>', { class: this.settings.stageOuterClass })), this.$element.append(this.$stage.parent())) }, e.prototype.initializeItems = function () { const b = this.$element.find('.owl-item'); if (b.length) return this._items = b.get().map((b) => a(b)), this._mergers = this._items.map(() => 1), void this.refresh(); this.replace(this.$element.children().not(this.$stage.parent())), this.isVisible() ? this.refresh() : this.invalidate('width'), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass) }, e.prototype.initialize = function () { if (this.enter('initializing'), this.trigger('initialize'), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is('pre-loading')) { let a, b, c; a = this.$element.find('img'), b = this.settings.nestedItemSelector ? `.${this.settings.nestedItemSelector}` : d, c = this.$element.children(b).width(), a.length && c <= 0 && this.preloadAutoWidthImages(a) } this.initializeStage(), this.initializeItems(), this.registerEventHandlers(), this.leave('initializing'), this.trigger('initialized') }, e.prototype.isVisible = function () { return !this.settings.checkVisibility || this.$element.is(':visible') }, e.prototype.setup = function () { const b = this.viewport(); const c = this.options.responsive; let d = -1; let e = null; c ? (a.each(c, (a) => { a <= b && a > d && (d = Number(a)) }), e = a.extend({}, this.options, c[d]), typeof e.stagePadding === 'function' && (e.stagePadding = e.stagePadding()), delete e.responsive, e.responsiveClass && this.$element.attr('class', this.$element.attr('class').replace(new RegExp(`(${this.options.responsiveClass}-)\\S+\\s`, 'g'), `$1${d}`))) : e = a.extend({}, this.options), this.trigger('change', { property: { name: 'settings', value: e } }), this._breakpoint = d, this.settings = e, this.invalidate('settings'), this.trigger('changed', { property: { name: 'settings', value: this.settings } }) }, e.prototype.optionsLogic = function () { this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1) }, e.prototype.prepare = function (b) { const c = this.trigger('prepare', { content: b }); return c.data || (c.data = a(`<${this.settings.itemElement}/>`).addClass(this.options.itemClass).append(b)), this.trigger('prepared', { content: c.data }), c.data }, e.prototype.update = function () { for (let b = 0, c = this._pipe.length, d = a.proxy(function (a) { return this[a] }, this._invalidated), e = {}; b < c;)(this._invalidated.all || a.grep(this._pipe[b].filter, d).length > 0) && this._pipe[b].run(e), b++; this._invalidated = {}, !this.is('valid') && this.enter('valid') }, e.prototype.width = function (a) { switch (a = a || e.Width.Default) { case e.Width.Inner:case e.Width.Outer:return this._width; default:return this._width - 2 * this.settings.stagePadding + this.settings.margin } }, e.prototype.refresh = function () { this.enter('refreshing'), this.trigger('refresh'), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave('refreshing'), this.trigger('refreshed') }, e.prototype.onThrottledResize = function () { b.clearTimeout(this.resizeTimer), this.resizeTimer = b.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate) }, e.prototype.onResize = function () { return !!this._items.length && (this._width !== this.$element.width() && (!!this.isVisible() && (this.enter('resizing'), this.trigger('resize').isDefaultPrevented() ? (this.leave('resizing'), !1) : (this.invalidate('width'), this.refresh(), this.leave('resizing'), void this.trigger('resized'))))) }, e.prototype.registerEventHandlers = function () { a.support.transition && this.$stage.on(`${a.support.transition.end}.owl.core`, a.proxy(this.onTransitionEnd, this)), !1 !== this.settings.responsive && this.on(b, 'resize', this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on('mousedown.owl.core', a.proxy(this.onDragStart, this)), this.$stage.on('dragstart.owl.core selectstart.owl.core', () => !1)), this.settings.touchDrag && (this.$stage.on('touchstart.owl.core', a.proxy(this.onDragStart, this)), this.$stage.on('touchcancel.owl.core', a.proxy(this.onDragEnd, this))) }, e.prototype.onDragStart = function (b) { let d = null; b.which !== 3 && (a.support.transform ? (d = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(','), d = { x: d[d.length === 16 ? 12 : 4], y: d[d.length === 16 ? 13 : 5] }) : (d = this.$stage.position(), d = { x: this.settings.rtl ? d.left + this.$stage.width() - this.width() + this.settings.margin : d.left, y: d.top }), this.is('animating') && (a.support.transform ? this.animate(d.x) : this.$stage.stop(), this.invalidate('position')), this.$element.toggleClass(this.options.grabClass, b.type === 'mousedown'), this.speed(0), this._drag.time = (new Date()).getTime(), this._drag.target = a(b.target), this._drag.stage.start = d, this._drag.stage.current = d, this._drag.pointer = this.pointer(b), a(c).on('mouseup.owl.core touchend.owl.core', a.proxy(this.onDragEnd, this)), a(c).one('mousemove.owl.core touchmove.owl.core', a.proxy(function (b) { const d = this.difference(this._drag.pointer, this.pointer(b)); a(c).on('mousemove.owl.core touchmove.owl.core', a.proxy(this.onDragMove, this)), Math.abs(d.x) < Math.abs(d.y) && this.is('valid') || (b.preventDefault(), this.enter('dragging'), this.trigger('drag')) }, this))) }, e.prototype.onDragMove = function (a) { let b = null; let c = null; let d = null; const e = this.difference(this._drag.pointer, this.pointer(a)); const f = this.difference(this._drag.stage.start, e); this.is('dragging') && (a.preventDefault(), this.settings.loop ? (b = this.coordinates(this.minimum()), c = this.coordinates(this.maximum() + 1) - b, f.x = ((f.x - b) % c + c) % c + b) : (b = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), c = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), d = this.settings.pullDrag ? -1 * e.x / 5 : 0, f.x = Math.max(Math.min(f.x, b + d), c + d)), this._drag.stage.current = f, this.animate(f.x)) }, e.prototype.onDragEnd = function (b) { const d = this.difference(this._drag.pointer, this.pointer(b)); const e = this._drag.stage.current; const f = d.x > 0 ^ this.settings.rtl ? 'left' : 'right'; a(c).off('.owl.core'), this.$element.removeClass(this.options.grabClass), (d.x !== 0 && this.is('dragging') || !this.is('valid')) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(e.x, d.x !== 0 ? f : this._drag.direction)), this.invalidate('position'), this.update(), this._drag.direction = f, (Math.abs(d.x) > 3 || (new Date()).getTime() - this._drag.time > 300) && this._drag.target.one('click.owl.core', () => !1)), this.is('dragging') && (this.leave('dragging'), this.trigger('dragged')) }, e.prototype.closest = function (b, c) { let e = -1; const f = 30; const g = this.width(); const h = this.coordinates(); return this.settings.freeDrag || a.each(h, a.proxy(function (a, i) { return c === 'left' && b > i - f && b < i + f ? e = a : c === 'right' && b > i - g - f && b < i - g + f ? e = a + 1 : this.op(b, '<', i) && this.op(b, '>', h[a + 1] !== d ? h[a + 1] : i - g) && (e = c === 'left' ? a + 1 : a), e === -1 }, this)), this.settings.loop || (this.op(b, '>', h[this.minimum()]) ? e = b = this.minimum() : this.op(b, '<', h[this.maximum()]) && (e = b = this.maximum())), e }, e.prototype.animate = function (b) { const c = this.speed() > 0; this.is('animating') && this.onTransitionEnd(), c && (this.enter('animating'), this.trigger('translate')), a.support.transform3d && a.support.transition ? this.$stage.css({ transform: `translate3d(${b}px,0px,0px)`, transition: `${this.speed() / 1e3}s${this.settings.slideTransition ? ` ${this.settings.slideTransition}` : ''}` }) : c ? this.$stage.animate({ left: `${b}px` }, this.speed(), this.settings.fallbackEasing, a.proxy(this.onTransitionEnd, this)) : this.$stage.css({ left: `${b}px` }) }, e.prototype.is = function (a) { return this._states.current[a] && this._states.current[a] > 0 }, e.prototype.current = function (a) { if (a === d) return this._current; if (this._items.length === 0) return d; if (a = this.normalize(a), this._current !== a) { const b = this.trigger('change', { property: { name: 'position', value: a } }); b.data !== d && (a = this.normalize(b.data)), this._current = a, this.invalidate('position'), this.trigger('changed', { property: { name: 'position', value: this._current } }) } return this._current }, e.prototype.invalidate = function (b) { return a.type(b) === 'string' && (this._invalidated[b] = !0, this.is('valid') && this.leave('valid')), a.map(this._invalidated, (a, b) => b) }, e.prototype.reset = function (a) { (a = this.normalize(a)) !== d && (this._speed = 0, this._current = a, this.suppress(['translate', 'translated']), this.animate(this.coordinates(a)), this.release(['translate', 'translated'])) }, e.prototype.normalize = function (a, b) { const c = this._items.length; const e = b ? 0 : this._clones.length; return !this.isNumeric(a) || c < 1 ? a = d : (a < 0 || a >= c + e) && (a = ((a - e / 2) % c + c) % c + e / 2), a }, e.prototype.relative = function (a) { return a -= this._clones.length / 2, this.normalize(a, !0) }, e.prototype.maximum = function (a) { let b; let c; let d; const e = this.settings; let f = this._coordinates.length; if (e.loop)f = this._clones.length / 2 + this._items.length - 1; else if (e.autoWidth || e.merge) { if (b = this._items.length) for (c = this._items[--b].width(), d = this.$element.width(); b-- && !((c += this._items[b].width() + this.settings.margin) > d););f = b + 1 } else f = e.center ? this._items.length - 1 : this._items.length - e.items; return a && (f -= this._clones.length / 2), Math.max(f, 0) }, e.prototype.minimum = function (a) { return a ? 0 : this._clones.length / 2 }, e.prototype.items = function (a) { return a === d ? this._items.slice() : (a = this.normalize(a, !0), this._items[a]) }, e.prototype.mergers = function (a) { return a === d ? this._mergers.slice() : (a = this.normalize(a, !0), this._mergers[a]) }, e.prototype.clones = function (b) { const c = this._clones.length / 2; const e = c + this._items.length; const f = function (a) { return a % 2 == 0 ? e + a / 2 : c - (a + 1) / 2 }; return b === d ? a.map(this._clones, (a, b) => f(b)) : a.map(this._clones, (a, c) => a === b ? f(c) : null) }, e.prototype.speed = function (a) { return a !== d && (this._speed = a), this._speed }, e.prototype.coordinates = function (b) { let c; let e = 1; let f = b - 1; return b === d ? a.map(this._coordinates, a.proxy(function (a, b) { return this.coordinates(b) }, this)) : (this.settings.center ? (this.settings.rtl && (e = -1, f = b + 1), c = this._coordinates[b], c += (this.width() - c + (this._coordinates[f] || 0)) / 2 * e) : c = this._coordinates[f] || 0, c = Math.ceil(c)) }, e.prototype.duration = function (a, b, c) { return c === 0 ? 0 : Math.min(Math.max(Math.abs(b - a), 1), 6) * Math.abs(c || this.settings.smartSpeed) }, e.prototype.to = function (a, b) { let c = this.current(); let d = null; let e = a - this.relative(c); const f = (e > 0) - (e < 0); const g = this._items.length; const h = this.minimum(); let i = this.maximum(); this.settings.loop ? (!this.settings.rewind && Math.abs(e) > g / 2 && (e += -1 * f * g), a = c + e, (d = ((a - h) % g + g) % g + h) !== a && d - e <= i && d - e > 0 && (c = d - e, a = d, this.reset(c))) : this.settings.rewind ? (i += 1, a = (a % i + i) % i) : a = Math.max(h, Math.min(i, a)), this.speed(this.duration(c, a, b)), this.current(a), this.isVisible() && this.update() }, e.prototype.next = function (a) { a = a || !1, this.to(this.relative(this.current()) + 1, a) }, e.prototype.prev = function (a) { a = a || !1, this.to(this.relative(this.current()) - 1, a) }, e.prototype.onTransitionEnd = function (a) { if (a !== d && (a.stopPropagation(), (a.target || a.srcElement || a.originalTarget) !== this.$stage.get(0))) return !1; this.leave('animating'), this.trigger('translated') }, e.prototype.viewport = function () { let d; return this.options.responsiveBaseElement !== b ? d = a(this.options.responsiveBaseElement).width() : b.innerWidth ? d = b.innerWidth : c.documentElement && c.documentElement.clientWidth ? d = c.documentElement.clientWidth : console.warn('Can not detect viewport width.'), d }, e.prototype.replace = function (b) { this.$stage.empty(), this._items = [], b && (b = b instanceof jQuery ? b : a(b)), this.settings.nestedItemSelector && (b = b.find(`.${this.settings.nestedItemSelector}`)), b.filter(function () { return this.nodeType === 1 }).each(a.proxy(function (a, b) { b = this.prepare(b), this.$stage.append(b), this._items.push(b), this._mergers.push(1 * b.find('[data-merge]').addBack('[data-merge]').attr('data-merge') || 1) }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate('items') }, e.prototype.add = function (b, c) { const e = this.relative(this._current); c = c === d ? this._items.length : this.normalize(c, !0), b = b instanceof jQuery ? b : a(b), this.trigger('add', { content: b, position: c }), b = this.prepare(b), this._items.length === 0 || c === this._items.length ? (this._items.length === 0 && this.$stage.append(b), this._items.length !== 0 && this._items[c - 1].after(b), this._items.push(b), this._mergers.push(1 * b.find('[data-merge]').addBack('[data-merge]').attr('data-merge') || 1)) : (this._items[c].before(b), this._items.splice(c, 0, b), this._mergers.splice(c, 0, 1 * b.find('[data-merge]').addBack('[data-merge]').attr('data-merge') || 1)), this._items[e] && this.reset(this._items[e].index()), this.invalidate('items'), this.trigger('added', { content: b, position: c }) }, e.prototype.remove = function (a) { (a = this.normalize(a, !0)) !== d && (this.trigger('remove', { content: this._items[a], position: a }), this._items[a].remove(), this._items.splice(a, 1), this._mergers.splice(a, 1), this.invalidate('items'), this.trigger('removed', { content: null, position: a })) }, e.prototype.preloadAutoWidthImages = function (b) { b.each(a.proxy(function (b, c) { this.enter('pre-loading'), c = a(c), a(new Image()).one('load', a.proxy(function (a) { c.attr('src', a.target.src), c.css('opacity', 1), this.leave('pre-loading'), !this.is('pre-loading') && !this.is('initializing') && this.refresh() }, this)).attr('src', c.attr('src') || c.attr('data-src') || c.attr('data-src-retina')) }, this)) }, e.prototype.destroy = function () { this.$element.off('.owl.core'), this.$stage.off('.owl.core'), a(c).off('.owl.core'), !1 !== this.settings.responsive && (b.clearTimeout(this.resizeTimer), this.off(b, 'resize', this._handlers.onThrottledResize)); for (const d in this._plugins) this._plugins[d].destroy(); this.$stage.children('.cloned').remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$stage.remove(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(`${this.options.responsiveClass}-\\S+\\s`, 'g'), '')).removeData('owl.carousel') }, e.prototype.op = function (a, b, c) { const d = this.settings.rtl; switch (b) { case '<':return d ? a > c : a < c; case '>':return d ? a < c : a > c; case '>=':return d ? a <= c : a >= c; case '<=':return d ? a >= c : a <= c } }, e.prototype.on = function (a, b, c, d) { a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent(`on${b}`, c) }, e.prototype.off = function (a, b, c, d) { a.removeEventListener ? a.removeEventListener(b, c, d) : a.detachEvent && a.detachEvent(`on${b}`, c) }, e.prototype.trigger = function (b, c, d, f, g) { const h = { item: { count: this._items.length, index: this.current() } }; const i = a.camelCase(a.grep(['on', b, d], (a) => a).join('-').toLowerCase()); const j = a.Event([b, 'owl', d || 'carousel'].join('.').toLowerCase(), a.extend({ relatedTarget: this }, h, c)); return this._supress[b] || (a.each(this._plugins, (a, b) => { b.onTrigger && b.onTrigger(j) }), this.register({ type: e.Type.Event, name: b }), this.$element.trigger(j), this.settings && typeof this.settings[i] === 'function' && this.settings[i].call(this, j)), j }, e.prototype.enter = function (b) { a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) { this._states.current[b] === d && (this._states.current[b] = 0), this._states.current[b]++ }, this)) }, e.prototype.leave = function (b) { a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) { this._states.current[b]-- }, this)) }, e.prototype.register = function (b) { if (b.type === e.Type.Event) { if (a.event.special[b.name] || (a.event.special[b.name] = {}), !a.event.special[b.name].owl) { const c = a.event.special[b.name]._default; a.event.special[b.name]._default = function (a) { return !c || !c.apply || a.namespace && a.namespace.indexOf('owl') !== -1 ? a.namespace && a.namespace.indexOf('owl') > -1 : c.apply(this, arguments) }, a.event.special[b.name].owl = !0 } } else b.type === e.Type.State && (this._states.tags[b.name] ? this._states.tags[b.name] = this._states.tags[b.name].concat(b.tags) : this._states.tags[b.name] = b.tags, this._states.tags[b.name] = a.grep(this._states.tags[b.name], a.proxy(function (c, d) { return a.inArray(c, this._states.tags[b.name]) === d }, this))) }, e.prototype.suppress = function (b) { a.each(b, a.proxy(function (a, b) { this._supress[b] = !0 }, this)) }, e.prototype.release = function (b) { a.each(b, a.proxy(function (a, b) { delete this._supress[b] }, this)) }, e.prototype.pointer = function (a) { const c = { x: null, y: null }; return a = a.originalEvent || a || b.event, a = a.touches && a.touches.length ? a.touches[0] : a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : a, a.pageX ? (c.x = a.pageX, c.y = a.pageY) : (c.x = a.clientX, c.y = a.clientY), c }, e.prototype.isNumeric = function (a) { return !isNaN(parseFloat(a)) }, e.prototype.difference = function (a, b) { return { x: a.x - b.x, y: a.y - b.y } }, a.fn.owlCarousel = function (b) { const c = Array.prototype.slice.call(arguments, 1); return this.each(function () { const d = a(this); let f = d.data('owl.carousel'); f || (f = new e(this, typeof b === 'object' && b), d.data('owl.carousel', f), a.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], (b, c) => { f.register({ type: e.Type.Event, name: c }), f.$element.on(`${c}.owl.carousel.core`, a.proxy(function (a) { a.namespace && a.relatedTarget !== this && (this.suppress([c]), f[c].apply(this, [].slice.call(arguments, 1)), this.release([c])) }, f)) })), typeof b === 'string' && b.charAt(0) !== '_' && f[b].apply(f, c) }) }, a.fn.owlCarousel.Constructor = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (b) { this._core = b, this._interval = null, this._visible = null, this._handlers = { 'initialized.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.autoRefresh && this.watch() }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers) }; e.Defaults = { autoRefresh: !0, autoRefreshInterval: 500 }, e.prototype.watch = function () { this._interval || (this._visible = this._core.isVisible(), this._interval = b.setInterval(a.proxy(this.refresh, this), this._core.settings.autoRefreshInterval)) }, e.prototype.refresh = function () { this._core.isVisible() !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass('owl-hidden', !this._visible), this._visible && this._core.invalidate('width') && this._core.refresh()) }, e.prototype.destroy = function () { let a, c; b.clearInterval(this._interval); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (c in Object.getOwnPropertyNames(this)) typeof this[c] !== 'function' && (this[c] = null) }, a.fn.owlCarousel.Constructor.Plugins.AutoRefresh = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (b) { this._core = b, this._loaded = [], this._handlers = { 'initialized.owl.carousel change.owl.carousel resized.owl.carousel': a.proxy(function (b) { if (b.namespace && this._core.settings && this._core.settings.lazyLoad && (b.property && b.property.name == 'position' || b.type == 'initialized')) { const c = this._core.settings; let e = c.center && Math.ceil(c.items / 2) || c.items; let f = c.center && -1 * e || 0; let g = (b.property && b.property.value !== d ? b.property.value : this._core.current()) + f; const h = this._core.clones().length; const i = a.proxy(function (a, b) { this.load(b) }, this); for (c.lazyLoadEager > 0 && (e += c.lazyLoadEager, c.loop && (g -= c.lazyLoadEager, e++)); f++ < e;) this.load(h / 2 + this._core.relative(g)), h && a.each(this._core.clones(this._core.relative(g)), i), g++ } }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers) }; e.Defaults = { lazyLoad: !1, lazyLoadEager: 0 }, e.prototype.load = function (c) { const d = this._core.$stage.children().eq(c); const e = d && d.find('.owl-lazy'); !e || a.inArray(d.get(0), this._loaded) > -1 || (e.each(a.proxy(function (c, d) { let e; const f = a(d); const g = b.devicePixelRatio > 1 && f.attr('data-src-retina') || f.attr('data-src') || f.attr('data-srcset'); this._core.trigger('load', { element: f, url: g }, 'lazy'), f.is('img') ? f.one('load.owl.lazy', a.proxy(function () { f.css('opacity', 1), this._core.trigger('loaded', { element: f, url: g }, 'lazy') }, this)).attr('src', g) : f.is('source') ? f.one('load.owl.lazy', a.proxy(function () { this._core.trigger('loaded', { element: f, url: g }, 'lazy') }, this)).attr('srcset', g) : (e = new Image(), e.onload = a.proxy(function () { f.css({ 'background-image': `url("${g}")`, opacity: '1' }), this._core.trigger('loaded', { element: f, url: g }, 'lazy') }, this), e.src = g) }, this)), this._loaded.push(d.get(0))) }, e.prototype.destroy = function () { let a, b; for (a in this.handlers) this._core.$element.off(a, this.handlers[a]); for (b in Object.getOwnPropertyNames(this)) typeof this[b] !== 'function' && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Lazy = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (c) { this._core = c, this._previousHeight = null, this._handlers = { 'initialized.owl.carousel refreshed.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && this.update() }, this), 'changed.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && a.property.name === 'position' && this.update() }, this), 'loaded.owl.lazy': a.proxy(function (a) { a.namespace && this._core.settings.autoHeight && a.element.closest(`.${this._core.settings.itemClass}`).index() === this._core.current() && this.update() }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._intervalId = null; const d = this; a(b).on('load', () => { d._core.settings.autoHeight && d.update() }), a(b).resize(() => { d._core.settings.autoHeight && (d._intervalId != null && clearTimeout(d._intervalId), d._intervalId = setTimeout(() => { d.update() }, 250)) }) }; e.Defaults = { autoHeight: !1, autoHeightClass: 'owl-height' }, e.prototype.update = function () { const b = this._core._current; const c = b + this._core.settings.items; const d = this._core.settings.lazyLoad; const e = this._core.$stage.children().toArray().slice(b, c); const f = []; let g = 0; a.each(e, (b, c) => { f.push(a(c).height()) }), g = Math.max.apply(null, f), g <= 1 && d && this._previousHeight && (g = this._previousHeight), this._previousHeight = g, this._core.$stage.parent().height(g).addClass(this._core.settings.autoHeightClass) }, e.prototype.destroy = function () { let a, b; for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) typeof this[b] !== 'function' && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.AutoHeight = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (b) { this._core = b, this._videos = {}, this._playing = null, this._handlers = { 'initialized.owl.carousel': a.proxy(function (a) { a.namespace && this._core.register({ type: 'state', name: 'playing', tags: ['interacting'] }) }, this), 'resize.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.video && this.isInFullScreen() && a.preventDefault() }, this), 'refreshed.owl.carousel': a.proxy(function (a) { a.namespace && this._core.is('resizing') && this._core.$stage.find('.cloned .owl-video-frame').remove() }, this), 'changed.owl.carousel': a.proxy(function (a) { a.namespace && a.property.name === 'position' && this._playing && this.stop() }, this), 'prepared.owl.carousel': a.proxy(function (b) { if (b.namespace) { const c = a(b.content).find('.owl-video'); c.length && (c.css('display', 'none'), this.fetch(c, a(b.content))) } }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on('click.owl.video', '.owl-video-play-icon', a.proxy(function (a) { this.play(a) }, this)) }; e.Defaults = { video: !1, videoHeight: !1, videoWidth: !1 }, e.prototype.fetch = function (a, b) { let c = (function () { return a.attr('data-vimeo-id') ? 'vimeo' : a.attr('data-vzaar-id') ? 'vzaar' : 'youtube' }()); let d = a.attr('data-vimeo-id') || a.attr('data-youtube-id') || a.attr('data-vzaar-id'); const e = a.attr('data-width') || this._core.settings.videoWidth; const f = a.attr('data-height') || this._core.settings.videoHeight; const g = a.attr('href'); if (!g) throw new Error('Missing video URL.'); if (d = g.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/), d[3].indexOf('youtu') > -1)c = 'youtube'; else if (d[3].indexOf('vimeo') > -1)c = 'vimeo'; else { if (!(d[3].indexOf('vzaar') > -1)) throw new Error('Video URL not supported.'); c = 'vzaar' }d = d[6], this._videos[g] = { type: c, id: d, width: e, height: f }, b.attr('data-video', g), this.thumbnail(a, this._videos[g]) }, e.prototype.thumbnail = function (b, c) { let d; let e; let f; const g = c.width && c.height ? `width:${c.width}px;height:${c.height}px;` : ''; const h = b.find('img'); let i = 'src'; let j = ''; const k = this._core.settings; const l = function (c) { e = '<div class="owl-video-play-icon"></div>', d = k.lazyLoad ? a('<div/>', { class: `owl-video-tn ${j}`, srcType: c }) : a('<div/>', { class: 'owl-video-tn', style: `opacity:1;background-image:url(${c})` }), b.after(d), b.after(e) }; if (b.wrap(a('<div/>', { class: 'owl-video-wrapper', style: g })), this._core.settings.lazyLoad && (i = 'data-src', j = 'owl-lazy'), h.length) return l(h.attr(i)), h.remove(), !1; c.type === 'youtube' ? (f = `//img.youtube.com/vi/${c.id}/hqdefault.jpg`, l(f)) : c.type === 'vimeo' ? a.ajax({ type: 'GET', url: `//vimeo.com/api/v2/video/${c.id}.json`, jsonp: 'callback', dataType: 'jsonp', success(a) { f = a[0].thumbnail_large, l(f) } }) : c.type === 'vzaar' && a.ajax({ type: 'GET', url: `//vzaar.com/api/videos/${c.id}.json`, jsonp: 'callback', dataType: 'jsonp', success(a) { f = a.framegrab_url, l(f) } }) }, e.prototype.stop = function () { this._core.trigger('stop', null, 'video'), this._playing.find('.owl-video-frame').remove(), this._playing.removeClass('owl-video-playing'), this._playing = null, this._core.leave('playing'), this._core.trigger('stopped', null, 'video') }, e.prototype.play = function (b) { let c; const d = a(b.target); let e = d.closest(`.${this._core.settings.itemClass}`); const f = this._videos[e.attr('data-video')]; const g = f.width || '100%'; const h = f.height || this._core.$stage.height(); this._playing || (this._core.enter('playing'), this._core.trigger('play', null, 'video'), e = this._core.items(this._core.relative(e.index())), this._core.reset(e.index()), c = a('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>'), c.attr('height', h), c.attr('width', g), f.type === 'youtube' ? c.attr('src', `//www.youtube.com/embed/${f.id}?autoplay=1&rel=0&v=${f.id}`) : f.type === 'vimeo' ? c.attr('src', `//player.vimeo.com/video/${f.id}?autoplay=1`) : f.type === 'vzaar' && c.attr('src', `//view.vzaar.com/${f.id}/player?autoplay=true`), a(c).wrap('<div class="owl-video-frame" />').insertAfter(e.find('.owl-video')), this._playing = e.addClass('owl-video-playing')) }, e.prototype.isInFullScreen = function () { const b = c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement; return b && a(b).parent().hasClass('owl-video-frame') }, e.prototype.destroy = function () { let a, b; this._core.$element.off('click.owl.video'); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) typeof this[b] !== 'function' && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Video = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (b) { this.core = b, this.core.options = a.extend({}, e.Defaults, this.core.options), this.swapping = !0, this.previous = d, this.next = d, this.handlers = { 'change.owl.carousel': a.proxy(function (a) { a.namespace && a.property.name == 'position' && (this.previous = this.core.current(), this.next = a.property.value) }, this), 'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': a.proxy(function (a) { a.namespace && (this.swapping = a.type == 'translated') }, this), 'translate.owl.carousel': a.proxy(function (a) { a.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap() }, this) }, this.core.$element.on(this.handlers) }; e.Defaults = { animateOut: !1, animateIn: !1 }, e.prototype.swap = function () { if (this.core.settings.items === 1 && a.support.animation && a.support.transition) { this.core.speed(0); let b; const c = a.proxy(this.clear, this); const d = this.core.$stage.children().eq(this.previous); const e = this.core.$stage.children().eq(this.next); const f = this.core.settings.animateIn; const g = this.core.settings.animateOut; this.core.current() !== this.previous && (g && (b = this.core.coordinates(this.previous) - this.core.coordinates(this.next), d.one(a.support.animation.end, c).css({ left: `${b}px` }).addClass('animated owl-animated-out').addClass(g)), f && e.one(a.support.animation.end, c).addClass('animated owl-animated-in').addClass(f)) } }, e.prototype.clear = function (b) { a(b.target).css({ left: '' }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd() }, e.prototype.destroy = function () { let a, b; for (a in this.handlers) this.core.$element.off(a, this.handlers[a]); for (b in Object.getOwnPropertyNames(this)) typeof this[b] !== 'function' && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.Animate = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { var e = function (b) { this._core = b, this._call = null, this._time = 0, this._timeout = 0, this._paused = !0, this._handlers = { 'changed.owl.carousel': a.proxy(function (a) { a.namespace && a.property.name === 'settings' ? this._core.settings.autoplay ? this.play() : this.stop() : a.namespace && a.property.name === 'position' && this._paused && (this._time = 0) }, this), 'initialized.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.autoplay && this.play() }, this), 'play.owl.autoplay': a.proxy(function (a, b, c) { a.namespace && this.play(b, c) }, this), 'stop.owl.autoplay': a.proxy(function (a) { a.namespace && this.stop() }, this), 'mouseover.owl.autoplay': a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is('rotating') && this.pause() }, this), 'mouseleave.owl.autoplay': a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is('rotating') && this.play() }, this), 'touchstart.owl.core': a.proxy(function () { this._core.settings.autoplayHoverPause && this._core.is('rotating') && this.pause() }, this), 'touchend.owl.core': a.proxy(function () { this._core.settings.autoplayHoverPause && this.play() }, this) }, this._core.$element.on(this._handlers), this._core.options = a.extend({}, e.Defaults, this._core.options) }; e.Defaults = { autoplay: !1, autoplayTimeout: 5e3, autoplayHoverPause: !1, autoplaySpeed: !1 }, e.prototype._next = function (d) { this._call = b.setTimeout(a.proxy(this._next, this, d), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()), this._core.is('interacting') || c.hidden || this._core.next(d || this._core.settings.autoplaySpeed) }, e.prototype.read = function () { return (new Date()).getTime() - this._time }, e.prototype.play = function (c, d) { let e; this._core.is('rotating') || this._core.enter('rotating'), c = c || this._core.settings.autoplayTimeout, e = Math.min(this._time % (this._timeout || c), c), this._paused ? (this._time = this.read(), this._paused = !1) : b.clearTimeout(this._call), this._time += this.read() % c - e, this._timeout = c, this._call = b.setTimeout(a.proxy(this._next, this, d), c - e) }, e.prototype.stop = function () { this._core.is('rotating') && (this._time = 0, this._paused = !0, b.clearTimeout(this._call), this._core.leave('rotating')) }, e.prototype.pause = function () { this._core.is('rotating') && !this._paused && (this._time = this.read(), this._paused = !0, b.clearTimeout(this._call)) }, e.prototype.destroy = function () { let a, b; this.stop(); for (a in this._handlers) this._core.$element.off(a, this._handlers[a]); for (b in Object.getOwnPropertyNames(this)) typeof this[b] !== 'function' && (this[b] = null) }, a.fn.owlCarousel.Constructor.Plugins.autoplay = e }(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) {
  var e = function (b) { this._core = b, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = { next: this._core.next, prev: this._core.prev, to: this._core.to }, this._handlers = { 'prepared.owl.carousel': a.proxy(function (b) { b.namespace && this._core.settings.dotsData && this._templates.push(`<div class="${this._core.settings.dotClass}">${a(b.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot')}</div>`) }, this), 'added.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 0, this._templates.pop()) }, this), 'remove.owl.carousel': a.proxy(function (a) { a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 1) }, this), 'changed.owl.carousel': a.proxy(function (a) { a.namespace && a.property.name == 'position' && this.draw() }, this), 'initialized.owl.carousel': a.proxy(function (a) { a.namespace && !this._initialized && (this._core.trigger('initialize', null, 'navigation'), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger('initialized', null, 'navigation')) }, this), 'refreshed.owl.carousel': a.proxy(function (a) { a.namespace && this._initialized && (this._core.trigger('refresh', null, 'navigation'), this.update(), this.draw(), this._core.trigger('refreshed', null, 'navigation')) }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers) }; e.Defaults = { nav: !1, navText: ['<span aria-label="Previous">&#x2039;</span>', '<span aria-label="Next">&#x203a;</span>'], navSpeed: !1, navElement: 'button type="button" role="presentation"', navContainer: !1, navContainerClass: 'owl-nav', navClass: ['owl-prev', 'owl-next'], slideBy: 1, dotClass: 'owl-dot', dotsClass: 'owl-dots', dots: !0, dotsEach: !1, dotsData: !1, dotsSpeed: !1, dotsContainer: !1 }, e.prototype.initialize = function () { let b; const c = this._core.settings; this._controls.$relative = (c.navContainer ? a(c.navContainer) : a('<div>').addClass(c.navContainerClass).appendTo(this.$element)).addClass('disabled'), this._controls.$previous = a(`<${c.navElement}>`).addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on('click', a.proxy(function (a) { this.prev(c.navSpeed) }, this)), this._controls.$next = a(`<${c.navElement}>`).addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on('click', a.proxy(function (a) { this.next(c.navSpeed) }, this)), c.dotsData || (this._templates = [a('<button role="button">').addClass(c.dotClass).append(a('<span>')).prop('outerHTML')]), this._controls.$absolute = (c.dotsContainer ? a(c.dotsContainer) : a('<div>').addClass(c.dotsClass).appendTo(this.$element)).addClass('disabled'), this._controls.$absolute.on('click', 'button', a.proxy(function (b) { const d = a(b.target).parent().is(this._controls.$absolute) ? a(b.target).index() : a(b.target).parent().index(); b.preventDefault(), this.to(d, c.dotsSpeed) }, this)); for (b in this._overrides) this._core[b] = a.proxy(this[b], this) }, e.prototype.destroy = function () { let a, b, c, d, e; e = this._core.settings; for (a in this._handlers) this.$element.off(a, this._handlers[a]); for (b in this._controls)b === '$relative' && e.navContainer ? this._controls[b].html('') : this._controls[b].remove(); for (d in this.overides) this._core[d] = this._overrides[d]; for (c in Object.getOwnPropertyNames(this)) typeof this[c] !== 'function' && (this[c] = null) }, e.prototype.update = function () { let a; let b; let c; const d = this._core.clones().length / 2; const e = d + this._core.items().length; const f = this._core.maximum(!0); const g = this._core.settings; const h = g.center || g.autoWidth || g.dotsData ? 1 : g.dotsEach || g.items; if (g.slideBy !== 'page' && (g.slideBy = Math.min(g.slideBy, g.items)), g.dots || g.slideBy == 'page') for (this._pages = [], a = d, b = 0, c = 0; a < e; a++) { if (b >= h || b === 0) { if (this._pages.push({ start: Math.min(f, a - d), end: a - d + h - 1 }), Math.min(f, a - d) === f) break; b = 0, ++c }b += this._core.mergers(this._core.relative(a)) } }, e.prototype.draw = function () { let b; const c = this._core.settings; const d = this._core.items().length <= c.items; const e = this._core.relative(this._core.current()); const f = c.loop || c.rewind; this._controls.$relative.toggleClass('disabled', !c.nav || d), c.nav && (this._controls.$previous.toggleClass('disabled', !f && e <= this._core.minimum(!0)), this._controls.$next.toggleClass('disabled', !f && e >= this._core.maximum(!0))), this._controls.$absolute.toggleClass('disabled', !c.dots || d), c.dots && (b = this._pages.length - this._controls.$absolute.children().length, c.dotsData && b !== 0 ? this._controls.$absolute.html(this._templates.join('')) : b > 0 ? this._controls.$absolute.append(new Array(b + 1).join(this._templates[0])) : b < 0 && this._controls.$absolute.children().slice(b).remove(), this._controls.$absolute.find('.active').removeClass('active'), this._controls.$absolute.children().eq(a.inArray(this.current(), this._pages)).addClass('active')) }, e.prototype.onTrigger = function (b) { const c = this._core.settings; b.page = { index: a.inArray(this.current(), this._pages), count: this._pages.length, size: c && (c.center || c.autoWidth || c.dotsData ? 1 : c.dotsEach || c.items) } }, e.prototype.current = function () { const b = this._core.relative(this._core.current()); return a.grep(this._pages, a.proxy((a, c) => a.start <= b && a.end >= b, this)).pop() }, e.prototype.getPosition = function (b) { let c; let d; const e = this._core.settings; return e.slideBy == 'page' ? (c = a.inArray(this.current(), this._pages), d = this._pages.length, b ? ++c : --c, c = this._pages[(c % d + d) % d].start) : (c = this._core.relative(this._core.current()), d = this._core.items().length, b ? c += e.slideBy : c -= e.slideBy), c }, e.prototype.next = function (b) { a.proxy(this._overrides.to, this._core)(this.getPosition(!0), b) }, e.prototype.prev = function (b) { a.proxy(this._overrides.to, this._core)(this.getPosition(!1), b) }, e.prototype.to = function (b, c, d) { let e; !d && this._pages.length ? (e = this._pages.length, a.proxy(this._overrides.to, this._core)(this._pages[(b % e + e) % e].start, c)) : a.proxy(this._overrides.to, this._core)(b, c) }, a.fn.owlCarousel.Constructor.Plugins.Navigation = e
}(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) {
  var e = function (c) { this._core = c, this._hashes = {}, this.$element = this._core.$element, this._handlers = { 'initialized.owl.carousel': a.proxy(function (c) { c.namespace && this._core.settings.startPosition === 'URLHash' && a(b).trigger('hashchange.owl.navigation') }, this), 'prepared.owl.carousel': a.proxy(function (b) { if (b.namespace) { const c = a(b.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash'); if (!c) return; this._hashes[c] = b.content } }, this), 'changed.owl.carousel': a.proxy(function (c) { if (c.namespace && c.property.name === 'position') { const d = this._core.items(this._core.relative(this._core.current())); const e = a.map(this._hashes, (a, b) => a === d ? b : null).join(); if (!e || b.location.hash.slice(1) === e) return; b.location.hash = e } }, this) }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers), a(b).on('hashchange.owl.navigation', a.proxy(function (a) { const c = b.location.hash.substring(1); const e = this._core.$stage.children(); const f = this._hashes[c] && e.index(this._hashes[c]); f !== d && f !== this._core.current() && this._core.to(this._core.relative(f), !1, !0) }, this)) }; e.Defaults = { URLhashListener: !1 }, e.prototype.destroy = function () { let c, d; a(b).off('hashchange.owl.navigation'); for (c in this._handlers) this._core.$element.off(c, this._handlers[c]); for (d in Object.getOwnPropertyNames(this)) typeof this[d] !== 'function' && (this[d] = null) }, a.fn.owlCarousel.Constructor.Plugins.Hash = e
}(window.Zepto || window.jQuery, window, document)), (function (a, b, c, d) { function e(b, c) { let e = !1; const f = b.charAt(0).toUpperCase() + b.slice(1); return a.each((`${b} ${h.join(`${f} `)}${f}`).split(' '), (a, b) => { if (g[b] !== d) return e = !c || b, !1 }), e } function f(a) { return e(a, !0) } var g = a('<support>').get(0).style; var h = 'Webkit Moz O ms'.split(' '); const i = { transition: { end: { WebkitTransition: 'webkitTransitionEnd', MozTransition: 'transitionend', OTransition: 'oTransitionEnd', transition: 'transitionend' } }, animation: { end: { WebkitAnimation: 'webkitAnimationEnd', MozAnimation: 'animationend', OAnimation: 'oAnimationEnd', animation: 'animationend' } } }; const j = { csstransforms() { return !!e('transform') }, csstransforms3d() { return !!e('perspective') }, csstransitions() { return !!e('transition') }, cssanimations() { return !!e('animation') } }; j.csstransitions() && (a.support.transition = new String(f('transition')), a.support.transition.end = i.transition.end[a.support.transition]), j.cssanimations() && (a.support.animation = new String(f('animation')), a.support.animation.end = i.animation.end[a.support.animation]), j.csstransforms() && (a.support.transform = new String(f('transform')), a.support.transform3d = j.csstransforms3d()) }(window.Zepto || window.jQuery, window, document))

/*! Morphext - v2.4.7 - 2016-11-04 */
!(function (a) {
  function b(b, c) { this.element = a(b), this.settings = a.extend({}, d, c), this._defaults = d, this._init() } const c = 'Morphext'; var d = { animation: 'bounceIn', separator: ',', speed: 2e3, complete: a.noop }; b.prototype = { _init() { const b = this; this.phrases = [], this.element.addClass('morphext'), a.each(this.element.text().split(this.settings.separator), (c, d) => { b.phrases.push(a.trim(d)) }), this.index = -1, this.animate(), this.start() }, animate() { this.index = ++this.index % this.phrases.length, this.element[0].innerHTML = `<span class="animated ${this.settings.animation}">${this.phrases[this.index]}</span>`, a.isFunction(this.settings.complete) && this.settings.complete.call(this) }, start() { const a = this; this._interval = setInterval(() => { a.animate() }, this.settings.speed) }, stop() { this._interval = clearInterval(this._interval) } }, a.fn[c] = function (d) { return this.each(function () { a.data(this, `plugin_${c}`) || a.data(this, `plugin_${c}`, new b(this, d)) }) }
}(jQuery))

/*!
 * Isotope PACKAGED v3.0.6
 *
 * Licensed GPLv3 for open source use
 * or Isotope Commercial License for commercial use
 *
 * https://isotope.metafizzy.co
 * Copyright 2010-2018 Metafizzy
 */

!(function (t, e) { typeof define === 'function' && define.amd ? define('jquery-bridget/jquery-bridget', ['jquery'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('jquery')) : t.jQueryBridget = e(t, t.jQuery) }(window, (t, e) => {
  function i(i, s, a) { function u(t, e, o) { let n; const s = `$().${i}("${e}")`; return t.each((t, u) => { const h = a.data(u, i); if (!h) return void r(`${i} not initialized. Cannot call methods, i.e. ${s}`); const d = h[e]; if (!d || e.charAt(0) == '_') return void r(`${s} is not a valid method`); const l = d.apply(h, o); n = void 0 === n ? l : n }), void 0 !== n ? n : t } function h(t, e) { t.each((t, o) => { let n = a.data(o, i); n ? (n.option(e), n._init()) : (n = new s(o, e), a.data(o, i, n)) }) }a = a || e || t.jQuery, a && (s.prototype.option || (s.prototype.option = function (t) { a.isPlainObject(t) && (this.options = a.extend(!0, this.options, t)) }), a.fn[i] = function (t) { if (typeof t === 'string') { const e = n.call(arguments, 1); return u(this, t, e) } return h(this, t), this }, o(a)) } function o(t) { !t || t && t.bridget || (t.bridget = i) } var n = Array.prototype.slice; const s = t.console; var r = typeof s === 'undefined' ? function () {} : function (t) { s.error(t) }; return o(e || t.jQuery), i
})), (function (t, e) { typeof define === 'function' && define.amd ? define('ev-emitter/ev-emitter', e) : typeof module === 'object' && module.exports ? module.exports = e() : t.EvEmitter = e() }(typeof window !== 'undefined' ? window : this, () => { function t() {} const e = t.prototype; return e.on = function (t, e) { if (t && e) { const i = this._events = this._events || {}; const o = i[t] = i[t] || []; return o.indexOf(e) == -1 && o.push(e), this } }, e.once = function (t, e) { if (t && e) { this.on(t, e); const i = this._onceEvents = this._onceEvents || {}; const o = i[t] = i[t] || {}; return o[e] = !0, this } }, e.off = function (t, e) { const i = this._events && this._events[t]; if (i && i.length) { const o = i.indexOf(e); return o != -1 && i.splice(o, 1), this } }, e.emitEvent = function (t, e) { let i = this._events && this._events[t]; if (i && i.length) { i = i.slice(0), e = e || []; for (let o = this._onceEvents && this._onceEvents[t], n = 0; n < i.length; n++) { const s = i[n]; const r = o && o[s]; r && (this.off(t, s), delete o[s]), s.apply(this, e) } return this } }, e.allOff = function () { delete this._events, delete this._onceEvents }, t })), (function (t, e) { typeof define === 'function' && define.amd ? define('get-size/get-size', e) : typeof module === 'object' && module.exports ? module.exports = e() : t.getSize = e() }(window, () => {
  function t(t) { const e = parseFloat(t); const i = t.indexOf('%') == -1 && !isNaN(e); return i && e } function e() {} function i() { for (var t = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }, e = 0; e < h; e++) { const i = u[e]; t[i] = 0 } return t } function o(t) { const e = getComputedStyle(t); return e || a(`Style returned ${e}. Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1`), e } function n() { if (!d) { d = !0; const e = document.createElement('div'); e.style.width = '200px', e.style.padding = '1px 2px 3px 4px', e.style.borderStyle = 'solid', e.style.borderWidth = '1px 2px 3px 4px', e.style.boxSizing = 'border-box'; const i = document.body || document.documentElement; i.appendChild(e); const n = o(e); r = Math.round(t(n.width)) == 200, s.isBoxSizeOuter = r, i.removeChild(e) } } function s(e) { if (n(), typeof e === 'string' && (e = document.querySelector(e)), e && typeof e === 'object' && e.nodeType) { const s = o(e); if (s.display == 'none') return i(); const a = {}; a.width = e.offsetWidth, a.height = e.offsetHeight; for (var d = a.isBorderBox = s.boxSizing == 'border-box', l = 0; l < h; l++) { const f = u[l]; const c = s[f]; const m = parseFloat(c); a[f] = isNaN(m) ? 0 : m } const p = a.paddingLeft + a.paddingRight; const y = a.paddingTop + a.paddingBottom; const g = a.marginLeft + a.marginRight; const v = a.marginTop + a.marginBottom; const _ = a.borderLeftWidth + a.borderRightWidth; const z = a.borderTopWidth + a.borderBottomWidth; const I = d && r; const x = t(s.width); x !== !1 && (a.width = x + (I ? 0 : p + _)); const S = t(s.height); return S !== !1 && (a.height = S + (I ? 0 : y + z)), a.innerWidth = a.width - (p + _), a.innerHeight = a.height - (y + z), a.outerWidth = a.width + g, a.outerHeight = a.height + v, a } } let r; var a = typeof console === 'undefined' ? e : function (t) { console.error(t) }; var u = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth']; var h = u.length; var d = !1; return s
})), (function (t, e) {
  typeof define === 'function' && define.amd ? define('desandro-matches-selector/matches-selector', e) : typeof module === 'object' && module.exports ? module.exports = e() : t.matchesSelector = e()
}(window, () => {
  const t = (function () { const t = window.Element.prototype; if (t.matches) return 'matches'; if (t.matchesSelector) return 'matchesSelector'; for (let e = ['webkit', 'moz', 'ms', 'o'], i = 0; i < e.length; i++) { const o = e[i]; const n = `${o}MatchesSelector`; if (t[n]) return n } }()); return function (e, i) { return e[t](i) }
})), (function (t, e) { typeof define === 'function' && define.amd ? define('fizzy-ui-utils/utils', ['desandro-matches-selector/matches-selector'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('desandro-matches-selector')) : t.fizzyUIUtils = e(t, t.matchesSelector) }(window, (t, e) => { const i = {}; i.extend = function (t, e) { for (const i in e)t[i] = e[i]; return t }, i.modulo = function (t, e) { return (t % e + e) % e }; const o = Array.prototype.slice; i.makeArray = function (t) { if (Array.isArray(t)) return t; if (t === null || void 0 === t) return []; const e = typeof t === 'object' && typeof t.length === 'number'; return e ? o.call(t) : [t] }, i.removeFrom = function (t, e) { const i = t.indexOf(e); i != -1 && t.splice(i, 1) }, i.getParent = function (t, i) { for (;t.parentNode && t != document.body;) if (t = t.parentNode, e(t, i)) return t }, i.getQueryElement = function (t) { return typeof t === 'string' ? document.querySelector(t) : t }, i.handleEvent = function (t) { const e = `on${t.type}`; this[e] && this[e](t) }, i.filterFindElements = function (t, o) { t = i.makeArray(t); const n = []; return t.forEach((t) => { if (t instanceof HTMLElement) { if (!o) return void n.push(t); e(t, o) && n.push(t); for (let i = t.querySelectorAll(o), s = 0; s < i.length; s++)n.push(i[s]) } }), n }, i.debounceMethod = function (t, e, i) { i = i || 100; const o = t.prototype[e]; const n = `${e}Timeout`; t.prototype[e] = function () { const t = this[n]; clearTimeout(t); const e = arguments; const s = this; this[n] = setTimeout(() => { o.apply(s, e), delete s[n] }, i) } }, i.docReady = function (t) { const e = document.readyState; e == 'complete' || e == 'interactive' ? setTimeout(t) : document.addEventListener('DOMContentLoaded', t) }, i.toDashed = function (t) { return t.replace(/(.)([A-Z])/g, (t, e, i) => `${e}-${i}`).toLowerCase() }; const n = t.console; return i.htmlInit = function (e, o) { i.docReady(() => { const s = i.toDashed(o); const r = `data-${s}`; const a = document.querySelectorAll(`[${r}]`); const u = document.querySelectorAll(`.js-${s}`); const h = i.makeArray(a).concat(i.makeArray(u)); const d = `${r}-options`; const l = t.jQuery; h.forEach((t) => { let i; const s = t.getAttribute(r) || t.getAttribute(d); try { i = s && JSON.parse(s) } catch (a) { return void (n && n.error(`Error parsing ${r} on ${t.className}: ${a}`)) } const u = new e(t, i); l && l.data(t, o, u) }) }) }, i })), (function (t, e) { typeof define === 'function' && define.amd ? define('outlayer/item', ['ev-emitter/ev-emitter', 'get-size/get-size'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('ev-emitter'), require('get-size')) : (t.Outlayer = {}, t.Outlayer.Item = e(t.EvEmitter, t.getSize)) }(window, (t, e) => {
  function i(t) { for (var e in t) return !1; return e = null, !0 } function o(t, e) { t && (this.element = t, this.layout = e, this.position = { x: 0, y: 0 }, this._create()) } function n(t) { return t.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`) } const s = document.documentElement.style; const r = typeof s.transition === 'string' ? 'transition' : 'WebkitTransition'; const a = typeof s.transform === 'string' ? 'transform' : 'WebkitTransform'; const u = { WebkitTransition: 'webkitTransitionEnd', transition: 'transitionend' }[r]; const h = { transform: a, transition: r, transitionDuration: `${r}Duration`, transitionProperty: `${r}Property`, transitionDelay: `${r}Delay` }; const d = o.prototype = Object.create(t.prototype); d.constructor = o, d._create = function () { this._transn = { ingProperties: {}, clean: {}, onEnd: {} }, this.css({ position: 'absolute' }) }, d.handleEvent = function (t) { const e = `on${t.type}`; this[e] && this[e](t) }, d.getSize = function () { this.size = e(this.element) }, d.css = function (t) { const e = this.element.style; for (const i in t) { const o = h[i] || i; e[o] = t[i] } }, d.getPosition = function () { const t = getComputedStyle(this.element); const e = this.layout._getOption('originLeft'); const i = this.layout._getOption('originTop'); const o = t[e ? 'left' : 'right']; const n = t[i ? 'top' : 'bottom']; let s = parseFloat(o); let r = parseFloat(n); const a = this.layout.size; o.indexOf('%') != -1 && (s = s / 100 * a.width), n.indexOf('%') != -1 && (r = r / 100 * a.height), s = isNaN(s) ? 0 : s, r = isNaN(r) ? 0 : r, s -= e ? a.paddingLeft : a.paddingRight, r -= i ? a.paddingTop : a.paddingBottom, this.position.x = s, this.position.y = r }, d.layoutPosition = function () { const t = this.layout.size; const e = {}; const i = this.layout._getOption('originLeft'); const o = this.layout._getOption('originTop'); const n = i ? 'paddingLeft' : 'paddingRight'; const s = i ? 'left' : 'right'; const r = i ? 'right' : 'left'; const a = this.position.x + t[n]; e[s] = this.getXValue(a), e[r] = ''; const u = o ? 'paddingTop' : 'paddingBottom'; const h = o ? 'top' : 'bottom'; const d = o ? 'bottom' : 'top'; const l = this.position.y + t[u]; e[h] = this.getYValue(l), e[d] = '', this.css(e), this.emitEvent('layout', [this]) }, d.getXValue = function (t) { const e = this.layout._getOption('horizontal'); return this.layout.options.percentPosition && !e ? `${t / this.layout.size.width * 100}%` : `${t}px` }, d.getYValue = function (t) { const e = this.layout._getOption('horizontal'); return this.layout.options.percentPosition && e ? `${t / this.layout.size.height * 100}%` : `${t}px` }, d._transitionTo = function (t, e) { this.getPosition(); const i = this.position.x; const o = this.position.y; const n = t == this.position.x && e == this.position.y; if (this.setPosition(t, e), n && !this.isTransitioning) return void this.layoutPosition(); const s = t - i; const r = e - o; const a = {}; a.transform = this.getTranslate(s, r), this.transition({ to: a, onTransitionEnd: { transform: this.layoutPosition }, isCleaning: !0 }) }, d.getTranslate = function (t, e) { const i = this.layout._getOption('originLeft'); const o = this.layout._getOption('originTop'); return t = i ? t : -t, e = o ? e : -e, `translate3d(${t}px, ${e}px, 0)` }, d.goTo = function (t, e) { this.setPosition(t, e), this.layoutPosition() }, d.moveTo = d._transitionTo, d.setPosition = function (t, e) { this.position.x = parseFloat(t), this.position.y = parseFloat(e) }, d._nonTransition = function (t) { this.css(t.to), t.isCleaning && this._removeStyles(t.to); for (const e in t.onTransitionEnd)t.onTransitionEnd[e].call(this) }, d.transition = function (t) { if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(t); const e = this._transn; for (var i in t.onTransitionEnd)e.onEnd[i] = t.onTransitionEnd[i]; for (i in t.to)e.ingProperties[i] = !0, t.isCleaning && (e.clean[i] = !0); if (t.from) { this.css(t.from); let o = this.element.offsetHeight; o = null } this.enableTransition(t.to), this.css(t.to), this.isTransitioning = !0 }; const l = `opacity,${n(a)}`; d.enableTransition = function () { if (!this.isTransitioning) { let t = this.layout.options.transitionDuration; t = typeof t === 'number' ? `${t}ms` : t, this.css({ transitionProperty: l, transitionDuration: t, transitionDelay: this.staggerDelay || 0 }), this.element.addEventListener(u, this, !1) } }, d.onwebkitTransitionEnd = function (t) { this.ontransitionend(t) }, d.onotransitionend = function (t) { this.ontransitionend(t) }; const f = { '-webkit-transform': 'transform' }; d.ontransitionend = function (t) { if (t.target === this.element) { const e = this._transn; const o = f[t.propertyName] || t.propertyName; if (delete e.ingProperties[o], i(e.ingProperties) && this.disableTransition(), o in e.clean && (this.element.style[t.propertyName] = '', delete e.clean[o]), o in e.onEnd) { const n = e.onEnd[o]; n.call(this), delete e.onEnd[o] } this.emitEvent('transitionEnd', [this]) } }, d.disableTransition = function () { this.removeTransitionStyles(), this.element.removeEventListener(u, this, !1), this.isTransitioning = !1 }, d._removeStyles = function (t) { const e = {}; for (const i in t)e[i] = ''; this.css(e) }; const c = { transitionProperty: '', transitionDuration: '', transitionDelay: '' }; return d.removeTransitionStyles = function () { this.css(c) }, d.stagger = function (t) { t = isNaN(t) ? 0 : t, this.staggerDelay = `${t}ms` }, d.removeElem = function () { this.element.parentNode.removeChild(this.element), this.css({ display: '' }), this.emitEvent('remove', [this]) }, d.remove = function () { return r && parseFloat(this.layout.options.transitionDuration) ? (this.once('transitionEnd', function () { this.removeElem() }), void this.hide()) : void this.removeElem() }, d.reveal = function () { delete this.isHidden, this.css({ display: '' }); const t = this.layout.options; const e = {}; const i = this.getHideRevealTransitionEndProperty('visibleStyle'); e[i] = this.onRevealTransitionEnd, this.transition({ from: t.hiddenStyle, to: t.visibleStyle, isCleaning: !0, onTransitionEnd: e }) }, d.onRevealTransitionEnd = function () { this.isHidden || this.emitEvent('reveal') }, d.getHideRevealTransitionEndProperty = function (t) { const e = this.layout.options[t]; if (e.opacity) return 'opacity'; for (const i in e) return i }, d.hide = function () { this.isHidden = !0, this.css({ display: '' }); const t = this.layout.options; const e = {}; const i = this.getHideRevealTransitionEndProperty('hiddenStyle'); e[i] = this.onHideTransitionEnd, this.transition({ from: t.visibleStyle, to: t.hiddenStyle, isCleaning: !0, onTransitionEnd: e }) }, d.onHideTransitionEnd = function () { this.isHidden && (this.css({ display: 'none' }), this.emitEvent('hide')) }, d.destroy = function () { this.css({ position: '', left: '', right: '', top: '', bottom: '', transition: '', transform: '' }) }, o
})), (function (t, e) {
  typeof define === 'function' && define.amd ? define('outlayer/outlayer', ['ev-emitter/ev-emitter', 'get-size/get-size', 'fizzy-ui-utils/utils', './item'], (i, o, n, s) => e(t, i, o, n, s)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('ev-emitter'), require('get-size'), require('fizzy-ui-utils'), require('./item')) : t.Outlayer = e(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item)
}(window, (t, e, i, o, n) => {
  function s(t, e) { const i = o.getQueryElement(t); if (!i) return void (u && u.error(`Bad element for ${this.constructor.namespace}: ${i || t}`)); this.element = i, h && (this.$element = h(this.element)), this.options = o.extend({}, this.constructor.defaults), this.option(e); const n = ++l; this.element.outlayerGUID = n, f[n] = this, this._create(); const s = this._getOption('initLayout'); s && this.layout() } function r(t) { function e() { t.apply(this, arguments) } return e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e } function a(t) { if (typeof t === 'number') return t; const e = t.match(/(^\d*\.?\d*)(\w*)/); let i = e && e[1]; const o = e && e[2]; if (!i.length) return 0; i = parseFloat(i); const n = m[o] || 1; return i * n } var u = t.console; var h = t.jQuery; const d = function () {}; var l = 0; var f = {}; s.namespace = 'outlayer', s.Item = n, s.defaults = { containerStyle: { position: 'relative' }, initLayout: !0, originLeft: !0, originTop: !0, resize: !0, resizeContainer: !0, transitionDuration: '0.4s', hiddenStyle: { opacity: 0, transform: 'scale(0.001)' }, visibleStyle: { opacity: 1, transform: 'scale(1)' } }; const c = s.prototype; o.extend(c, e.prototype), c.option = function (t) { o.extend(this.options, t) }, c._getOption = function (t) { const e = this.constructor.compatOptions[t]; return e && void 0 !== this.options[e] ? this.options[e] : this.options[t] }, s.compatOptions = { initLayout: 'isInitLayout', horizontal: 'isHorizontal', layoutInstant: 'isLayoutInstant', originLeft: 'isOriginLeft', originTop: 'isOriginTop', resize: 'isResizeBound', resizeContainer: 'isResizingContainer' }, c._create = function () { this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), o.extend(this.element.style, this.options.containerStyle); const t = this._getOption('resize'); t && this.bindResize() }, c.reloadItems = function () { this.items = this._itemize(this.element.children) }, c._itemize = function (t) { for (var e = this._filterFindItemElements(t), i = this.constructor.Item, o = [], n = 0; n < e.length; n++) { const s = e[n]; const r = new i(s, this); o.push(r) } return o }, c._filterFindItemElements = function (t) { return o.filterFindElements(t, this.options.itemSelector) }, c.getItemElements = function () { return this.items.map((t) => t.element) }, c.layout = function () { this._resetLayout(), this._manageStamps(); const t = this._getOption('layoutInstant'); const e = void 0 !== t ? t : !this._isLayoutInited; this.layoutItems(this.items, e), this._isLayoutInited = !0 }, c._init = c.layout, c._resetLayout = function () { this.getSize() }, c.getSize = function () { this.size = i(this.element) }, c._getMeasurement = function (t, e) { let o; const n = this.options[t]; n ? (typeof n === 'string' ? o = this.element.querySelector(n) : n instanceof HTMLElement && (o = n), this[t] = o ? i(o)[e] : n) : this[t] = 0 }, c.layoutItems = function (t, e) { t = this._getItemsForLayout(t), this._layoutItems(t, e), this._postLayout() }, c._getItemsForLayout = function (t) { return t.filter((t) => !t.isIgnored) }, c._layoutItems = function (t, e) { if (this._emitCompleteOnItems('layout', t), t && t.length) { const i = []; t.forEach(function (t) { const o = this._getItemLayoutPosition(t); o.item = t, o.isInstant = e || t.isLayoutInstant, i.push(o) }, this), this._processLayoutQueue(i) } }, c._getItemLayoutPosition = function () { return { x: 0, y: 0 } }, c._processLayoutQueue = function (t) { this.updateStagger(), t.forEach(function (t, e) { this._positionItem(t.item, t.x, t.y, t.isInstant, e) }, this) }, c.updateStagger = function () { const t = this.options.stagger; return t === null || void 0 === t ? void (this.stagger = 0) : (this.stagger = a(t), this.stagger) }, c._positionItem = function (t, e, i, o, n) { o ? t.goTo(e, i) : (t.stagger(n * this.stagger), t.moveTo(e, i)) }, c._postLayout = function () { this.resizeContainer() }, c.resizeContainer = function () { const t = this._getOption('resizeContainer'); if (t) { const e = this._getContainerSize(); e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1)) } }, c._getContainerSize = d, c._setContainerMeasure = function (t, e) { if (void 0 !== t) { const i = this.size; i.isBorderBox && (t += e ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), t = Math.max(t, 0), this.element.style[e ? 'width' : 'height'] = `${t}px` } }, c._emitCompleteOnItems = function (t, e) { function i() { n.dispatchEvent(`${t}Complete`, null, [e]) } function o() { r++, r == s && i() } var n = this; var s = e.length; if (!e || !s) return void i(); var r = 0; e.forEach((e) => { e.once(t, o) }) }, c.dispatchEvent = function (t, e, i) { const o = e ? [e].concat(i) : i; if (this.emitEvent(t, o), h) if (this.$element = this.$element || h(this.element), e) { const n = h.Event(e); n.type = t, this.$element.trigger(n, i) } else this.$element.trigger(t, i) }, c.ignore = function (t) { const e = this.getItem(t); e && (e.isIgnored = !0) }, c.unignore = function (t) { const e = this.getItem(t); e && delete e.isIgnored }, c.stamp = function (t) { t = this._find(t), t && (this.stamps = this.stamps.concat(t), t.forEach(this.ignore, this)) }, c.unstamp = function (t) { t = this._find(t), t && t.forEach(function (t) { o.removeFrom(this.stamps, t), this.unignore(t) }, this) }, c._find = function (t) { if (t) return typeof t === 'string' && (t = this.element.querySelectorAll(t)), t = o.makeArray(t) }, c._manageStamps = function () { this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this)) }, c._getBoundingRect = function () { const t = this.element.getBoundingClientRect(); const e = this.size; this._boundingRect = { left: t.left + e.paddingLeft + e.borderLeftWidth, top: t.top + e.paddingTop + e.borderTopWidth, right: t.right - (e.paddingRight + e.borderRightWidth), bottom: t.bottom - (e.paddingBottom + e.borderBottomWidth) } }, c._manageStamp = d, c._getElementOffset = function (t) { const e = t.getBoundingClientRect(); const o = this._boundingRect; const n = i(t); const s = { left: e.left - o.left - n.marginLeft, top: e.top - o.top - n.marginTop, right: o.right - e.right - n.marginRight, bottom: o.bottom - e.bottom - n.marginBottom }; return s }, c.handleEvent = o.handleEvent, c.bindResize = function () { t.addEventListener('resize', this), this.isResizeBound = !0 }, c.unbindResize = function () { t.removeEventListener('resize', this), this.isResizeBound = !1 }, c.onresize = function () { this.resize() }, o.debounceMethod(s, 'onresize', 100), c.resize = function () { this.isResizeBound && this.needsResizeLayout() && this.layout() }, c.needsResizeLayout = function () { const t = i(this.element); const e = this.size && t; return e && t.innerWidth !== this.size.innerWidth }, c.addItems = function (t) { const e = this._itemize(t); return e.length && (this.items = this.items.concat(e)), e }, c.appended = function (t) { const e = this.addItems(t); e.length && (this.layoutItems(e, !0), this.reveal(e)) }, c.prepended = function (t) { const e = this._itemize(t); if (e.length) { const i = this.items.slice(0); this.items = e.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(e, !0), this.reveal(e), this.layoutItems(i) } }, c.reveal = function (t) { if (this._emitCompleteOnItems('reveal', t), t && t.length) { const e = this.updateStagger(); t.forEach((t, i) => { t.stagger(i * e), t.reveal() }) } }, c.hide = function (t) { if (this._emitCompleteOnItems('hide', t), t && t.length) { const e = this.updateStagger(); t.forEach((t, i) => { t.stagger(i * e), t.hide() }) } }, c.revealItemElements = function (t) { const e = this.getItems(t); this.reveal(e) }, c.hideItemElements = function (t) { const e = this.getItems(t); this.hide(e) }, c.getItem = function (t) { for (let e = 0; e < this.items.length; e++) { const i = this.items[e]; if (i.element == t) return i } }, c.getItems = function (t) { t = o.makeArray(t); const e = []; return t.forEach(function (t) { const i = this.getItem(t); i && e.push(i) }, this), e }, c.remove = function (t) { const e = this.getItems(t); this._emitCompleteOnItems('remove', e), e && e.length && e.forEach(function (t) { t.remove(), o.removeFrom(this.items, t) }, this) }, c.destroy = function () { const t = this.element.style; t.height = '', t.position = '', t.width = '', this.items.forEach((t) => { t.destroy() }), this.unbindResize(); const e = this.element.outlayerGUID; delete f[e], delete this.element.outlayerGUID, h && h.removeData(this.element, this.constructor.namespace) }, s.data = function (t) { t = o.getQueryElement(t); const e = t && t.outlayerGUID; return e && f[e] }, s.create = function (t, e) { const i = r(s); return i.defaults = o.extend({}, s.defaults), o.extend(i.defaults, e), i.compatOptions = o.extend({}, s.compatOptions), i.namespace = t, i.data = s.data, i.Item = r(n), o.htmlInit(i, t), h && h.bridget && h.bridget(t, i), i }; var m = { ms: 1, s: 1e3 }; return s.Item = n, s
})), (function (t, e) { typeof define === 'function' && define.amd ? define('isotope-layout/js/item', ['outlayer/outlayer'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('outlayer')) : (t.Isotope = t.Isotope || {}, t.Isotope.Item = e(t.Outlayer)) }(window, (t) => {
  function e() { t.Item.apply(this, arguments) } const i = e.prototype = Object.create(t.Item.prototype); const o = i._create; i._create = function () { this.id = this.layout.itemGUID++, o.call(this), this.sortData = {} }, i.updateSortData = function () { if (!this.isIgnored) { this.sortData.id = this.id, this.sortData['original-order'] = this.id, this.sortData.random = Math.random(); const t = this.layout.options.getSortData; const e = this.layout._sorters; for (const i in t) { const o = e[i]; this.sortData[i] = o(this.element, this) } } }; const n = i.destroy; return i.destroy = function () { n.apply(this, arguments), this.css({ display: '' }) }, e
})), (function (t, e) { typeof define === 'function' && define.amd ? define('isotope-layout/js/layout-mode', ['get-size/get-size', 'outlayer/outlayer'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('get-size'), require('outlayer')) : (t.Isotope = t.Isotope || {}, t.Isotope.LayoutMode = e(t.getSize, t.Outlayer)) }(window, (t, e) => {
  function i(t) { this.isotope = t, t && (this.options = t.options[this.namespace], this.element = t.element, this.items = t.filteredItems, this.size = t.size) } const o = i.prototype; const n = ['_resetLayout', '_getItemLayoutPosition', '_manageStamp', '_getContainerSize', '_getElementOffset', 'needsResizeLayout', '_getOption']; return n.forEach((t) => { o[t] = function () { return e.prototype[t].apply(this.isotope, arguments) } }), o.needsVerticalResizeLayout = function () { const e = t(this.isotope.element); const i = this.isotope.size && e; return i && e.innerHeight != this.isotope.size.innerHeight }, o._getMeasurement = function () { this.isotope._getMeasurement.apply(this, arguments) }, o.getColumnWidth = function () { this.getSegmentSize('column', 'Width') }, o.getRowHeight = function () { this.getSegmentSize('row', 'Height') }, o.getSegmentSize = function (t, e) { const i = t + e; const o = `outer${e}`; if (this._getMeasurement(i, o), !this[i]) { const n = this.getFirstItemSize(); this[i] = n && n[o] || this.isotope.size[`inner${e}`] } }, o.getFirstItemSize = function () { const e = this.isotope.filteredItems[0]; return e && e.element && t(e.element) }, o.layout = function () { this.isotope.layout.apply(this.isotope, arguments) }, o.getSize = function () { this.isotope.getSize(), this.size = this.isotope.size }, i.modes = {}, i.create = function (t, e) { function n() { i.apply(this, arguments) } return n.prototype = Object.create(o), n.prototype.constructor = n, e && (n.options = e), n.prototype.namespace = t, i.modes[t] = n, n }, i
})), (function (t, e) { typeof define === 'function' && define.amd ? define('masonry-layout/masonry', ['outlayer/outlayer', 'get-size/get-size'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('outlayer'), require('get-size')) : t.Masonry = e(t.Outlayer, t.getSize) }(window, (t, e) => { const i = t.create('masonry'); i.compatOptions.fitWidth = 'isFitWidth'; const o = i.prototype; return o._resetLayout = function () { this.getSize(), this._getMeasurement('columnWidth', 'outerWidth'), this._getMeasurement('gutter', 'outerWidth'), this.measureColumns(), this.colYs = []; for (let t = 0; t < this.cols; t++) this.colYs.push(0); this.maxY = 0, this.horizontalColIndex = 0 }, o.measureColumns = function () { if (this.getContainerWidth(), !this.columnWidth) { const t = this.items[0]; const i = t && t.element; this.columnWidth = i && e(i).outerWidth || this.containerWidth } const o = this.columnWidth += this.gutter; const n = this.containerWidth + this.gutter; let s = n / o; const r = o - n % o; const a = r && r < 1 ? 'round' : 'floor'; s = Math[a](s), this.cols = Math.max(s, 1) }, o.getContainerWidth = function () { const t = this._getOption('fitWidth'); const i = t ? this.element.parentNode : this.element; const o = e(i); this.containerWidth = o && o.innerWidth }, o._getItemLayoutPosition = function (t) { t.getSize(); const e = t.size.outerWidth % this.columnWidth; const i = e && e < 1 ? 'round' : 'ceil'; let o = Math[i](t.size.outerWidth / this.columnWidth); o = Math.min(o, this.cols); for (var n = this.options.horizontalOrder ? '_getHorizontalColPosition' : '_getTopColPosition', s = this[n](o, t), r = { x: this.columnWidth * s.col, y: s.y }, a = s.y + t.size.outerHeight, u = o + s.col, h = s.col; h < u; h++) this.colYs[h] = a; return r }, o._getTopColPosition = function (t) { const e = this._getTopColGroup(t); const i = Math.min.apply(Math, e); return { col: e.indexOf(i), y: i } }, o._getTopColGroup = function (t) { if (t < 2) return this.colYs; for (var e = [], i = this.cols + 1 - t, o = 0; o < i; o++)e[o] = this._getColGroupY(o, t); return e }, o._getColGroupY = function (t, e) { if (e < 2) return this.colYs[t]; const i = this.colYs.slice(t, t + e); return Math.max.apply(Math, i) }, o._getHorizontalColPosition = function (t, e) { let i = this.horizontalColIndex % this.cols; const o = t > 1 && i + t > this.cols; i = o ? 0 : i; const n = e.size.outerWidth && e.size.outerHeight; return this.horizontalColIndex = n ? i + t : this.horizontalColIndex, { col: i, y: this._getColGroupY(i, t) } }, o._manageStamp = function (t) { const i = e(t); const o = this._getElementOffset(t); const n = this._getOption('originLeft'); const s = n ? o.left : o.right; const r = s + i.outerWidth; let a = Math.floor(s / this.columnWidth); a = Math.max(0, a); let u = Math.floor(r / this.columnWidth); u -= r % this.columnWidth ? 0 : 1, u = Math.min(this.cols - 1, u); for (let h = this._getOption('originTop'), d = (h ? o.top : o.bottom) + i.outerHeight, l = a; l <= u; l++) this.colYs[l] = Math.max(d, this.colYs[l]) }, o._getContainerSize = function () { this.maxY = Math.max.apply(Math, this.colYs); const t = { height: this.maxY }; return this._getOption('fitWidth') && (t.width = this._getContainerFitWidth()), t }, o._getContainerFitWidth = function () { for (var t = 0, e = this.cols; --e && this.colYs[e] === 0;)t++; return (this.cols - t) * this.columnWidth - this.gutter }, o.needsResizeLayout = function () { const t = this.containerWidth; return this.getContainerWidth(), t != this.containerWidth }, i })), (function (t, e) { typeof define === 'function' && define.amd ? define('isotope-layout/js/layout-modes/masonry', ['../layout-mode', 'masonry-layout/masonry'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('../layout-mode'), require('masonry-layout')) : e(t.Isotope.LayoutMode, t.Masonry) }(window, (t, e) => {
  const i = t.create('masonry'); const o = i.prototype; const n = { _getElementOffset: !0, layout: !0, _getMeasurement: !0 }; for (const s in e.prototype)n[s] || (o[s] = e.prototype[s]); const r = o.measureColumns; o.measureColumns = function () { this.items = this.isotope.filteredItems, r.call(this) }; const a = o._getOption; return o._getOption = function (t) { return t == 'fitWidth' ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments) }, i
})), (function (t, e) { typeof define === 'function' && define.amd ? define('isotope-layout/js/layout-modes/fit-rows', ['../layout-mode'], e) : typeof exports === 'object' ? module.exports = e(require('../layout-mode')) : e(t.Isotope.LayoutMode) }(window, (t) => {
  const e = t.create('fitRows'); const i = e.prototype; return i._resetLayout = function () { this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement('gutter', 'outerWidth') }, i._getItemLayoutPosition = function (t) { t.getSize(); const e = t.size.outerWidth + this.gutter; const i = this.isotope.size.innerWidth + this.gutter; this.x !== 0 && e + this.x > i && (this.x = 0, this.y = this.maxY); const o = { x: this.x, y: this.y }; return this.maxY = Math.max(this.maxY, this.y + t.size.outerHeight), this.x += e, o }, i._getContainerSize = function () { return { height: this.maxY } }, e
})), (function (t, e) { typeof define === 'function' && define.amd ? define('isotope-layout/js/layout-modes/vertical', ['../layout-mode'], e) : typeof module === 'object' && module.exports ? module.exports = e(require('../layout-mode')) : e(t.Isotope.LayoutMode) }(window, (t) => {
  const e = t.create('vertical', { horizontalAlignment: 0 }); const i = e.prototype; return i._resetLayout = function () { this.y = 0 }, i._getItemLayoutPosition = function (t) { t.getSize(); const e = (this.isotope.size.innerWidth - t.size.outerWidth) * this.options.horizontalAlignment; const i = this.y; return this.y += t.size.outerHeight, { x: e, y: i } }, i._getContainerSize = function () { return { height: this.y } }, e
})), (function (t, e) { typeof define === 'function' && define.amd ? define(['outlayer/outlayer', 'get-size/get-size', 'desandro-matches-selector/matches-selector', 'fizzy-ui-utils/utils', 'isotope-layout/js/item', 'isotope-layout/js/layout-mode', 'isotope-layout/js/layout-modes/masonry', 'isotope-layout/js/layout-modes/fit-rows', 'isotope-layout/js/layout-modes/vertical'], (i, o, n, s, r, a) => e(t, i, o, n, s, r, a)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('outlayer'), require('get-size'), require('desandro-matches-selector'), require('fizzy-ui-utils'), require('isotope-layout/js/item'), require('isotope-layout/js/layout-mode'), require('isotope-layout/js/layout-modes/masonry'), require('isotope-layout/js/layout-modes/fit-rows'), require('isotope-layout/js/layout-modes/vertical')) : t.Isotope = e(t, t.Outlayer, t.getSize, t.matchesSelector, t.fizzyUIUtils, t.Isotope.Item, t.Isotope.LayoutMode) }(window, (t, e, i, o, n, s, r) => { function a(t, e) { return function (i, o) { for (let n = 0; n < t.length; n++) { const s = t[n]; const r = i.sortData[s]; const a = o.sortData[s]; if (r > a || r < a) { const u = void 0 !== e[s] ? e[s] : e; const h = u ? 1 : -1; return (r > a ? 1 : -1) * h } } return 0 } } const u = t.jQuery; const h = String.prototype.trim ? function (t) { return t.trim() } : function (t) { return t.replace(/^\s+|\s+$/g, '') }; const d = e.create('isotope', { layoutMode: 'masonry', isJQueryFiltering: !0, sortAscending: !0 }); d.Item = s, d.LayoutMode = r; const l = d.prototype; l._create = function () { this.itemGUID = 0, this._sorters = {}, this._getSorters(), e.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ['original-order']; for (const t in r.modes) this._initLayoutMode(t) }, l.reloadItems = function () { this.itemGUID = 0, e.prototype.reloadItems.call(this) }, l._itemize = function () { for (var t = e.prototype._itemize.apply(this, arguments), i = 0; i < t.length; i++) { const o = t[i]; o.id = this.itemGUID++ } return this._updateItemsSortData(t), t }, l._initLayoutMode = function (t) { const e = r.modes[t]; const i = this.options[t] || {}; this.options[t] = e.options ? n.extend(e.options, i) : i, this.modes[t] = new e(this) }, l.layout = function () { return !this._isLayoutInited && this._getOption('initLayout') ? void this.arrange() : void this._layout() }, l._layout = function () { const t = this._getIsInstant(); this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, t), this._isLayoutInited = !0 }, l.arrange = function (t) { this.option(t), this._getIsInstant(); const e = this._filter(this.items); this.filteredItems = e.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [e]) : this._hideReveal(e), this._sort(), this._layout() }, l._init = l.arrange, l._hideReveal = function (t) { this.reveal(t.needReveal), this.hide(t.needHide) }, l._getIsInstant = function () { const t = this._getOption('layoutInstant'); const e = void 0 !== t ? t : !this._isLayoutInited; return this._isInstant = e, e }, l._bindArrangeComplete = function () { function t() { e && i && o && n.dispatchEvent('arrangeComplete', null, [n.filteredItems]) } let e; let i; let o; var n = this; this.once('layoutComplete', () => { e = !0, t() }), this.once('hideComplete', () => { i = !0, t() }), this.once('revealComplete', () => { o = !0, t() }) }, l._filter = function (t) { let e = this.options.filter; e = e || '*'; for (var i = [], o = [], n = [], s = this._getFilterTest(e), r = 0; r < t.length; r++) { const a = t[r]; if (!a.isIgnored) { const u = s(a); u && i.push(a), u && a.isHidden ? o.push(a) : u || a.isHidden || n.push(a) } } return { matches: i, needReveal: o, needHide: n } }, l._getFilterTest = function (t) { return u && this.options.isJQueryFiltering ? function (e) { return u(e.element).is(t) } : typeof t === 'function' ? function (e) { return t(e.element) } : function (e) { return o(e.element, t) } }, l.updateSortData = function (t) { let e; t ? (t = n.makeArray(t), e = this.getItems(t)) : e = this.items, this._getSorters(), this._updateItemsSortData(e) }, l._getSorters = function () { const t = this.options.getSortData; for (const e in t) { const i = t[e]; this._sorters[e] = f(i) } }, l._updateItemsSortData = function (t) { for (let e = t && t.length, i = 0; e && i < e; i++) { const o = t[i]; o.updateSortData() } }; var f = (function () { function t(t) { if (typeof t !== 'string') return t; const i = h(t).split(' '); const o = i[0]; const n = o.match(/^\[(.+)\]$/); const s = n && n[1]; const r = e(s, o); const a = d.sortDataParsers[i[1]]; return t = a ? function (t) { return t && a(r(t)) } : function (t) { return t && r(t) } } function e(t, e) { return t ? function (e) { return e.getAttribute(t) } : function (t) { const i = t.querySelector(e); return i && i.textContent } } return t }()); d.sortDataParsers = { parseInt(t) { return parseInt(t, 10) }, parseFloat(t) { return parseFloat(t) } }, l._sort = function () { if (this.options.sortBy) { const t = n.makeArray(this.options.sortBy); this._getIsSameSortBy(t) || (this.sortHistory = t.concat(this.sortHistory)); const e = a(this.sortHistory, this.options.sortAscending); this.filteredItems.sort(e) } }, l._getIsSameSortBy = function (t) { for (let e = 0; e < t.length; e++) if (t[e] != this.sortHistory[e]) return !1; return !0 }, l._mode = function () { const t = this.options.layoutMode; const e = this.modes[t]; if (!e) throw new Error(`No layout mode: ${t}`); return e.options = this.options[t], e }, l._resetLayout = function () { e.prototype._resetLayout.call(this), this._mode()._resetLayout() }, l._getItemLayoutPosition = function (t) { return this._mode()._getItemLayoutPosition(t) }, l._manageStamp = function (t) { this._mode()._manageStamp(t) }, l._getContainerSize = function () { return this._mode()._getContainerSize() }, l.needsResizeLayout = function () { return this._mode().needsResizeLayout() }, l.appended = function (t) { const e = this.addItems(t); if (e.length) { const i = this._filterRevealAdded(e); this.filteredItems = this.filteredItems.concat(i) } }, l.prepended = function (t) { const e = this._itemize(t); if (e.length) { this._resetLayout(), this._manageStamps(); const i = this._filterRevealAdded(e); this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = e.concat(this.items) } }, l._filterRevealAdded = function (t) { const e = this._filter(t); return this.hide(e.needHide), this.reveal(e.matches), this.layoutItems(e.matches, !0), e.matches }, l.insert = function (t) { const e = this.addItems(t); if (e.length) { let i; let o; const n = e.length; for (i = 0; i < n; i++)o = e[i], this.element.appendChild(o.element); const s = this._filter(e).matches; for (i = 0; i < n; i++)e[i].isLayoutInstant = !0; for (this.arrange(), i = 0; i < n; i++) delete e[i].isLayoutInstant; this.reveal(s) } }; const c = l.remove; return l.remove = function (t) { t = n.makeArray(t); const e = this.getItems(t); c.call(this, t); for (let i = e && e.length, o = 0; i && o < i; o++) { const s = e[o]; n.removeFrom(this.filteredItems, s) } }, l.shuffle = function () { for (let t = 0; t < this.items.length; t++) { const e = this.items[t]; e.sortData.random = Math.random() } this.options.sortBy = 'random', this._sort(), this._layout() }, l._noTransition = function (t, e) { const i = this.options.transitionDuration; this.options.transitionDuration = 0; const o = t.apply(this, e); return this.options.transitionDuration = i, o }, l.getFilteredItemElements = function () { return this.filteredItems.map((t) => t.element) }, d }))

/*!
 * imagesLoaded PACKAGED v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

!(function (e, t) { typeof define === 'function' && define.amd ? define('ev-emitter/ev-emitter', t) : typeof module === 'object' && module.exports ? module.exports = t() : e.EvEmitter = t() }(typeof window !== 'undefined' ? window : this, () => { function e() {} const t = e.prototype; return t.on = function (e, t) { if (e && t) { const i = this._events = this._events || {}; const n = i[e] = i[e] || []; return n.indexOf(t) == -1 && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); const i = this._onceEvents = this._onceEvents || {}; const n = i[e] = i[e] || {}; return n[t] = !0, this } }, t.off = function (e, t) { const i = this._events && this._events[e]; if (i && i.length) { const n = i.indexOf(t); return n != -1 && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { let i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (let n = this._onceEvents && this._onceEvents[e], o = 0; o < i.length; o++) { const r = i[o]; const s = n && n[r]; s && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e })), (function (e, t) {
  typeof define === 'function' && define.amd ? define(['ev-emitter/ev-emitter'], (i) => t(e, i)) : typeof module === 'object' && module.exports ? module.exports = t(e, require('ev-emitter')) : e.imagesLoaded = t(e, e.EvEmitter)
}(typeof window !== 'undefined' ? window : this, (e, t) => { function i(e, t) { for (const i in t)e[i] = t[i]; return e } function n(e) { if (Array.isArray(e)) return e; const t = typeof e === 'object' && typeof e.length === 'number'; return t ? d.call(e) : [e] } function o(e, t, r) { if (!(this instanceof o)) return new o(e, t, r); let s = e; return typeof e === 'string' && (s = document.querySelectorAll(e)), s ? (this.elements = n(s), this.options = i({}, this.options), typeof t === 'function' ? r = t : i(this.options, t), r && this.on('always', r), this.getImages(), h && (this.jqDeferred = new h.Deferred()), void setTimeout(this.check.bind(this))) : void a.error(`Bad element for imagesLoaded ${s || e}`) } function r(e) { this.img = e } function s(e, t) { this.url = e, this.element = t, this.img = new Image() } var h = e.jQuery; var a = e.console; var d = Array.prototype.slice; o.prototype = Object.create(t.prototype), o.prototype.options = {}, o.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, o.prototype.addElementImages = function (e) { e.nodeName == 'IMG' && this.addImage(e), this.options.background === !0 && this.addElementBackgroundImages(e); const t = e.nodeType; if (t && u[t]) { for (var i = e.querySelectorAll('img'), n = 0; n < i.length; n++) { const o = i[n]; this.addImage(o) } if (typeof this.options.background === 'string') { const r = e.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { const s = r[n]; this.addElementBackgroundImages(s) } } } }; var u = { 1: !0, 9: !0, 11: !0 }; return o.prototype.addElementBackgroundImages = function (e) { const t = getComputedStyle(e); if (t) for (let i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); n !== null;) { const o = n && n[2]; o && this.addBackground(o, e), n = i.exec(t.backgroundImage) } }, o.prototype.addImage = function (e) { const t = new r(e); this.images.push(t) }, o.prototype.addBackground = function (e, t) { const i = new s(e, t); this.images.push(i) }, o.prototype.check = function () { function e(e, i, n) { setTimeout(() => { t.progress(e, i, n) }) } var t = this; return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((t) => { t.once('progress', e), t.check() }) : void this.complete() }, o.prototype.progress = function (e, t, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent('progress', [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log(`progress: ${i}`, e, t) }, o.prototype.complete = function () { const e = this.hasAnyBroken ? 'fail' : 'done'; if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent('always', [this]), this.jqDeferred) { const t = this.hasAnyBroken ? 'reject' : 'resolve'; this.jqDeferred[t](this) } }, r.prototype = Object.create(t.prototype), r.prototype.check = function () { const e = this.getIsImageComplete(); return e ? void this.confirm(this.img.naturalWidth !== 0, 'naturalWidth') : (this.proxyImage = new Image(), this.proxyImage.addEventListener('load', this), this.proxyImage.addEventListener('error', this), this.img.addEventListener('load', this), this.img.addEventListener('error', this), void (this.proxyImage.src = this.img.src)) }, r.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, r.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent('progress', [this, this.img, t]) }, r.prototype.handleEvent = function (e) { const t = `on${e.type}`; this[t] && this[t](e) }, r.prototype.onload = function () { this.confirm(!0, 'onload'), this.unbindEvents() }, r.prototype.onerror = function () { this.confirm(!1, 'onerror'), this.unbindEvents() }, r.prototype.unbindEvents = function () { this.proxyImage.removeEventListener('load', this), this.proxyImage.removeEventListener('error', this), this.img.removeEventListener('load', this), this.img.removeEventListener('error', this) }, s.prototype = Object.create(r.prototype), s.prototype.check = function () { this.img.addEventListener('load', this), this.img.addEventListener('error', this), this.img.src = this.url; const e = this.getIsImageComplete(); e && (this.confirm(this.img.naturalWidth !== 0, 'naturalWidth'), this.unbindEvents()) }, s.prototype.unbindEvents = function () { this.img.removeEventListener('load', this), this.img.removeEventListener('error', this) }, s.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent('progress', [this, this.element, t]) }, o.makeJQueryPlugin = function (t) { t = t || e.jQuery, t && (h = t, h.fn.imagesLoaded = function (e, t) { const i = new o(this, e, t); return i.jqDeferred.promise(h(this)) }) }, o.makeJQueryPlugin(), o }))

/**
 * Swiper 4.4.6
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2018 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: December 19, 2018
 */
!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : e.Swiper = t() }(this, () => {
  const f = typeof document === 'undefined' ? { body: {}, addEventListener() {}, removeEventListener() {}, activeElement: { blur() {}, nodeName: '' }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() {} } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() {}, getElementsByTagName() { return [] } } }, location: { hash: '' } } : document; const J = typeof window === 'undefined' ? { document: f, navigator: { userAgent: '' }, location: {}, history: {}, CustomEvent() { return this }, addEventListener() {}, removeEventListener() {}, getComputedStyle() { return { getPropertyValue() { return '' } } }, Image() {}, Date() {}, screen: {}, setTimeout() {}, clearTimeout() {} } : window; const l = function (e) { for (let t = 0; t < e.length; t += 1) this[t] = e[t]; return this.length = e.length, this }; function L(e, t) { const a = []; let i = 0; if (e && !t && e instanceof l) return e; if (e) if (typeof e === 'string') { let s; let r; const n = e.trim(); if (n.indexOf('<') >= 0 && n.indexOf('>') >= 0) { let o = 'div'; for (n.indexOf('<li') === 0 && (o = 'ul'), n.indexOf('<tr') === 0 && (o = 'tbody'), n.indexOf('<td') !== 0 && n.indexOf('<th') !== 0 || (o = 'tr'), n.indexOf('<tbody') === 0 && (o = 'table'), n.indexOf('<option') === 0 && (o = 'select'), (r = f.createElement(o)).innerHTML = n, i = 0; i < r.childNodes.length; i += 1)a.push(r.childNodes[i]) } else for (s = t || e[0] !== '#' || e.match(/[ .<>:~]/) ? (t || f).querySelectorAll(e.trim()) : [f.getElementById(e.trim().split('#')[1])], i = 0; i < s.length; i += 1)s[i] && a.push(s[i]) } else if (e.nodeType || e === J || e === f)a.push(e); else if (e.length > 0 && e[0].nodeType) for (i = 0; i < e.length; i += 1)a.push(e[i]); return new l(a) } function r(e) { for (var t = [], a = 0; a < e.length; a += 1)t.indexOf(e[a]) === -1 && t.push(e[a]); return t }L.fn = l.prototype, L.Class = l, L.Dom7 = l; const t = { addClass(e) { if (void 0 === e) return this; for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.add(t[a]); return this }, removeClass(e) { for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.remove(t[a]); return this }, hasClass(e) { return !!this[0] && this[0].classList.contains(e) }, toggleClass(e) { for (let t = e.split(' '), a = 0; a < t.length; a += 1) for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.toggle(t[a]); return this }, attr(e, t) { const a = arguments; if (arguments.length === 1 && typeof e === 'string') return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1) if (a.length === 2) this[i].setAttribute(e, t); else for (const s in e) this[i][s] = e[s], this[i].setAttribute(s, e[s]); return this }, removeAttr(e) { for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e); return this }, data(e, t) { let a; if (void 0 !== t) { for (let i = 0; i < this.length; i += 1)(a = this[i]).dom7ElementDataStorage || (a.dom7ElementDataStorage = {}), a.dom7ElementDataStorage[e] = t; return this } if (a = this[0]) { if (a.dom7ElementDataStorage && e in a.dom7ElementDataStorage) return a.dom7ElementDataStorage[e]; const s = a.getAttribute(`data-${e}`); return s || void 0 } }, transform(e) { for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransform = e, a.transform = e } return this }, transition(e) { typeof e !== 'string' && (e += 'ms'); for (let t = 0; t < this.length; t += 1) { const a = this[t].style; a.webkitTransitionDuration = e, a.transitionDuration = e } return this }, on() { for (var e, t = [], a = arguments.length; a--;)t[a] = arguments[a]; let i = t[0]; let r = t[1]; let n = t[2]; let s = t[3]; function o(e) { const t = e.target; if (t) { const a = e.target.dom7EventData || []; if (a.indexOf(e) < 0 && a.unshift(e), L(t).is(r))n.apply(t, a); else for (let i = L(t).parents(), s = 0; s < i.length; s += 1)L(i[s]).is(r) && n.apply(i[s], a) } } function l(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), n.apply(this, t) } typeof t[1] === 'function' && (i = (e = t)[0], n = e[1], s = e[2], r = void 0), s || (s = !1); for (var d, p = i.split(' '), c = 0; c < this.length; c += 1) { const u = this[c]; if (r) for (d = 0; d < p.length; d += 1) { const h = p[d]; u.dom7LiveListeners || (u.dom7LiveListeners = {}), u.dom7LiveListeners[h] || (u.dom7LiveListeners[h] = []), u.dom7LiveListeners[h].push({ listener: n, proxyListener: o }), u.addEventListener(h, o, s) } else for (d = 0; d < p.length; d += 1) { const v = p[d]; u.dom7Listeners || (u.dom7Listeners = {}), u.dom7Listeners[v] || (u.dom7Listeners[v] = []), u.dom7Listeners[v].push({ listener: n, proxyListener: l }), u.addEventListener(v, l, s) } } return this }, off() { for (var e, t = [], a = arguments.length; a--;)t[a] = arguments[a]; let i = t[0]; let s = t[1]; let r = t[2]; let n = t[3]; typeof t[1] === 'function' && (i = (e = t)[0], r = e[1], n = e[2], s = void 0), n || (n = !1); for (let o = i.split(' '), l = 0; l < o.length; l += 1) for (let d = o[l], p = 0; p < this.length; p += 1) { const c = this[p]; let u = void 0; if (!s && c.dom7Listeners ? u = c.dom7Listeners[d] : s && c.dom7LiveListeners && (u = c.dom7LiveListeners[d]), u && u.length) for (let h = u.length - 1; h >= 0; h -= 1) { const v = u[h]; r && v.listener === r ? (c.removeEventListener(d, v.proxyListener, n), u.splice(h, 1)) : r || (c.removeEventListener(d, v.proxyListener, n), u.splice(h, 1)) } } return this }, trigger() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; for (let a = e[0].split(' '), i = e[1], s = 0; s < a.length; s += 1) for (let r = a[s], n = 0; n < this.length; n += 1) { const o = this[n]; let l = void 0; try { l = new J.CustomEvent(r, { detail: i, bubbles: !0, cancelable: !0 }) } catch (e) { (l = f.createEvent('Event')).initEvent(r, !0, !0), l.detail = i }o.dom7EventData = e.filter((e, t) => t > 0), o.dispatchEvent(l), o.dom7EventData = [], delete o.dom7EventData } return this }, transitionEnd(t) { let a; const i = ['webkitTransitionEnd', 'transitionend']; const s = this; function r(e) { if (e.target === this) for (t.call(this, e), a = 0; a < i.length; a += 1)s.off(i[a], r) } if (t) for (a = 0; a < i.length; a += 1)s.on(i[a], r); return this }, outerWidth(e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetWidth + parseFloat(t.getPropertyValue('margin-right')) + parseFloat(t.getPropertyValue('margin-left')) } return this[0].offsetWidth } return null }, outerHeight(e) { if (this.length > 0) { if (e) { const t = this.styles(); return this[0].offsetHeight + parseFloat(t.getPropertyValue('margin-top')) + parseFloat(t.getPropertyValue('margin-bottom')) } return this[0].offsetHeight } return null }, offset() { if (this.length > 0) { const e = this[0]; const t = e.getBoundingClientRect(); const a = f.body; const i = e.clientTop || a.clientTop || 0; const s = e.clientLeft || a.clientLeft || 0; const r = e === J ? J.scrollY : e.scrollTop; const n = e === J ? J.scrollX : e.scrollLeft; return { top: t.top + r - i, left: t.left + n - s } } return null }, css(e, t) { let a; if (arguments.length === 1) { if (typeof e !== 'string') { for (a = 0; a < this.length; a += 1) for (const i in e) this[a].style[i] = e[i]; return this } if (this[0]) return J.getComputedStyle(this[0], null).getPropertyValue(e) } if (arguments.length === 2 && typeof e === 'string') { for (a = 0; a < this.length; a += 1) this[a].style[e] = t; return this } return this }, each(e) { if (!e) return this; for (let t = 0; t < this.length; t += 1) if (!1 === e.call(this[t], t, this[t])) return this; return this }, html(e) { if (void 0 === e) return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e; return this }, text(e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1) this[t].textContent = e; return this }, is(e) { let t; let a; const i = this[0]; if (!i || void 0 === e) return !1; if (typeof e === 'string') { if (i.matches) return i.matches(e); if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e); if (i.msMatchesSelector) return i.msMatchesSelector(e); for (t = L(e), a = 0; a < t.length; a += 1) if (t[a] === i) return !0; return !1 } if (e === f) return i === f; if (e === J) return i === J; if (e.nodeType || e instanceof l) { for (t = e.nodeType ? [e] : e, a = 0; a < t.length; a += 1) if (t[a] === i) return !0; return !1 } return !1 }, index() { let e; let t = this[0]; if (t) { for (e = 0; (t = t.previousSibling) !== null;)t.nodeType === 1 && (e += 1); return e } }, eq(e) { if (void 0 === e) return this; let t; const a = this.length; return new l(a - 1 < e ? [] : e < 0 ? (t = a + e) < 0 ? [] : [this[t]] : [this[e]]) }, append() { for (var e, t = [], a = arguments.length; a--;)t[a] = arguments[a]; for (let i = 0; i < t.length; i += 1) { e = t[i]; for (let s = 0; s < this.length; s += 1) if (typeof e === 'string') { const r = f.createElement('div'); for (r.innerHTML = e; r.firstChild;) this[s].appendChild(r.firstChild) } else if (e instanceof l) for (let n = 0; n < e.length; n += 1) this[s].appendChild(e[n]); else this[s].appendChild(e) } return this }, prepend(e) { let t, a; for (t = 0; t < this.length; t += 1) if (typeof e === 'string') { const i = f.createElement('div'); for (i.innerHTML = e, a = i.childNodes.length - 1; a >= 0; a -= 1) this[t].insertBefore(i.childNodes[a], this[t].childNodes[0]) } else if (e instanceof l) for (a = 0; a < e.length; a += 1) this[t].insertBefore(e[a], this[t].childNodes[0]); else this[t].insertBefore(e, this[t].childNodes[0]); return this }, next(e) { return this.length > 0 ? e ? this[0].nextElementSibling && L(this[0].nextElementSibling).is(e) ? new l([this[0].nextElementSibling]) : new l([]) : this[0].nextElementSibling ? new l([this[0].nextElementSibling]) : new l([]) : new l([]) }, nextAll(e) { const t = []; let a = this[0]; if (!a) return new l([]); for (;a.nextElementSibling;) { const i = a.nextElementSibling; e ? L(i).is(e) && t.push(i) : t.push(i), a = i } return new l(t) }, prev(e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && L(t.previousElementSibling).is(e) ? new l([t.previousElementSibling]) : new l([]) : t.previousElementSibling ? new l([t.previousElementSibling]) : new l([]) } return new l([]) }, prevAll(e) { const t = []; let a = this[0]; if (!a) return new l([]); for (;a.previousElementSibling;) { const i = a.previousElementSibling; e ? L(i).is(e) && t.push(i) : t.push(i), a = i } return new l(t) }, parent(e) { for (var t = [], a = 0; a < this.length; a += 1) this[a].parentNode !== null && (e ? L(this[a].parentNode).is(e) && t.push(this[a].parentNode) : t.push(this[a].parentNode)); return L(r(t)) }, parents(e) { for (var t = [], a = 0; a < this.length; a += 1) for (let i = this[a].parentNode; i;)e ? L(i).is(e) && t.push(i) : t.push(i), i = i.parentNode; return L(r(t)) }, closest(e) { let t = this; return void 0 === e ? new l([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find(e) { for (var t = [], a = 0; a < this.length; a += 1) for (let i = this[a].querySelectorAll(e), s = 0; s < i.length; s += 1)t.push(i[s]); return new l(t) }, children(e) { for (var t = [], a = 0; a < this.length; a += 1) for (let i = this[a].childNodes, s = 0; s < i.length; s += 1)e ? i[s].nodeType === 1 && L(i[s]).is(e) && t.push(i[s]) : i[s].nodeType === 1 && t.push(i[s]); return new l(r(t)) }, remove() { for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this }, add() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; let a, i; for (a = 0; a < e.length; a += 1) { const s = L(e[a]); for (i = 0; i < s.length; i += 1) this[this.length] = s[i], this.length += 1 } return this }, styles() { return this[0] ? J.getComputedStyle(this[0], null) : {} } }; Object.keys(t).forEach((e) => { L.fn[e] = t[e] }); let e; let a; let i; var ee = { deleteProps(e) { const t = e; Object.keys(t).forEach((e) => { try { t[e] = null } catch (e) {} try { delete t[e] } catch (e) {} }) }, nextTick(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) }, now() { return Date.now() }, getTranslate(e, t) { let a, i, s; void 0 === t && (t = 'x'); const r = J.getComputedStyle(e, null); return J.WebKitCSSMatrix ? ((i = r.transform || r.webkitTransform).split(',').length > 6 && (i = i.split(', ').map((e) => e.replace(',', '.')).join(', ')), s = new J.WebKitCSSMatrix(i === 'none' ? '' : i)) : a = (s = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,')).toString().split(','), t === 'x' && (i = J.WebKitCSSMatrix ? s.m41 : a.length === 16 ? parseFloat(a[12]) : parseFloat(a[4])), t === 'y' && (i = J.WebKitCSSMatrix ? s.m42 : a.length === 16 ? parseFloat(a[13]) : parseFloat(a[5])), i || 0 }, parseUrlQuery(e) { let t; let a; let i; let s; const r = {}; let n = e || J.location.href; if (typeof n === 'string' && n.length) for (s = (a = (n = n.indexOf('?') > -1 ? n.replace(/\S*\?/, '') : '').split('&').filter((e) => e !== '')).length, t = 0; t < s; t += 1)i = a[t].replace(/#\S+/g, '').split('='), r[decodeURIComponent(i[0])] = void 0 === i[1] ? void 0 : decodeURIComponent(i[1]) || ''; return r }, isObject(e) { return typeof e === 'object' && e !== null && e.constructor && e.constructor === Object }, extend() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; for (var a = Object(e[0]), i = 1; i < e.length; i += 1) { const s = e[i]; if (s != null) for (let r = Object.keys(Object(s)), n = 0, o = r.length; n < o; n += 1) { const l = r[n]; const d = Object.getOwnPropertyDescriptor(s, l); void 0 !== d && d.enumerable && (ee.isObject(a[l]) && ee.isObject(s[l]) ? ee.extend(a[l], s[l]) : !ee.isObject(a[l]) && ee.isObject(s[l]) ? (a[l] = {}, ee.extend(a[l], s[l])) : a[l] = s[l]) } } return a } }; const te = (i = f.createElement('div'), { touch: J.Modernizr && !0 === J.Modernizr.touch || !!(J.navigator.maxTouchPoints > 0 || 'ontouchstart' in J || J.DocumentTouch && f instanceof J.DocumentTouch), pointerEvents: !!(J.navigator.pointerEnabled || J.PointerEvent || 'maxTouchPoints' in J.navigator), prefixedPointerEvents: !!J.navigator.msPointerEnabled, transition: (a = i.style, 'transition' in a || 'webkitTransition' in a || 'MozTransition' in a), transforms3d: J.Modernizr && !0 === J.Modernizr.csstransforms3d || (e = i.style, 'webkitPerspective' in e || 'MozPerspective' in e || 'OPerspective' in e || 'MsPerspective' in e || 'perspective' in e), flexbox: (function () { for (let e = i.style, t = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' '), a = 0; a < t.length; a += 1) if (t[a] in e) return !0; return !1 }()), observer: 'MutationObserver' in J || 'WebkitMutationObserver' in J, passiveListener: (function () { let e = !1; try { const t = Object.defineProperty({}, 'passive', { get() { e = !0 } }); J.addEventListener('testPassiveListener', null, t) } catch (e) {} return e }()), gestures: 'ongesturestart' in J }); const s = function (e) { void 0 === e && (e = {}); const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach((e) => { t.on(e, t.params.on[e]) }) }; const n = { components: { configurable: !0 } }; s.prototype.on = function (e, t, a) { const i = this; if (typeof t !== 'function') return i; const s = a ? 'unshift' : 'push'; return e.split(' ').forEach((e) => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][s](t) }), i }, s.prototype.once = function (i, s, e) { const r = this; if (typeof s !== 'function') return r; return r.on(i, function e() { for (var t = [], a = arguments.length; a--;)t[a] = arguments[a]; s.apply(r, t), r.off(i, e) }, e) }, s.prototype.off = function (e, i) { const s = this; return s.eventsListeners && e.split(' ').forEach((a) => { void 0 === i ? s.eventsListeners[a] = [] : s.eventsListeners[a] && s.eventsListeners[a].length && s.eventsListeners[a].forEach((e, t) => { e === i && s.eventsListeners[a].splice(t, 1) }) }), s }, s.prototype.emit = function () { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; let a; let i; let s; const r = this; return r.eventsListeners && (typeof e[0] === 'string' || Array.isArray(e[0]) ? (a = e[0], i = e.slice(1, e.length), s = r) : (a = e[0].events, i = e[0].data, s = e[0].context || r), (Array.isArray(a) ? a : a.split(' ')).forEach((e) => { if (r.eventsListeners && r.eventsListeners[e]) { const t = []; r.eventsListeners[e].forEach((e) => { t.push(e) }), t.forEach((e) => { e.apply(s, i) }) } })), r }, s.prototype.useModulesParams = function (a) { const i = this; i.modules && Object.keys(i.modules).forEach((e) => { const t = i.modules[e]; t.params && ee.extend(a, t.params) }) }, s.prototype.useModules = function (i) { void 0 === i && (i = {}); const s = this; s.modules && Object.keys(s.modules).forEach((e) => { const a = s.modules[e]; const t = i[e] || {}; a.instance && Object.keys(a.instance).forEach((e) => { const t = a.instance[e]; s[e] = typeof t === 'function' ? t.bind(s) : t }), a.on && s.on && Object.keys(a.on).forEach((e) => { s.on(e, a.on[e]) }), a.create && a.create.bind(s)(t) }) }, n.components.set = function (e) { this.use && this.use(e) }, s.installModule = function (t) { for (var e = [], a = arguments.length - 1; a-- > 0;)e[a] = arguments[a + 1]; const i = this; i.prototype.modules || (i.prototype.modules = {}); const s = t.name || `${Object.keys(i.prototype.modules).length}_${ee.now()}`; return (i.prototype.modules[s] = t).proto && Object.keys(t.proto).forEach((e) => { i.prototype[e] = t.proto[e] }), t.static && Object.keys(t.static).forEach((e) => { i[e] = t.static[e] }), t.install && t.install.apply(i, e), i }, s.use = function (e) { for (var t = [], a = arguments.length - 1; a-- > 0;)t[a] = arguments[a + 1]; const i = this; return Array.isArray(e) ? (e.forEach((e) => i.installModule(e)), i) : i.installModule.apply(i, [e].concat(t)) }, Object.defineProperties(s, n); const o = { updateSize() { let e; let t; const a = this; const i = a.$el; e = void 0 !== a.params.width ? a.params.width : i[0].clientWidth, t = void 0 !== a.params.height ? a.params.height : i[0].clientHeight, e === 0 && a.isHorizontal() || t === 0 && a.isVertical() || (e = e - parseInt(i.css('padding-left'), 10) - parseInt(i.css('padding-right'), 10), t = t - parseInt(i.css('padding-top'), 10) - parseInt(i.css('padding-bottom'), 10), ee.extend(a, { width: e, height: t, size: a.isHorizontal() ? e : t })) }, updateSlides() { const e = this; const t = e.params; const a = e.$wrapperEl; const i = e.size; const s = e.rtlTranslate; const r = e.wrongRTL; const n = e.virtual && t.virtual.enabled; const o = n ? e.virtual.slides.length : e.slides.length; const l = a.children(`.${e.params.slideClass}`); const d = n ? e.virtual.slides.length : l.length; let p = []; const c = []; const u = []; let h = t.slidesOffsetBefore; typeof h === 'function' && (h = t.slidesOffsetBefore.call(e)); let v = t.slidesOffsetAfter; typeof v === 'function' && (v = t.slidesOffsetAfter.call(e)); const f = e.snapGrid.length; const m = e.snapGrid.length; let g = t.spaceBetween; let b = -h; let w = 0; let y = 0; if (void 0 !== i) { let x, T; typeof g === 'string' && g.indexOf('%') >= 0 && (g = parseFloat(g.replace('%', '')) / 100 * i), e.virtualSize = -g, s ? l.css({ marginLeft: '', marginTop: '' }) : l.css({ marginRight: '', marginBottom: '' }), t.slidesPerColumn > 1 && (x = Math.floor(d / t.slidesPerColumn) === d / e.params.slidesPerColumn ? d : Math.ceil(d / t.slidesPerColumn) * t.slidesPerColumn, t.slidesPerView !== 'auto' && t.slidesPerColumnFill === 'row' && (x = Math.max(x, t.slidesPerView * t.slidesPerColumn))); for (var E, S = t.slidesPerColumn, C = x / S, M = Math.floor(d / t.slidesPerColumn), k = 0; k < d; k += 1) { T = 0; const P = l.eq(k); if (t.slidesPerColumn > 1) { let z = void 0; let $ = void 0; let L = void 0; t.slidesPerColumnFill === 'column' ? (L = k - ($ = Math.floor(k / S)) * S, (M < $ || $ === M && L === S - 1) && S <= (L += 1) && (L = 0, $ += 1), z = $ + L * x / S, P.css({ '-webkit-box-ordinal-group': z, '-moz-box-ordinal-group': z, '-ms-flex-order': z, '-webkit-order': z, order: z })) : $ = k - (L = Math.floor(k / C)) * C, P.css(`margin-${e.isHorizontal() ? 'top' : 'left'}`, L !== 0 && t.spaceBetween && `${t.spaceBetween}px`).attr('data-swiper-column', $).attr('data-swiper-row', L) } if (P.css('display') !== 'none') { if (t.slidesPerView === 'auto') { const I = J.getComputedStyle(P[0], null); const D = P[0].style.transform; const O = P[0].style.webkitTransform; if (D && (P[0].style.transform = 'none'), O && (P[0].style.webkitTransform = 'none'), t.roundLengths)T = e.isHorizontal() ? P.outerWidth(!0) : P.outerHeight(!0); else if (e.isHorizontal()) { const A = parseFloat(I.getPropertyValue('width')); const N = parseFloat(I.getPropertyValue('padding-left')); const H = parseFloat(I.getPropertyValue('padding-right')); const G = parseFloat(I.getPropertyValue('margin-left')); const B = parseFloat(I.getPropertyValue('margin-right')); const X = I.getPropertyValue('box-sizing'); T = X && X === 'border-box' ? A + G + B : A + N + H + G + B } else { const Y = parseFloat(I.getPropertyValue('height')); const V = parseFloat(I.getPropertyValue('padding-top')); const F = parseFloat(I.getPropertyValue('padding-bottom')); const R = parseFloat(I.getPropertyValue('margin-top')); const q = parseFloat(I.getPropertyValue('margin-bottom')); const W = I.getPropertyValue('box-sizing'); T = W && W === 'border-box' ? Y + R + q : Y + V + F + R + q }D && (P[0].style.transform = D), O && (P[0].style.webkitTransform = O), t.roundLengths && (T = Math.floor(T)) } else T = (i - (t.slidesPerView - 1) * g) / t.slidesPerView, t.roundLengths && (T = Math.floor(T)), l[k] && (e.isHorizontal() ? l[k].style.width = `${T}px` : l[k].style.height = `${T}px`); l[k] && (l[k].swiperSlideSize = T), u.push(T), t.centeredSlides ? (b = b + T / 2 + w / 2 + g, w === 0 && k !== 0 && (b = b - i / 2 - g), k === 0 && (b = b - i / 2 - g), Math.abs(b) < 0.001 && (b = 0), t.roundLengths && (b = Math.floor(b)), y % t.slidesPerGroup == 0 && p.push(b), c.push(b)) : (t.roundLengths && (b = Math.floor(b)), y % t.slidesPerGroup == 0 && p.push(b), c.push(b), b = b + T + g), e.virtualSize += T + g, w = T, y += 1 } } if (e.virtualSize = Math.max(e.virtualSize, i) + v, s && r && (t.effect === 'slide' || t.effect === 'coverflow') && a.css({ width: `${e.virtualSize + t.spaceBetween}px` }), te.flexbox && !t.setWrapperSize || (e.isHorizontal() ? a.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : a.css({ height: `${e.virtualSize + t.spaceBetween}px` })), t.slidesPerColumn > 1 && (e.virtualSize = (T + t.spaceBetween) * x, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? a.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : a.css({ height: `${e.virtualSize + t.spaceBetween}px` }), t.centeredSlides)) { E = []; for (let j = 0; j < p.length; j += 1) { let U = p[j]; t.roundLengths && (U = Math.floor(U)), p[j] < e.virtualSize + p[0] && E.push(U) }p = E } if (!t.centeredSlides) { E = []; for (let K = 0; K < p.length; K += 1) { let _ = p[K]; t.roundLengths && (_ = Math.floor(_)), p[K] <= e.virtualSize - i && E.push(_) }p = E, Math.floor(e.virtualSize - i) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - i) } if (p.length === 0 && (p = [0]), t.spaceBetween !== 0 && (e.isHorizontal() ? s ? l.css({ marginLeft: `${g}px` }) : l.css({ marginRight: `${g}px` }) : l.css({ marginBottom: `${g}px` })), t.centerInsufficientSlides) { let Z = 0; if (u.forEach((e) => { Z += e + (t.spaceBetween ? t.spaceBetween : 0) }), (Z -= t.spaceBetween) < i) { const Q = (i - Z) / 2; p.forEach((e, t) => { p[t] = e - Q }), c.forEach((e, t) => { c[t] = e + Q }) } }ee.extend(e, { slides: l, snapGrid: p, slidesGrid: c, slidesSizesGrid: u }), d !== o && e.emit('slidesLengthChange'), p.length !== f && (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')), c.length !== m && e.emit('slidesGridLengthChange'), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset() } }, updateAutoHeight(e) { let t; const a = this; const i = []; let s = 0; if (typeof e === 'number' ? a.setTransition(e) : !0 === e && a.setTransition(a.params.speed), a.params.slidesPerView !== 'auto' && a.params.slidesPerView > 1) for (t = 0; t < Math.ceil(a.params.slidesPerView); t += 1) { const r = a.activeIndex + t; if (r > a.slides.length) break; i.push(a.slides.eq(r)[0]) } else i.push(a.slides.eq(a.activeIndex)[0]); for (t = 0; t < i.length; t += 1) if (void 0 !== i[t]) { const n = i[t].offsetHeight; s = s < n ? n : s }s && a.$wrapperEl.css('height', `${s}px`) }, updateSlidesOffset() { for (let e = this.slides, t = 0; t < e.length; t += 1)e[t].swiperSlideOffset = this.isHorizontal() ? e[t].offsetLeft : e[t].offsetTop }, updateSlidesProgress(e) { void 0 === e && (e = this && this.translate || 0); const t = this; const a = t.params; const i = t.slides; const s = t.rtlTranslate; if (i.length !== 0) { void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset(); let r = -e; s && (r = e), i.removeClass(a.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let n = 0; n < i.length; n += 1) { const o = i[n]; const l = (r + (a.centeredSlides ? t.minTranslate() : 0) - o.swiperSlideOffset) / (o.swiperSlideSize + a.spaceBetween); if (a.watchSlidesVisibility) { const d = -(r - o.swiperSlideOffset); const p = d + t.slidesSizesGrid[n]; (d >= 0 && d < t.size || p > 0 && p <= t.size || d <= 0 && p >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(n), i.eq(n).addClass(a.slideVisibleClass)) }o.progress = s ? -l : l }t.visibleSlides = L(t.visibleSlides) } }, updateProgress(e) { void 0 === e && (e = this && this.translate || 0); const t = this; const a = t.params; const i = t.maxTranslate() - t.minTranslate(); let s = t.progress; let r = t.isBeginning; let n = t.isEnd; const o = r; const l = n; i === 0 ? n = r = !(s = 0) : (r = (s = (e - t.minTranslate()) / i) <= 0, n = s >= 1), ee.extend(t, { progress: s, isBeginning: r, isEnd: n }), (a.watchSlidesProgress || a.watchSlidesVisibility) && t.updateSlidesProgress(e), r && !o && t.emit('reachBeginning toEdge'), n && !l && t.emit('reachEnd toEdge'), (o && !r || l && !n) && t.emit('fromEdge'), t.emit('progress', s) }, updateSlidesClasses() { let e; const t = this; const a = t.slides; const i = t.params; const s = t.$wrapperEl; const r = t.activeIndex; const n = t.realIndex; const o = t.virtual && i.virtual.enabled; a.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), (e = o ? t.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${r}"]`) : a.eq(r)).addClass(i.slideActiveClass), i.loop && (e.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${n}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${n}"]`).addClass(i.slideDuplicateActiveClass)); let l = e.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && l.length === 0 && (l = a.eq(0)).addClass(i.slideNextClass); let d = e.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && d.length === 0 && (d = a.eq(-1)).addClass(i.slidePrevClass), i.loop && (l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicateNextClass), d.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${d.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${d.attr('data-swiper-slide-index')}"]`).addClass(i.slideDuplicatePrevClass)) }, updateActiveIndex(e) { let t; const a = this; const i = a.rtlTranslate ? a.translate : -a.translate; const s = a.slidesGrid; const r = a.snapGrid; const n = a.params; const o = a.activeIndex; const l = a.realIndex; const d = a.snapIndex; let p = e; if (void 0 === p) { for (let c = 0; c < s.length; c += 1) void 0 !== s[c + 1] ? i >= s[c] && i < s[c + 1] - (s[c + 1] - s[c]) / 2 ? p = c : i >= s[c] && i < s[c + 1] && (p = c + 1) : i >= s[c] && (p = c); n.normalizeSlideIndex && (p < 0 || void 0 === p) && (p = 0) } if ((t = r.indexOf(i) >= 0 ? r.indexOf(i) : Math.floor(p / n.slidesPerGroup)) >= r.length && (t = r.length - 1), p !== o) { const u = parseInt(a.slides.eq(p).attr('data-swiper-slide-index') || p, 10); ee.extend(a, { snapIndex: t, realIndex: u, previousIndex: o, activeIndex: p }), a.emit('activeIndexChange'), a.emit('snapIndexChange'), l !== u && a.emit('realIndexChange'), a.emit('slideChange') } else t !== d && (a.snapIndex = t, a.emit('snapIndexChange')) }, updateClickedSlide(e) { const t = this; const a = t.params; const i = L(e.target).closest(`.${a.slideClass}`)[0]; let s = !1; if (i) for (let r = 0; r < t.slides.length; r += 1)t.slides[r] === i && (s = !0); if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(L(i).attr('data-swiper-slide-index'), 10) : t.clickedIndex = L(i).index(), a.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; const d = { getTranslate(e) { void 0 === e && (e = this.isHorizontal() ? 'x' : 'y'); const t = this.params; const a = this.rtlTranslate; const i = this.translate; const s = this.$wrapperEl; if (t.virtualTranslate) return a ? -i : i; let r = ee.getTranslate(s[0], e); return a && (r = -r), r || 0 }, setTranslate(e, t) { const a = this; const i = a.rtlTranslate; const s = a.params; const r = a.$wrapperEl; const n = a.progress; let o = 0; let l = 0; a.isHorizontal() ? o = i ? -e : e : l = e, s.roundLengths && (o = Math.floor(o), l = Math.floor(l)), s.virtualTranslate || (te.transforms3d ? r.transform(`translate3d(${o}px, ${l}px, 0px)`) : r.transform(`translate(${o}px, ${l}px)`)), a.previousTranslate = a.translate, a.translate = a.isHorizontal() ? o : l; const d = a.maxTranslate() - a.minTranslate(); (d === 0 ? 0 : (e - a.minTranslate()) / d) !== n && a.updateProgress(e), a.emit('setTranslate', a.translate, t) }, minTranslate() { return -this.snapGrid[0] }, maxTranslate() { return -this.snapGrid[this.snapGrid.length - 1] } }; const p = { setTransition(e, t) { this.$wrapperEl.transition(e), this.emit('setTransition', e, t) }, transitionStart(e, t) { void 0 === e && (e = !0); const a = this; const i = a.activeIndex; const s = a.params; const r = a.previousIndex; s.autoHeight && a.updateAutoHeight(); let n = t; if (n || (n = r < i ? 'next' : i < r ? 'prev' : 'reset'), a.emit('transitionStart'), e && i !== r) { if (n === 'reset') return void a.emit('slideResetTransitionStart'); a.emit('slideChangeTransitionStart'), n === 'next' ? a.emit('slideNextTransitionStart') : a.emit('slidePrevTransitionStart') } }, transitionEnd(e, t) { void 0 === e && (e = !0); const a = this; const i = a.activeIndex; const s = a.previousIndex; a.animating = !1, a.setTransition(0); let r = t; if (r || (r = s < i ? 'next' : i < s ? 'prev' : 'reset'), a.emit('transitionEnd'), e && i !== s) { if (r === 'reset') return void a.emit('slideResetTransitionEnd'); a.emit('slideChangeTransitionEnd'), r === 'next' ? a.emit('slideNextTransitionEnd') : a.emit('slidePrevTransitionEnd') } } }; const c = { slideTo(e, t, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0); const s = this; let r = e; r < 0 && (r = 0); const n = s.params; const o = s.snapGrid; const l = s.slidesGrid; const d = s.previousIndex; const p = s.activeIndex; const c = s.rtlTranslate; if (s.animating && n.preventInteractionOnTransition) return !1; let u = Math.floor(r / n.slidesPerGroup); u >= o.length && (u = o.length - 1), (p || n.initialSlide || 0) === (d || 0) && a && s.emit('beforeSlideChangeStart'); let h; const v = -o[u]; if (s.updateProgress(v), n.normalizeSlideIndex) for (let f = 0; f < l.length; f += 1)-Math.floor(100 * v) >= Math.floor(100 * l[f]) && (r = f); if (s.initialized && r !== p) { if (!s.allowSlideNext && v < s.translate && v < s.minTranslate()) return !1; if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (p || 0) !== r) return !1 } return h = p < r ? 'next' : r < p ? 'prev' : 'reset', c && -v === s.translate || !c && v === s.translate ? (s.updateActiveIndex(r), n.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), n.effect !== 'slide' && s.setTranslate(v), h !== 'reset' && (s.transitionStart(a, h), s.transitionEnd(a, h)), !1) : (t !== 0 && te.transition ? (s.setTransition(t), s.setTranslate(v), s.updateActiveIndex(r), s.updateSlidesClasses(), s.emit('beforeTransitionStart', t, i), s.transitionStart(a, h), s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.$wrapperEl[0].removeEventListener('transitionend', s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener('webkitTransitionEnd', s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(a, h)) }), s.$wrapperEl[0].addEventListener('transitionend', s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener('webkitTransitionEnd', s.onSlideToWrapperTransitionEnd))) : (s.setTransition(0), s.setTranslate(v), s.updateActiveIndex(r), s.updateSlidesClasses(), s.emit('beforeTransitionStart', t, i), s.transitionStart(a, h), s.transitionEnd(a, h)), !0) }, slideToLoop(e, t, a, i) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === a && (a = !0); let s = e; return this.params.loop && (s += this.loopedSlides), this.slideTo(s, t, a, i) }, slideNext(e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this; const s = i.params; const r = i.animating; return s.loop ? !r && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, i.slideTo(i.activeIndex + s.slidesPerGroup, e, t, a)) : i.slideTo(i.activeIndex + s.slidesPerGroup, e, t, a) }, slidePrev(e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this; const s = i.params; const r = i.animating; const n = i.snapGrid; const o = i.slidesGrid; const l = i.rtlTranslate; if (s.loop) { if (r) return !1; i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } let p; const c = d(l ? i.translate : -i.translate); const u = n.map((e) => d(e)); const h = (o.map((e) => d(e)), n[u.indexOf(c)], n[u.indexOf(c) - 1]); return void 0 !== h && (p = o.indexOf(h)) < 0 && (p = i.activeIndex - 1), i.slideTo(p, e, t, a) }, slideReset(e, t, a) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, a) }, slideToClosest(e, t, a) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this; let s = i.activeIndex; const r = Math.floor(s / i.params.slidesPerGroup); if (r < i.snapGrid.length - 1) { const n = i.rtlTranslate ? i.translate : -i.translate; const o = i.snapGrid[r]; (i.snapGrid[r + 1] - o) / 2 < n - o && (s = i.params.slidesPerGroup) } return i.slideTo(s, e, t, a) }, slideToClickedSlide() { let e; const t = this; const a = t.params; const i = t.$wrapperEl; const s = a.slidesPerView === 'auto' ? t.slidesPerViewDynamic() : a.slidesPerView; let r = t.clickedIndex; if (a.loop) { if (t.animating) return; e = parseInt(L(t.clickedSlide).attr('data-swiper-slide-index'), 10), a.centeredSlides ? r < t.loopedSlides - s / 2 || r > t.slides.length - t.loopedSlides + s / 2 ? (t.loopFix(), r = i.children(`.${a.slideClass}[data-swiper-slide-index="${e}"]:not(.${a.slideDuplicateClass})`).eq(0).index(), ee.nextTick(() => { t.slideTo(r) })) : t.slideTo(r) : r > t.slides.length - s ? (t.loopFix(), r = i.children(`.${a.slideClass}[data-swiper-slide-index="${e}"]:not(.${a.slideDuplicateClass})`).eq(0).index(), ee.nextTick(() => { t.slideTo(r) })) : t.slideTo(r) } else t.slideTo(r) } }; const u = { loopCreate() { const i = this; const e = i.params; const t = i.$wrapperEl; t.children(`.${e.slideClass}.${e.slideDuplicateClass}`).remove(); let s = t.children(`.${e.slideClass}`); if (e.loopFillGroupWithBlank) { const a = e.slidesPerGroup - s.length % e.slidesPerGroup; if (a !== e.slidesPerGroup) { for (let r = 0; r < a; r += 1) { const n = L(f.createElement('div')).addClass(`${e.slideClass} ${e.slideBlankClass}`); t.append(n) }s = t.children(`.${e.slideClass}`) } }e.slidesPerView !== 'auto' || e.loopedSlides || (e.loopedSlides = s.length), i.loopedSlides = parseInt(e.loopedSlides || e.slidesPerView, 10), i.loopedSlides += e.loopAdditionalSlides, i.loopedSlides > s.length && (i.loopedSlides = s.length); const o = []; const l = []; s.each((e, t) => { const a = L(t); e < i.loopedSlides && l.push(t), e < s.length && e >= s.length - i.loopedSlides && o.push(t), a.attr('data-swiper-slide-index', e) }); for (let d = 0; d < l.length; d += 1)t.append(L(l[d].cloneNode(!0)).addClass(e.slideDuplicateClass)); for (let p = o.length - 1; p >= 0; p -= 1)t.prepend(L(o[p].cloneNode(!0)).addClass(e.slideDuplicateClass)) }, loopFix() { let e; const t = this; const a = t.params; const i = t.activeIndex; const s = t.slides; const r = t.loopedSlides; const n = t.allowSlidePrev; const o = t.allowSlideNext; const l = t.snapGrid; const d = t.rtlTranslate; t.allowSlidePrev = !0, t.allowSlideNext = !0; const p = -l[i] - t.getTranslate(); i < r ? (e = s.length - 3 * r + i, e += r, t.slideTo(e, 0, !1, !0) && p !== 0 && t.setTranslate((d ? -t.translate : t.translate) - p)) : (a.slidesPerView === 'auto' && 2 * r <= i || i >= s.length - r) && (e = -s.length + i + r, e += r, t.slideTo(e, 0, !1, !0) && p !== 0 && t.setTranslate((d ? -t.translate : t.translate) - p)); t.allowSlidePrev = n, t.allowSlideNext = o }, loopDestroy() { const e = this.$wrapperEl; const t = this.params; const a = this.slides; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), a.removeAttr('data-swiper-slide-index') } }; const h = { setGrabCursor(e) { if (!(te.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked)) { const t = this.el; t.style.cursor = 'move', t.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab', t.style.cursor = e ? '-moz-grabbin' : '-moz-grab', t.style.cursor = e ? 'grabbing' : 'grab' } }, unsetGrabCursor() { te.touch || this.params.watchOverflow && this.isLocked || (this.el.style.cursor = '') } }; const v = { appendSlide(e) { const t = this; const a = t.$wrapperEl; const i = t.params; if (i.loop && t.loopDestroy(), typeof e === 'object' && 'length' in e) for (let s = 0; s < e.length; s += 1)e[s] && a.append(e[s]); else a.append(e); i.loop && t.loopCreate(), i.observer && te.observer || t.update() }, prependSlide(e) { const t = this; const a = t.params; const i = t.$wrapperEl; const s = t.activeIndex; a.loop && t.loopDestroy(); let r = s + 1; if (typeof e === 'object' && 'length' in e) { for (let n = 0; n < e.length; n += 1)e[n] && i.prepend(e[n]); r = s + e.length } else i.prepend(e); a.loop && t.loopCreate(), a.observer && te.observer || t.update(), t.slideTo(r, 0, !1) }, addSlide(e, t) { const a = this; const i = a.$wrapperEl; const s = a.params; let r = a.activeIndex; s.loop && (r -= a.loopedSlides, a.loopDestroy(), a.slides = i.children(`.${s.slideClass}`)); const n = a.slides.length; if (e <= 0)a.prependSlide(t); else if (n <= e)a.appendSlide(t); else { for (var o = e < r ? r + 1 : r, l = [], d = n - 1; e <= d; d -= 1) { const p = a.slides.eq(d); p.remove(), l.unshift(p) } if (typeof t === 'object' && 'length' in t) { for (let c = 0; c < t.length; c += 1)t[c] && i.append(t[c]); o = e < r ? r + t.length : r } else i.append(t); for (let u = 0; u < l.length; u += 1)i.append(l[u]); s.loop && a.loopCreate(), s.observer && te.observer || a.update(), s.loop ? a.slideTo(o + a.loopedSlides, 0, !1) : a.slideTo(o, 0, !1) } }, removeSlide(e) { const t = this; const a = t.params; const i = t.$wrapperEl; let s = t.activeIndex; a.loop && (s -= t.loopedSlides, t.loopDestroy(), t.slides = i.children(`.${a.slideClass}`)); let r; let n = s; if (typeof e === 'object' && 'length' in e) { for (let o = 0; o < e.length; o += 1)r = e[o], t.slides[r] && t.slides.eq(r).remove(), r < n && (n -= 1); n = Math.max(n, 0) } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < n && (n -= 1), n = Math.max(n, 0); a.loop && t.loopCreate(), a.observer && te.observer || t.update(), a.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1) }, removeAllSlides() { for (var e = [], t = 0; t < this.slides.length; t += 1)e.push(t); this.removeSlide(e) } }; const m = (function () { const e = J.navigator.userAgent; const t = { ios: !1, android: !1, androidChrome: !1, desktop: !1, windows: !1, iphone: !1, ipod: !1, ipad: !1, cordova: J.cordova || J.phonegap, phonegap: J.cordova || J.phonegap }; const a = e.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); const i = e.match(/(Android);?[\s\/]+([\d.]+)?/); const s = e.match(/(iPad).*OS\s([\d_]+)/); const r = e.match(/(iPod)(.*OS\s([\d_]+))?/); const n = !s && e.match(/(iPhone\sOS|iOS)\s([\d_]+)/); if (a && (t.os = 'windows', t.osVersion = a[2], t.windows = !0), i && !a && (t.os = 'android', t.osVersion = i[2], t.android = !0, t.androidChrome = e.toLowerCase().indexOf('chrome') >= 0), (s || n || r) && (t.os = 'ios', t.ios = !0), n && !r && (t.osVersion = n[2].replace(/_/g, '.'), t.iphone = !0), s && (t.osVersion = s[2].replace(/_/g, '.'), t.ipad = !0), r && (t.osVersion = r[3] ? r[3].replace(/_/g, '.') : null, t.iphone = !0), t.ios && t.osVersion && e.indexOf('Version/') >= 0 && t.osVersion.split('.')[0] === '10' && (t.osVersion = e.toLowerCase().split('version/')[1].split(' ')[0]), t.desktop = !(t.os || t.android || t.webView), t.webView = (n || s || r) && e.match(/.*AppleWebKit(?!.*Safari)/i), t.os && t.os === 'ios') { const o = t.osVersion.split('.'); const l = f.querySelector('meta[name="viewport"]'); t.minimalUi = !t.webView && (r || n) && (1 * o[0] == 7 ? 1 * o[1] >= 1 : 1 * o[0] > 7) && l && l.getAttribute('content').indexOf('minimal-ui') >= 0 } return t.pixelRatio = J.devicePixelRatio || 1, t }()); function g() { const e = this; const t = e.params; const a = e.el; if (!a || a.offsetWidth !== 0) { t.breakpoints && e.setBreakpoint(); const i = e.allowSlideNext; const s = e.allowSlidePrev; const r = e.snapGrid; if (e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), t.freeMode) { const n = Math.min(Math.max(e.translate, e.maxTranslate()), e.minTranslate()); e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses(), t.autoHeight && e.updateAutoHeight() } else e.updateSlidesClasses(), (t.slidesPerView === 'auto' || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0); e.allowSlidePrev = s, e.allowSlideNext = i, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } } const b = { attachEvents() { const e = this; const t = e.params; const a = e.touchEvents; const i = e.el; const s = e.wrapperEl; e.onTouchStart = function (e) { const t = this; const a = t.touchEventsData; const i = t.params; const s = t.touches; if (!t.animating || !i.preventInteractionOnTransition) { let r = e; if (r.originalEvent && (r = r.originalEvent), a.isTouchEvent = r.type === 'touchstart', (a.isTouchEvent || !('which' in r) || r.which !== 3) && !(!a.isTouchEvent && 'button' in r && r.button > 0 || a.isTouched && a.isMoved)) if (i.noSwiping && L(r.target).closest(i.noSwipingSelector ? i.noSwipingSelector : `.${i.noSwipingClass}`)[0])t.allowClick = !0; else if (!i.swipeHandler || L(r).closest(i.swipeHandler)[0]) { s.currentX = r.type === 'touchstart' ? r.targetTouches[0].pageX : r.pageX, s.currentY = r.type === 'touchstart' ? r.targetTouches[0].pageY : r.pageY; const n = s.currentX; const o = s.currentY; const l = i.edgeSwipeDetection || i.iOSEdgeSwipeDetection; const d = i.edgeSwipeThreshold || i.iOSEdgeSwipeThreshold; if (!l || !(n <= d || n >= J.screen.width - d)) { if (ee.extend(a, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), s.startX = n, s.startY = o, a.touchStartTime = ee.now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, i.threshold > 0 && (a.allowThresholdMove = !1), r.type !== 'touchstart') { let p = !0; L(r.target).is(a.formElements) && (p = !1), f.activeElement && L(f.activeElement).is(a.formElements) && f.activeElement !== r.target && f.activeElement.blur(); const c = p && t.allowTouchMove && i.touchStartPreventDefault; (i.touchStartForcePreventDefault || c) && r.preventDefault() }t.emit('touchStart', r) } } } }.bind(e), e.onTouchMove = function (e) { const t = this; const a = t.touchEventsData; const i = t.params; const s = t.touches; const r = t.rtlTranslate; let n = e; if (n.originalEvent && (n = n.originalEvent), a.isTouched) { if (!a.isTouchEvent || n.type !== 'mousemove') { const o = n.type === 'touchmove' ? n.targetTouches[0].pageX : n.pageX; const l = n.type === 'touchmove' ? n.targetTouches[0].pageY : n.pageY; if (n.preventedByNestedSwiper) return s.startX = o, void (s.startY = l); if (!t.allowTouchMove) return t.allowClick = !1, void (a.isTouched && (ee.extend(s, { startX: o, startY: l, currentX: o, currentY: l }), a.touchStartTime = ee.now())); if (a.isTouchEvent && i.touchReleaseOnEdges && !i.loop) if (t.isVertical()) { if (l < s.startY && t.translate <= t.maxTranslate() || l > s.startY && t.translate >= t.minTranslate()) return a.isTouched = !1, void (a.isMoved = !1) } else if (o < s.startX && t.translate <= t.maxTranslate() || o > s.startX && t.translate >= t.minTranslate()) return; if (a.isTouchEvent && f.activeElement && n.target === f.activeElement && L(n.target).is(a.formElements)) return a.isMoved = !0, void (t.allowClick = !1); if (a.allowTouchCallbacks && t.emit('touchMove', n), !(n.targetTouches && n.targetTouches.length > 1)) { s.currentX = o, s.currentY = l; let d; const p = s.currentX - s.startX; const c = s.currentY - s.startY; if (!(t.params.threshold && Math.sqrt(Math.pow(p, 2) + Math.pow(c, 2)) < t.params.threshold)) if (void 0 === a.isScrolling && (t.isHorizontal() && s.currentY === s.startY || t.isVertical() && s.currentX === s.startX ? a.isScrolling = !1 : p * p + c * c >= 25 && (d = 180 * Math.atan2(Math.abs(c), Math.abs(p)) / Math.PI, a.isScrolling = t.isHorizontal() ? d > i.touchAngle : 90 - d > i.touchAngle)), a.isScrolling && t.emit('touchMoveOpposite', n), void 0 === a.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (a.startMoving = !0)), a.isScrolling)a.isTouched = !1; else if (a.startMoving) { t.allowClick = !1, n.preventDefault(), i.touchMoveStopPropagation && !i.nested && n.stopPropagation(), a.isMoved || (i.loop && t.loopFix(), a.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger('webkitTransitionEnd transitionend'), a.allowMomentumBounce = !1, !i.grabCursor || !0 !== t.allowSlideNext && !0 !== t.allowSlidePrev || t.setGrabCursor(!0), t.emit('sliderFirstMove', n)), t.emit('sliderMove', n), a.isMoved = !0; let u = t.isHorizontal() ? p : c; s.diff = u, u *= i.touchRatio, r && (u = -u), t.swipeDirection = u > 0 ? 'prev' : 'next', a.currentTranslate = u + a.startTranslate; let h = !0; let v = i.resistanceRatio; if (i.touchReleaseOnEdges && (v = 0), u > 0 && a.currentTranslate > t.minTranslate() ? (h = !1, i.resistance && (a.currentTranslate = t.minTranslate() - 1 + Math.pow(-t.minTranslate() + a.startTranslate + u, v))) : u < 0 && a.currentTranslate < t.maxTranslate() && (h = !1, i.resistance && (a.currentTranslate = t.maxTranslate() + 1 - Math.pow(t.maxTranslate() - a.startTranslate - u, v))), h && (n.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === 'next' && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !t.allowSlidePrev && t.swipeDirection === 'prev' && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), i.threshold > 0) { if (!(Math.abs(u) > i.threshold || a.allowThresholdMove)) return void (a.currentTranslate = a.startTranslate); if (!a.allowThresholdMove) return a.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, a.currentTranslate = a.startTranslate, void (s.diff = t.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY) }i.followFinger && ((i.freeMode || i.watchSlidesProgress || i.watchSlidesVisibility) && (t.updateActiveIndex(), t.updateSlidesClasses()), i.freeMode && (a.velocities.length === 0 && a.velocities.push({ position: s[t.isHorizontal() ? 'startX' : 'startY'], time: a.touchStartTime }), a.velocities.push({ position: s[t.isHorizontal() ? 'currentX' : 'currentY'], time: ee.now() })), t.updateProgress(a.currentTranslate), t.setTranslate(a.currentTranslate)) } } } } else a.startMoving && a.isScrolling && t.emit('touchMoveOpposite', n) }.bind(e), e.onTouchEnd = function (e) { const t = this; const a = t.touchEventsData; const i = t.params; const s = t.touches; const r = t.rtlTranslate; const n = t.$wrapperEl; const o = t.slidesGrid; const l = t.snapGrid; let d = e; if (d.originalEvent && (d = d.originalEvent), a.allowTouchCallbacks && t.emit('touchEnd', d), a.allowTouchCallbacks = !1, !a.isTouched) return a.isMoved && i.grabCursor && t.setGrabCursor(!1), a.isMoved = !1, void (a.startMoving = !1); i.grabCursor && a.isMoved && a.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); let p; const c = ee.now(); const u = c - a.touchStartTime; if (t.allowClick && (t.updateClickedSlide(d), t.emit('tap', d), u < 300 && c - a.lastClickTime > 300 && (a.clickTimeout && clearTimeout(a.clickTimeout), a.clickTimeout = ee.nextTick(() => { t && !t.destroyed && t.emit('click', d) }, 300)), u < 300 && c - a.lastClickTime < 300 && (a.clickTimeout && clearTimeout(a.clickTimeout), t.emit('doubleTap', d))), a.lastClickTime = ee.now(), ee.nextTick(() => { t.destroyed || (t.allowClick = !0) }), !a.isTouched || !a.isMoved || !t.swipeDirection || s.diff === 0 || a.currentTranslate === a.startTranslate) return a.isTouched = !1, a.isMoved = !1, void (a.startMoving = !1); if (a.isTouched = !1, a.isMoved = !1, a.startMoving = !1, p = i.followFinger ? r ? t.translate : -t.translate : -a.currentTranslate, i.freeMode) { if (p < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (p > -t.maxTranslate()) return void (t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1)); if (i.freeModeMomentum) { if (a.velocities.length > 1) { const h = a.velocities.pop(); const v = a.velocities.pop(); const f = h.position - v.position; const m = h.time - v.time; t.velocity = f / m, t.velocity /= 2, Math.abs(t.velocity) < i.freeModeMinimumVelocity && (t.velocity = 0), (m > 150 || ee.now() - h.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= i.freeModeMomentumVelocityRatio, a.velocities.length = 0; let g = 1e3 * i.freeModeMomentumRatio; const b = t.velocity * g; let w = t.translate + b; r && (w = -w); let y; let x; let T = !1; const E = 20 * Math.abs(t.velocity) * i.freeModeMomentumBounceRatio; if (w < t.maxTranslate())i.freeModeMomentumBounce ? (w + t.maxTranslate() < -E && (w = t.maxTranslate() - E), y = t.maxTranslate(), T = !0, a.allowMomentumBounce = !0) : w = t.maxTranslate(), i.loop && i.centeredSlides && (x = !0); else if (w > t.minTranslate())i.freeModeMomentumBounce ? (w - t.minTranslate() > E && (w = t.minTranslate() + E), y = t.minTranslate(), T = !0, a.allowMomentumBounce = !0) : w = t.minTranslate(), i.loop && i.centeredSlides && (x = !0); else if (i.freeModeSticky) { for (var S, C = 0; C < l.length; C += 1) if (l[C] > -w) { S = C; break }w = -(w = Math.abs(l[S] - w) < Math.abs(l[S - 1] - w) || t.swipeDirection === 'next' ? l[S] : l[S - 1]) } if (x && t.once('transitionEnd', () => { t.loopFix() }), t.velocity !== 0)g = r ? Math.abs((-w - t.translate) / t.velocity) : Math.abs((w - t.translate) / t.velocity); else if (i.freeModeSticky) return void t.slideToClosest(); i.freeModeMomentumBounce && T ? (t.updateProgress(y), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd(() => { t && !t.destroyed && a.allowMomentumBounce && (t.emit('momentumBounce'), t.setTransition(i.speed), t.setTranslate(y), n.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() })) })) : t.velocity ? (t.updateProgress(w), t.setTransition(g), t.setTranslate(w), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(w), t.updateActiveIndex(), t.updateSlidesClasses() } else if (i.freeModeSticky) return void t.slideToClosest(); (!i.freeModeMomentum || u >= i.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()) } else { for (var M = 0, k = t.slidesSizesGrid[0], P = 0; P < o.length; P += i.slidesPerGroup) void 0 !== o[P + i.slidesPerGroup] ? p >= o[P] && p < o[P + i.slidesPerGroup] && (k = o[(M = P) + i.slidesPerGroup] - o[P]) : p >= o[P] && (M = P, k = o[o.length - 1] - o[o.length - 2]); const z = (p - o[M]) / k; if (u > i.longSwipesMs) { if (!i.longSwipes) return void t.slideTo(t.activeIndex); t.swipeDirection === 'next' && (z >= i.longSwipesRatio ? t.slideTo(M + i.slidesPerGroup) : t.slideTo(M)), t.swipeDirection === 'prev' && (z > 1 - i.longSwipesRatio ? t.slideTo(M + i.slidesPerGroup) : t.slideTo(M)) } else { if (!i.shortSwipes) return void t.slideTo(t.activeIndex); t.swipeDirection === 'next' && t.slideTo(M + i.slidesPerGroup), t.swipeDirection === 'prev' && t.slideTo(M) } } }.bind(e), e.onClick = function (e) { this.allowClick || (this.params.preventClicks && e.preventDefault(), this.params.preventClicksPropagation && this.animating && (e.stopPropagation(), e.stopImmediatePropagation())) }.bind(e); const r = t.touchEventsTarget === 'container' ? i : s; const n = !!t.nested; if (te.touch || !te.pointerEvents && !te.prefixedPointerEvents) { if (te.touch) { const o = !(a.start !== 'touchstart' || !te.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; r.addEventListener(a.start, e.onTouchStart, o), r.addEventListener(a.move, e.onTouchMove, te.passiveListener ? { passive: !1, capture: n } : n), r.addEventListener(a.end, e.onTouchEnd, o) }(t.simulateTouch && !m.ios && !m.android || t.simulateTouch && !te.touch && m.ios) && (r.addEventListener('mousedown', e.onTouchStart, !1), f.addEventListener('mousemove', e.onTouchMove, n), f.addEventListener('mouseup', e.onTouchEnd, !1)) } else r.addEventListener(a.start, e.onTouchStart, !1), f.addEventListener(a.move, e.onTouchMove, n), f.addEventListener(a.end, e.onTouchEnd, !1); (t.preventClicks || t.preventClicksPropagation) && r.addEventListener('click', e.onClick, !0), e.on(m.ios || m.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', g, !0) }, detachEvents() { const e = this; const t = e.params; const a = e.touchEvents; const i = e.el; const s = e.wrapperEl; const r = t.touchEventsTarget === 'container' ? i : s; const n = !!t.nested; if (te.touch || !te.pointerEvents && !te.prefixedPointerEvents) { if (te.touch) { const o = !(a.start !== 'onTouchStart' || !te.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; r.removeEventListener(a.start, e.onTouchStart, o), r.removeEventListener(a.move, e.onTouchMove, n), r.removeEventListener(a.end, e.onTouchEnd, o) }(t.simulateTouch && !m.ios && !m.android || t.simulateTouch && !te.touch && m.ios) && (r.removeEventListener('mousedown', e.onTouchStart, !1), f.removeEventListener('mousemove', e.onTouchMove, n), f.removeEventListener('mouseup', e.onTouchEnd, !1)) } else r.removeEventListener(a.start, e.onTouchStart, !1), f.removeEventListener(a.move, e.onTouchMove, n), f.removeEventListener(a.end, e.onTouchEnd, !1); (t.preventClicks || t.preventClicksPropagation) && r.removeEventListener('click', e.onClick, !0), e.off(m.ios || m.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', g) } }; let w; const y = { setBreakpoint() { const e = this; const t = e.activeIndex; const a = e.initialized; let i = e.loopedSlides; void 0 === i && (i = 0); const s = e.params; const r = s.breakpoints; if (r && (!r || Object.keys(r).length !== 0)) { const n = e.getBreakpoint(r); if (n && e.currentBreakpoint !== n) { const o = n in r ? r[n] : void 0; o && ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach((e) => { const t = o[e]; void 0 !== t && (o[e] = e !== 'slidesPerView' || t !== 'AUTO' && t !== 'auto' ? e === 'slidesPerView' ? parseFloat(t) : parseInt(t, 10) : 'auto') }); const l = o || e.originalParams; const d = s.loop && l.slidesPerView !== s.slidesPerView; ee.extend(e.params, l), ee.extend(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), e.currentBreakpoint = n, d && a && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - i + e.loopedSlides, 0, !1)), e.emit('breakpoint', l) } } }, getBreakpoint(e) { if (e) { let t = !1; const a = []; Object.keys(e).forEach((e) => { a.push(e) }), a.sort((e, t) => parseInt(e, 10) - parseInt(t, 10)); for (let i = 0; i < a.length; i += 1) { const s = a[i]; this.params.breakpointsInverse ? s <= J.innerWidth && (t = s) : s >= J.innerWidth && !t && (t = s) } return t || 'max' } } }; const I = { isIE: !!J.navigator.userAgent.match(/Trident/g) || !!J.navigator.userAgent.match(/MSIE/g), isEdge: !!J.navigator.userAgent.match(/Edge/g), isSafari: (w = J.navigator.userAgent.toLowerCase(), w.indexOf('safari') >= 0 && w.indexOf('chrome') < 0 && w.indexOf('android') < 0), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(J.navigator.userAgent) }; const x = { init: !0, direction: 'horizontal', touchEventsTarget: 'container', initialSlide: 0, speed: 300, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: 0.02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', breakpoints: void 0, breakpointsInverse: !1, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: 'column', slidesPerGroup: 1, centeredSlides: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !0, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: 0.85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', noSwipingSelector: null, passiveListeners: !0, containerModifierClass: 'swiper-container-', slideClass: 'swiper-slide', slideBlankClass: 'swiper-slide-invisible-blank', slideActiveClass: 'swiper-slide-active', slideDuplicateActiveClass: 'swiper-slide-duplicate-active', slideVisibleClass: 'swiper-slide-visible', slideDuplicateClass: 'swiper-slide-duplicate', slideNextClass: 'swiper-slide-next', slideDuplicateNextClass: 'swiper-slide-duplicate-next', slidePrevClass: 'swiper-slide-prev', slideDuplicatePrevClass: 'swiper-slide-duplicate-prev', wrapperClass: 'swiper-wrapper', runCallbacksOnInit: !0 }; const T = { update: o, translate: d, transition: p, slide: c, loop: u, grabCursor: h, manipulation: v, events: b, breakpoints: y, checkOverflow: { checkOverflow() { const e = this; const t = e.isLocked; e.isLocked = e.snapGrid.length === 1, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, t !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'), t && t !== e.isLocked && (e.isEnd = !1, e.navigation.update()) } }, classes: { addClasses() { const t = this.classNames; const a = this.params; const e = this.rtl; const i = this.$el; const s = []; s.push(a.direction), a.freeMode && s.push('free-mode'), te.flexbox || s.push('no-flexbox'), a.autoHeight && s.push('autoheight'), e && s.push('rtl'), a.slidesPerColumn > 1 && s.push('multirow'), m.android && s.push('android'), m.ios && s.push('ios'), (I.isIE || I.isEdge) && (te.pointerEvents || te.prefixedPointerEvents) && s.push(`wp8-${a.direction}`), s.forEach((e) => { t.push(a.containerModifierClass + e) }), i.addClass(t.join(' ')) }, removeClasses() { const e = this.$el; const t = this.classNames; e.removeClass(t.join(' ')) } }, images: { loadImage(e, t, a, i, s, r) { let n; function o() { r && r() }e.complete && s ? o() : t ? ((n = new J.Image()).onload = o, n.onerror = o, i && (n.sizes = i), a && (n.srcset = a), t && (n.src = t)) : o() }, preloadImages() { const e = this; function t() { e != null && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit('imagesReady'))) }e.imagesToLoad = e.$el.find('img'); for (let a = 0; a < e.imagesToLoad.length; a += 1) { const i = e.imagesToLoad[a]; e.loadImage(i, i.currentSrc || i.getAttribute('src'), i.srcset || i.getAttribute('srcset'), i.sizes || i.getAttribute('sizes'), !0, t) } } } }; const E = {}; const S = (function (u) { function h() { for (var e, t, s, a = [], i = arguments.length; i--;)a[i] = arguments[i]; a.length === 1 && a[0].constructor && a[0].constructor === Object ? s = a[0] : (t = (e = a)[0], s = e[1]), s || (s = {}), s = ee.extend({}, s), t && !s.el && (s.el = t), u.call(this, s), Object.keys(T).forEach((t) => { Object.keys(T[t]).forEach((e) => { h.prototype[e] || (h.prototype[e] = T[t][e]) }) }); const r = this; void 0 === r.modules && (r.modules = {}), Object.keys(r.modules).forEach((e) => { const t = r.modules[e]; if (t.params) { const a = Object.keys(t.params)[0]; const i = t.params[a]; if (typeof i !== 'object' || i === null) return; if (!(a in s && 'enabled' in i)) return; !0 === s[a] && (s[a] = { enabled: !0 }), typeof s[a] !== 'object' || 'enabled' in s[a] || (s[a].enabled = !0), s[a] || (s[a] = { enabled: !1 }) } }); const n = ee.extend({}, x); r.useModulesParams(n), r.params = ee.extend({}, n, E, s), r.originalParams = ee.extend({}, r.params), r.passedParams = ee.extend({}, s); const o = (r.$ = L)(r.params.el); if (t = o[0]) { if (o.length > 1) { const l = []; return o.each((e, t) => { const a = ee.extend({}, s, { el: t }); l.push(new h(a)) }), l }t.swiper = r, o.data('swiper', r); let d; let p; const c = o.children(`.${r.params.wrapperClass}`); return ee.extend(r, { $el: o, el: t, $wrapperEl: c, wrapperEl: c[0], classNames: [], slides: L(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return r.params.direction === 'horizontal' }, isVertical() { return r.params.direction === 'vertical' }, rtl: t.dir.toLowerCase() === 'rtl' || o.css('direction') === 'rtl', rtlTranslate: r.params.direction === 'horizontal' && (t.dir.toLowerCase() === 'rtl' || o.css('direction') === 'rtl'), wrongRTL: c.css('display') === '-webkit-box', activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEvents: (d = ['touchstart', 'touchmove', 'touchend'], p = ['mousedown', 'mousemove', 'mouseup'], te.pointerEvents ? p = ['pointerdown', 'pointermove', 'pointerup'] : te.prefixedPointerEvents && (p = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp']), r.touchEventsTouch = { start: d[0], move: d[1], end: d[2] }, r.touchEventsDesktop = { start: p[0], move: p[1], end: p[2] }, te.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: 'input, select, option, textarea, button, video', lastClickTime: ee.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.useModules(), r.params.init && r.init(), r } }u && (h.__proto__ = u); const e = { extendedDefaults: { configurable: !0 }, defaults: { configurable: !0 }, Class: { configurable: !0 }, $: { configurable: !0 } }; return ((h.prototype = Object.create(u && u.prototype)).constructor = h).prototype.slidesPerViewDynamic = function () { const e = this; const t = e.params; const a = e.slides; const i = e.slidesGrid; const s = e.size; const r = e.activeIndex; let n = 1; if (t.centeredSlides) { for (var o, l = a[r].swiperSlideSize, d = r + 1; d < a.length; d += 1)a[d] && !o && (n += 1, s < (l += a[d].swiperSlideSize) && (o = !0)); for (let p = r - 1; p >= 0; p -= 1)a[p] && !o && (n += 1, s < (l += a[p].swiperSlideSize) && (o = !0)) } else for (let c = r + 1; c < a.length; c += 1)i[c] - i[r] < s && (n += 1); return n }, h.prototype.update = function () { const a = this; if (a && !a.destroyed) { const e = a.snapGrid; const t = a.params; t.breakpoints && a.setBreakpoint(), a.updateSize(), a.updateSlides(), a.updateProgress(), a.updateSlidesClasses(), a.params.freeMode ? (i(), a.params.autoHeight && a.updateAutoHeight()) : ((a.params.slidesPerView === 'auto' || a.params.slidesPerView > 1) && a.isEnd && !a.params.centeredSlides ? a.slideTo(a.slides.length - 1, 0, !1, !0) : a.slideTo(a.activeIndex, 0, !1, !0)) || i(), t.watchOverflow && e !== a.snapGrid && a.checkOverflow(), a.emit('update') } function i() { const e = a.rtlTranslate ? -1 * a.translate : a.translate; const t = Math.min(Math.max(e, a.maxTranslate()), a.minTranslate()); a.setTranslate(t), a.updateActiveIndex(), a.updateSlidesClasses() } }, h.prototype.init = function () { const e = this; e.initialized || (e.emit('beforeInit'), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit('init')) }, h.prototype.destroy = function (e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const a = this; const i = a.params; const s = a.$el; const r = a.$wrapperEl; const n = a.slides; return void 0 === a.params || a.destroyed || (a.emit('beforeDestroy'), a.initialized = !1, a.detachEvents(), i.loop && a.loopDestroy(), t && (a.removeClasses(), s.removeAttr('style'), r.removeAttr('style'), n && n.length && n.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index').removeAttr('data-swiper-column').removeAttr('data-swiper-row')), a.emit('destroy'), Object.keys(a.eventsListeners).forEach((e) => { a.off(e) }), !1 !== e && (a.$el[0].swiper = null, a.$el.data('swiper', null), ee.deleteProps(a)), a.destroyed = !0), null }, h.extendDefaults = function (e) { ee.extend(E, e) }, e.extendedDefaults.get = function () { return E }, e.defaults.get = function () { return x }, e.Class.get = function () { return u }, e.$.get = function () { return L }, Object.defineProperties(h, e), h }(s)); const C = { name: 'device', proto: { device: m }, static: { device: m } }; const M = { name: 'support', proto: { support: te }, static: { support: te } }; const k = { name: 'browser', proto: { browser: I }, static: { browser: I } }; const P = { name: 'resize', create() { const e = this; ee.extend(e, { resize: { resizeHandler() { e && !e.destroyed && e.initialized && (e.emit('beforeResize'), e.emit('resize')) }, orientationChangeHandler() { e && !e.destroyed && e.initialized && e.emit('orientationchange') } } }) }, on: { init() { J.addEventListener('resize', this.resize.resizeHandler), J.addEventListener('orientationchange', this.resize.orientationChangeHandler) }, destroy() { J.removeEventListener('resize', this.resize.resizeHandler), J.removeEventListener('orientationchange', this.resize.orientationChangeHandler) } } }; var z = { func: J.MutationObserver || J.WebkitMutationObserver, attach(e, t) { void 0 === t && (t = {}); const a = this; const i = new z.func((e) => { if (e.length !== 1) { const t = function () { a.emit('observerUpdate', e[0]) }; J.requestAnimationFrame ? J.requestAnimationFrame(t) : J.setTimeout(t, 0) } else a.emit('observerUpdate', e[0]) }); i.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), a.observer.observers.push(i) }, init() { const e = this; if (te.observer && e.params.observer) { if (e.params.observeParents) for (let t = e.$el.parents(), a = 0; a < t.length; a += 1)e.observer.attach(t[a]); e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }), e.observer.attach(e.$wrapperEl[0], { attributes: !1 }) } }, destroy() { this.observer.observers.forEach((e) => { e.disconnect() }), this.observer.observers = [] } }; const $ = { name: 'observer', params: { observer: !1, observeParents: !1, observeSlideChildren: !1 }, create() { ee.extend(this, { observer: { init: z.init.bind(this), attach: z.attach.bind(this), destroy: z.destroy.bind(this), observers: [] } }) }, on: { init() { this.observer.init() }, destroy() { this.observer.destroy() } } }; const D = { update(e) { const t = this; const a = t.params; const i = a.slidesPerView; const s = a.slidesPerGroup; const r = a.centeredSlides; const n = t.params.virtual; const o = n.addSlidesBefore; const l = n.addSlidesAfter; const d = t.virtual; const p = d.from; const c = d.to; const u = d.slides; const h = d.slidesGrid; const v = d.renderSlide; const f = d.offset; t.updateActiveIndex(); let m; let g; let b; const w = t.activeIndex || 0; m = t.rtlTranslate ? 'right' : t.isHorizontal() ? 'left' : 'top', r ? (g = Math.floor(i / 2) + s + o, b = Math.floor(i / 2) + s + l) : (g = i + (s - 1) + o, b = s + l); const y = Math.max((w || 0) - b, 0); const x = Math.min((w || 0) + g, u.length - 1); const T = (t.slidesGrid[y] || 0) - (t.slidesGrid[0] || 0); function E() { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load() } if (ee.extend(t.virtual, { from: y, to: x, offset: T, slidesGrid: t.slidesGrid }), p === y && c === x && !e) return t.slidesGrid !== h && T !== f && t.slides.css(m, `${T}px`), void t.updateProgress(); if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, { offset: T, from: y, to: x, slides: (function () { for (var e = [], t = y; t <= x; t += 1)e.push(u[t]); return e }()) }), void E(); const S = []; const C = []; if (e)t.$wrapperEl.find(`.${t.params.slideClass}`).remove(); else for (let M = p; M <= c; M += 1)(M < y || x < M) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${M}"]`).remove(); for (let k = 0; k < u.length; k += 1)y <= k && k <= x && (void 0 === c || e ? C.push(k) : (c < k && C.push(k), k < p && S.push(k))); C.forEach((e) => { t.$wrapperEl.append(v(u[e], e)) }), S.sort((e, t) => t - e).forEach((e) => { t.$wrapperEl.prepend(v(u[e], e)) }), t.$wrapperEl.children('.swiper-slide').css(m, `${T}px`), E() }, renderSlide(e, t) { const a = this; const i = a.params.virtual; if (i.cache && a.virtual.cache[t]) return a.virtual.cache[t]; const s = i.renderSlide ? L(i.renderSlide.call(a, e, t)) : L(`<div class="${a.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return s.attr('data-swiper-slide-index') || s.attr('data-swiper-slide-index', t), i.cache && (a.virtual.cache[t] = s), s }, appendSlide(e) { this.virtual.slides.push(e), this.virtual.update(!0) }, prependSlide(e) { const t = this; if (t.virtual.slides.unshift(e), t.params.virtual.cache) { const a = t.virtual.cache; const i = {}; Object.keys(a).forEach((e) => { i[e + 1] = a[e] }), t.virtual.cache = i }t.virtual.update(!0), t.slideNext(0) } }; const O = { name: 'virtual', params: { virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0 } }, create() { const e = this; ee.extend(e, { virtual: { update: D.update.bind(e), appendSlide: D.appendSlide.bind(e), prependSlide: D.prependSlide.bind(e), renderSlide: D.renderSlide.bind(e), slides: e.params.virtual.slides, cache: {} } }) }, on: { beforeInit() { const e = this; if (e.params.virtual.enabled) { e.classNames.push(`${e.params.containerModifierClass}virtual`); const t = { watchSlidesProgress: !0 }; ee.extend(e.params, t), ee.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update() } }, setTranslate() { this.params.virtual.enabled && this.virtual.update() } } }; const A = { handle(e) { const t = this; const a = t.rtlTranslate; let i = e; i.originalEvent && (i = i.originalEvent); const s = i.keyCode || i.charCode; if (!t.allowSlideNext && (t.isHorizontal() && s === 39 || t.isVertical() && s === 40)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && s === 37 || t.isVertical() && s === 38)) return !1; if (!(i.shiftKey || i.altKey || i.ctrlKey || i.metaKey || f.activeElement && f.activeElement.nodeName && (f.activeElement.nodeName.toLowerCase() === 'input' || f.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (t.params.keyboard.onlyInViewport && (s === 37 || s === 39 || s === 38 || s === 40)) { let r = !1; if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && t.$el.parents(`.${t.params.slideActiveClass}`).length === 0) return; const n = J.innerWidth; const o = J.innerHeight; const l = t.$el.offset(); a && (l.left -= t.$el[0].scrollLeft); for (let d = [[l.left, l.top], [l.left + t.width, l.top], [l.left, l.top + t.height], [l.left + t.width, l.top + t.height]], p = 0; p < d.length; p += 1) { const c = d[p]; c[0] >= 0 && c[0] <= n && c[1] >= 0 && c[1] <= o && (r = !0) } if (!r) return }t.isHorizontal() ? (s !== 37 && s !== 39 || (i.preventDefault ? i.preventDefault() : i.returnValue = !1), (s === 39 && !a || s === 37 && a) && t.slideNext(), (s === 37 && !a || s === 39 && a) && t.slidePrev()) : (s !== 38 && s !== 40 || (i.preventDefault ? i.preventDefault() : i.returnValue = !1), s === 40 && t.slideNext(), s === 38 && t.slidePrev()), t.emit('keyPress', s) } }, enable() { this.keyboard.enabled || (L(f).on('keydown', this.keyboard.handle), this.keyboard.enabled = !0) }, disable() { this.keyboard.enabled && (L(f).off('keydown', this.keyboard.handle), this.keyboard.enabled = !1) } }; const N = { name: 'keyboard', params: { keyboard: { enabled: !1, onlyInViewport: !0 } }, create() { ee.extend(this, { keyboard: { enabled: !1, enable: A.enable.bind(this), disable: A.disable.bind(this), handle: A.handle.bind(this) } }) }, on: { init() { this.params.keyboard.enabled && this.keyboard.enable() }, destroy() { this.keyboard.enabled && this.keyboard.disable() } } }; var H = { lastScrollTime: ee.now(), event: J.navigator.userAgent.indexOf('firefox') > -1 ? 'DOMMouseScroll' : (function () { const e = 'onwheel'; let t = e in f; if (!t) { const a = f.createElement('div'); a.setAttribute(e, 'return;'), t = typeof a[e] === 'function' } return !t && f.implementation && f.implementation.hasFeature && !0 !== f.implementation.hasFeature('', '') && (t = f.implementation.hasFeature('Events.wheel', '3.0')), t }()) ? 'wheel' : 'mousewheel', normalize(e) { let t = 0; let a = 0; let i = 0; let s = 0; return 'detail' in e && (a = e.detail), 'wheelDelta' in e && (a = -e.wheelDelta / 120), 'wheelDeltaY' in e && (a = -e.wheelDeltaY / 120), 'wheelDeltaX' in e && (t = -e.wheelDeltaX / 120), 'axis' in e && e.axis === e.HORIZONTAL_AXIS && (t = a, a = 0), i = 10 * t, s = 10 * a, 'deltaY' in e && (s = e.deltaY), 'deltaX' in e && (i = e.deltaX), (i || s) && e.deltaMode && (e.deltaMode === 1 ? (i *= 40, s *= 40) : (i *= 800, s *= 800)), i && !t && (t = i < 1 ? -1 : 1), s && !a && (a = s < 1 ? -1 : 1), { spinX: t, spinY: a, pixelX: i, pixelY: s } }, handleMouseEnter() { this.mouseEntered = !0 }, handleMouseLeave() { this.mouseEntered = !1 }, handle(e) { let t = e; const a = this; const i = a.params.mousewheel; if (!a.mouseEntered && !i.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let s = 0; const r = a.rtlTranslate ? -1 : 1; const n = H.normalize(t); if (i.forceToAxis) if (a.isHorizontal()) { if (!(Math.abs(n.pixelX) > Math.abs(n.pixelY))) return !0; s = n.pixelX * r } else { if (!(Math.abs(n.pixelY) > Math.abs(n.pixelX))) return !0; s = n.pixelY } else s = Math.abs(n.pixelX) > Math.abs(n.pixelY) ? -n.pixelX * r : -n.pixelY; if (s === 0) return !0; if (i.invert && (s = -s), a.params.freeMode) { a.params.loop && a.loopFix(); let o = a.getTranslate() + s * i.sensitivity; const l = a.isBeginning; const d = a.isEnd; if (o >= a.minTranslate() && (o = a.minTranslate()), o <= a.maxTranslate() && (o = a.maxTranslate()), a.setTransition(0), a.setTranslate(o), a.updateProgress(), a.updateActiveIndex(), a.updateSlidesClasses(), (!l && a.isBeginning || !d && a.isEnd) && a.updateSlidesClasses(), a.params.freeModeSticky && (clearTimeout(a.mousewheel.timeout), a.mousewheel.timeout = ee.nextTick(() => { a.slideToClosest() }, 300)), a.emit('scroll', t), a.params.autoplay && a.params.autoplayDisableOnInteraction && a.autoplay.stop(), o === a.minTranslate() || o === a.maxTranslate()) return !0 } else { if (ee.now() - a.mousewheel.lastScrollTime > 60) if (s < 0) if (a.isEnd && !a.params.loop || a.animating) { if (i.releaseOnEdges) return !0 } else a.slideNext(), a.emit('scroll', t); else if (a.isBeginning && !a.params.loop || a.animating) { if (i.releaseOnEdges) return !0 } else a.slidePrev(), a.emit('scroll', t); a.mousewheel.lastScrollTime = (new J.Date()).getTime() } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 }, enable() { const e = this; if (!H.event) return !1; if (e.mousewheel.enabled) return !1; let t = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (t = L(e.params.mousewheel.eventsTarged)), t.on('mouseenter', e.mousewheel.handleMouseEnter), t.on('mouseleave', e.mousewheel.handleMouseLeave), t.on(H.event, e.mousewheel.handle), e.mousewheel.enabled = !0 }, disable() { const e = this; if (!H.event) return !1; if (!e.mousewheel.enabled) return !1; let t = e.$el; return e.params.mousewheel.eventsTarged !== 'container' && (t = L(e.params.mousewheel.eventsTarged)), t.off(H.event, e.mousewheel.handle), !(e.mousewheel.enabled = !1) } }; const G = { update() { const e = this; const t = e.params.navigation; if (!e.params.loop) { const a = e.navigation; const i = a.$nextEl; const s = a.$prevEl; s && s.length > 0 && (e.isBeginning ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)), i && i.length > 0 && (e.isEnd ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](t.lockClass)) } }, onPrevClick(e) { e.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev() }, onNextClick(e) { e.preventDefault(), this.isEnd && !this.params.loop || this.slideNext() }, init() { let e; let t; const a = this; const i = a.params.navigation; (i.nextEl || i.prevEl) && (i.nextEl && (e = L(i.nextEl), a.params.uniqueNavElements && typeof i.nextEl === 'string' && e.length > 1 && a.$el.find(i.nextEl).length === 1 && (e = a.$el.find(i.nextEl))), i.prevEl && (t = L(i.prevEl), a.params.uniqueNavElements && typeof i.prevEl === 'string' && t.length > 1 && a.$el.find(i.prevEl).length === 1 && (t = a.$el.find(i.prevEl))), e && e.length > 0 && e.on('click', a.navigation.onNextClick), t && t.length > 0 && t.on('click', a.navigation.onPrevClick), ee.extend(a.navigation, { $nextEl: e, nextEl: e && e[0], $prevEl: t, prevEl: t && t[0] })) }, destroy() { const e = this; const t = e.navigation; const a = t.$nextEl; const i = t.$prevEl; a && a.length && (a.off('click', e.navigation.onNextClick), a.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off('click', e.navigation.onPrevClick), i.removeClass(e.params.navigation.disabledClass)) } }; const B = { update() { const e = this; const t = e.rtl; const s = e.params.pagination; if (s.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { let r; const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const i = e.pagination.$el; const n = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? ((r = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup)) > a - 1 - 2 * e.loopedSlides && (r -= a - 2 * e.loopedSlides), n - 1 < r && (r -= n), r < 0 && e.params.paginationType !== 'bullets' && (r = n + r)) : r = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, s.type === 'bullets' && e.pagination.bullets && e.pagination.bullets.length > 0) { let o; let l; let d; const p = e.pagination.bullets; if (s.dynamicBullets && (e.pagination.bulletSize = p.eq(0)[e.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0), i.css(e.isHorizontal() ? 'width' : 'height', `${e.pagination.bulletSize * (s.dynamicMainBullets + 4)}px`), s.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += r - e.previousIndex, e.pagination.dynamicBulletIndex > s.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = s.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), o = r - e.pagination.dynamicBulletIndex, d = ((l = o + (Math.min(p.length, s.dynamicMainBullets) - 1)) + o) / 2), p.removeClass(`${s.bulletActiveClass} ${s.bulletActiveClass}-next ${s.bulletActiveClass}-next-next ${s.bulletActiveClass}-prev ${s.bulletActiveClass}-prev-prev ${s.bulletActiveClass}-main`), i.length > 1)p.each((e, t) => { const a = L(t); const i = a.index(); i === r && a.addClass(s.bulletActiveClass), s.dynamicBullets && (o <= i && i <= l && a.addClass(`${s.bulletActiveClass}-main`), i === o && a.prev().addClass(`${s.bulletActiveClass}-prev`).prev().addClass(`${s.bulletActiveClass}-prev-prev`), i === l && a.next().addClass(`${s.bulletActiveClass}-next`).next().addClass(`${s.bulletActiveClass}-next-next`)) }); else if (p.eq(r).addClass(s.bulletActiveClass), s.dynamicBullets) { for (var c = p.eq(o), u = p.eq(l), h = o; h <= l; h += 1)p.eq(h).addClass(`${s.bulletActiveClass}-main`); c.prev().addClass(`${s.bulletActiveClass}-prev`).prev().addClass(`${s.bulletActiveClass}-prev-prev`), u.next().addClass(`${s.bulletActiveClass}-next`).next().addClass(`${s.bulletActiveClass}-next-next`) } if (s.dynamicBullets) { const v = Math.min(p.length, s.dynamicMainBullets + 4); const f = (e.pagination.bulletSize * v - e.pagination.bulletSize) / 2 - d * e.pagination.bulletSize; const m = t ? 'right' : 'left'; p.css(e.isHorizontal() ? m : 'top', `${f}px`) } } if (s.type === 'fraction' && (i.find(`.${s.currentClass}`).text(s.formatFractionCurrent(r + 1)), i.find(`.${s.totalClass}`).text(s.formatFractionTotal(n))), s.type === 'progressbar') { let g; g = s.progressbarOpposite ? e.isHorizontal() ? 'vertical' : 'horizontal' : e.isHorizontal() ? 'horizontal' : 'vertical'; const b = (r + 1) / n; let w = 1; let y = 1; g === 'horizontal' ? w = b : y = b, i.find(`.${s.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${w}) scaleY(${y})`).transition(e.params.speed) }s.type === 'custom' && s.renderCustom ? (i.html(s.renderCustom(e, r + 1, n)), e.emit('paginationRender', e, i[0])) : e.emit('paginationUpdate', e, i[0]), i[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](s.lockClass) } }, render() { const e = this; const t = e.params.pagination; if (t.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { const a = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length; const i = e.pagination.$el; let s = ''; if (t.type === 'bullets') { for (let r = e.params.loop ? Math.ceil((a - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length, n = 0; n < r; n += 1)t.renderBullet ? s += t.renderBullet.call(e, n, t.bulletClass) : s += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; i.html(s), e.pagination.bullets = i.find(`.${t.bulletClass}`) }t.type === 'fraction' && (s = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, i.html(s)), t.type === 'progressbar' && (s = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, i.html(s)), t.type !== 'custom' && e.emit('paginationRender', e.pagination.$el[0]) } }, init() { const a = this; const e = a.params.pagination; if (e.el) { let t = L(e.el); t.length !== 0 && (a.params.uniqueNavElements && typeof e.el === 'string' && t.length > 1 && a.$el.find(e.el).length === 1 && (t = a.$el.find(e.el)), e.type === 'bullets' && e.clickable && t.addClass(e.clickableClass), t.addClass(e.modifierClass + e.type), e.type === 'bullets' && e.dynamicBullets && (t.addClass(`${e.modifierClass}${e.type}-dynamic`), a.pagination.dynamicBulletIndex = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), e.type === 'progressbar' && e.progressbarOpposite && t.addClass(e.progressbarOppositeClass), e.clickable && t.on('click', `.${e.bulletClass}`, function (e) { e.preventDefault(); let t = L(this).index() * a.params.slidesPerGroup; a.params.loop && (t += a.loopedSlides), a.slideTo(t) }), ee.extend(a.pagination, { $el: t, el: t[0] })) } }, destroy() { const e = this; const t = e.params.pagination; if (t.el && e.pagination.el && e.pagination.$el && e.pagination.$el.length !== 0) { const a = e.pagination.$el; a.removeClass(t.hiddenClass), a.removeClass(t.modifierClass + t.type), e.pagination.bullets && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && a.off('click', `.${t.bulletClass}`) } } }; const X = { setTranslate() { const e = this; if (e.params.scrollbar.el && e.scrollbar.el) { const t = e.scrollbar; const a = e.rtlTranslate; const i = e.progress; const s = t.dragSize; const r = t.trackSize; const n = t.$dragEl; const o = t.$el; const l = e.params.scrollbar; let d = s; let p = (r - s) * i; a ? (p = -p) > 0 ? (d = s - p, p = 0) : r < -p + s && (d = r + p) : p < 0 ? (d = s + p, p = 0) : r < p + s && (d = r - p), e.isHorizontal() ? (te.transforms3d ? n.transform(`translate3d(${p}px, 0, 0)`) : n.transform(`translateX(${p}px)`), n[0].style.width = `${d}px`) : (te.transforms3d ? n.transform(`translate3d(0px, ${p}px, 0)`) : n.transform(`translateY(${p}px)`), n[0].style.height = `${d}px`), l.hide && (clearTimeout(e.scrollbar.timeout), o[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(() => { o[0].style.opacity = 0, o.transition(400) }, 1e3)) } }, setTransition(e) { this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(e) }, updateSize() { const e = this; if (e.params.scrollbar.el && e.scrollbar.el) { const t = e.scrollbar; const a = t.$dragEl; const i = t.$el; a[0].style.width = '', a[0].style.height = ''; let s; const r = e.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight; const n = e.size / e.virtualSize; const o = n * (r / e.size); s = e.params.scrollbar.dragSize === 'auto' ? r * n : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? a[0].style.width = `${s}px` : a[0].style.height = `${s}px`, i[0].style.display = n >= 1 ? 'none' : '', e.params.scrollbarHide && (i[0].style.opacity = 0), ee.extend(t, { trackSize: r, divider: n, moveDivider: o, dragSize: s }), t.$el[e.params.watchOverflow && e.isLocked ? 'addClass' : 'removeClass'](e.params.scrollbar.lockClass) } }, setDragPosition(e) { let t; const a = this; const i = a.scrollbar; const s = a.rtlTranslate; const r = i.$el; const n = i.dragSize; const o = i.trackSize; t = ((a.isHorizontal() ? e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX || e.clientX : e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY || e.clientY) - r.offset()[a.isHorizontal() ? 'left' : 'top'] - n / 2) / (o - n), t = Math.max(Math.min(t, 1), 0), s && (t = 1 - t); const l = a.minTranslate() + (a.maxTranslate() - a.minTranslate()) * t; a.updateProgress(l), a.setTranslate(l), a.updateActiveIndex(), a.updateSlidesClasses() }, onDragStart(e) { const t = this; const a = t.params.scrollbar; const i = t.scrollbar; const s = t.$wrapperEl; const r = i.$el; const n = i.$dragEl; t.scrollbar.isTouched = !0, e.preventDefault(), e.stopPropagation(), s.transition(100), n.transition(100), i.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), r.transition(0), a.hide && r.css('opacity', 1), t.emit('scrollbarDragStart', e) }, onDragMove(e) { const t = this.scrollbar; const a = this.$wrapperEl; const i = t.$el; const s = t.$dragEl; this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, t.setDragPosition(e), a.transition(0), i.transition(0), s.transition(0), this.emit('scrollbarDragMove', e)) }, onDragEnd(e) { const t = this; const a = t.params.scrollbar; const i = t.scrollbar.$el; t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, a.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = ee.nextTick(() => { i.css('opacity', 0), i.transition(400) }, 1e3)), t.emit('scrollbarDragEnd', e), a.snapOnRelease && t.slideToClosest()) }, enableDraggable() { const e = this; if (e.params.scrollbar.el) { const t = e.scrollbar; const a = e.touchEventsTouch; const i = e.touchEventsDesktop; const s = e.params; const r = t.$el[0]; const n = !(!te.passiveListener || !s.passiveListeners) && { passive: !1, capture: !1 }; const o = !(!te.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; te.touch ? (r.addEventListener(a.start, e.scrollbar.onDragStart, n), r.addEventListener(a.move, e.scrollbar.onDragMove, n), r.addEventListener(a.end, e.scrollbar.onDragEnd, o)) : (r.addEventListener(i.start, e.scrollbar.onDragStart, n), f.addEventListener(i.move, e.scrollbar.onDragMove, n), f.addEventListener(i.end, e.scrollbar.onDragEnd, o)) } }, disableDraggable() { const e = this; if (e.params.scrollbar.el) { const t = e.scrollbar; const a = e.touchEventsTouch; const i = e.touchEventsDesktop; const s = e.params; const r = t.$el[0]; const n = !(!te.passiveListener || !s.passiveListeners) && { passive: !1, capture: !1 }; const o = !(!te.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; te.touch ? (r.removeEventListener(a.start, e.scrollbar.onDragStart, n), r.removeEventListener(a.move, e.scrollbar.onDragMove, n), r.removeEventListener(a.end, e.scrollbar.onDragEnd, o)) : (r.removeEventListener(i.start, e.scrollbar.onDragStart, n), f.removeEventListener(i.move, e.scrollbar.onDragMove, n), f.removeEventListener(i.end, e.scrollbar.onDragEnd, o)) } }, init() { const e = this; if (e.params.scrollbar.el) { const t = e.scrollbar; const a = e.$el; const i = e.params.scrollbar; let s = L(i.el); e.params.uniqueNavElements && typeof i.el === 'string' && s.length > 1 && a.find(i.el).length === 1 && (s = a.find(i.el)); let r = s.find(`.${e.params.scrollbar.dragClass}`); r.length === 0 && (r = L(`<div class="${e.params.scrollbar.dragClass}"></div>`), s.append(r)), ee.extend(t, { $el: s, el: s[0], $dragEl: r, dragEl: r[0] }), i.draggable && t.enableDraggable() } }, destroy() { this.scrollbar.disableDraggable() } }; const Y = { setTransform(e, t) { const a = this.rtl; const i = L(e); const s = a ? -1 : 1; const r = i.attr('data-swiper-parallax') || '0'; let n = i.attr('data-swiper-parallax-x'); let o = i.attr('data-swiper-parallax-y'); const l = i.attr('data-swiper-parallax-scale'); const d = i.attr('data-swiper-parallax-opacity'); if (n || o ? (n = n || '0', o = o || '0') : this.isHorizontal() ? (n = r, o = '0') : (o = r, n = '0'), n = n.indexOf('%') >= 0 ? `${parseInt(n, 10) * t * s}%` : `${n * t * s}px`, o = o.indexOf('%') >= 0 ? `${parseInt(o, 10) * t}%` : `${o * t}px`, d != null) { const p = d - (d - 1) * (1 - Math.abs(t)); i[0].style.opacity = p } if (l == null)i.transform(`translate3d(${n}, ${o}, 0px)`); else { const c = l - (l - 1) * (1 - Math.abs(t)); i.transform(`translate3d(${n}, ${o}, 0px) scale(${c})`) } }, setTranslate() { const i = this; const e = i.$el; const t = i.slides; const s = i.progress; const r = i.snapGrid; e.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((e, t) => { i.parallax.setTransform(t, s) }), t.each((e, t) => { let a = t.progress; i.params.slidesPerGroup > 1 && i.params.slidesPerView !== 'auto' && (a += Math.ceil(e / 2) - s * (r.length - 1)), a = Math.min(Math.max(a, -1), 1), L(t).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((e, t) => { i.parallax.setTransform(t, a) }) }) }, setTransition(s) { void 0 === s && (s = this.params.speed); this.$el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((e, t) => { const a = L(t); let i = parseInt(a.attr('data-swiper-parallax-duration'), 10) || s; s === 0 && (i = 0), a.transition(i) }) } }; var V = { getDistanceBetweenTouches(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX; const a = e.targetTouches[0].pageY; const i = e.targetTouches[1].pageX; const s = e.targetTouches[1].pageY; return Math.sqrt(Math.pow(i - t, 2) + Math.pow(s - a, 2)) }, onGestureStart(e) { const t = this; const a = t.params.zoom; const i = t.zoom; const s = i.gesture; if (i.fakeGestureTouched = !1, i.fakeGestureMoved = !1, !te.gestures) { if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) return; i.fakeGestureTouched = !0, s.scaleStart = V.getDistanceBetweenTouches(e) }s.$slideEl && s.$slideEl.length || (s.$slideEl = L(e.target).closest('.swiper-slide'), s.$slideEl.length === 0 && (s.$slideEl = t.slides.eq(t.activeIndex)), s.$imageEl = s.$slideEl.find('img, svg, canvas'), s.$imageWrapEl = s.$imageEl.parent(`.${a.containerClass}`), s.maxRatio = s.$imageWrapEl.attr('data-swiper-zoom') || a.maxRatio, s.$imageWrapEl.length !== 0) ? (s.$imageEl.transition(0), t.zoom.isScaling = !0) : s.$imageEl = void 0 }, onGestureChange(e) { const t = this.params.zoom; const a = this.zoom; const i = a.gesture; if (!te.gestures) { if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) return; a.fakeGestureMoved = !0, i.scaleMove = V.getDistanceBetweenTouches(e) }i.$imageEl && i.$imageEl.length !== 0 && (a.scale = te.gestures ? e.scale * a.currentScale : i.scaleMove / i.scaleStart * a.currentScale, a.scale > i.maxRatio && (a.scale = i.maxRatio - 1 + Math.pow(a.scale - i.maxRatio + 1, 0.5)), a.scale < t.minRatio && (a.scale = t.minRatio + 1 - Math.pow(t.minRatio - a.scale + 1, 0.5)), i.$imageEl.transform(`translate3d(0,0,0) scale(${a.scale})`)) }, onGestureEnd(e) { const t = this.params.zoom; const a = this.zoom; const i = a.gesture; if (!te.gestures) { if (!a.fakeGestureTouched || !a.fakeGestureMoved) return; if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !m.android) return; a.fakeGestureTouched = !1, a.fakeGestureMoved = !1 }i.$imageEl && i.$imageEl.length !== 0 && (a.scale = Math.max(Math.min(a.scale, i.maxRatio), t.minRatio), i.$imageEl.transition(this.params.speed).transform(`translate3d(0,0,0) scale(${a.scale})`), a.currentScale = a.scale, a.isScaling = !1, a.scale === 1 && (i.$slideEl = void 0)) }, onTouchStart(e) { const t = this.zoom; const a = t.gesture; const i = t.image; a.$imageEl && a.$imageEl.length !== 0 && (i.isTouched || (m.android && e.preventDefault(), i.isTouched = !0, i.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX, i.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY)) }, onTouchMove(e) { const t = this; const a = t.zoom; const i = a.gesture; const s = a.image; const r = a.velocity; if (i.$imageEl && i.$imageEl.length !== 0 && (t.allowClick = !1, s.isTouched && i.$slideEl)) { s.isMoved || (s.width = i.$imageEl[0].offsetWidth, s.height = i.$imageEl[0].offsetHeight, s.startX = ee.getTranslate(i.$imageWrapEl[0], 'x') || 0, s.startY = ee.getTranslate(i.$imageWrapEl[0], 'y') || 0, i.slideWidth = i.$slideEl[0].offsetWidth, i.slideHeight = i.$slideEl[0].offsetHeight, i.$imageWrapEl.transition(0), t.rtl && (s.startX = -s.startX, s.startY = -s.startY)); const n = s.width * a.scale; const o = s.height * a.scale; if (!(n < i.slideWidth && o < i.slideHeight)) { if (s.minX = Math.min(i.slideWidth / 2 - n / 2, 0), s.maxX = -s.minX, s.minY = Math.min(i.slideHeight / 2 - o / 2, 0), s.maxY = -s.minY, s.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX, s.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY, !s.isMoved && !a.isScaling) { if (t.isHorizontal() && (Math.floor(s.minX) === Math.floor(s.startX) && s.touchesCurrent.x < s.touchesStart.x || Math.floor(s.maxX) === Math.floor(s.startX) && s.touchesCurrent.x > s.touchesStart.x)) return void (s.isTouched = !1); if (!t.isHorizontal() && (Math.floor(s.minY) === Math.floor(s.startY) && s.touchesCurrent.y < s.touchesStart.y || Math.floor(s.maxY) === Math.floor(s.startY) && s.touchesCurrent.y > s.touchesStart.y)) return void (s.isTouched = !1) }e.preventDefault(), e.stopPropagation(), s.isMoved = !0, s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX, s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY, s.currentX < s.minX && (s.currentX = s.minX + 1 - Math.pow(s.minX - s.currentX + 1, 0.8)), s.currentX > s.maxX && (s.currentX = s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, 0.8)), s.currentY < s.minY && (s.currentY = s.minY + 1 - Math.pow(s.minY - s.currentY + 1, 0.8)), s.currentY > s.maxY && (s.currentY = s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, 0.8)), r.prevPositionX || (r.prevPositionX = s.touchesCurrent.x), r.prevPositionY || (r.prevPositionY = s.touchesCurrent.y), r.prevTime || (r.prevTime = Date.now()), r.x = (s.touchesCurrent.x - r.prevPositionX) / (Date.now() - r.prevTime) / 2, r.y = (s.touchesCurrent.y - r.prevPositionY) / (Date.now() - r.prevTime) / 2, Math.abs(s.touchesCurrent.x - r.prevPositionX) < 2 && (r.x = 0), Math.abs(s.touchesCurrent.y - r.prevPositionY) < 2 && (r.y = 0), r.prevPositionX = s.touchesCurrent.x, r.prevPositionY = s.touchesCurrent.y, r.prevTime = Date.now(), i.$imageWrapEl.transform(`translate3d(${s.currentX}px, ${s.currentY}px,0)`) } } }, onTouchEnd() { const e = this.zoom; const t = e.gesture; const a = e.image; const i = e.velocity; if (t.$imageEl && t.$imageEl.length !== 0) { if (!a.isTouched || !a.isMoved) return a.isTouched = !1, void (a.isMoved = !1); a.isTouched = !1, a.isMoved = !1; let s = 300; let r = 300; const n = i.x * s; const o = a.currentX + n; const l = i.y * r; const d = a.currentY + l; i.x !== 0 && (s = Math.abs((o - a.currentX) / i.x)), i.y !== 0 && (r = Math.abs((d - a.currentY) / i.y)); const p = Math.max(s, r); a.currentX = o, a.currentY = d; const c = a.width * e.scale; const u = a.height * e.scale; a.minX = Math.min(t.slideWidth / 2 - c / 2, 0), a.maxX = -a.minX, a.minY = Math.min(t.slideHeight / 2 - u / 2, 0), a.maxY = -a.minY, a.currentX = Math.max(Math.min(a.currentX, a.maxX), a.minX), a.currentY = Math.max(Math.min(a.currentY, a.maxY), a.minY), t.$imageWrapEl.transition(p).transform(`translate3d(${a.currentX}px, ${a.currentY}px,0)`) } }, onTransitionEnd() { const e = this.zoom; const t = e.gesture; t.$slideEl && this.previousIndex !== this.activeIndex && (t.$imageEl.transform('translate3d(0,0,0) scale(1)'), t.$imageWrapEl.transform('translate3d(0,0,0)'), e.scale = 1, e.currentScale = 1, t.$slideEl = void 0, t.$imageEl = void 0, t.$imageWrapEl = void 0) }, toggle(e) { const t = this.zoom; t.scale && t.scale !== 1 ? t.out() : t.in(e) }, in(e) { let t; let a; let i; let s; let r; let n; let o; let l; let d; let p; let c; let u; let h; let v; let f; let m; const g = this; const b = g.zoom; const w = g.params.zoom; const y = b.gesture; const x = b.image; (y.$slideEl || (y.$slideEl = g.clickedSlide ? L(g.clickedSlide) : g.slides.eq(g.activeIndex), y.$imageEl = y.$slideEl.find('img, svg, canvas'), y.$imageWrapEl = y.$imageEl.parent(`.${w.containerClass}`)), y.$imageEl && y.$imageEl.length !== 0) && (y.$slideEl.addClass(`${w.zoomedSlideClass}`), void 0 === x.touchesStart.x && e ? (t = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX, a = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY) : (t = x.touchesStart.x, a = x.touchesStart.y), b.scale = y.$imageWrapEl.attr('data-swiper-zoom') || w.maxRatio, b.currentScale = y.$imageWrapEl.attr('data-swiper-zoom') || w.maxRatio, e ? (f = y.$slideEl[0].offsetWidth, m = y.$slideEl[0].offsetHeight, i = y.$slideEl.offset().left + f / 2 - t, s = y.$slideEl.offset().top + m / 2 - a, o = y.$imageEl[0].offsetWidth, l = y.$imageEl[0].offsetHeight, d = o * b.scale, p = l * b.scale, h = -(c = Math.min(f / 2 - d / 2, 0)), v = -(u = Math.min(m / 2 - p / 2, 0)), (r = i * b.scale) < c && (r = c), h < r && (r = h), (n = s * b.scale) < u && (n = u), v < n && (n = v)) : n = r = 0, y.$imageWrapEl.transition(300).transform(`translate3d(${r}px, ${n}px,0)`), y.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${b.scale})`)) }, out() { const e = this; const t = e.zoom; const a = e.params.zoom; const i = t.gesture; i.$slideEl || (i.$slideEl = e.clickedSlide ? L(e.clickedSlide) : e.slides.eq(e.activeIndex), i.$imageEl = i.$slideEl.find('img, svg, canvas'), i.$imageWrapEl = i.$imageEl.parent(`.${a.containerClass}`)), i.$imageEl && i.$imageEl.length !== 0 && (t.scale = 1, t.currentScale = 1, i.$imageWrapEl.transition(300).transform('translate3d(0,0,0)'), i.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)'), i.$slideEl.removeClass(`${a.zoomedSlideClass}`), i.$slideEl = void 0) }, enable() { const e = this; const t = e.zoom; if (!t.enabled) { t.enabled = !0; const a = !(e.touchEvents.start !== 'touchstart' || !te.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; te.gestures ? (e.$wrapperEl.on('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.on('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.on(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.on(e.touchEvents.move, '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.on(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove) } }, disable() { const e = this; const t = e.zoom; if (t.enabled) { e.zoom.enabled = !1; const a = !(e.touchEvents.start !== 'touchstart' || !te.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; te.gestures ? (e.$wrapperEl.off('gesturestart', '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off('gesturechange', '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.off('gestureend', '.swiper-slide', t.onGestureEnd, a)) : e.touchEvents.start === 'touchstart' && (e.$wrapperEl.off(e.touchEvents.start, '.swiper-slide', t.onGestureStart, a), e.$wrapperEl.off(e.touchEvents.move, '.swiper-slide', t.onGestureChange, a), e.$wrapperEl.off(e.touchEvents.end, '.swiper-slide', t.onGestureEnd, a)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove) } } }; const F = { loadInSlide(e, l) { void 0 === l && (l = !0); const d = this; const p = d.params.lazy; if (void 0 !== e && d.slides.length !== 0) { const c = d.virtual && d.params.virtual.enabled ? d.$wrapperEl.children(`.${d.params.slideClass}[data-swiper-slide-index="${e}"]`) : d.slides.eq(e); let t = c.find(`.${p.elementClass}:not(.${p.loadedClass}):not(.${p.loadingClass})`); !c.hasClass(p.elementClass) || c.hasClass(p.loadedClass) || c.hasClass(p.loadingClass) || (t = t.add(c[0])), t.length !== 0 && t.each((e, t) => { const i = L(t); i.addClass(p.loadingClass); const s = i.attr('data-background'); const r = i.attr('data-src'); const n = i.attr('data-srcset'); const o = i.attr('data-sizes'); d.loadImage(i[0], r || s, n, o, !1, () => { if (d != null && d && (!d || d.params) && !d.destroyed) { if (s ? (i.css('background-image', `url("${s}")`), i.removeAttr('data-background')) : (n && (i.attr('srcset', n), i.removeAttr('data-srcset')), o && (i.attr('sizes', o), i.removeAttr('data-sizes')), r && (i.attr('src', r), i.removeAttr('data-src'))), i.addClass(p.loadedClass).removeClass(p.loadingClass), c.find(`.${p.preloaderClass}`).remove(), d.params.loop && l) { const e = c.attr('data-swiper-slide-index'); if (c.hasClass(d.params.slideDuplicateClass)) { const t = d.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${d.params.slideDuplicateClass})`); d.lazy.loadInSlide(t.index(), !1) } else { const a = d.$wrapperEl.children(`.${d.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); d.lazy.loadInSlide(a.index(), !1) } }d.emit('lazyImageReady', c[0], i[0]) } }), d.emit('lazyImageLoad', c[0], i[0]) }) } }, load() { const i = this; const t = i.$wrapperEl; const a = i.params; const s = i.slides; const e = i.activeIndex; const r = i.virtual && a.virtual.enabled; const n = a.lazy; let o = a.slidesPerView; function l(e) { if (r) { if (t.children(`.${a.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (s[e]) return !0; return !1 } function d(e) { return r ? L(e).attr('data-swiper-slide-index') : L(e).index() } if (o === 'auto' && (o = 0), i.lazy.initialImageLoaded || (i.lazy.initialImageLoaded = !0), i.params.watchSlidesVisibility)t.children(`.${a.slideVisibleClass}`).each((e, t) => { const a = r ? L(t).attr('data-swiper-slide-index') : L(t).index(); i.lazy.loadInSlide(a) }); else if (o > 1) for (let p = e; p < e + o; p += 1)l(p) && i.lazy.loadInSlide(p); else i.lazy.loadInSlide(e); if (n.loadPrevNext) if (o > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) { for (var c = n.loadPrevNextAmount, u = o, h = Math.min(e + u + Math.max(c, u), s.length), v = Math.max(e - Math.max(u, c), 0), f = e + o; f < h; f += 1)l(f) && i.lazy.loadInSlide(f); for (let m = v; m < e; m += 1)l(m) && i.lazy.loadInSlide(m) } else { const g = t.children(`.${a.slideNextClass}`); g.length > 0 && i.lazy.loadInSlide(d(g)); const b = t.children(`.${a.slidePrevClass}`); b.length > 0 && i.lazy.loadInSlide(d(b)) } } }; var R = { LinearSpline(e, t) { let a; let i; let s; let r; let n; const o = function (e, t) { for (i = -1, a = e.length; a - i > 1;)e[s = a + i >> 1] <= t ? i = s : a = s; return a }; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (n = o(this.x, e), r = n - 1, (e - this.x[r]) * (this.y[n] - this.y[r]) / (this.x[n] - this.x[r]) + this.y[r]) : 0 }, this }, getInterpolateFunction(e) { const t = this; t.controller.spline || (t.controller.spline = t.params.loop ? new R.LinearSpline(t.slidesGrid, e.slidesGrid) : new R.LinearSpline(t.snapGrid, e.snapGrid)) }, setTranslate(e, t) { let a; let i; const s = this; const r = s.controller.control; function n(e) { const t = s.rtlTranslate ? -s.translate : s.translate; s.params.controller.by === 'slide' && (s.controller.getInterpolateFunction(e), i = -s.controller.spline.interpolate(-t)), i && s.params.controller.by !== 'container' || (a = (e.maxTranslate() - e.minTranslate()) / (s.maxTranslate() - s.minTranslate()), i = (t - s.minTranslate()) * a + e.minTranslate()), s.params.controller.inverse && (i = e.maxTranslate() - i), e.updateProgress(i), e.setTranslate(i, s), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(r)) for (let o = 0; o < r.length; o += 1)r[o] !== t && r[o] instanceof S && n(r[o]); else r instanceof S && t !== r && n(r) }, setTransition(t, e) { let a; const i = this; const s = i.controller.control; function r(e) { e.setTransition(t, i), t !== 0 && (e.transitionStart(), e.params.autoHeight && ee.nextTick(() => { e.updateAutoHeight() }), e.$wrapperEl.transitionEnd(() => { s && (e.params.loop && i.params.controller.by === 'slide' && e.loopFix(), e.transitionEnd()) })) } if (Array.isArray(s)) for (a = 0; a < s.length; a += 1)s[a] !== e && s[a] instanceof S && r(s[a]); else s instanceof S && e !== s && r(s) } }; const q = { makeElFocusable(e) { return e.attr('tabIndex', '0'), e }, addElRole(e, t) { return e.attr('role', t), e }, addElLabel(e, t) { return e.attr('aria-label', t), e }, disableEl(e) { return e.attr('aria-disabled', !0), e }, enableEl(e) { return e.attr('aria-disabled', !1), e }, onEnterKey(e) { const t = this; const a = t.params.a11y; if (e.keyCode === 13) { const i = L(e.target); t.navigation && t.navigation.$nextEl && i.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(a.lastSlideMessage) : t.a11y.notify(a.nextSlideMessage)), t.navigation && t.navigation.$prevEl && i.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(a.firstSlideMessage) : t.a11y.notify(a.prevSlideMessage)), t.pagination && i.is(`.${t.params.pagination.bulletClass}`) && i[0].click() } }, notify(e) { const t = this.a11y.liveRegion; t.length !== 0 && (t.html(''), t.html(e)) }, updateNavigation() { const e = this; if (!e.params.loop) { const t = e.navigation; const a = t.$nextEl; const i = t.$prevEl; i && i.length > 0 && (e.isBeginning ? e.a11y.disableEl(i) : e.a11y.enableEl(i)), a && a.length > 0 && (e.isEnd ? e.a11y.disableEl(a) : e.a11y.enableEl(a)) } }, updatePagination() { const i = this; const s = i.params.a11y; i.pagination && i.params.pagination.clickable && i.pagination.bullets && i.pagination.bullets.length && i.pagination.bullets.each((e, t) => { const a = L(t); i.a11y.makeElFocusable(a), i.a11y.addElRole(a, 'button'), i.a11y.addElLabel(a, s.paginationBulletMessage.replace(/{{index}}/, a.index() + 1)) }) }, init() { const e = this; e.$el.append(e.a11y.liveRegion); let t; let a; const i = e.params.a11y; e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (a = e.navigation.$prevEl), t && (e.a11y.makeElFocusable(t), e.a11y.addElRole(t, 'button'), e.a11y.addElLabel(t, i.nextSlideMessage), t.on('keydown', e.a11y.onEnterKey)), a && (e.a11y.makeElFocusable(a), e.a11y.addElRole(a, 'button'), e.a11y.addElLabel(a, i.prevSlideMessage), a.on('keydown', e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on('keydown', `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey) }, destroy() { let e; let t; const a = this; a.a11y.liveRegion && a.a11y.liveRegion.length > 0 && a.a11y.liveRegion.remove(), a.navigation && a.navigation.$nextEl && (e = a.navigation.$nextEl), a.navigation && a.navigation.$prevEl && (t = a.navigation.$prevEl), e && e.off('keydown', a.a11y.onEnterKey), t && t.off('keydown', a.a11y.onEnterKey), a.pagination && a.params.pagination.clickable && a.pagination.bullets && a.pagination.bullets.length && a.pagination.$el.off('keydown', `.${a.params.pagination.bulletClass}`, a.a11y.onEnterKey) } }; var W = { init() { const e = this; if (e.params.history) { if (!J.history || !J.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); const t = e.history; t.initialized = !0, t.paths = W.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || J.addEventListener('popstate', e.history.setHistoryPopState)) } }, destroy() { this.params.history.replaceState || J.removeEventListener('popstate', this.history.setHistoryPopState) }, setHistoryPopState() { this.history.paths = W.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1) }, getPathValues() { const e = J.location.pathname.slice(1).split('/').filter((e) => e !== ''); const t = e.length; return { key: e[t - 2], value: e[t - 1] } }, setHistory(e, t) { if (this.history.initialized && this.params.history.enabled) { const a = this.slides.eq(t); let i = W.slugify(a.attr('data-history')); J.location.pathname.includes(e) || (i = `${e}/${i}`); const s = J.history.state; s && s.value === i || (this.params.history.replaceState ? J.history.replaceState({ value: i }, null, i) : J.history.pushState({ value: i }, null, i)) } }, slugify(e) { return e.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '') }, scrollToSlide(e, t, a) { const i = this; if (t) for (let s = 0, r = i.slides.length; s < r; s += 1) { const n = i.slides.eq(s); if (W.slugify(n.attr('data-history')) === t && !n.hasClass(i.params.slideDuplicateClass)) { const o = n.index(); i.slideTo(o, e, a) } } else i.slideTo(0, e, a) } }; const j = { onHashCange() { const e = this; const t = f.location.hash.replace('#', ''); if (t !== e.slides.eq(e.activeIndex).attr('data-hash')) { const a = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === a) return; e.slideTo(a) } }, setHash() { const e = this; if (e.hashNavigation.initialized && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && J.history && J.history.replaceState)J.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr('data-hash')}` || ''); else { const t = e.slides.eq(e.activeIndex); const a = t.attr('data-hash') || t.attr('data-history'); f.location.hash = a || '' } }, init() { const e = this; if (!(!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled)) { e.hashNavigation.initialized = !0; const t = f.location.hash.replace('#', ''); if (t) for (let a = 0, i = e.slides.length; a < i; a += 1) { const s = e.slides.eq(a); if ((s.attr('data-hash') || s.attr('data-history')) === t && !s.hasClass(e.params.slideDuplicateClass)) { const r = s.index(); e.slideTo(r, 0, e.params.runCallbacksOnInit, !0) } }e.params.hashNavigation.watchState && L(J).on('hashchange', e.hashNavigation.onHashCange) } }, destroy() { this.params.hashNavigation.watchState && L(J).off('hashchange', this.hashNavigation.onHashCange) } }; const U = { run() { const e = this; const t = e.slides.eq(e.activeIndex); let a = e.params.autoplay.delay; t.attr('data-swiper-autoplay') && (a = t.attr('data-swiper-autoplay') || e.params.autoplay.delay), e.autoplay.timeout = ee.nextTick(() => { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay')) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit('autoplay')) : (e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')) }, a) }, start() { const e = this; return void 0 === e.autoplay.timeout && (!e.autoplay.running && (e.autoplay.running = !0, e.emit('autoplayStart'), e.autoplay.run(), !0)) }, stop() { const e = this; return !!e.autoplay.running && (void 0 !== e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit('autoplayStop'), !0)) }, pause(e) { const t = this; t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, e !== 0 && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener('transitionend', t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener('webkitTransitionEnd', t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run()))) } }; const K = { setTranslate() { for (let e = this, t = e.slides, a = 0; a < t.length; a += 1) { const i = e.slides.eq(a); let s = -i[0].swiperSlideOffset; e.params.virtualTranslate || (s -= e.translate); let r = 0; e.isHorizontal() || (r = s, s = 0); const n = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(i[0].progress), 0) : 1 + Math.min(Math.max(i[0].progress, -1), 0); i.css({ opacity: n }).transform(`translate3d(${s}px, ${r}px, 0px)`) } }, setTransition(e) { const a = this; const t = a.slides; const i = a.$wrapperEl; if (t.transition(e), a.params.virtualTranslate && e !== 0) { let s = !1; t.transitionEnd(() => { if (!s && a && !a.destroyed) { s = !0, a.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], t = 0; t < e.length; t += 1)i.trigger(e[t]) } }) } } }; const _ = { setTranslate() { let e; const t = this; const a = t.$el; const i = t.$wrapperEl; const s = t.slides; const r = t.width; const n = t.height; const o = t.rtlTranslate; const l = t.size; const d = t.params.cubeEffect; const p = t.isHorizontal(); const c = t.virtual && t.params.virtual.enabled; let u = 0; d.shadow && (p ? ((e = i.find('.swiper-cube-shadow')).length === 0 && (e = L('<div class="swiper-cube-shadow"></div>'), i.append(e)), e.css({ height: `${r}px` })) : (e = a.find('.swiper-cube-shadow')).length === 0 && (e = L('<div class="swiper-cube-shadow"></div>'), a.append(e))); for (let h = 0; h < s.length; h += 1) { const v = s.eq(h); let f = h; c && (f = parseInt(v.attr('data-swiper-slide-index'), 10)); let m = 90 * f; let g = Math.floor(m / 360); o && (m = -m, g = Math.floor(-m / 360)); const b = Math.max(Math.min(v[0].progress, 1), -1); let w = 0; let y = 0; let x = 0; f % 4 == 0 ? (w = 4 * -g * l, x = 0) : (f - 1) % 4 == 0 ? (w = 0, x = 4 * -g * l) : (f - 2) % 4 == 0 ? (w = l + 4 * g * l, x = l) : (f - 3) % 4 == 0 && (w = -l, x = 3 * l + 4 * l * g), o && (w = -w), p || (y = w, w = 0); const T = `rotateX(${p ? 0 : -m}deg) rotateY(${p ? m : 0}deg) translate3d(${w}px, ${y}px, ${x}px)`; if (b <= 1 && b > -1 && (u = 90 * f + 90 * b, o && (u = 90 * -f - 90 * b)), v.transform(T), d.slideShadows) { let E = p ? v.find('.swiper-slide-shadow-left') : v.find('.swiper-slide-shadow-top'); let S = p ? v.find('.swiper-slide-shadow-right') : v.find('.swiper-slide-shadow-bottom'); E.length === 0 && (E = L(`<div class="swiper-slide-shadow-${p ? 'left' : 'top'}"></div>`), v.append(E)), S.length === 0 && (S = L(`<div class="swiper-slide-shadow-${p ? 'right' : 'bottom'}"></div>`), v.append(S)), E.length && (E[0].style.opacity = Math.max(-b, 0)), S.length && (S[0].style.opacity = Math.max(b, 0)) } } if (i.css({ '-webkit-transform-origin': `50% 50% -${l / 2}px`, '-moz-transform-origin': `50% 50% -${l / 2}px`, '-ms-transform-origin': `50% 50% -${l / 2}px`, 'transform-origin': `50% 50% -${l / 2}px` }), d.shadow) if (p)e.transform(`translate3d(0px, ${r / 2 + d.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${d.shadowScale})`); else { const C = Math.abs(u) - 90 * Math.floor(Math.abs(u) / 90); const M = 1.5 - (Math.sin(2 * C * Math.PI / 360) / 2 + Math.cos(2 * C * Math.PI / 360) / 2); const k = d.shadowScale; const P = d.shadowScale / M; const z = d.shadowOffset; e.transform(`scale3d(${k}, 1, ${P}) translate3d(0px, ${n / 2 + z}px, ${-n / 2 / P}px) rotateX(-90deg)`) } const $ = I.isSafari || I.isUiWebView ? -l / 2 : 0; i.transform(`translate3d(0px,0,${$}px) rotateX(${t.isHorizontal() ? 0 : u}deg) rotateY(${t.isHorizontal() ? -u : 0}deg)`) }, setTransition(e) { const t = this.$el; this.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), this.params.cubeEffect.shadow && !this.isHorizontal() && t.find('.swiper-cube-shadow').transition(e) } }; const Z = { setTranslate() { for (let e = this, t = e.slides, a = e.rtlTranslate, i = 0; i < t.length; i += 1) { const s = t.eq(i); let r = s[0].progress; e.params.flipEffect.limitRotation && (r = Math.max(Math.min(s[0].progress, 1), -1)); let n = -180 * r; let o = 0; let l = -s[0].swiperSlideOffset; let d = 0; if (e.isHorizontal() ? a && (n = -n) : (d = l, o = -n, n = l = 0), s[0].style.zIndex = -Math.abs(Math.round(r)) + t.length, e.params.flipEffect.slideShadows) { let p = e.isHorizontal() ? s.find('.swiper-slide-shadow-left') : s.find('.swiper-slide-shadow-top'); let c = e.isHorizontal() ? s.find('.swiper-slide-shadow-right') : s.find('.swiper-slide-shadow-bottom'); p.length === 0 && (p = L(`<div class="swiper-slide-shadow-${e.isHorizontal() ? 'left' : 'top'}"></div>`), s.append(p)), c.length === 0 && (c = L(`<div class="swiper-slide-shadow-${e.isHorizontal() ? 'right' : 'bottom'}"></div>`), s.append(c)), p.length && (p[0].style.opacity = Math.max(-r, 0)), c.length && (c[0].style.opacity = Math.max(r, 0)) }s.transform(`translate3d(${l}px, ${d}px, 0px) rotateX(${o}deg) rotateY(${n}deg)`) } }, setTransition(e) { const a = this; const t = a.slides; const i = a.activeIndex; const s = a.$wrapperEl; if (t.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e), a.params.virtualTranslate && e !== 0) { let r = !1; t.eq(i).transitionEnd(() => { if (!r && a && !a.destroyed) { r = !0, a.animating = !1; for (let e = ['webkitTransitionEnd', 'transitionend'], t = 0; t < e.length; t += 1)s.trigger(e[t]) } }) } } }; const Q = { setTranslate() { for (var e = this, t = e.width, a = e.height, i = e.slides, s = e.$wrapperEl, r = e.slidesSizesGrid, n = e.params.coverflowEffect, o = e.isHorizontal(), l = e.translate, d = o ? t / 2 - l : a / 2 - l, p = o ? n.rotate : -n.rotate, c = n.depth, u = 0, h = i.length; u < h; u += 1) { const v = i.eq(u); const f = r[u]; const m = (d - v[0].swiperSlideOffset - f / 2) / f * n.modifier; let g = o ? p * m : 0; let b = o ? 0 : p * m; let w = -c * Math.abs(m); let y = o ? 0 : n.stretch * m; let x = o ? n.stretch * m : 0; Math.abs(x) < 0.001 && (x = 0), Math.abs(y) < 0.001 && (y = 0), Math.abs(w) < 0.001 && (w = 0), Math.abs(g) < 0.001 && (g = 0), Math.abs(b) < 0.001 && (b = 0); const T = `translate3d(${x}px,${y}px,${w}px)  rotateX(${b}deg) rotateY(${g}deg)`; if (v.transform(T), v[0].style.zIndex = 1 - Math.abs(Math.round(m)), n.slideShadows) { let E = o ? v.find('.swiper-slide-shadow-left') : v.find('.swiper-slide-shadow-top'); let S = o ? v.find('.swiper-slide-shadow-right') : v.find('.swiper-slide-shadow-bottom'); E.length === 0 && (E = L(`<div class="swiper-slide-shadow-${o ? 'left' : 'top'}"></div>`), v.append(E)), S.length === 0 && (S = L(`<div class="swiper-slide-shadow-${o ? 'right' : 'bottom'}"></div>`), v.append(S)), E.length && (E[0].style.opacity = m > 0 ? m : 0), S.length && (S[0].style.opacity = -m > 0 ? -m : 0) } }(te.pointerEvents || te.prefixedPointerEvents) && (s[0].style.perspectiveOrigin = `${d}px 50%`) }, setTransition(e) { this.slides.transition(e).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(e) } }; const ae = { init() { const e = this; const t = e.params.thumbs; const a = e.constructor; t.swiper instanceof a ? (e.thumbs.swiper = t.swiper, ee.extend(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), ee.extend(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : ee.isObject(t.swiper) && (e.thumbs.swiper = new a(ee.extend({}, t.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on('tap', e.thumbs.onThumbClick) }, onThumbClick() { const e = this; const t = e.thumbs.swiper; if (t) { const a = t.clickedIndex; const i = t.clickedSlide; if (!(i && L(i).hasClass(e.params.thumbs.slideThumbActiveClass) || a == null)) { let s; if (s = t.params.loop ? parseInt(L(t.clickedSlide).attr('data-swiper-slide-index'), 10) : a, e.params.loop) { let r = e.activeIndex; e.slides.eq(r).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, r = e.activeIndex); const n = e.slides.eq(r).prevAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(); const o = e.slides.eq(r).nextAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(); s = void 0 === n ? o : void 0 === o ? n : o - r < r - n ? o : n }e.slideTo(s) } } }, update(e) { const t = this; const a = t.thumbs.swiper; if (a) { const i = a.params.slidesPerView === 'auto' ? a.slidesPerViewDynamic() : a.params.slidesPerView; if (t.realIndex !== a.realIndex) { let s; let r = a.activeIndex; if (a.params.loop) { a.slides.eq(r).hasClass(a.params.slideDuplicateClass) && (a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft, r = a.activeIndex); const n = a.slides.eq(r).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); const o = a.slides.eq(r).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); s = void 0 === n ? o : void 0 === o ? n : o - r == r - n ? r : o - r < r - n ? o : n } else s = t.realIndex; a.visibleSlidesIndexes.indexOf(s) < 0 && (a.params.centeredSlides ? s = r < s ? s - Math.floor(i / 2) + 1 : s + Math.floor(i / 2) - 1 : r < s && (s = s - i + 1), a.slideTo(s, e ? 0 : void 0)) } let l = 1; const d = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (l = t.params.slidesPerView), a.slides.removeClass(d), a.params.loop) for (let p = 0; p < l; p += 1)a.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + p}"]`).addClass(d); else for (let c = 0; c < l; c += 1)a.slides.eq(t.realIndex + c).addClass(d) } } }; const ie = [C, M, k, P, $, O, N, { name: 'mousewheel', params: { mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: 'container' } }, create() { const e = this; ee.extend(e, { mousewheel: { enabled: !1, enable: H.enable.bind(e), disable: H.disable.bind(e), handle: H.handle.bind(e), handleMouseEnter: H.handleMouseEnter.bind(e), handleMouseLeave: H.handleMouseLeave.bind(e), lastScrollTime: ee.now() } }) }, on: { init() { this.params.mousewheel.enabled && this.mousewheel.enable() }, destroy() { this.mousewheel.enabled && this.mousewheel.disable() } } }, { name: 'navigation', params: { navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: 'swiper-button-disabled', hiddenClass: 'swiper-button-hidden', lockClass: 'swiper-button-lock' } }, create() { const e = this; ee.extend(e, { navigation: { init: G.init.bind(e), update: G.update.bind(e), destroy: G.destroy.bind(e), onNextClick: G.onNextClick.bind(e), onPrevClick: G.onPrevClick.bind(e) } }) }, on: { init() { this.navigation.init(), this.navigation.update() }, toEdge() { this.navigation.update() }, fromEdge() { this.navigation.update() }, destroy() { this.navigation.destroy() }, click(e) { const t = this.navigation; const a = t.$nextEl; const i = t.$prevEl; !this.params.navigation.hideOnClick || L(e.target).is(i) || L(e.target).is(a) || (a && a.toggleClass(this.params.navigation.hiddenClass), i && i.toggleClass(this.params.navigation.hiddenClass)) } } }, { name: 'pagination', params: { pagination: { el: null, bulletElement: 'span', clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: 'bullets', dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent(e) { return e }, formatFractionTotal(e) { return e }, bulletClass: 'swiper-pagination-bullet', bulletActiveClass: 'swiper-pagination-bullet-active', modifierClass: 'swiper-pagination-', currentClass: 'swiper-pagination-current', totalClass: 'swiper-pagination-total', hiddenClass: 'swiper-pagination-hidden', progressbarFillClass: 'swiper-pagination-progressbar-fill', progressbarOppositeClass: 'swiper-pagination-progressbar-opposite', clickableClass: 'swiper-pagination-clickable', lockClass: 'swiper-pagination-lock' } }, create() { const e = this; ee.extend(e, { pagination: { init: B.init.bind(e), render: B.render.bind(e), update: B.update.bind(e), destroy: B.destroy.bind(e), dynamicBulletIndex: 0 } }) }, on: { init() { this.pagination.init(), this.pagination.render(), this.pagination.update() }, activeIndexChange() { this.params.loop ? this.pagination.update() : void 0 === this.snapIndex && this.pagination.update() }, snapIndexChange() { this.params.loop || this.pagination.update() }, slidesLengthChange() { this.params.loop && (this.pagination.render(), this.pagination.update()) }, snapGridLengthChange() { this.params.loop || (this.pagination.render(), this.pagination.update()) }, destroy() { this.pagination.destroy() }, click(e) { const t = this; t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !L(e.target).hasClass(t.params.pagination.bulletClass) && t.pagination.$el.toggleClass(t.params.pagination.hiddenClass) } } }, { name: 'scrollbar', params: { scrollbar: { el: null, dragSize: 'auto', hide: !1, draggable: !1, snapOnRelease: !0, lockClass: 'swiper-scrollbar-lock', dragClass: 'swiper-scrollbar-drag' } }, create() { const e = this; ee.extend(e, { scrollbar: { init: X.init.bind(e), destroy: X.destroy.bind(e), updateSize: X.updateSize.bind(e), setTranslate: X.setTranslate.bind(e), setTransition: X.setTransition.bind(e), enableDraggable: X.enableDraggable.bind(e), disableDraggable: X.disableDraggable.bind(e), setDragPosition: X.setDragPosition.bind(e), onDragStart: X.onDragStart.bind(e), onDragMove: X.onDragMove.bind(e), onDragEnd: X.onDragEnd.bind(e), isTouched: !1, timeout: null, dragTimeout: null } }) }, on: { init() { this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate() }, update() { this.scrollbar.updateSize() }, resize() { this.scrollbar.updateSize() }, observerUpdate() { this.scrollbar.updateSize() }, setTranslate() { this.scrollbar.setTranslate() }, setTransition(e) { this.scrollbar.setTransition(e) }, destroy() { this.scrollbar.destroy() } } }, { name: 'parallax', params: { parallax: { enabled: !1 } }, create() { ee.extend(this, { parallax: { setTransform: Y.setTransform.bind(this), setTranslate: Y.setTranslate.bind(this), setTransition: Y.setTransition.bind(this) } }) }, on: { beforeInit() { this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0) }, init() { this.params.parallax && this.parallax.setTranslate() }, setTranslate() { this.params.parallax && this.parallax.setTranslate() }, setTransition(e) { this.params.parallax && this.parallax.setTransition(e) } } }, { name: 'zoom', params: { zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: 'swiper-zoom-container', zoomedSlideClass: 'swiper-slide-zoomed' } }, create() { const i = this; const t = { enabled: !1, scale: 1, currentScale: 1, isScaling: !1, gesture: { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 } }; 'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach((e) => { t[e] = V[e].bind(i) }), ee.extend(i, { zoom: t }); let s = 1; Object.defineProperty(i.zoom, 'scale', { get() { return s }, set(e) { if (s !== e) { const t = i.zoom.gesture.$imageEl ? i.zoom.gesture.$imageEl[0] : void 0; const a = i.zoom.gesture.$slideEl ? i.zoom.gesture.$slideEl[0] : void 0; i.emit('zoomChange', e, t, a) }s = e } }) }, on: { init() { this.params.zoom.enabled && this.zoom.enable() }, destroy() { this.zoom.disable() }, touchStart(e) { this.zoom.enabled && this.zoom.onTouchStart(e) }, touchEnd(e) { this.zoom.enabled && this.zoom.onTouchEnd(e) }, doubleTap(e) { this.params.zoom.enabled && this.zoom.enabled && this.params.zoom.toggle && this.zoom.toggle(e) }, transitionEnd() { this.zoom.enabled && this.params.zoom.enabled && this.zoom.onTransitionEnd() } } }, { name: 'lazy', params: { lazy: { enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: 'swiper-lazy', loadingClass: 'swiper-lazy-loading', loadedClass: 'swiper-lazy-loaded', preloaderClass: 'swiper-lazy-preloader' } }, create() { ee.extend(this, { lazy: { initialImageLoaded: !1, load: F.load.bind(this), loadInSlide: F.loadInSlide.bind(this) } }) }, on: { beforeInit() { this.params.lazy.enabled && this.params.preloadImages && (this.params.preloadImages = !1) }, init() { this.params.lazy.enabled && !this.params.loop && this.params.initialSlide === 0 && this.lazy.load() }, scroll() { this.params.freeMode && !this.params.freeModeSticky && this.lazy.load() }, resize() { this.params.lazy.enabled && this.lazy.load() }, scrollbarDragMove() { this.params.lazy.enabled && this.lazy.load() }, transitionStart() { const e = this; e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load() }, transitionEnd() { this.params.lazy.enabled && !this.params.lazy.loadOnTransitionStart && this.lazy.load() } } }, { name: 'controller', params: { controller: { control: void 0, inverse: !1, by: 'slide' } }, create() { const e = this; ee.extend(e, { controller: { control: e.params.controller.control, getInterpolateFunction: R.getInterpolateFunction.bind(e), setTranslate: R.setTranslate.bind(e), setTransition: R.setTransition.bind(e) } }) }, on: { update() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline) }, resize() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline) }, observerUpdate() { this.controller.control && this.controller.spline && (this.controller.spline = void 0, delete this.controller.spline) }, setTranslate(e, t) { this.controller.control && this.controller.setTranslate(e, t) }, setTransition(e, t) { this.controller.control && this.controller.setTransition(e, t) } } }, { name: 'a11y', params: { a11y: { enabled: !0, notificationClass: 'swiper-notification', prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', paginationBulletMessage: 'Go to slide {{index}}' } }, create() { const t = this; ee.extend(t, { a11y: { liveRegion: L(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) } }), Object.keys(q).forEach((e) => { t.a11y[e] = q[e].bind(t) }) }, on: { init() { this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation()) }, toEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, fromEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, paginationUpdate() { this.params.a11y.enabled && this.a11y.updatePagination() }, destroy() { this.params.a11y.enabled && this.a11y.destroy() } } }, { name: 'history', params: { history: { enabled: !1, replaceState: !1, key: 'slides' } }, create() { const e = this; ee.extend(e, { history: { init: W.init.bind(e), setHistory: W.setHistory.bind(e), setHistoryPopState: W.setHistoryPopState.bind(e), scrollToSlide: W.scrollToSlide.bind(e), destroy: W.destroy.bind(e) } }) }, on: { init() { this.params.history.enabled && this.history.init() }, destroy() { this.params.history.enabled && this.history.destroy() }, transitionEnd() { this.history.initialized && this.history.setHistory(this.params.history.key, this.activeIndex) } } }, { name: 'hash-navigation', params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }, create() { const e = this; ee.extend(e, { hashNavigation: { initialized: !1, init: j.init.bind(e), destroy: j.destroy.bind(e), setHash: j.setHash.bind(e), onHashCange: j.onHashCange.bind(e) } }) }, on: { init() { this.params.hashNavigation.enabled && this.hashNavigation.init() }, destroy() { this.params.hashNavigation.enabled && this.hashNavigation.destroy() }, transitionEnd() { this.hashNavigation.initialized && this.hashNavigation.setHash() } } }, { name: 'autoplay', params: { autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1 } }, create() { const t = this; ee.extend(t, { autoplay: { running: !1, paused: !1, run: U.run.bind(t), start: U.start.bind(t), stop: U.stop.bind(t), pause: U.pause.bind(t), onTransitionEnd(e) { t && !t.destroyed && t.$wrapperEl && e.target === this && (t.$wrapperEl[0].removeEventListener('transitionend', t.autoplay.onTransitionEnd), t.$wrapperEl[0].removeEventListener('webkitTransitionEnd', t.autoplay.onTransitionEnd), t.autoplay.paused = !1, t.autoplay.running ? t.autoplay.run() : t.autoplay.stop()) } } }) }, on: { init() { this.params.autoplay.enabled && this.autoplay.start() }, beforeTransitionStart(e, t) { this.autoplay.running && (t || !this.params.autoplay.disableOnInteraction ? this.autoplay.pause(e) : this.autoplay.stop()) }, sliderFirstMove() { this.autoplay.running && (this.params.autoplay.disableOnInteraction ? this.autoplay.stop() : this.autoplay.pause()) }, destroy() { this.autoplay.running && this.autoplay.stop() } } }, { name: 'effect-fade', params: { fadeEffect: { crossFade: !1 } }, create() { ee.extend(this, { fadeEffect: { setTranslate: K.setTranslate.bind(this), setTransition: K.setTransition.bind(this) } }) }, on: { beforeInit() { const e = this; if (e.params.effect === 'fade') { e.classNames.push(`${e.params.containerModifierClass}fade`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; ee.extend(e.params, t), ee.extend(e.originalParams, t) } }, setTranslate() { this.params.effect === 'fade' && this.fadeEffect.setTranslate() }, setTransition(e) { this.params.effect === 'fade' && this.fadeEffect.setTransition(e) } } }, { name: 'effect-cube', params: { cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94 } }, create() { ee.extend(this, { cubeEffect: { setTranslate: _.setTranslate.bind(this), setTransition: _.setTransition.bind(this) } }) }, on: { beforeInit() { const e = this; if (e.params.effect === 'cube') { e.classNames.push(`${e.params.containerModifierClass}cube`), e.classNames.push(`${e.params.containerModifierClass}3d`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }; ee.extend(e.params, t), ee.extend(e.originalParams, t) } }, setTranslate() { this.params.effect === 'cube' && this.cubeEffect.setTranslate() }, setTransition(e) { this.params.effect === 'cube' && this.cubeEffect.setTransition(e) } } }, { name: 'effect-flip', params: { flipEffect: { slideShadows: !0, limitRotation: !0 } }, create() { ee.extend(this, { flipEffect: { setTranslate: Z.setTranslate.bind(this), setTransition: Z.setTransition.bind(this) } }) }, on: { beforeInit() { const e = this; if (e.params.effect === 'flip') { e.classNames.push(`${e.params.containerModifierClass}flip`), e.classNames.push(`${e.params.containerModifierClass}3d`); const t = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; ee.extend(e.params, t), ee.extend(e.originalParams, t) } }, setTranslate() { this.params.effect === 'flip' && this.flipEffect.setTranslate() }, setTransition(e) { this.params.effect === 'flip' && this.flipEffect.setTransition(e) } } }, { name: 'effect-coverflow', params: { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 } }, create() { ee.extend(this, { coverflowEffect: { setTranslate: Q.setTranslate.bind(this), setTransition: Q.setTransition.bind(this) } }) }, on: { beforeInit() { const e = this; e.params.effect === 'coverflow' && (e.classNames.push(`${e.params.containerModifierClass}coverflow`), e.classNames.push(`${e.params.containerModifierClass}3d`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }, setTranslate() { this.params.effect === 'coverflow' && this.coverflowEffect.setTranslate() }, setTransition(e) { this.params.effect === 'coverflow' && this.coverflowEffect.setTransition(e) } } }, { name: 'thumbs', params: { thumbs: { swiper: null, slideThumbActiveClass: 'swiper-slide-thumb-active', thumbsContainerClass: 'swiper-container-thumbs' } }, create() { ee.extend(this, { thumbs: { swiper: null, init: ae.init.bind(this), update: ae.update.bind(this), onThumbClick: ae.onThumbClick.bind(this) } }) }, on: { beforeInit() { const e = this.params.thumbs; e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0)) }, slideChange() { this.thumbs.swiper && this.thumbs.update() }, update() { this.thumbs.swiper && this.thumbs.update() }, resize() { this.thumbs.swiper && this.thumbs.update() }, observerUpdate() { this.thumbs.swiper && this.thumbs.update() }, setTransition(e) { const t = this.thumbs.swiper; t && t.setTransition(e) }, beforeDestroy() { const e = this.thumbs.swiper; e && this.thumbs.swiperCreated && e && e.destroy() } } }]; return void 0 === S.use && (S.use = S.Class.use, S.installModule = S.Class.installModule), S.use(ie), S
}));

/*
 * jQuery BBQ: Back Button & Query Library - v1.2.1 - 2/17/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function ($, r) { let h; const n = Array.prototype.slice; const t = decodeURIComponent; const a = $.param; let j; let c; let m; let y; const b = $.bbq = $.bbq || {}; let s; let x; let k; const e = $.event.special; const d = 'hashchange'; const B = 'querystring'; const F = 'fragment'; const z = 'elemUrlAttr'; const l = 'href'; const w = 'src'; const p = /^.*\?|#.*$/g; let u; let H; let g; let i; let C; const E = {}; function G(I) { return typeof I === 'string' } function D(J) { const I = n.call(arguments, 1); return function () { return J.apply(this, I.concat(n.call(arguments))) } } function o(I) { return I.replace(H, '$2') } function q(I) { return I.replace(/(?:^[^?#]*\?([^#]*).*$)?.*/, '$1') } function f(K, P, I, L, J) { let R, O, N, Q, M; if (L !== h) { N = I.match(K ? H : /^([^#?]*)\??([^#]*)(#?.*)/); M = N[3] || ''; if (J === 2 && G(L)) { O = L.replace(K ? u : p, '') } else { Q = m(N[2]); L = G(L) ? m[K ? F : B](L) : L; O = J === 2 ? L : J === 1 ? $.extend({}, L, Q) : $.extend({}, Q, L); O = j(O); if (K) { O = O.replace(g, t) } }R = N[1] + (K ? C : O || !N[1] ? '?' : '') + O + M } else { R = P(I !== h ? I : location.href) } return R }a[B] = D(f, 0, q); a[F] = c = D(f, 1, o); a.sorted = j = function (J, K) { const I = []; const L = {}; $.each(a(J, K).split('&'), (P, M) => { const O = M.replace(/(?:%5B|=).*$/, ''); let N = L[O]; if (!N) { N = L[O] = []; I.push(O) }N.push(M) }); return $.map(I.sort(), (M) => L[M]).join('&') }; c.noEscape = function (J) { J = J || ''; const I = $.map(J.split(''), encodeURIComponent); g = new RegExp(I.join('|'), 'g') }; c.noEscape(',/'); c.ajaxCrawlable = function (I) { if (I !== h) { if (I) { u = /^.*(?:#!|#)/; H = /^([^#]*)(?:#!|#)?(.*)$/; C = '#!' } else { u = /^.*#/; H = /^([^#]*)#?(.*)$/; C = '#' }i = !!I } return i }; c.ajaxCrawlable(0); $.deparam = m = function (L, I) { const K = {}; const J = { true: !0, false: !1, null: null }; $.each(L.replace(/\+/g, ' ').split('&'), (O, T) => { const N = T.split('='); let S = t(N[0]); let M; let R = K; let P = 0; let U = S.split(']['); let Q = U.length - 1; if (/\[/.test(U[0]) && /\]$/.test(U[Q])) { U[Q] = U[Q].replace(/\]$/, ''); U = U.shift().split('[').concat(U); Q = U.length - 1 } else { Q = 0 } if (N.length === 2) { M = t(N[1]); if (I) { M = M && !isNaN(M) ? +M : M === 'undefined' ? h : J[M] !== h ? J[M] : M } if (Q) { for (;P <= Q; P++) { S = U[P] === '' ? R.length : U[P]; R = R[S] = P < Q ? R[S] || (U[P + 1] && isNaN(U[P + 1]) ? {} : []) : M } } else if ($.isArray(K[S])) { K[S].push(M) } else if (K[S] !== h) { K[S] = [K[S], M] } else { K[S] = M } } else if (S) { K[S] = I ? h : '' } }); return K }; function A(K, I, J) { if (I === h || typeof I === 'boolean') { J = I; I = a[K ? F : B]() } else { I = G(I) ? I.replace(K ? u : p, '') : I } return m(I, J) }m[B] = D(A, 0); m[F] = y = D(A, 1); $[z] || ($[z] = function (I) { return $.extend(E, I) })({ a: l, base: l, iframe: w, img: w, input: w, form: 'action', link: l, script: w }); k = $[z]; function v(L, J, K, I) { if (!G(K) && typeof K !== 'object') { I = K; K = J; J = h } return this.each(function () { const O = $(this); const M = J || k()[(this.nodeName || '').toLowerCase()] || ''; const N = M && O.attr(M) || ''; O.attr(M, a[L](N, K, I)) }) }$.fn[B] = D(v, B); $.fn[F] = D(v, F); b.pushState = s = function (L, I) { if (G(L) && /^#/.test(L) && I === h) { I = 2 } const K = L !== h; const J = c(location.href, K ? L : {}, K ? I : 2); location.href = J }; b.getState = x = function (I, J) { return I === h || typeof I === 'boolean' ? y(I) : y(J)[I] }; b.removeState = function (I) { let J = {}; if (I !== h) { J = x(); $.each($.isArray(I) ? I : arguments, (L, K) => { delete J[K] }) }s(J, 2) }; e[d] = $.extend(e[d], { add(I) { let K; function J(M) { const L = M[F] = c(); M.getState = function (N, O) { return N === h || typeof N === 'boolean' ? m(L, N) : m(L, O)[N] }; K.apply(this, arguments) } if ($.isFunction(I)) { K = I; return J } K = I.handler; I.handler = J } }) })(jQuery, this);
/*
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function (e, t, n) {
  '$:nomunge'

  function f(e) { e = e || location.href; return `#${e.replace(/^[^#]*#?(.*)$/, '$1')}` } const r = 'hashchange'; const i = document; let s; const o = e.event.special; const u = i.documentMode; const a = `on${r}` in t && (u === n || u > 7); e.fn[r] = function (e) { return e ? this.bind(r, e) : this.trigger(r) }; e.fn[r].delay = 50; o[r] = e.extend(o[r], { setup() { if (a) { return false }e(s.start) }, teardown() { if (a) { return false }e(s.stop) } }); s = (function () { function p() { const n = f(); const i = h(u); if (n !== u) { c(u = n, i); e(t).trigger(r) } else if (i !== u) { location.href = location.href.replace(/#.*/, '') + i }o = setTimeout(p, e.fn[r].delay) } const s = {}; let o; var u = f(); const l = function (e) { return e }; var c = l; var h = l; s.start = function () { o || p() }; s.stop = function () { o && clearTimeout(o); o = n }; navigator.appName === 'Microsoft Internet Explorer' && !a && (function () { let t, n; s.start = function () { if (!t) { n = e.fn[r].src; n = n && n + f(); t = e('<iframe tabindex="-1" title="empty"/>').hide().one('load', () => { n || c(f()); p() }).attr('src', n || 'javascript:0').insertAfter('body')[0].contentWindow; i.onpropertychange = function () { try { if (event.propertyName === 'title') { t.document.title = i.title } } catch (e) {} } } }; s.stop = l; h = function () { return f(t.location.href) }; c = function (n, s) { const o = t.document; const u = e.fn[r].domain; if (n !== s) { o.title = i.title; o.open(); u && o.write(`<script>document.domain="${u}"</script>`); o.close(); t.location.hash = n } } }()); return s }())
})(jQuery, this)

/*!
 * Theia Sticky Sidebar v1.7.0
 * https://github.com/WeCodePixels/theia-sticky-sidebar
 */
!(function (i) { i.fn.scwStickySidebar = function (t) { function e(t, e) { const a = o(t, e); a || (console.log('TSS: Body width smaller than options.minWidth. Init is delayed.'), i(document).on(`scroll.${t.namespace}`, (function (t, e) { return function (a) { const n = o(t, e); n && i(this).unbind(a) } }(t, e))), i(window).on(`resize.${t.namespace}`, (function (t, e) { return function (a) { const n = o(t, e); n && i(this).unbind(a) } }(t, e)))) } function o(t, e) { return t.initialized === !0 || !(i('body').width() < t.minWidth) && (a(t, e), !0) } function a(t, e) { t.initialized = !0; const o = i(`#scw-sticky-sidebar-stylesheet-${t.namespace}`); o.length === 0 && i('head').append(i(`<style id="scw-sticky-sidebar-stylesheet-${t.namespace}">.scwStickySidebar:after {content: ""; display: table; clear: both;}</style>`)), e.each(function () { function e() { a.fixedScrollTop = 0, a.sidebar.css({ 'min-height': '1px' }), a.stickySidebar.css({ position: 'static', width: '', transform: 'none' }) } function o(t) { let e = t.height(); return t.children().each(function () { e = Math.max(e, i(this).height()) }), e } var a = {}; if (a.sidebar = i(this), a.options = t || {}, a.container = i(a.options.containerSelector), a.container.length == 0 && (a.container = a.sidebar.parent()), a.sidebar.parents().css('-webkit-transform', 'none'), a.sidebar.css({ position: a.options.defaultPosition, overflow: 'visible', '-webkit-box-sizing': 'border-box', '-moz-box-sizing': 'border-box', 'box-sizing': 'border-box' }), a.stickySidebar = a.sidebar.find('.scwStickySidebar'), a.stickySidebar.length == 0) { const s = /(?:text|application)\/(?:x-)?(?:javascript|ecmascript)/i; a.sidebar.find('script').filter((i, t) => t.type.length === 0 || t.type.match(s)).remove(), a.stickySidebar = i('<div>').addClass('scwStickySidebar').append(a.sidebar.children()), a.sidebar.append(a.stickySidebar) }a.marginBottom = parseInt(a.sidebar.css('margin-bottom')), a.paddingTop = parseInt(a.sidebar.css('padding-top')), a.paddingBottom = parseInt(a.sidebar.css('padding-bottom')); let r = a.stickySidebar.offset().top; let d = a.stickySidebar.outerHeight(); a.stickySidebar.css('padding-top', 1), a.stickySidebar.css('padding-bottom', 1), r -= a.stickySidebar.offset().top, d = a.stickySidebar.outerHeight() - d - r, r == 0 ? (a.stickySidebar.css('padding-top', 0), a.stickySidebarPaddingTop = 0) : a.stickySidebarPaddingTop = 1, d == 0 ? (a.stickySidebar.css('padding-bottom', 0), a.stickySidebarPaddingBottom = 0) : a.stickySidebarPaddingBottom = 1, a.previousScrollTop = null, a.fixedScrollTop = 0, e(), a.onScroll = function (a) { if (a.stickySidebar.is(':visible')) { if (i('body').width() < a.options.minWidth) return void e(); if (a.options.disableOnResponsiveLayouts) { const s = a.sidebar.outerWidth(a.sidebar.css('float') == 'none'); if (s + 50 > a.container.width()) return void e() } const r = i(document).scrollTop(); let d = 'static'; if (r >= a.sidebar.offset().top + (a.paddingTop - a.options.additionalMarginTop)) { let c; const p = a.paddingTop + t.additionalMarginTop; const b = a.paddingBottom + a.marginBottom + t.additionalMarginBottom; const l = a.sidebar.offset().top; const f = a.sidebar.offset().top + o(a.container); const h = 0 + t.additionalMarginTop; const g = a.stickySidebar.outerHeight() + p + b < i(window).height(); c = g ? h + a.stickySidebar.outerHeight() : i(window).height() - a.marginBottom - a.paddingBottom - t.additionalMarginBottom; const u = l - r + a.paddingTop; const S = f - r - a.paddingBottom - a.marginBottom; var y = a.stickySidebar.offset().top - r; const m = a.previousScrollTop - r; a.stickySidebar.css('position') == 'fixed' && a.options.sidebarBehavior == 'modern' && (y += m), a.options.sidebarBehavior == 'stick-to-top' && (y = t.additionalMarginTop), a.options.sidebarBehavior == 'stick-to-bottom' && (y = c - a.stickySidebar.outerHeight()), y = m > 0 ? Math.min(y, h) : Math.max(y, c - a.stickySidebar.outerHeight()), y = Math.max(y, u), y = Math.min(y, S - a.stickySidebar.outerHeight()); const k = a.container.height() == a.stickySidebar.outerHeight(); d = (k || y != h) && (k || y != c - a.stickySidebar.outerHeight()) ? r + y - a.sidebar.offset().top - a.paddingTop <= t.additionalMarginTop ? 'static' : 'absolute' : 'fixed' } if (d == 'fixed') { const v = i(document).scrollLeft(); a.stickySidebar.css({ position: 'fixed', width: `${n(a.stickySidebar)}px`, transform: `translateY(${y}px)`, left: `${a.sidebar.offset().left + parseInt(a.sidebar.css('padding-left')) - v}px`, top: '0px' }) } else if (d == 'absolute') { const x = {}; a.stickySidebar.css('position') != 'absolute' && (x.position = 'absolute', x.transform = `translateY(${r + y - a.sidebar.offset().top - a.stickySidebarPaddingTop - a.stickySidebarPaddingBottom}px)`, x.top = '0px'), x.width = `${n(a.stickySidebar)}px`, x.left = '', a.stickySidebar.css(x) } else d == 'static' && e(); d != 'static' && a.options.updateSidebarHeight == 1 && a.sidebar.css({ 'min-height': a.stickySidebar.outerHeight() + a.stickySidebar.offset().top - a.sidebar.offset().top + a.paddingBottom }), a.previousScrollTop = r } }, a.onScroll(a), i(document).on(`scroll.${a.options.namespace}`, (function (i) { return function () { i.onScroll(i) } }(a))), i(window).on(`resize.${a.options.namespace}`, (function (i) { return function () { i.stickySidebar.css({ position: 'static' }), i.onScroll(i) } }(a))), typeof ResizeSensor !== 'undefined' && new ResizeSensor(a.stickySidebar[0], (function (i) { return function () { i.onScroll(i) } }(a))) }) } function n(i) { let t; try { t = i[0].getBoundingClientRect().width } catch (i) {} return typeof t === 'undefined' && (t = i.width()), t } const s = { containerSelector: '', additionalMarginTop: 0, additionalMarginBottom: 0, updateSidebarHeight: !0, minWidth: 0, disableOnResponsiveLayouts: !0, sidebarBehavior: 'modern', defaultPosition: 'relative', namespace: 'TSS' }; return t = i.extend(s, t), t.additionalMarginTop = parseInt(t.additionalMarginTop) || 0, t.additionalMarginBottom = parseInt(t.additionalMarginBottom) || 0, e(t, this), this } }(jQuery))
!(function () { var e = function (t, i) { function s() { this.q = [], this.add = function (e) { this.q.push(e) }; let e, t; this.call = function () { for (e = 0, t = this.q.length; e < t; e++) this.q[e].call() } } function o(e, t) { return e.currentStyle ? e.currentStyle[t] : window.getComputedStyle ? window.getComputedStyle(e, null).getPropertyValue(t) : e.style[t] } function n(e, t) { if (e.resizedAttached) { if (e.resizedAttached) return void e.resizedAttached.add(t) } else e.resizedAttached = new s(), e.resizedAttached.add(t); e.resizeSensor = document.createElement('div'), e.resizeSensor.className = 'resize-sensor'; const i = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;'; const n = 'position: absolute; left: 0; top: 0; transition: 0s;'; e.resizeSensor.style.cssText = i, e.resizeSensor.innerHTML = `<div class="resize-sensor-expand" style="${i}"><div style="${n}"></div></div><div class="resize-sensor-shrink" style="${i}"><div style="${n} width: 200%; height: 200%"></div></div>`, e.appendChild(e.resizeSensor), { fixed: 1, absolute: 1 }[o(e, 'position')] || (e.style.position = 'relative'); let d; let r; const l = e.resizeSensor.childNodes[0]; const c = l.childNodes[0]; const h = e.resizeSensor.childNodes[1]; const a = (h.childNodes[0], function () { c.style.width = `${l.offsetWidth + 10}px`, c.style.height = `${l.offsetHeight + 10}px`, l.scrollLeft = l.scrollWidth, l.scrollTop = l.scrollHeight, h.scrollLeft = h.scrollWidth, h.scrollTop = h.scrollHeight, d = e.offsetWidth, r = e.offsetHeight }); a(); const f = function () { e.resizedAttached && e.resizedAttached.call() }; const u = function (e, t, i) { e.attachEvent ? e.attachEvent(`on${t}`, i) : e.addEventListener(t, i) }; const p = function () { e.offsetWidth == d && e.offsetHeight == r || f(), a() }; u(l, 'scroll', p), u(h, 'scroll', p) } const d = Object.prototype.toString.call(t); const r = d === '[object Array]' || d === '[object NodeList]' || d === '[object HTMLCollection]' || typeof jQuery !== 'undefined' && t instanceof jQuery || typeof Elements !== 'undefined' && t instanceof Elements; if (r) for (let l = 0, c = t.length; l < c; l++)n(t[l], i); else n(t, i); this.detach = function () { if (r) for (let i = 0, s = t.length; i < s; i++)e.detach(t[i]); else e.detach(t) } }; e.detach = function (e) { e.resizeSensor && (e.removeChild(e.resizeSensor), delete e.resizeSensor, delete e.resizedAttached) }, typeof module !== 'undefined' && typeof module.exports !== 'undefined' ? module.exports = e : window.ResizeSensor = e }())

/*!
 * jQuery Color Animations v@VERSION
 * https://github.com/jquery/jquery-color
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: @DATE
 */
!(function (r, n) { function t(r, n, t) { const e = f[n.type] || {}; return r == null ? t || !n.def ? null : n.def : (r = e.floor ? ~~r : parseFloat(r), isNaN(r) ? n.def : e.mod ? (r + e.mod) % e.mod : r < 0 ? 0 : e.max < r ? e.max : r) } function e(n) { const t = l(); let e = t._rgba = []; return n = n.toLowerCase(), h(u, (r, o) => { let a; const s = o.re.exec(n); const i = s && o.parse(s); const u = o.space || 'rgba'; return i ? (a = t[u](i), t[c[u].cache] = a[c[u].cache], e = t._rgba = a._rgba, !1) : void 0 }), e.length ? (e.join() === '0,0,0,0' && r.extend(e, a.transparent), t) : a[n] } function o(r, n, t) { return t = (t + 1) % 1, 6 * t < 1 ? r + (n - r) * t * 6 : 2 * t < 1 ? n : 3 * t < 2 ? r + (n - r) * (2 / 3 - t) * 6 : r } let a; const s = 'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor'; const i = /^([\-+])=\s*(\d+\.?\d*)/; var u = [{ re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse(r) { return [r[1], r[2], r[3], r[4]] } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse(r) { return [2.55 * r[1], 2.55 * r[2], 2.55 * r[3], r[4]] } }, { re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse(r) { return [parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16)] } }, { re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse(r) { return [parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16), parseInt(r[3] + r[3], 16)] } }, { re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, space: 'hsla', parse(r) { return [r[1], r[2] / 100, r[3] / 100, r[4]] } }]; var l = r.Color = function (n, t, e, o) { return new r.Color.fn.parse(n, t, e, o) }; var c = { rgba: { props: { red: { idx: 0, type: 'byte' }, green: { idx: 1, type: 'byte' }, blue: { idx: 2, type: 'byte' } } }, hsla: { props: { hue: { idx: 0, type: 'degrees' }, saturation: { idx: 1, type: 'percent' }, lightness: { idx: 2, type: 'percent' } } } }; var f = { byte: { floor: !0, max: 255 }, percent: { max: 1 }, degrees: { mod: 360, floor: !0 } }; const p = l.support = {}; const d = r('<p>')[0]; var h = r.each; d.style.cssText = 'background-color:rgba(1,1,1,.5)', p.rgba = d.style.backgroundColor.indexOf('rgba') > -1, h(c, (r, n) => { n.cache = `_${r}`, n.props.alpha = { idx: 3, type: 'percent', def: 1 } }), l.fn = r.extend(l.prototype, { parse(o, s, i, u) { if (o === n) return this._rgba = [null, null, null, null], this; (o.jquery || o.nodeType) && (o = r(o).css(s), s = n); const f = this; let p = r.type(o); const d = this._rgba = []; return s !== n && (o = [o, s, i, u], p = 'array'), p === 'string' ? this.parse(e(o) || a._default) : p === 'array' ? (h(c.rgba.props, (r, n) => { d[n.idx] = t(o[n.idx], n) }), this) : p === 'object' ? (o instanceof l ? h(c, (r, n) => { o[n.cache] && (f[n.cache] = o[n.cache].slice()) }) : h(c, (n, e) => { const a = e.cache; h(e.props, (r, n) => { if (!f[a] && e.to) { if (r === 'alpha' || o[r] == null) return; f[a] = e.to(f._rgba) }f[a][n.idx] = t(o[r], n, !0) }), f[a] && r.inArray(null, f[a].slice(0, 3)) < 0 && (f[a][3] = 1, e.from && (f._rgba = e.from(f[a]))) }), this) : void 0 }, is(r) { const n = l(r); let t = !0; const e = this; return h(c, (r, o) => { let a; const s = n[o.cache]; return s && (a = e[o.cache] || o.to && o.to(e._rgba) || [], h(o.props, (r, n) => s[n.idx] != null ? t = s[n.idx] === a[n.idx] : void 0)), t }), t }, _space() { const r = []; const n = this; return h(c, (t, e) => { n[e.cache] && r.push(t) }), r.pop() }, transition(r, n) { let e = l(r); const o = e._space(); const a = c[o]; const s = this.alpha() === 0 ? l('transparent') : this; const i = s[a.cache] || a.to(s._rgba); const u = i.slice(); return e = e[a.cache], h(a.props, (r, o) => { const a = o.idx; let s = i[a]; const l = e[a]; const c = f[o.type] || {}; l !== null && (s === null ? u[a] = l : (c.mod && (l - s > c.mod / 2 ? s += c.mod : s - l > c.mod / 2 && (s -= c.mod)), u[a] = t((l - s) * n + s, o))) }), this[o](u) }, blend(n) { if (this._rgba[3] === 1) return this; const t = this._rgba.slice(); const e = t.pop(); const o = l(n)._rgba; return l(r.map(t, (r, n) => (1 - e) * o[n] + e * r)) }, toRgbaString() { let n = 'rgba('; const t = r.map(this._rgba, (r, n) => r == null ? n > 2 ? 1 : 0 : r); return t[3] === 1 && (t.pop(), n = 'rgb('), `${n + t.join()})` }, toHslaString() { let n = 'hsla('; const t = r.map(this.hsla(), (r, n) => r == null && (r = n > 2 ? 1 : 0), n && n < 3 && (r = `${Math.round(100 * r)}%`), r); return t[3] === 1 && (t.pop(), n = 'hsl('), `${n + t.join()})` }, toHexString(n) { const t = this._rgba.slice(); const e = t.pop(); return n && t.push(~~(255 * e)), `#${r.map(t, (r) => r = (r || 0).toString(16), r.length === 1 ? `0${r}` : r).join('')}` }, toString() { return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString() } }), l.fn.parse.prototype = l.fn, c.hsla.to = function (r) { if (r[0] == null || r[1] == null || r[2] == null) return [null, null, null, r[3]]; let n; let t; const e = r[0] / 255; const o = r[1] / 255; const a = r[2] / 255; const s = r[3]; const i = Math.max(e, o, a); const u = Math.min(e, o, a); const l = i - u; const c = i + u; const f = 0.5 * c; return n = u === i ? 0 : e === i ? 60 * (o - a) / l + 360 : o === i ? 60 * (a - e) / l + 120 : 60 * (e - o) / l + 240, t = l === 0 ? 0 : f <= 0.5 ? l / c : l / (2 - c), [Math.round(n) % 360, t, f, s == null ? 1 : s] }, c.hsla.from = function (r) { if (r[0] == null || r[1] == null || r[2] == null) return [null, null, null, r[3]]; const n = r[0] / 360; const t = r[1]; const e = r[2]; const a = r[3]; const s = e <= 0.5 ? e * (1 + t) : e + t - e * t; const i = 2 * e - s; return [Math.round(255 * o(i, s, n + 1 / 3)), Math.round(255 * o(i, s, n)), Math.round(255 * o(i, s, n - 1 / 3)), a] }, h(c, (e, o) => { const a = o.props; const s = o.cache; const u = o.to; const c = o.from; l.fn[e] = function (e) { if (u && !this[s] && (this[s] = u(this._rgba)), e === n) return this[s].slice(); let o; const i = r.type(e); const f = i === 'array' || i === 'object' ? e : arguments; const p = this[s].slice(); return h(a, (r, n) => { let e = f[i === 'object' ? r : n.idx]; e == null && (e = p[n.idx]), p[n.idx] = t(e, n) }), c ? (o = l(c(p)), o[s] = p, o) : l(p) }, h(a, (n, t) => { l.fn[n] || (l.fn[n] = function (o) { let a; let s = r.type(o); const u = n === 'alpha' ? this._hsla ? 'hsla' : 'rgba' : e; const l = this[u](); const c = l[t.idx]; return s === 'undefined' ? c : (s === 'function' && (o = o.call(this, c), s = r.type(o)), o == null && t.empty ? this : (s === 'string' && (a = i.exec(o), a && (o = c + parseFloat(a[2]) * (a[1] === '+' ? 1 : -1))), l[t.idx] = o, this[u](l))) }) }) }), l.hook = function (n) { const t = n.split(' '); h(t, (n, t) => { r.cssHooks[t] = { set(n, o) { let a; let s; let i = ''; if (o !== 'transparent' && (r.type(o) !== 'string' || (a = e(o)))) { if (o = l(a || o), !p.rgba && o._rgba[3] !== 1) { for (s = t === 'backgroundColor' ? n.parentNode : n; (i === '' || i === 'transparent') && s && s.style;) try { i = r.css(s, 'backgroundColor'), s = s.parentNode } catch (u) {}o = o.blend(i && i !== 'transparent' ? i : '_default') }o = o.toRgbaString() } try { n.style[t] = o } catch (u) {} } }, r.fx.step[t] = function (n) { n.colorInit || (n.start = l(n.elem, t), n.end = l(n.end), n.colorInit = !0), r.cssHooks[t].set(n.elem, n.start.transition(n.end, n.pos)) } }) }, l.hook(s), r.cssHooks.borderColor = { expand(r) { const n = {}; return h(['Top', 'Right', 'Bottom', 'Left'], (t, e) => { n[`border${e}Color`] = r }), n } }, a = r.Color.names = { aqua: '#00ffff', black: '#000000', blue: '#0000ff', fuchsia: '#ff00ff', gray: '#808080', green: '#008000', lime: '#00ff00', maroon: '#800000', navy: '#000080', olive: '#808000', purple: '#800080', red: '#ff0000', silver: '#c0c0c0', teal: '#008080', white: '#ffffff', yellow: '#ffff00', transparent: [null, null, null, 0], _default: '#ffffff' } }(jQuery))

// Toastr v2.1.4
!(function (e) { e(['jquery'], (e) => (function () { function t(e, t, n) { return g({ type: O.error, iconClass: m().iconClasses.error, message: e, optionsOverride: n, title: t }) } function n(t, n) { return t || (t = m()), v = e(`#${t.containerId}`), v.length ? v : (n && (v = u(t)), v) } function o(e, t, n) { return g({ type: O.info, iconClass: m().iconClasses.info, message: e, optionsOverride: n, title: t }) } function s(e) { C = e } function i(e, t, n) { return g({ type: O.success, iconClass: m().iconClasses.success, message: e, optionsOverride: n, title: t }) } function a(e, t, n) { return g({ type: O.warning, iconClass: m().iconClasses.warning, message: e, optionsOverride: n, title: t }) } function r(e, t) { const o = m(); v || n(o), d(e, o, t) || l(o) } function c(t) { const o = m(); return v || n(o), t && e(':focus', t).length === 0 ? void h(t) : void (v.children().length && v.remove()) } function l(t) { for (let n = v.children(), o = n.length - 1; o >= 0; o--)d(e(n[o]), t) } function d(t, n, o) { const s = o && o.force ? o.force : !1; return t && (s || e(':focus', t).length === 0) ? (t[n.hideMethod]({ duration: n.hideDuration, easing: n.hideEasing, complete() { h(t) } }), !0) : !1 } function u(t) { return v = e('<div/>').attr('id', t.containerId).addClass(t.positionClass), v.appendTo(e(t.target)), v } function p() { return { tapToDismiss: !0, toastClass: 'toast', containerId: 'toast-container', debug: !1, showMethod: 'fadeIn', showDuration: 300, showEasing: 'swing', onShown: void 0, hideMethod: 'fadeOut', hideDuration: 1e3, hideEasing: 'swing', onHidden: void 0, closeMethod: !1, closeDuration: !1, closeEasing: !1, closeOnHover: !0, extendedTimeOut: 1e3, iconClasses: { error: 'toast-error', info: 'toast-info', success: 'toast-success', warning: 'toast-warning' }, iconClass: 'toast-info', positionClass: 'toast-top-right', timeOut: 5e3, titleClass: 'toast-title', messageClass: 'toast-message', escapeHtml: !1, target: 'body', closeHtml: '<button type="button">&times;</button>', closeClass: 'toast-close-button', newestOnTop: !0, preventDuplicates: !1, progressBar: !1, progressClass: 'toast-progress', rtl: !1 } } function f(e) { C && C(e) } function g(t) { function o(e) { return e == null && (e = ''), e.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;') } function s() { c(), d(), u(), p(), g(), C(), l(), i() } function i() { let e = ''; switch (t.iconClass) { case 'toast-success':case 'toast-info':e = 'polite'; break; default:e = 'assertive' }I.attr('aria-live', e) } function a() { E.closeOnHover && I.hover(H, D), !E.onclick && E.tapToDismiss && I.click(b), E.closeButton && j && j.click((e) => { e.stopPropagation ? e.stopPropagation() : void 0 !== e.cancelBubble && e.cancelBubble !== !0 && (e.cancelBubble = !0), E.onCloseClick && E.onCloseClick(e), b(!0) }), E.onclick && I.click((e) => { E.onclick(e), b() }) } function r() { I.hide(), I[E.showMethod]({ duration: E.showDuration, easing: E.showEasing, complete: E.onShown }), E.timeOut > 0 && (k = setTimeout(b, E.timeOut), F.maxHideTime = parseFloat(E.timeOut), F.hideEta = (new Date()).getTime() + F.maxHideTime, E.progressBar && (F.intervalId = setInterval(x, 10))) } function c() { t.iconClass && I.addClass(E.toastClass).addClass(y) } function l() { E.newestOnTop ? v.prepend(I) : v.append(I) } function d() { if (t.title) { let e = t.title; E.escapeHtml && (e = o(t.title)), M.append(e).addClass(E.titleClass), I.append(M) } } function u() { if (t.message) { let e = t.message; E.escapeHtml && (e = o(t.message)), B.append(e).addClass(E.messageClass), I.append(B) } } function p() { E.closeButton && (j.addClass(E.closeClass).attr('role', 'button'), I.prepend(j)) } function g() { E.progressBar && (q.addClass(E.progressClass), I.prepend(q)) } function C() { E.rtl && I.addClass('rtl') } function O(e, t) { if (e.preventDuplicates) { if (t.message === w) return !0; w = t.message } return !1 } function b(t) { const n = t && E.closeMethod !== !1 ? E.closeMethod : E.hideMethod; const o = t && E.closeDuration !== !1 ? E.closeDuration : E.hideDuration; const s = t && E.closeEasing !== !1 ? E.closeEasing : E.hideEasing; return !e(':focus', I).length || t ? (clearTimeout(F.intervalId), I[n]({ duration: o, easing: s, complete() { h(I), clearTimeout(k), E.onHidden && P.state !== 'hidden' && E.onHidden(), P.state = 'hidden', P.endTime = new Date(), f(P) } })) : void 0 } function D() { (E.timeOut > 0 || E.extendedTimeOut > 0) && (k = setTimeout(b, E.extendedTimeOut), F.maxHideTime = parseFloat(E.extendedTimeOut), F.hideEta = (new Date()).getTime() + F.maxHideTime) } function H() { clearTimeout(k), F.hideEta = 0, I.stop(!0, !0)[E.showMethod]({ duration: E.showDuration, easing: E.showEasing }) } function x() { const e = (F.hideEta - (new Date()).getTime()) / F.maxHideTime * 100; q.width(`${e}%`) } var E = m(); var y = t.iconClass || E.iconClass; if (typeof t.optionsOverride !== 'undefined' && (E = e.extend(E, t.optionsOverride), y = t.optionsOverride.iconClass || y), !O(E, t)) { T++, v = n(E, !0); var k = null; var I = e('<div/>'); var M = e('<div/>'); var B = e('<div/>'); var q = e('<div/>'); var j = e(E.closeHtml); var F = { intervalId: null, hideEta: null, maxHideTime: null }; var P = { toastId: T, state: 'visible', startTime: new Date(), options: E, map: t }; return s(), r(), a(), f(P), E.debug && console && console.log(P), I } } function m() { return e.extend({}, p(), b.options) } function h(e) { v || (v = n()), e.is(':visible') || (e.remove(), e = null, v.children().length === 0 && (v.remove(), w = void 0)) } let v; let C; let w; var T = 0; var O = { error: 'error', info: 'info', success: 'success', warning: 'warning' }; var b = { clear: r, remove: c, error: t, getContainer: n, info: o, options: {}, subscribe: s, success: i, version: '2.1.4', warning: a }; return b }())) }(typeof define === 'function' && define.amd ? define : (e, t) => { typeof module !== 'undefined' && module.exports ? module.exports = t(require('jquery')) : window.toastr = t(window.jQuery) }))

/*!
 * jQuery Form Plugin
 * version: 3.51.0-2014.06.20
 * Requires jQuery v1.5 or later
 * Copyright (c) 2014 M. Alsup
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Project repository: https://github.com/malsup/form
 * Dual licensed under the MIT and GPL licenses.
 * https://github.com/malsup/form#copyright-and-license
 */
!(function (e) {
  typeof define === 'function' && define.amd ? define(['jquery'], e) : e(typeof jQuery !== 'undefined' ? jQuery : window.Zepto)
}((e) => {
  function t(t) { const r = t.data; t.isDefaultPrevented() || (t.preventDefault(), e(t.target).ajaxSubmit(r)) } function r(t) { let r = t.target; const a = e(r); if (!a.is('[type=submit],[type=image]')) { const n = a.closest('[type=submit]'); if (n.length === 0) return; r = n[0] } const i = this; if (i.clk = r, r.type == 'image') if (void 0 !== t.offsetX)i.clk_x = t.offsetX, i.clk_y = t.offsetY; else if (typeof e.fn.offset === 'function') { const o = a.offset(); i.clk_x = t.pageX - o.left, i.clk_y = t.pageY - o.top } else i.clk_x = t.pageX - r.offsetLeft, i.clk_y = t.pageY - r.offsetTop; setTimeout(() => { i.clk = i.clk_x = i.clk_y = null }, 100) } function a() { if (e.fn.ajaxSubmit.debug) { const t = `[jquery.form] ${Array.prototype.join.call(arguments, '')}`; window.console && window.console.log ? window.console.log(t) : window.opera && window.opera.postError && window.opera.postError(t) } } const n = {}; n.fileapi = void 0 !== e("<input type='file'/>").get(0).files, n.formdata = void 0 !== window.FormData; const i = !!e.fn.prop; e.fn.attr2 = function () { if (!i) return this.attr.apply(this, arguments); const e = this.prop.apply(this, arguments); return e && e.jquery || typeof e === 'string' ? e : this.attr.apply(this, arguments) }, e.fn.ajaxSubmit = function (t) { function r(r) { let a; let n; const i = e.param(r, t.traditional).split('&'); const o = i.length; const s = []; for (a = 0; o > a; a++)i[a] = i[a].replace(/\+/g, ' '), n = i[a].split('='), s.push([decodeURIComponent(n[0]), decodeURIComponent(n[1])]); return s } function o(a) { for (var n = new FormData(), i = 0; i < a.length; i++)n.append(a[i].name, a[i].value); if (t.extraData) { const o = r(t.extraData); for (i = 0; i < o.length; i++)o[i] && n.append(o[i][0], o[i][1]) }t.data = null; const s = e.extend(!0, {}, e.ajaxSettings, t, { contentType: !1, processData: !1, cache: !1, type: u || 'POST' }); t.uploadProgress && (s.xhr = function () { const r = e.ajaxSettings.xhr(); return r.upload && r.upload.addEventListener('progress', (e) => { let r = 0; const a = e.loaded || e.position; const n = e.total; e.lengthComputable && (r = Math.ceil(a / n * 100)), t.uploadProgress(e, a, n, r) }, !1), r }), s.data = null; const c = s.beforeSend; return s.beforeSend = function (e, r) { r.data = t.formData ? t.formData : n, c && c.call(this, e, r) }, e.ajax(s) } function s(r) { function n(e) { let t = null; try { e.contentWindow && (t = e.contentWindow.document) } catch (r) { a(`cannot get iframe.contentWindow document: ${r}`) } if (t) return t; try { t = e.contentDocument ? e.contentDocument : e.document } catch (r) { a(`cannot get iframe.contentDocument: ${r}`), t = e.document } return t } function o() { function t() { try { const e = n(g).readyState; a(`state = ${e}`), e && e.toLowerCase() == 'uninitialized' && setTimeout(t, 50) } catch (r) { a('Server abort: ', r, ' (', r.name, ')'), s(k), j && clearTimeout(j), j = void 0 } } const r = f.attr2('target'); const i = f.attr2('action'); const o = 'multipart/form-data'; const c = f.attr('enctype') || f.attr('encoding') || o; w.setAttribute('target', p), (!u || /post/i.test(u)) && w.setAttribute('method', 'POST'), i != m.url && w.setAttribute('action', m.url), m.skipEncodingOverride || u && !/post/i.test(u) || f.attr({ encoding: 'multipart/form-data', enctype: 'multipart/form-data' }), m.timeout && (j = setTimeout(() => { T = !0, s(D) }, m.timeout)); const l = []; try { if (m.extraData) for (const d in m.extraData)m.extraData.hasOwnProperty(d) && l.push(e.isPlainObject(m.extraData[d]) && m.extraData[d].hasOwnProperty('name') && m.extraData[d].hasOwnProperty('value') ? e(`<input type="hidden" name="${m.extraData[d].name}">`).val(m.extraData[d].value).appendTo(w)[0] : e(`<input type="hidden" name="${d}">`).val(m.extraData[d]).appendTo(w)[0]); m.iframeTarget || v.appendTo('body'), g.attachEvent ? g.attachEvent('onload', s) : g.addEventListener('load', s, !1), setTimeout(t, 15); try { w.submit() } catch (h) { const x = document.createElement('form').submit; x.apply(w) } } finally { w.setAttribute('action', i), w.setAttribute('enctype', c), r ? w.setAttribute('target', r) : f.removeAttr('target'), e(l).remove() } } function s(t) { if (!x.aborted && !F) { if (M = n(g), M || (a('cannot access response document'), t = k), t === D && x) return x.abort('timeout'), void S.reject(x, 'timeout'); if (t == k && x) return x.abort('server abort'), void S.reject(x, 'error', 'server abort'); if (M && M.location.href != m.iframeSrc || T) { g.detachEvent ? g.detachEvent('onload', s) : g.removeEventListener('load', s, !1); let r; let i = 'success'; try { if (T) throw 'timeout'; const o = m.dataType == 'xml' || M.XMLDocument || e.isXMLDoc(M); if (a(`isXml=${o}`), !o && window.opera && (M.body === null || !M.body.innerHTML) && --O) return a('requeing onLoad callback, DOM not available'), void setTimeout(s, 250); const u = M.body ? M.body : M.documentElement; x.responseText = u ? u.innerHTML : null, x.responseXML = M.XMLDocument ? M.XMLDocument : M, o && (m.dataType = 'xml'), x.getResponseHeader = function (e) { const t = { 'content-type': m.dataType }; return t[e.toLowerCase()] }, u && (x.status = Number(u.getAttribute('status')) || x.status, x.statusText = u.getAttribute('statusText') || x.statusText); const c = (m.dataType || '').toLowerCase(); const l = /(json|script|text)/.test(c); if (l || m.textarea) { const f = M.getElementsByTagName('textarea')[0]; if (f)x.responseText = f.value, x.status = Number(f.getAttribute('status')) || x.status, x.statusText = f.getAttribute('statusText') || x.statusText; else if (l) { const p = M.getElementsByTagName('pre')[0]; const h = M.getElementsByTagName('body')[0]; p ? x.responseText = p.textContent ? p.textContent : p.innerText : h && (x.responseText = h.textContent ? h.textContent : h.innerText) } } else c == 'xml' && !x.responseXML && x.responseText && (x.responseXML = X(x.responseText)); try { E = _(x, c, m) } catch (y) { i = 'parsererror', x.error = r = y || i } } catch (y) { a('error caught: ', y), i = 'error', x.error = r = y || i }x.aborted && (a('upload aborted'), i = null), x.status && (i = x.status >= 200 && x.status < 300 || x.status === 304 ? 'success' : 'error'), i === 'success' ? (m.success && m.success.call(m.context, E, 'success', x), S.resolve(x.responseText, 'success', x), d && e.event.trigger('ajaxSuccess', [x, m])) : i && (void 0 === r && (r = x.statusText), m.error && m.error.call(m.context, x, i, r), S.reject(x, 'error', r), d && e.event.trigger('ajaxError', [x, m, r])), d && e.event.trigger('ajaxComplete', [x, m]), d && !--e.active && e.event.trigger('ajaxStop'), m.complete && m.complete.call(m.context, x, i), F = !0, m.timeout && clearTimeout(j), setTimeout(() => { m.iframeTarget ? v.attr('src', m.iframeSrc) : v.remove(), x.responseXML = null }, 100) } } } let c; let l; let m; let d; let p; let v; let g; let x; let y; let b; let T; let j; var w = f[0]; var S = e.Deferred(); if (S.abort = function (e) { x.abort(e) }, r) for (l = 0; l < h.length; l++)c = e(h[l]), i ? c.prop('disabled', !1) : c.removeAttr('disabled'); if (m = e.extend(!0, {}, e.ajaxSettings, t), m.context = m.context || m, p = `jqFormIO${(new Date()).getTime()}`, m.iframeTarget ? (v = e(m.iframeTarget), b = v.attr2('name'), b ? p = b : v.attr2('name', p)) : (v = e(`<iframe name="${p}" src="${m.iframeSrc}" />`), v.css({ position: 'absolute', top: '-1000px', left: '-1000px' })), g = v[0], x = { aborted: 0, responseText: null, responseXML: null, status: 0, statusText: 'n/a', getAllResponseHeaders() {}, getResponseHeader() {}, setRequestHeader() {}, abort(t) { const r = t === 'timeout' ? 'timeout' : 'aborted'; a(`aborting upload... ${r}`), this.aborted = 1; try { g.contentWindow.document.execCommand && g.contentWindow.document.execCommand('Stop') } catch (n) {}v.attr('src', m.iframeSrc), x.error = r, m.error && m.error.call(m.context, x, r, t), d && e.event.trigger('ajaxError', [x, m, r]), m.complete && m.complete.call(m.context, x, r) } }, d = m.global, d && e.active++ === 0 && e.event.trigger('ajaxStart'), d && e.event.trigger('ajaxSend', [x, m]), m.beforeSend && m.beforeSend.call(m.context, x, m) === !1) return m.global && e.active--, S.reject(), S; if (x.aborted) return S.reject(), S; y = w.clk, y && (b = y.name, b && !y.disabled && (m.extraData = m.extraData || {}, m.extraData[b] = y.value, y.type == 'image' && (m.extraData[`${b}.x`] = w.clk_x, m.extraData[`${b}.y`] = w.clk_y))); var D = 1; var k = 2; const A = e('meta[name=csrf-token]').attr('content'); const L = e('meta[name=csrf-param]').attr('content'); L && A && (m.extraData = m.extraData || {}, m.extraData[L] = A), m.forceSync ? o() : setTimeout(o, 10); let E; let M; let F; var O = 50; var X = e.parseXML || function (e, t) { return window.ActiveXObject ? (t = new ActiveXObject('Microsoft.XMLDOM'), t.async = 'false', t.loadXML(e)) : t = (new DOMParser()).parseFromString(e, 'text/xml'), t && t.documentElement && t.documentElement.nodeName != 'parsererror' ? t : null }; const C = e.parseJSON || function (e) { return window.eval(`(${e})`) }; var _ = function (t, r, a) { const n = t.getResponseHeader('content-type') || ''; const i = r === 'xml' || !r && n.indexOf('xml') >= 0; let o = i ? t.responseXML : t.responseText; return i && o.documentElement.nodeName === 'parsererror' && e.error && e.error('parsererror'), a && a.dataFilter && (o = a.dataFilter(o, r)), typeof o === 'string' && (r === 'json' || !r && n.indexOf('json') >= 0 ? o = C(o) : (r === 'script' || !r && n.indexOf('javascript') >= 0) && e.globalEval(o)), o }; return S } if (!this.length) return a('ajaxSubmit: skipping submit process - no element selected'), this; let u; let c; let l; var f = this; typeof t === 'function' ? t = { success: t } : void 0 === t && (t = {}), u = t.type || this.attr2('method'), c = t.url || this.attr2('action'), l = typeof c === 'string' ? e.trim(c) : '', l = l || window.location.href || '', l && (l = (l.match(/^([^#]+)/) || [])[1]), t = e.extend(!0, { url: l, success: e.ajaxSettings.success, type: u || e.ajaxSettings.type, iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank' }, t); const m = {}; if (this.trigger('form-pre-serialize', [this, t, m]), m.veto) return a('ajaxSubmit: submit vetoed via form-pre-serialize trigger'), this; if (t.beforeSerialize && t.beforeSerialize(this, t) === !1) return a('ajaxSubmit: submit aborted via beforeSerialize callback'), this; let d = t.traditional; void 0 === d && (d = e.ajaxSettings.traditional); let p; var h = []; const v = this.formToArray(t.semantic, h); if (t.data && (t.extraData = t.data, p = e.param(t.data, d)), t.beforeSubmit && t.beforeSubmit(v, this, t) === !1) return a('ajaxSubmit: submit aborted via beforeSubmit callback'), this; if (this.trigger('form-submit-validate', [v, this, t, m]), m.veto) return a('ajaxSubmit: submit vetoed via form-submit-validate trigger'), this; let g = e.param(v, d); p && (g = g ? `${g}&${p}` : p), t.type.toUpperCase() == 'GET' ? (t.url += (t.url.indexOf('?') >= 0 ? '&' : '?') + g, t.data = null) : t.data = g; const x = []; if (t.resetForm && x.push(() => { f.resetForm() }), t.clearForm && x.push(() => { f.clearForm(t.includeHidden) }), !t.dataType && t.target) { const y = t.success || function () {}; x.push(function (r) { const a = t.replaceTarget ? 'replaceWith' : 'html'; e(t.target)[a](r).each(y, arguments) }) } else t.success && x.push(t.success); if (t.success = function (e, r, a) { for (let n = t.context || this, i = 0, o = x.length; o > i; i++)x[i].apply(n, [e, r, a || f, f]) }, t.error) { const b = t.error; t.error = function (e, r, a) { const n = t.context || this; b.apply(n, [e, r, a, f]) } } if (t.complete) { const T = t.complete; t.complete = function (e, r) { const a = t.context || this; T.apply(a, [e, r, f]) } } const j = e('input[type=file]:enabled', this).filter(function () { return e(this).val() !== '' }); const w = j.length > 0; const S = 'multipart/form-data'; const D = f.attr('enctype') == S || f.attr('encoding') == S; const k = n.fileapi && n.formdata; a(`fileAPI :${k}`); let A; const L = (w || D) && !k; t.iframe !== !1 && (t.iframe || L) ? t.closeKeepAlive ? e.get(t.closeKeepAlive, () => { A = s(v) }) : A = s(v) : A = (w || D) && k ? o(v) : e.ajax(t), f.removeData('jqxhr').data('jqxhr', A); for (let E = 0; E < h.length; E++)h[E] = null; return this.trigger('form-submit-notify', [this, t]), this }, e.fn.ajaxForm = function (n) { if (n = n || {}, n.delegation = n.delegation && e.isFunction(e.fn.on), !n.delegation && this.length === 0) { const i = { s: this.selector, c: this.context }; return !e.isReady && i.s ? (a('DOM not ready, queuing ajaxForm'), e(() => { e(i.s, i.c).ajaxForm(n) }), this) : (a(`terminating; zero elements found by selector${e.isReady ? '' : ' (DOM not ready)'}`), this) } return n.delegation ? (e(document).off('submit.form-plugin', this.selector, t).off('click.form-plugin', this.selector, r).on('submit.form-plugin', this.selector, n, t).on('click.form-plugin', this.selector, n, r), this) : this.ajaxFormUnbind().bind('submit.form-plugin', n, t).bind('click.form-plugin', n, r) }, e.fn.ajaxFormUnbind = function () { return this.unbind('submit.form-plugin click.form-plugin') }, e.fn.formToArray = function (t, r) { const a = []; if (this.length === 0) return a; let i; const o = this[0]; const s = this.attr('id'); let u = t ? o.getElementsByTagName('*') : o.elements; if (u && !/MSIE [678]/.test(navigator.userAgent) && (u = e(u).get()), s && (i = e(`:input[form="${s}"]`).get(), i.length && (u = (u || []).concat(i))), !u || !u.length) return a; let c, l, f, m, d, p, h; for (c = 0, p = u.length; p > c; c++) if (d = u[c], f = d.name, f && !d.disabled) if (t && o.clk && d.type == 'image')o.clk == d && (a.push({ name: f, value: e(d).val(), type: d.type }), a.push({ name: `${f}.x`, value: o.clk_x }, { name: `${f}.y`, value: o.clk_y })); else if (m = e.fieldValue(d, !0), m && m.constructor == Array) for (r && r.push(d), l = 0, h = m.length; h > l; l++)a.push({ name: f, value: m[l] }); else if (n.fileapi && d.type == 'file') { r && r.push(d); const v = d.files; if (v.length) for (l = 0; l < v.length; l++)a.push({ name: f, value: v[l], type: d.type }); else a.push({ name: f, value: '', type: d.type }) } else m !== null && typeof m !== 'undefined' && (r && r.push(d), a.push({ name: f, value: m, type: d.type, required: d.required })); if (!t && o.clk) { const g = e(o.clk); const x = g[0]; f = x.name, f && !x.disabled && x.type == 'image' && (a.push({ name: f, value: g.val() }), a.push({ name: `${f}.x`, value: o.clk_x }, { name: `${f}.y`, value: o.clk_y })) } return a }, e.fn.formSerialize = function (t) { return e.param(this.formToArray(t)) }, e.fn.fieldSerialize = function (t) { const r = []; return this.each(function () { const a = this.name; if (a) { const n = e.fieldValue(this, t); if (n && n.constructor == Array) for (let i = 0, o = n.length; o > i; i++)r.push({ name: a, value: n[i] }); else n !== null && typeof n !== 'undefined' && r.push({ name: this.name, value: n }) } }), e.param(r) }, e.fn.fieldValue = function (t) { for (var r = [], a = 0, n = this.length; n > a; a++) { const i = this[a]; const o = e.fieldValue(i, t); o === null || typeof o === 'undefined' || o.constructor == Array && !o.length || (o.constructor == Array ? e.merge(r, o) : r.push(o)) } return r }, e.fieldValue = function (t, r) { const a = t.name; const n = t.type; const i = t.tagName.toLowerCase(); if (void 0 === r && (r = !0), r && (!a || t.disabled || n == 'reset' || n == 'button' || (n == 'checkbox' || n == 'radio') && !t.checked || (n == 'submit' || n == 'image') && t.form && t.form.clk != t || i == 'select' && t.selectedIndex == -1)) return null; if (i == 'select') { const o = t.selectedIndex; if (o < 0) return null; for (var s = [], u = t.options, c = n == 'select-one', l = c ? o + 1 : u.length, f = c ? o : 0; l > f; f++) { const m = u[f]; if (m.selected) { let d = m.value; if (d || (d = m.attributes && m.attributes.value && !m.attributes.value.specified ? m.text : m.value), c) return d; s.push(d) } } return s } return e(t).val() }, e.fn.clearForm = function (t) { return this.each(function () { e('input,select,textarea', this).clearFields(t) }) }, e.fn.clearFields = e.fn.clearInputs = function (t) { const r = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; return this.each(function () { const a = this.type; const n = this.tagName.toLowerCase(); r.test(a) || n == 'textarea' ? this.value = '' : a == 'checkbox' || a == 'radio' ? this.checked = !1 : n == 'select' ? this.selectedIndex = -1 : a == 'file' ? /MSIE/.test(navigator.userAgent) ? e(this).replaceWith(e(this).clone(!0)) : e(this).val('') : t && (t === !0 && /hidden/.test(a) || typeof t === 'string' && e(this).is(t)) && (this.value = '') }) }, e.fn.resetForm = function () { return this.each(function () { (typeof this.reset === 'function' || typeof this.reset === 'object' && !this.reset.nodeType) && this.reset() }) }, e.fn.enable = function (e) { return void 0 === e && (e = !0), this.each(function () { this.disabled = !e }) }, e.fn.selected = function (t) { return void 0 === t && (t = !0), this.each(function () { const r = this.type; if (r == 'checkbox' || r == 'radio') this.checked = t; else if (this.tagName.toLowerCase() == 'option') { const a = e(this).parent('select'); t && a[0] && a[0].type == 'select-one' && a.find('option').selected(!1), this.selected = t } }) }, e.fn.ajaxSubmit.debug = !1
}))

/*! Magnific Popup - v1.1.0 - 2016-02-20
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2016 Dmitry Semenov; */
!(function (a) { typeof define === 'function' && define.amd ? define(['jquery'], a) : a(typeof exports === 'object' ? require('jquery') : window.jQuery || window.Zepto) }((a) => { let b; let c; let d; let e; let f; let g; const h = 'Close'; const i = 'BeforeClose'; const j = 'AfterClose'; const k = 'BeforeAppend'; const l = 'MarkupParse'; const m = 'Open'; const n = 'Change'; const o = 'mfp'; const p = `.${o}`; const q = 'mfp-ready'; const r = 'mfp-removing'; const s = 'mfp-prevent-close'; const t = function () {}; const u = !!window.jQuery; const v = a(window); const w = function (a, c) { b.ev.on(o + a + p, c) }; const x = function (b, c, d, e) { let f = document.createElement('div'); return f.className = `mfp-${b}`, d && (f.innerHTML = d), e ? c && c.appendChild(f) : (f = a(f), c && f.appendTo(c)), f }; const y = function (c, d) { b.ev.triggerHandler(o + c, d), b.st.callbacks && (c = c.charAt(0).toLowerCase() + c.slice(1), b.st.callbacks[c] && b.st.callbacks[c].apply(b, a.isArray(d) ? d : [d])) }; const z = function (c) { return c === g && b.currTemplate.closeBtn || (b.currTemplate.closeBtn = a(b.st.closeMarkup.replace('%title%', b.st.tClose)), g = c), b.currTemplate.closeBtn }; const A = function () { a.magnificPopup.instance || (b = new t(), b.init(), a.magnificPopup.instance = b) }; const B = function () { const a = document.createElement('p').style; const b = ['ms', 'O', 'Moz', 'Webkit']; if (void 0 !== a.transition) return !0; for (;b.length;) if (`${b.pop()}Transition` in a) return !0; return !1 }; t.prototype = { constructor: t, init() { const c = navigator.appVersion; b.isLowIE = b.isIE8 = document.all && !document.addEventListener, b.isAndroid = /android/gi.test(c), b.isIOS = /iphone|ipad|ipod/gi.test(c), b.supportsTransition = B(), b.probablyMobile = b.isAndroid || b.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), d = a(document), b.popupsCache = {} }, open(c) { let e; if (c.isObj === !1) { b.items = c.items.toArray(), b.index = 0; let g; const h = c.items; for (e = 0; e < h.length; e++) if (g = h[e], g.parsed && (g = g.el[0]), g === c.el[0]) { b.index = e; break } } else b.items = a.isArray(c.items) ? c.items : [c.items], b.index = c.index || 0; if (b.isOpen) return void b.updateItemHTML(); b.types = [], f = '', c.mainEl && c.mainEl.length ? b.ev = c.mainEl.eq(0) : b.ev = d, c.key ? (b.popupsCache[c.key] || (b.popupsCache[c.key] = {}), b.currTemplate = b.popupsCache[c.key]) : b.currTemplate = {}, b.st = a.extend(!0, {}, a.magnificPopup.defaults, c), b.fixedContentPos = b.st.fixedContentPos === 'auto' ? !b.probablyMobile : b.st.fixedContentPos, b.st.modal && (b.st.closeOnContentClick = !1, b.st.closeOnBgClick = !1, b.st.showCloseBtn = !1, b.st.enableEscapeKey = !1), b.bgOverlay || (b.bgOverlay = x('bg').on(`click${p}`, () => { b.close() }), b.wrap = x('wrap').attr('tabindex', -1).on(`click${p}`, (a) => { b._checkIfClose(a.target) && b.close() }), b.container = x('container', b.wrap)), b.contentContainer = x('content'), b.st.preloader && (b.preloader = x('preloader', b.container, b.st.tLoading)); const i = a.magnificPopup.modules; for (e = 0; e < i.length; e++) { let j = i[e]; j = j.charAt(0).toUpperCase() + j.slice(1), b[`init${j}`].call(b) }y('BeforeOpen'), b.st.showCloseBtn && (b.st.closeBtnInside ? (w(l, (a, b, c, d) => { c.close_replaceWith = z(d.type) }), f += ' mfp-close-btn-in') : b.wrap.append(z())), b.st.alignTop && (f += ' mfp-align-top'), b.fixedContentPos ? b.wrap.css({ overflow: b.st.overflowY, overflowX: 'hidden', overflowY: b.st.overflowY }) : b.wrap.css({ top: v.scrollTop(), position: 'absolute' }), (b.st.fixedBgPos === !1 || b.st.fixedBgPos === 'auto' && !b.fixedContentPos) && b.bgOverlay.css({ height: d.height(), position: 'absolute' }), b.st.enableEscapeKey && d.on(`keyup${p}`, (a) => { a.keyCode === 27 && b.close() }), v.on(`resize${p}`, () => { b.updateSize() }), b.st.closeOnContentClick || (f += ' mfp-auto-cursor'), f && b.wrap.addClass(f); const k = b.wH = v.height(); const n = {}; if (b.fixedContentPos && b._hasScrollBar(k)) { const o = b._getScrollbarSize(); o && (n.marginRight = o) }b.fixedContentPos && (b.isIE7 ? a('body, html').css('overflow', 'hidden') : n.overflow = 'hidden'); let r = b.st.mainClass; return b.isIE7 && (r += ' mfp-ie7'), r && b._addClassToMFP(r), b.updateItemHTML(), y('BuildControls'), a('html').css(n), b.bgOverlay.add(b.wrap).prependTo(b.st.prependTo || a(document.body)), b._lastFocusedEl = document.activeElement, setTimeout(() => { b.content ? (b._addClassToMFP(q), b._setFocus()) : b.bgOverlay.addClass(q), d.on(`focusin${p}`, b._onFocusIn) }, 16), b.isOpen = !0, b.updateSize(k), y(m), c }, close() { b.isOpen && (y(i), b.isOpen = !1, b.st.removalDelay && !b.isLowIE && b.supportsTransition ? (b._addClassToMFP(r), setTimeout(() => { b._close() }, b.st.removalDelay)) : b._close()) }, _close() { y(h); let c = `${r} ${q} `; if (b.bgOverlay.detach(), b.wrap.detach(), b.container.empty(), b.st.mainClass && (c += `${b.st.mainClass} `), b._removeClassFromMFP(c), b.fixedContentPos) { const e = { marginRight: '' }; b.isIE7 ? a('body, html').css('overflow', '') : e.overflow = '', a('html').css(e) }d.off(`keyup${p} focusin${p}`), b.ev.off(p), b.wrap.attr('class', 'mfp-wrap').removeAttr('style'), b.bgOverlay.attr('class', 'mfp-bg'), b.container.attr('class', 'mfp-container'), !b.st.showCloseBtn || b.st.closeBtnInside && b.currTemplate[b.currItem.type] !== !0 || b.currTemplate.closeBtn && b.currTemplate.closeBtn.detach(), b.st.autoFocusLast && b._lastFocusedEl && a(b._lastFocusedEl).focus(), b.currItem = null, b.content = null, b.currTemplate = null, b.prevHeight = 0, y(j) }, updateSize(a) { if (b.isIOS) { const c = document.documentElement.clientWidth / window.innerWidth; const d = window.innerHeight * c; b.wrap.css('height', d), b.wH = d } else b.wH = a || v.height(); b.fixedContentPos || b.wrap.css('height', b.wH), y('Resize') }, updateItemHTML() { let c = b.items[b.index]; b.contentContainer.detach(), b.content && b.content.detach(), c.parsed || (c = b.parseEl(b.index)); const d = c.type; if (y('BeforeChange', [b.currItem ? b.currItem.type : '', d]), b.currItem = c, !b.currTemplate[d]) { const f = b.st[d] ? b.st[d].markup : !1; y('FirstMarkupParse', f), f ? b.currTemplate[d] = a(f) : b.currTemplate[d] = !0 }e && e !== c.type && b.container.removeClass(`mfp-${e}-holder`); const g = b[`get${d.charAt(0).toUpperCase()}${d.slice(1)}`](c, b.currTemplate[d]); b.appendContent(g, d), c.preloaded = !0, y(n, c), e = c.type, b.container.prepend(b.contentContainer), y('AfterChange') }, appendContent(a, c) { b.content = a, a ? b.st.showCloseBtn && b.st.closeBtnInside && b.currTemplate[c] === !0 ? b.content.find('.mfp-close').length || b.content.append(z()) : b.content = a : b.content = '', y(k), b.container.addClass(`mfp-${c}-holder`), b.contentContainer.append(b.content) }, parseEl(c) { let d; let e = b.items[c]; if (e.tagName ? e = { el: a(e) } : (d = e.type, e = { data: e, src: e.src }), e.el) { for (let f = b.types, g = 0; g < f.length; g++) if (e.el.hasClass(`mfp-${f[g]}`)) { d = f[g]; break }e.src = e.el.attr('data-mfp-src'), e.src || (e.src = e.el.attr('href')) } return e.type = d || b.st.type || 'inline', e.index = c, e.parsed = !0, b.items[c] = e, y('ElementParse', e), b.items[c] }, addGroup(a, c) { const d = function (d) { d.mfpEl = this, b._openClick(d, a, c) }; c || (c = {}); const e = 'click.magnificPopup'; c.mainEl = a, c.items ? (c.isObj = !0, a.off(e).on(e, d)) : (c.isObj = !1, c.delegate ? a.off(e).on(e, c.delegate, d) : (c.items = a, a.off(e).on(e, d))) }, _openClick(c, d, e) { const f = void 0 !== e.midClick ? e.midClick : a.magnificPopup.defaults.midClick; if (f || !(c.which === 2 || c.ctrlKey || c.metaKey || c.altKey || c.shiftKey)) { const g = void 0 !== e.disableOn ? e.disableOn : a.magnificPopup.defaults.disableOn; if (g) if (a.isFunction(g)) { if (!g.call(b)) return !0 } else if (v.width() < g) return !0; c.type && (c.preventDefault(), b.isOpen && c.stopPropagation()), e.el = a(c.mfpEl), e.delegate && (e.items = d.find(e.delegate)), b.open(e) } }, updateStatus(a, d) { if (b.preloader) { c !== a && b.container.removeClass(`mfp-s-${c}`), d || a !== 'loading' || (d = b.st.tLoading); const e = { status: a, text: d }; y('UpdateStatus', e), a = e.status, d = e.text, b.preloader.html(d), b.preloader.find('a').on('click', (a) => { a.stopImmediatePropagation() }), b.container.addClass(`mfp-s-${a}`), c = a } }, _checkIfClose(c) { if (!a(c).hasClass(s)) { const d = b.st.closeOnContentClick; const e = b.st.closeOnBgClick; if (d && e) return !0; if (!b.content || a(c).hasClass('mfp-close') || b.preloader && c === b.preloader[0]) return !0; if (c === b.content[0] || a.contains(b.content[0], c)) { if (d) return !0 } else if (e && a.contains(document, c)) return !0; return !1 } }, _addClassToMFP(a) { b.bgOverlay.addClass(a), b.wrap.addClass(a) }, _removeClassFromMFP(a) { this.bgOverlay.removeClass(a), b.wrap.removeClass(a) }, _hasScrollBar(a) { return (b.isIE7 ? d.height() : document.body.scrollHeight) > (a || v.height()) }, _setFocus() { (b.st.focus ? b.content.find(b.st.focus).eq(0) : b.wrap).focus() }, _onFocusIn(c) { return c.target === b.wrap[0] || a.contains(b.wrap[0], c.target) ? void 0 : (b._setFocus(), !1) }, _parseMarkup(b, c, d) { let e; d.data && (c = a.extend(d.data, c)), y(l, [b, c, d]), a.each(c, (c, d) => { if (void 0 === d || d === !1) return !0; if (e = c.split('_'), e.length > 1) { const f = b.find(`${p}-${e[0]}`); if (f.length > 0) { const g = e[1]; g === 'replaceWith' ? f[0] !== d[0] && f.replaceWith(d) : g === 'img' ? f.is('img') ? f.attr('src', d) : f.replaceWith(a('<img>').attr('src', d).attr('class', f.attr('class'))) : f.attr(e[1], d) } } else b.find(`${p}-${c}`).html(d) }) }, _getScrollbarSize() { if (void 0 === b.scrollbarSize) { const a = document.createElement('div'); a.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;', document.body.appendChild(a), b.scrollbarSize = a.offsetWidth - a.clientWidth, document.body.removeChild(a) } return b.scrollbarSize } }, a.magnificPopup = { instance: null, proto: t.prototype, modules: [], open(b, c) { return A(), b = b ? a.extend(!0, {}, b) : {}, b.isObj = !0, b.index = c || 0, this.instance.open(b) }, close() { return a.magnificPopup.instance && a.magnificPopup.instance.close() }, registerModule(b, c) { c.options && (a.magnificPopup.defaults[b] = c.options), a.extend(this.proto, c.proto), this.modules.push(b) }, defaults: { disableOn: 0, key: null, midClick: !1, mainClass: '', preloader: !0, focus: '', closeOnContentClick: !1, closeOnBgClick: !0, closeBtnInside: !0, showCloseBtn: !0, enableEscapeKey: !0, modal: !1, alignTop: !1, removalDelay: 0, prependTo: null, fixedContentPos: 'auto', fixedBgPos: 'auto', overflowY: 'auto', closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>', tClose: 'Close (Esc)', tLoading: 'Loading...', autoFocusLast: !0 } }, a.fn.magnificPopup = function (c) { A(); const d = a(this); if (typeof c === 'string') if (c === 'open') { let e; const f = u ? d.data('magnificPopup') : d[0].magnificPopup; const g = parseInt(arguments[1], 10) || 0; f.items ? e = f.items[g] : (e = d, f.delegate && (e = e.find(f.delegate)), e = e.eq(g)), b._openClick({ mfpEl: e }, d, f) } else b.isOpen && b[c].apply(b, Array.prototype.slice.call(arguments, 1)); else c = a.extend(!0, {}, c), u ? d.data('magnificPopup', c) : d[0].magnificPopup = c, b.addGroup(d, c); return d }; let C; let D; let E; const F = 'inline'; const G = function () { E && (D.after(E.addClass(C)).detach(), E = null) }; a.magnificPopup.registerModule(F, { options: { hiddenClass: 'hide', markup: '', tNotFound: 'Content not found' }, proto: { initInline() { b.types.push(F), w(`${h}.${F}`, () => { G() }) }, getInline(c, d) { if (G(), c.src) { const e = b.st.inline; let f = a(c.src); if (f.length) { const g = f[0].parentNode; g && g.tagName && (D || (C = e.hiddenClass, D = x(C), C = `mfp-${C}`), E = f.after(D).detach().removeClass(C)), b.updateStatus('ready') } else b.updateStatus('error', e.tNotFound), f = a('<div>'); return c.inlineElement = f, f } return b.updateStatus('ready'), b._parseMarkup(d, {}, c), d } } }); let H; const I = 'ajax'; const J = function () { H && a(document.body).removeClass(H) }; const K = function () { J(), b.req && b.req.abort() }; a.magnificPopup.registerModule(I, { options: { settings: null, cursor: 'mfp-ajax-cur', tError: '<a href="%url%">The content</a> could not be loaded.' }, proto: { initAjax() { b.types.push(I), H = b.st.ajax.cursor, w(`${h}.${I}`, K), w(`BeforeChange.${I}`, K) }, getAjax(c) { H && a(document.body).addClass(H), b.updateStatus('loading'); const d = a.extend({ url: c.src, success(d, e, f) { const g = { data: d, xhr: f }; y('ParseAjax', g), b.appendContent(a(g.data), I), c.finished = !0, J(), b._setFocus(), setTimeout(() => { b.wrap.addClass(q) }, 16), b.updateStatus('ready'), y('AjaxContentAdded') }, error() { J(), c.finished = c.loadError = !0, b.updateStatus('error', b.st.ajax.tError.replace('%url%', c.src)) } }, b.st.ajax.settings); return b.req = a.ajax(d), '' } } }); let L; const M = function (c) { if (c.data && void 0 !== c.data.title) return c.data.title; const d = b.st.image.titleSrc; if (d) { if (a.isFunction(d)) return d.call(b, c); if (c.el) return c.el.attr(d) || '' } return '' }; a.magnificPopup.registerModule('image', { options: { markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>', cursor: 'mfp-zoom-out-cur', titleSrc: 'title', verticalFit: !0, tError: '<a href="%url%">The image</a> could not be loaded.' }, proto: { initImage() { const c = b.st.image; const d = '.image'; b.types.push('image'), w(m + d, () => { b.currItem.type === 'image' && c.cursor && a(document.body).addClass(c.cursor) }), w(h + d, () => { c.cursor && a(document.body).removeClass(c.cursor), v.off(`resize${p}`) }), w(`Resize${d}`, b.resizeImage), b.isLowIE && w('AfterChange', b.resizeImage) }, resizeImage() { const a = b.currItem; if (a && a.img && b.st.image.verticalFit) { let c = 0; b.isLowIE && (c = parseInt(a.img.css('padding-top'), 10) + parseInt(a.img.css('padding-bottom'), 10)), a.img.css('max-height', b.wH - c) } }, _onImageHasSize(a) { a.img && (a.hasSize = !0, L && clearInterval(L), a.isCheckingImgSize = !1, y('ImageHasSize', a), a.imgHidden && (b.content && b.content.removeClass('mfp-loading'), a.imgHidden = !1)) }, findImageSize(a) { let c = 0; const d = a.img[0]; var e = function (f) { L && clearInterval(L), L = setInterval(() => d.naturalWidth > 0 ? void b._onImageHasSize(a) : (c > 200 && clearInterval(L), c++, void (c === 3 ? e(10) : c === 40 ? e(50) : c === 100 && e(500))), f) }; e(1) }, getImage(c, d) { let e = 0; var f = function () { c && (c.img[0].complete ? (c.img.off('.mfploader'), c === b.currItem && (b._onImageHasSize(c), b.updateStatus('ready')), c.hasSize = !0, c.loaded = !0, y('ImageLoadComplete')) : (e++, e < 200 ? setTimeout(f, 100) : g())) }; var g = function () { c && (c.img.off('.mfploader'), c === b.currItem && (b._onImageHasSize(c), b.updateStatus('error', h.tError.replace('%url%', c.src))), c.hasSize = !0, c.loaded = !0, c.loadError = !0) }; var h = b.st.image; const i = d.find('.mfp-img'); if (i.length) { let j = document.createElement('img'); j.className = 'mfp-img', c.el && c.el.find('img').length && (j.alt = c.el.find('img').attr('alt')), c.img = a(j).on('load.mfploader', f).on('error.mfploader', g), j.src = c.src, i.is('img') && (c.img = c.img.clone()), j = c.img[0], j.naturalWidth > 0 ? c.hasSize = !0 : j.width || (c.hasSize = !1) } return b._parseMarkup(d, { title: M(c), img_replaceWith: c.img }, c), b.resizeImage(), c.hasSize ? (L && clearInterval(L), c.loadError ? (d.addClass('mfp-loading'), b.updateStatus('error', h.tError.replace('%url%', c.src))) : (d.removeClass('mfp-loading'), b.updateStatus('ready')), d) : (b.updateStatus('loading'), c.loading = !0, c.hasSize || (c.imgHidden = !0, d.addClass('mfp-loading'), b.findImageSize(c)), d) } } }); let N; const O = function () { return void 0 === N && (N = void 0 !== document.createElement('p').style.MozTransform), N }; a.magnificPopup.registerModule('zoom', { options: { enabled: !1, easing: 'ease-in-out', duration: 300, opener(a) { return a.is('img') ? a : a.find('img') } }, proto: { initZoom() { let a; const c = b.st.zoom; const d = '.zoom'; if (c.enabled && b.supportsTransition) { let e; let f; const g = c.duration; const j = function (a) { const b = a.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'); const d = `all ${c.duration / 1e3}s ${c.easing}`; const e = { position: 'fixed', zIndex: 9999, left: 0, top: 0, '-webkit-backface-visibility': 'hidden' }; const f = 'transition'; return e[`-webkit-${f}`] = e[`-moz-${f}`] = e[`-o-${f}`] = e[f] = d, b.css(e), b }; const k = function () { b.content.css('visibility', 'visible') }; w(`BuildControls${d}`, () => { if (b._allowZoom()) { if (clearTimeout(e), b.content.css('visibility', 'hidden'), a = b._getItemToZoom(), !a) return void k(); f = j(a), f.css(b._getOffset()), b.wrap.append(f), e = setTimeout(() => { f.css(b._getOffset(!0)), e = setTimeout(() => { k(), setTimeout(() => { f.remove(), a = f = null, y('ZoomAnimationEnded') }, 16) }, g) }, 16) } }), w(i + d, () => { if (b._allowZoom()) { if (clearTimeout(e), b.st.removalDelay = g, !a) { if (a = b._getItemToZoom(), !a) return; f = j(a) }f.css(b._getOffset(!0)), b.wrap.append(f), b.content.css('visibility', 'hidden'), setTimeout(() => { f.css(b._getOffset()) }, 16) } }), w(h + d, () => { b._allowZoom() && (k(), f && f.remove(), a = null) }) } }, _allowZoom() { return b.currItem.type === 'image' }, _getItemToZoom() { return b.currItem.hasSize ? b.currItem.img : !1 }, _getOffset(c) { let d; d = c ? b.currItem.img : b.st.zoom.opener(b.currItem.el || b.currItem); const e = d.offset(); const f = parseInt(d.css('padding-top'), 10); const g = parseInt(d.css('padding-bottom'), 10); e.top -= a(window).scrollTop() - f; const h = { width: d.width(), height: (u ? d.innerHeight() : d[0].offsetHeight) - g - f }; return O() ? h['-moz-transform'] = h.transform = `translate(${e.left}px,${e.top}px)` : (h.left = e.left, h.top = e.top), h } } }); const P = 'iframe'; const Q = '//about:blank'; const R = function (a) { if (b.currTemplate[P]) { const c = b.currTemplate[P].find('iframe'); c.length && (a || (c[0].src = Q), b.isIE8 && c.css('display', a ? 'block' : 'none')) } }; a.magnificPopup.registerModule(P, { options: { markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>', srcAction: 'iframe_src', patterns: { youtube: { index: 'youtube.com', id: 'v=', src: '//www.youtube.com/embed/%id%?autoplay=1' }, vimeo: { index: 'vimeo.com/', id: '/', src: '//player.vimeo.com/video/%id%?autoplay=1' }, gmaps: { index: '//maps.google.', src: '%id%&output=embed' } } }, proto: { initIframe() { b.types.push(P), w('BeforeChange', (a, b, c) => { b !== c && (b === P ? R() : c === P && R(!0)) }), w(`${h}.${P}`, () => { R() }) }, getIframe(c, d) { let e = c.src; const f = b.st.iframe; a.each(f.patterns, function () { return e.indexOf(this.index) > -1 ? (this.id && (e = typeof this.id === 'string' ? e.substr(e.lastIndexOf(this.id) + this.id.length, e.length) : this.id.call(this, e)), e = this.src.replace('%id%', e), !1) : void 0 }); const g = {}; return f.srcAction && (g[f.srcAction] = e), b._parseMarkup(d, g, c), b.updateStatus('ready'), d } } }); const S = function (a) { const c = b.items.length; return a > c - 1 ? a - c : a < 0 ? c + a : a }; const T = function (a, b, c) { return a.replace(/%curr%/gi, b + 1).replace(/%total%/gi, c) }; a.magnificPopup.registerModule('gallery', { options: { enabled: !1, arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>', preload: [0, 2], navigateByImgClick: !0, arrows: !0, tPrev: 'Previous (Left arrow key)', tNext: 'Next (Right arrow key)', tCounter: '%curr% of %total%' }, proto: { initGallery() { const c = b.st.gallery; const e = '.mfp-gallery'; return b.direction = !0, c && c.enabled ? (f += ' mfp-gallery', w(m + e, () => { c.navigateByImgClick && b.wrap.on(`click${e}`, '.mfp-img', () => b.items.length > 1 ? (b.next(), !1) : void 0), d.on(`keydown${e}`, (a) => { a.keyCode === 37 ? b.prev() : a.keyCode === 39 && b.next() }) }), w(`UpdateStatus${e}`, (a, c) => { c.text && (c.text = T(c.text, b.currItem.index, b.items.length)) }), w(l + e, (a, d, e, f) => { const g = b.items.length; e.counter = g > 1 ? T(c.tCounter, f.index, g) : '' }), w(`BuildControls${e}`, () => { if (b.items.length > 1 && c.arrows && !b.arrowLeft) { const d = c.arrowMarkup; const e = b.arrowLeft = a(d.replace(/%title%/gi, c.tPrev).replace(/%dir%/gi, 'left')).addClass(s); const f = b.arrowRight = a(d.replace(/%title%/gi, c.tNext).replace(/%dir%/gi, 'right')).addClass(s); e.click(() => { b.prev() }), f.click(() => { b.next() }), b.container.append(e.add(f)) } }), w(n + e, () => { b._preloadTimeout && clearTimeout(b._preloadTimeout), b._preloadTimeout = setTimeout(() => { b.preloadNearbyImages(), b._preloadTimeout = null }, 16) }), void w(h + e, () => { d.off(e), b.wrap.off(`click${e}`), b.arrowRight = b.arrowLeft = null })) : !1 }, next() { b.direction = !0, b.index = S(b.index + 1), b.updateItemHTML() }, prev() { b.direction = !1, b.index = S(b.index - 1), b.updateItemHTML() }, goTo(a) { b.direction = a >= b.index, b.index = a, b.updateItemHTML() }, preloadNearbyImages() { let a; const c = b.st.gallery.preload; const d = Math.min(c[0], b.items.length); const e = Math.min(c[1], b.items.length); for (a = 1; a <= (b.direction ? e : d); a++)b._preloadItem(b.index + a); for (a = 1; a <= (b.direction ? d : e); a++)b._preloadItem(b.index - a) }, _preloadItem(c) { if (c = S(c), !b.items[c].preloaded) { let d = b.items[c]; d.parsed || (d = b.parseEl(c)), y('LazyLoad', d), d.type === 'image' && (d.img = a('<img class="mfp-img" />').on('load.mfploader', () => { d.hasSize = !0 }).on('error.mfploader', () => { d.hasSize = !0, d.loadError = !0, y('LazyLoadError', d) }).attr('src', d.src)), d.preloaded = !0 } } } }); const U = 'retina'; a.magnificPopup.registerModule(U, { options: { replaceSrc(a) { return a.src.replace(/\.\w+$/, (a) => `@2x${a}`) }, ratio: 1 }, proto: { initRetina() { if (window.devicePixelRatio > 1) { const a = b.st.retina; let c = a.ratio; c = isNaN(c) ? c() : c, c > 1 && (w(`ImageHasSize.${U}`, (a, b) => { b.img.css({ 'max-width': b.img[0].naturalWidth / c, width: '100%' }) }), w(`ElementParse.${U}`, (b, d) => { d.src = a.replaceSrc(d, c) })) } } } }), A() }))

/*
 * jQuery FlexSlider v2.7.1
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
!(function ($) { let e = !0; $.flexslider = function (t, a) { const n = $(t); void 0 === a.rtl && $('html').attr('dir') == 'rtl' && (a.rtl = !0), n.vars = $.extend({}, $.flexslider.defaults, a); const i = n.vars.namespace; const r = window.navigator && window.navigator.msPointerEnabled && window.MSGesture; const s = ('ontouchstart' in window || r || window.DocumentTouch && document instanceof DocumentTouch) && n.vars.touch; const o = 'click touchend MSPointerUp keyup'; let l = ''; let c; const d = n.vars.direction === 'vertical'; const u = n.vars.reverse; const v = n.vars.itemWidth > 0; const p = n.vars.animation === 'fade'; const m = n.vars.asNavFor !== ''; let f = {}; $.data(t, 'flexslider', n), f = { init() { n.animating = !1, n.currentSlide = parseInt(n.vars.startAt ? n.vars.startAt : 0, 10), isNaN(n.currentSlide) && (n.currentSlide = 0), n.animatingTo = n.currentSlide, n.atEnd = n.currentSlide === 0 || n.currentSlide === n.last, n.containerSelector = n.vars.selector.substr(0, n.vars.selector.search(' ')), n.slides = $(n.vars.selector, n), n.container = $(n.containerSelector, n), n.count = n.slides.length, n.syncExists = $(n.vars.sync).length > 0, n.vars.animation === 'slide' && (n.vars.animation = 'swing'), n.prop = d ? 'top' : n.vars.rtl ? 'marginRight' : 'marginLeft', n.args = {}, n.manualPause = !1, n.stopped = !1, n.started = !1, n.startTimeout = null, n.transitions = !n.vars.video && !p && n.vars.useCSS && (function () { const e = document.createElement('div'); const t = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective']; for (const a in t) if (void 0 !== e.style[t[a]]) return n.pfx = t[a].replace('Perspective', '').toLowerCase(), n.prop = `-${n.pfx}-transform`, !0; return !1 }()), n.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1, n.ensureAnimationEnd = '', n.vars.controlsContainer !== '' && (n.controlsContainer = $(n.vars.controlsContainer).length > 0 && $(n.vars.controlsContainer)), n.vars.manualControls !== '' && (n.manualControls = $(n.vars.manualControls).length > 0 && $(n.vars.manualControls)), n.vars.customDirectionNav !== '' && (n.customDirectionNav = $(n.vars.customDirectionNav).length === 2 && $(n.vars.customDirectionNav)), n.vars.randomize && (n.slides.sort(() => Math.round(Math.random()) - 0.5), n.container.empty().append(n.slides)), n.doMath(), n.setup('init'), n.vars.controlNav && f.controlNav.setup(), n.vars.directionNav && f.directionNav.setup(), n.vars.keyboard && ($(n.containerSelector).length === 1 || n.vars.multipleKeyboard) && $(document).bind('keyup', (e) => { const t = e.keyCode; if (!n.animating && (t === 39 || t === 37)) { const a = n.vars.rtl ? t === 37 ? n.getTarget('next') : t === 39 && n.getTarget('prev') : t === 39 ? n.getTarget('next') : t === 37 && n.getTarget('prev'); n.flexAnimate(a, n.vars.pauseOnAction) } }), n.vars.mousewheel && n.bind('mousewheel', (e, t, a, i) => { e.preventDefault(); const r = t < 0 ? n.getTarget('next') : n.getTarget('prev'); n.flexAnimate(r, n.vars.pauseOnAction) }), n.vars.pausePlay && f.pausePlay.setup(), n.vars.slideshow && n.vars.pauseInvisible && f.pauseInvisible.init(), n.vars.slideshow && (n.vars.pauseOnHover && n.hover(() => { n.manualPlay || n.manualPause || n.pause() }, () => { n.manualPause || n.manualPlay || n.stopped || n.play() }), n.vars.pauseInvisible && f.pauseInvisible.isHidden() || (n.vars.initDelay > 0 ? n.startTimeout = setTimeout(n.play, n.vars.initDelay) : n.play())), m && f.asNav.setup(), s && n.vars.touch && f.touch(), (!p || p && n.vars.smoothHeight) && $(window).bind('resize orientationchange focus', f.resize), n.find('img').attr('draggable', 'false'), setTimeout(() => { n.vars.start(n) }, 200) }, asNav: { setup() { n.asNav = !0, n.animatingTo = Math.floor(n.currentSlide / n.move), n.currentItem = n.currentSlide, n.slides.removeClass(`${i}active-slide`).eq(n.currentItem).addClass(`${i}active-slide`), r ? (t._slider = n, n.slides.each(function () { const e = this; e._gesture = new MSGesture(), e._gesture.target = e, e.addEventListener('MSPointerDown', (e) => { e.preventDefault(), e.currentTarget._gesture && e.currentTarget._gesture.addPointer(e.pointerId) }, !1), e.addEventListener('MSGestureTap', function (e) { e.preventDefault(); const t = $(this); const a = t.index(); $(n.vars.asNavFor).data('flexslider').animating || t.hasClass('active') || (n.direction = n.currentItem < a ? 'next' : 'prev', n.flexAnimate(a, n.vars.pauseOnAction, !1, !0, !0)) }) })) : n.slides.on(o, function (e) { e.preventDefault(); const t = $(this); const a = t.index(); let r; r = n.vars.rtl ? -1 * (t.offset().right - $(n).scrollLeft()) : t.offset().left - $(n).scrollLeft(), r <= 0 && t.hasClass(`${i}active-slide`) ? n.flexAnimate(n.getTarget('prev'), !0) : $(n.vars.asNavFor).data('flexslider').animating || t.hasClass(`${i}active-slide`) || (n.direction = n.currentItem < a ? 'next' : 'prev', n.flexAnimate(a, n.vars.pauseOnAction, !1, !0, !0)) }) } }, controlNav: { setup() { n.manualControls ? f.controlNav.setupManual() : f.controlNav.setupPaging() }, setupPaging() { const e = n.vars.controlNav === 'thumbnails' ? 'control-thumbs' : 'control-paging'; let t = 1; let a; let r; if (n.controlNavScaffold = $(`<ol class="${i}control-nav ${i}${e}"></ol>`), n.pagingCount > 1) for (let s = 0; s < n.pagingCount; s++) { r = n.slides.eq(s), void 0 === r.attr('data-thumb-alt') && r.attr('data-thumb-alt', ''); var c = r.attr('data-thumb-alt') !== '' ? c = ` alt="${r.attr('data-thumb-alt')}"` : ''; if (a = n.vars.controlNav === 'thumbnails' ? `<img src="${r.attr('data-thumb')}"${c}/>` : `<a href="#">${t}</a>`, n.vars.controlNav === 'thumbnails' && !0 === n.vars.thumbCaptions) { const d = r.attr('data-thumbcaption'); d !== '' && void 0 !== d && (a += `<span class="${i}caption">${d}</span>`) }n.controlNavScaffold.append(`<li>${a}</li>`), t++ }n.controlsContainer ? $(n.controlsContainer).append(n.controlNavScaffold) : n.append(n.controlNavScaffold), f.controlNav.set(), f.controlNav.active(), n.controlNavScaffold.delegate('a, img', o, function (e) { if (e.preventDefault(), l === '' || l === e.type) { const t = $(this); const a = n.controlNav.index(t); t.hasClass(`${i}active`) || (n.direction = a > n.currentSlide ? 'next' : 'prev', n.flexAnimate(a, n.vars.pauseOnAction)) }l === '' && (l = e.type), f.setToClearWatchedEvent() }) }, setupManual() { n.controlNav = n.manualControls, f.controlNav.active(), n.controlNav.bind(o, function (e) { if (e.preventDefault(), l === '' || l === e.type) { const t = $(this); const a = n.controlNav.index(t); t.hasClass(`${i}active`) || (a > n.currentSlide ? n.direction = 'next' : n.direction = 'prev', n.flexAnimate(a, n.vars.pauseOnAction)) }l === '' && (l = e.type), f.setToClearWatchedEvent() }) }, set() { const e = n.vars.controlNav === 'thumbnails' ? 'img' : 'a'; n.controlNav = $(`.${i}control-nav li ${e}`, n.controlsContainer ? n.controlsContainer : n) }, active() { n.controlNav.removeClass(`${i}active`).eq(n.animatingTo).addClass(`${i}active`) }, update(e, t) { n.pagingCount > 1 && e === 'add' ? n.controlNavScaffold.append($(`<li><a href="#">${n.count}</a></li>`)) : n.pagingCount === 1 ? n.controlNavScaffold.find('li').remove() : n.controlNav.eq(t).closest('li').remove(), f.controlNav.set(), n.pagingCount > 1 && n.pagingCount !== n.controlNav.length ? n.update(t, e) : f.controlNav.active() } }, directionNav: { setup() { const e = $(`<ul class="${i}direction-nav"><li class="${i}nav-prev"><a class="${i}prev" href="#">${n.vars.prevText}</a></li><li class="${i}nav-next"><a class="${i}next" href="#">${n.vars.nextText}</a></li></ul>`); n.customDirectionNav ? n.directionNav = n.customDirectionNav : n.controlsContainer ? ($(n.controlsContainer).append(e), n.directionNav = $(`.${i}direction-nav li a`, n.controlsContainer)) : (n.append(e), n.directionNav = $(`.${i}direction-nav li a`, n)), f.directionNav.update(), n.directionNav.bind(o, function (e) { e.preventDefault(); let t; l !== '' && l !== e.type || (t = $(this).hasClass(`${i}next`) ? n.getTarget('next') : n.getTarget('prev'), n.flexAnimate(t, n.vars.pauseOnAction)), l === '' && (l = e.type), f.setToClearWatchedEvent() }) }, update() { const e = `${i}disabled`; n.pagingCount === 1 ? n.directionNav.addClass(e).attr('tabindex', '-1') : n.vars.animationLoop ? n.directionNav.removeClass(e).removeAttr('tabindex') : n.animatingTo === 0 ? n.directionNav.removeClass(e).filter(`.${i}prev`).addClass(e).attr('tabindex', '-1') : n.animatingTo === n.last ? n.directionNav.removeClass(e).filter(`.${i}next`).addClass(e).attr('tabindex', '-1') : n.directionNav.removeClass(e).removeAttr('tabindex') } }, pausePlay: { setup() { const e = $(`<div class="${i}pauseplay"><a href="#"></a></div>`); n.controlsContainer ? (n.controlsContainer.append(e), n.pausePlay = $(`.${i}pauseplay a`, n.controlsContainer)) : (n.append(e), n.pausePlay = $(`.${i}pauseplay a`, n)), f.pausePlay.update(n.vars.slideshow ? `${i}pause` : `${i}play`), n.pausePlay.bind(o, function (e) { e.preventDefault(), l !== '' && l !== e.type || ($(this).hasClass(`${i}pause`) ? (n.manualPause = !0, n.manualPlay = !1, n.pause()) : (n.manualPause = !1, n.manualPlay = !0, n.play())), l === '' && (l = e.type), f.setToClearWatchedEvent() }) }, update(e) { e === 'play' ? n.pausePlay.removeClass(`${i}pause`).addClass(`${i}play`).html(n.vars.playText) : n.pausePlay.removeClass(`${i}play`).addClass(`${i}pause`).html(n.vars.pauseText) } }, touch() { function e(e) { e.stopPropagation(), n.animating ? e.preventDefault() : (n.pause(), t._gesture.addPointer(e.pointerId), w = 0, c = d ? n.h : n.w, f = Number(new Date()), l = v && u && n.animatingTo === n.last ? 0 : v && u ? n.limit - (n.itemW + n.vars.itemMargin) * n.move * n.animatingTo : v && n.currentSlide === n.last ? n.limit : v ? (n.itemW + n.vars.itemMargin) * n.move * n.currentSlide : u ? (n.last - n.currentSlide + n.cloneOffset) * c : (n.currentSlide + n.cloneOffset) * c) } function a(e) { e.stopPropagation(); const a = e.target._slider; if (a) { const n = -e.translationX; const i = -e.translationY; if (w += d ? i : n, m = (a.vars.rtl ? -1 : 1) * w, x = d ? Math.abs(w) < Math.abs(-n) : Math.abs(w) < Math.abs(-i), e.detail === e.MSGESTURE_FLAG_INERTIA) return void setImmediate(() => { t._gesture.stop() }); (!x || Number(new Date()) - f > 500) && (e.preventDefault(), !p && a.transitions && (a.vars.animationLoop || (m = w / (a.currentSlide === 0 && w < 0 || a.currentSlide === a.last && w > 0 ? Math.abs(w) / c + 2 : 1)), a.setProps(l + m, 'setTouch'))) } } function i(e) { e.stopPropagation(); const t = e.target._slider; if (t) { if (t.animatingTo === t.currentSlide && !x && m !== null) { const a = u ? -m : m; const n = a > 0 ? t.getTarget('next') : t.getTarget('prev'); t.canAdvance(n) && (Number(new Date()) - f < 550 && Math.abs(a) > 50 || Math.abs(a) > c / 2) ? t.flexAnimate(n, t.vars.pauseOnAction) : p || t.flexAnimate(t.currentSlide, t.vars.pauseOnAction, !0) }s = null, o = null, m = null, l = null, w = 0 } } let s; let o; let l; let c; let m; let f; let g; let h; let S; var x = !1; let y = 0; let b = 0; var w = 0; r ? (t.style.msTouchAction = 'none', t._gesture = new MSGesture(), t._gesture.target = t, t.addEventListener('MSPointerDown', e, !1), t._slider = n, t.addEventListener('MSGestureChange', a, !1), t.addEventListener('MSGestureEnd', i, !1)) : (g = function (e) { n.animating ? e.preventDefault() : (window.navigator.msPointerEnabled || e.touches.length === 1) && (n.pause(), c = d ? n.h : n.w, f = Number(new Date()), y = e.touches[0].pageX, b = e.touches[0].pageY, l = v && u && n.animatingTo === n.last ? 0 : v && u ? n.limit - (n.itemW + n.vars.itemMargin) * n.move * n.animatingTo : v && n.currentSlide === n.last ? n.limit : v ? (n.itemW + n.vars.itemMargin) * n.move * n.currentSlide : u ? (n.last - n.currentSlide + n.cloneOffset) * c : (n.currentSlide + n.cloneOffset) * c, s = d ? b : y, o = d ? y : b, t.addEventListener('touchmove', h, !1), t.addEventListener('touchend', S, !1)) }, h = function (e) { y = e.touches[0].pageX, b = e.touches[0].pageY, m = d ? s - b : (n.vars.rtl ? -1 : 1) * (s - y), x = d ? Math.abs(m) < Math.abs(y - o) : Math.abs(m) < Math.abs(b - o); const t = 500; (!x || Number(new Date()) - f > 500) && (e.preventDefault(), !p && n.transitions && (n.vars.animationLoop || (m /= n.currentSlide === 0 && m < 0 || n.currentSlide === n.last && m > 0 ? Math.abs(m) / c + 2 : 1), n.setProps(l + m, 'setTouch'))) }, S = function (e) { if (t.removeEventListener('touchmove', h, !1), n.animatingTo === n.currentSlide && !x && m !== null) { const a = u ? -m : m; const i = a > 0 ? n.getTarget('next') : n.getTarget('prev'); n.canAdvance(i) && (Number(new Date()) - f < 550 && Math.abs(a) > 50 || Math.abs(a) > c / 2) ? n.flexAnimate(i, n.vars.pauseOnAction) : p || n.flexAnimate(n.currentSlide, n.vars.pauseOnAction, !0) }t.removeEventListener('touchend', S, !1), s = null, o = null, m = null, l = null }, t.addEventListener('touchstart', g, !1)) }, resize() { !n.animating && n.is(':visible') && (v || n.doMath(), p ? f.smoothHeight() : v ? (n.slides.width(n.computedW), n.update(n.pagingCount), n.setProps()) : d ? (n.viewport.height(n.h), n.setProps(n.h, 'setTotal')) : (n.vars.smoothHeight && f.smoothHeight(), n.newSlides.width(n.computedW), n.setProps(n.computedW, 'setTotal'))) }, smoothHeight(e) { if (!d || p) { const t = p ? n : n.viewport; e ? t.animate({ height: n.slides.eq(n.animatingTo).innerHeight() }, e) : t.innerHeight(n.slides.eq(n.animatingTo).innerHeight()) } }, sync(e) { const t = $(n.vars.sync).data('flexslider'); const a = n.animatingTo; switch (e) { case 'animate':t.flexAnimate(a, n.vars.pauseOnAction, !1, !0); break; case 'play':t.playing || t.asNav || t.play(); break; case 'pause':t.pause(); break } }, uniqueID(e) { return e.filter('[id]').add(e.find('[id]')).each(function () { const e = $(this); e.attr('id', `${e.attr('id')}_clone`) }), e }, pauseInvisible: { visProp: null, init() { const e = f.pauseInvisible.getHiddenProp(); if (e) { const t = `${e.replace(/[H|h]idden/, '')}visibilitychange`; document.addEventListener(t, () => { f.pauseInvisible.isHidden() ? n.startTimeout ? clearTimeout(n.startTimeout) : n.pause() : n.started ? n.play() : n.vars.initDelay > 0 ? setTimeout(n.play, n.vars.initDelay) : n.play() }) } }, isHidden() { const e = f.pauseInvisible.getHiddenProp(); return !!e && document[e] }, getHiddenProp() { const e = ['webkit', 'moz', 'ms', 'o']; if ('hidden' in document) return 'hidden'; for (let t = 0; t < e.length; t++) if (`${e[t]}Hidden` in document) return `${e[t]}Hidden`; return null } }, setToClearWatchedEvent() { clearTimeout(c), c = setTimeout(() => { l = '' }, 3e3) } }, n.flexAnimate = function (e, t, a, r, o) { if (n.vars.animationLoop || e === n.currentSlide || (n.direction = e > n.currentSlide ? 'next' : 'prev'), m && n.pagingCount === 1 && (n.direction = n.currentItem < e ? 'next' : 'prev'), !n.animating && (n.canAdvance(e, o) || a) && n.is(':visible')) { if (m && r) { const l = $(n.vars.asNavFor).data('flexslider'); if (n.atEnd = e === 0 || e === n.count - 1, l.flexAnimate(e, !0, !1, !0, o), n.direction = n.currentItem < e ? 'next' : 'prev', l.direction = n.direction, Math.ceil((e + 1) / n.visible) - 1 === n.currentSlide || e === 0) return n.currentItem = e, n.slides.removeClass(`${i}active-slide`).eq(e).addClass(`${i}active-slide`), !1; n.currentItem = e, n.slides.removeClass(`${i}active-slide`).eq(e).addClass(`${i}active-slide`), e = Math.floor(e / n.visible) } if (n.animating = !0, n.animatingTo = e, t && n.pause(), n.vars.before(n), n.syncExists && !o && f.sync('animate'), n.vars.controlNav && f.controlNav.active(), v || n.slides.removeClass(`${i}active-slide`).eq(e).addClass(`${i}active-slide`), n.atEnd = e === 0 || e === n.last, n.vars.directionNav && f.directionNav.update(), e === n.last && (n.vars.end(n), n.vars.animationLoop || n.pause()), p)s ? (n.slides.eq(n.currentSlide).css({ opacity: 0, zIndex: 1 }), n.slides.eq(e).css({ opacity: 1, zIndex: 2 }), n.wrapup(c)) : (n.slides.eq(n.currentSlide).css({ zIndex: 1 }).animate({ opacity: 0 }, n.vars.animationSpeed, n.vars.easing), n.slides.eq(e).css({ zIndex: 2 }).animate({ opacity: 1 }, n.vars.animationSpeed, n.vars.easing, n.wrapup)); else { var c = d ? n.slides.filter(':first').height() : n.computedW; let g; let h; let S; v ? (g = n.vars.itemMargin, S = (n.itemW + g) * n.move * n.animatingTo, h = S > n.limit && n.visible !== 1 ? n.limit : S) : h = n.currentSlide === 0 && e === n.count - 1 && n.vars.animationLoop && n.direction !== 'next' ? u ? (n.count + n.cloneOffset) * c : 0 : n.currentSlide === n.last && e === 0 && n.vars.animationLoop && n.direction !== 'prev' ? u ? 0 : (n.count + 1) * c : u ? (n.count - 1 - e + n.cloneOffset) * c : (e + n.cloneOffset) * c, n.setProps(h, '', n.vars.animationSpeed), n.transitions ? (n.vars.animationLoop && n.atEnd || (n.animating = !1, n.currentSlide = n.animatingTo), n.container.unbind('webkitTransitionEnd transitionend'), n.container.bind('webkitTransitionEnd transitionend', () => { clearTimeout(n.ensureAnimationEnd), n.wrapup(c) }), clearTimeout(n.ensureAnimationEnd), n.ensureAnimationEnd = setTimeout(() => { n.wrapup(c) }, n.vars.animationSpeed + 100)) : n.container.animate(n.args, n.vars.animationSpeed, n.vars.easing, () => { n.wrapup(c) }) }n.vars.smoothHeight && f.smoothHeight(n.vars.animationSpeed) } }, n.wrapup = function (e) { p || v || (n.currentSlide === 0 && n.animatingTo === n.last && n.vars.animationLoop ? n.setProps(e, 'jumpEnd') : n.currentSlide === n.last && n.animatingTo === 0 && n.vars.animationLoop && n.setProps(e, 'jumpStart')), n.animating = !1, n.currentSlide = n.animatingTo, n.vars.after(n) }, n.animateSlides = function () { !n.animating && e && n.flexAnimate(n.getTarget('next')) }, n.pause = function () { clearInterval(n.animatedSlides), n.animatedSlides = null, n.playing = !1, n.vars.pausePlay && f.pausePlay.update('play'), n.syncExists && f.sync('pause') }, n.play = function () { n.playing && clearInterval(n.animatedSlides), n.animatedSlides = n.animatedSlides || setInterval(n.animateSlides, n.vars.slideshowSpeed), n.started = n.playing = !0, n.vars.pausePlay && f.pausePlay.update('pause'), n.syncExists && f.sync('play') }, n.stop = function () { n.pause(), n.stopped = !0 }, n.canAdvance = function (e, t) { const a = m ? n.pagingCount - 1 : n.last; return !!t || (!(!m || n.currentItem !== n.count - 1 || e !== 0 || n.direction !== 'prev') || (!m || n.currentItem !== 0 || e !== n.pagingCount - 1 || n.direction === 'next') && (!(e === n.currentSlide && !m) && (!!n.vars.animationLoop || (!n.atEnd || n.currentSlide !== 0 || e !== a || n.direction === 'next') && (!n.atEnd || n.currentSlide !== a || e !== 0 || n.direction !== 'next')))) }, n.getTarget = function (e) { return n.direction = e, e === 'next' ? n.currentSlide === n.last ? 0 : n.currentSlide + 1 : n.currentSlide === 0 ? n.last : n.currentSlide - 1 }, n.setProps = function (e, t, a) { let i = (function () { const a = e || (n.itemW + n.vars.itemMargin) * n.move * n.animatingTo; return `${(function () { if (v) return t === 'setTouch' ? e : u && n.animatingTo === n.last ? 0 : u ? n.limit - (n.itemW + n.vars.itemMargin) * n.move * n.animatingTo : n.animatingTo === n.last ? n.limit : a; switch (t) { case 'setTotal':return u ? (n.count - 1 - n.currentSlide + n.cloneOffset) * e : (n.currentSlide + n.cloneOffset) * e; case 'setTouch':return e; case 'jumpEnd':return u ? e : n.count * e; case 'jumpStart':return u ? n.count * e : e; default:return e } }()) * (n.vars.rtl ? 1 : -1)}px` }()); n.transitions && (i = n.isFirefox ? d ? `translate3d(0,${i},0)` : `translate3d(${parseInt(i)}px,0,0)` : d ? `translate3d(0,${i},0)` : `translate3d(${(n.vars.rtl ? -1 : 1) * parseInt(i)}px,0,0)`, a = void 0 !== a ? `${a / 1e3}s` : '0s', n.container.css(`-${n.pfx}-transition-duration`, a), n.container.css('transition-duration', a)), n.args[n.prop] = i, (n.transitions || void 0 === a) && n.container.css(n.args), n.container.css('transform', i) }, n.setup = function (e) { if (p)n.vars.rtl ? n.slides.css({ width: '100%', float: 'right', marginLeft: '-100%', position: 'relative' }) : n.slides.css({ width: '100%', float: 'left', marginRight: '-100%', position: 'relative' }), e === 'init' && (s ? n.slides.css({ opacity: 0, display: 'block', webkitTransition: `opacity ${n.vars.animationSpeed / 1e3}s ease`, zIndex: 1 }).eq(n.currentSlide).css({ opacity: 1, zIndex: 2 }) : n.vars.fadeFirstSlide == 0 ? n.slides.css({ opacity: 0, display: 'block', zIndex: 1 }).eq(n.currentSlide).css({ zIndex: 2 }).css({ opacity: 1 }) : n.slides.css({ opacity: 0, display: 'block', zIndex: 1 }).eq(n.currentSlide).css({ zIndex: 2 }).animate({ opacity: 1 }, n.vars.animationSpeed, n.vars.easing)), n.vars.smoothHeight && f.smoothHeight(); else { let t, a; e === 'init' && (n.viewport = $(`<div class="${i}viewport"></div>`).css({ overflow: 'hidden', position: 'relative' }).appendTo(n).append(n.container), n.cloneCount = 0, n.cloneOffset = 0, u && (a = $.makeArray(n.slides).reverse(), n.slides = $(a), n.container.empty().append(n.slides))), n.vars.animationLoop && !v && (n.cloneCount = 2, n.cloneOffset = 1, e !== 'init' && n.container.find('.clone').remove(), n.container.append(f.uniqueID(n.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true')).prepend(f.uniqueID(n.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'))), n.newSlides = $(n.vars.selector, n), t = u ? n.count - 1 - n.currentSlide + n.cloneOffset : n.currentSlide + n.cloneOffset, d && !v ? (n.container.height(`${200 * (n.count + n.cloneCount)}%`).css('position', 'absolute').width('100%'), setTimeout(() => { n.newSlides.css({ display: 'block' }), n.doMath(), n.viewport.height(n.h), n.setProps(t * n.h, 'init') }, e === 'init' ? 100 : 0)) : (n.container.width(`${200 * (n.count + n.cloneCount)}%`), n.setProps(t * n.computedW, 'init'), setTimeout(() => { n.doMath(), n.vars.rtl && n.isFirefox ? n.newSlides.css({ width: n.computedW, marginRight: n.computedM, float: 'right', display: 'block' }) : n.newSlides.css({ width: n.computedW, marginRight: n.computedM, float: 'left', display: 'block' }), n.vars.smoothHeight && f.smoothHeight() }, e === 'init' ? 100 : 0)) }v || n.slides.removeClass(`${i}active-slide`).eq(n.currentSlide).addClass(`${i}active-slide`), n.vars.init(n) }, n.doMath = function () { const e = n.slides.first(); const t = n.vars.itemMargin; const a = n.vars.minItems; const i = n.vars.maxItems; n.w = void 0 === n.viewport ? n.width() : n.viewport.width(), n.isFirefox && (n.w = n.width()), n.h = e.height(), n.boxPadding = e.outerWidth() - e.width(), v ? (n.itemT = n.vars.itemWidth + t, n.itemM = t, n.minW = a ? a * n.itemT : n.w, n.maxW = i ? i * n.itemT - t : n.w, n.itemW = n.minW > n.w ? (n.w - t * (a - 1)) / a : n.maxW < n.w ? (n.w - t * (i - 1)) / i : n.vars.itemWidth > n.w ? n.w : n.vars.itemWidth, n.visible = Math.floor(n.w / n.itemW), n.move = n.vars.move > 0 && n.vars.move < n.visible ? n.vars.move : n.visible, n.pagingCount = Math.ceil((n.count - n.visible) / n.move + 1), n.last = n.pagingCount - 1, n.limit = n.pagingCount === 1 ? 0 : n.vars.itemWidth > n.w ? n.itemW * (n.count - 1) + t * (n.count - 1) : (n.itemW + t) * n.count - n.w - t) : (n.itemW = n.w, n.itemM = t, n.pagingCount = n.count, n.last = n.count - 1), n.computedW = n.itemW - n.boxPadding, n.computedM = n.itemM }, n.update = function (e, t) { n.doMath(), v || (e < n.currentSlide ? n.currentSlide += 1 : e <= n.currentSlide && e !== 0 && (n.currentSlide -= 1), n.animatingTo = n.currentSlide), n.vars.controlNav && !n.manualControls && (t === 'add' && !v || n.pagingCount > n.controlNav.length ? f.controlNav.update('add') : (t === 'remove' && !v || n.pagingCount < n.controlNav.length) && (v && n.currentSlide > n.last && (n.currentSlide -= 1, n.animatingTo -= 1), f.controlNav.update('remove', n.last))), n.vars.directionNav && f.directionNav.update() }, n.addSlide = function (e, t) { const a = $(e); n.count += 1, n.last = n.count - 1, d && u ? void 0 !== t ? n.slides.eq(n.count - t).after(a) : n.container.prepend(a) : void 0 !== t ? n.slides.eq(t).before(a) : n.container.append(a), n.update(t, 'add'), n.slides = $(`${n.vars.selector}:not(.clone)`, n), n.setup(), n.vars.added(n) }, n.removeSlide = function (e) { const t = isNaN(e) ? n.slides.index($(e)) : e; n.count -= 1, n.last = n.count - 1, isNaN(e) ? $(e, n.slides).remove() : d && u ? n.slides.eq(n.last).remove() : n.slides.eq(e).remove(), n.doMath(), n.update(t, 'remove'), n.slides = $(`${n.vars.selector}:not(.clone)`, n), n.setup(), n.vars.removed(n) }, f.init() }, $(window).blur((t) => { e = !1 }).focus((t) => { e = !0 }), $.flexslider.defaults = { namespace: 'flex-', selector: '.slides > li', animation: 'fade', easing: 'swing', direction: 'horizontal', reverse: !1, animationLoop: !0, smoothHeight: !1, startAt: 0, slideshow: !0, slideshowSpeed: 7e3, animationSpeed: 600, initDelay: 0, randomize: !1, fadeFirstSlide: !0, thumbCaptions: !1, pauseOnAction: !0, pauseOnHover: !1, pauseInvisible: !0, useCSS: !0, touch: !0, video: !1, controlNav: !0, directionNav: !0, prevText: 'Previous', nextText: 'Next', keyboard: !0, multipleKeyboard: !1, mousewheel: !1, pausePlay: !1, pauseText: 'Pause', playText: 'Play', controlsContainer: '', manualControls: '', customDirectionNav: '', sync: '', asNavFor: '', itemWidth: 0, itemMargin: 0, minItems: 1, maxItems: 0, move: 0, allowOneSlide: !0, isFirefox: !1, start() {}, before() {}, after() {}, end() {}, added() {}, removed() {}, init() {}, rtl: !1 }, $.fn.flexslider = function (e) { if (void 0 === e && (e = {}), typeof e === 'object') return this.each(function () { const t = $(this); const a = e.selector ? e.selector : '.slides > li'; const n = t.find(a); n.length === 1 && !1 === e.allowOneSlide || n.length === 0 ? (n.fadeIn(400), e.start && e.start(t)) : void 0 === t.data('flexslider') && new $.flexslider(this, e) }); const t = $(this).data('flexslider'); switch (e) { case 'play':t.play(); break; case 'pause':t.pause(); break; case 'stop':t.stop(); break; case 'next':t.flexAnimate(t.getTarget('next'), !0); break; case 'prev':case 'previous':t.flexAnimate(t.getTarget('prev'), !0); break; default:typeof e === 'number' && t.flexAnimate(e, !0) } } }(jQuery))

// jQuery Paginate v0.4
;(function ($) { $.fn.pajinate = function (options) { const current_page = 'current_page'; const items_per_page = 'items_per_page'; let meta; const defaults = { item_container_id: '.content', items_per_page: 10, nav_panel_id: '.page_navigation', nav_info_id: '.info_text', num_page_links_to_display: 20, start_page: 0, wrap_around: false, nav_label_first: 'First', nav_label_prev: 'Prev', nav_label_next: 'Next', nav_label_last: 'Last', nav_order: ['first', 'prev', 'num', 'next', 'last'], nav_label_info: 'Showing {0}-{1} of {2} results', show_first_last: true, abort_on_small_lists: false, jquery_ui: false, jquery_ui_active: 'ui-state-highlight', jquery_ui_default: 'ui-state-default', jquery_ui_disabled: 'ui-state-disabled' }; var options = $.extend(defaults, options); let $item_container; let $page_container; let $items; let $nav_panels; let total_page_no_links; const jquery_ui_default_class = options.jquery_ui ? options.jquery_ui_default : ''; const jquery_ui_active_class = options.jquery_ui ? options.jquery_ui_active : ''; const jquery_ui_disabled_class = options.jquery_ui ? options.jquery_ui_disabled : ''; return this.each(function () { $page_container = $(this); $item_container = $(this).find(options.item_container_id); $items = $page_container.find(options.item_container_id).children(); if (options.abort_on_small_lists && options.items_per_page >= $items.size()) { return $page_container }meta = $page_container; meta.data(current_page, 0); meta.data(items_per_page, options.items_per_page); const total_items = $item_container.children().length; const number_of_pages = Math.ceil(total_items / options.items_per_page); const more = '<li class="page-item disabled ellipse more"><a class="page-link" href="#">...</a></li>'; const less = '<li class="page-item disabled ellipse less"><a class="page-link" href="#">...</a></li>'; const first = !options.show_first_last ? '' : `<li class="page-item first_link ${jquery_ui_default_class}"><a class="page-link" href="#">${options.nav_label_first}</a></li>`; const last = !options.show_first_last ? '' : `<li class="page-item last_link ${jquery_ui_default_class}"><a class="page-link" href="#">${options.nav_label_last}</a></li>`; let navigation_html = ''; for (let i = 0; i < options.nav_order.length; i++) { switch (options.nav_order[i]) { case 'first':navigation_html += first; break; case 'last':navigation_html += last; break; case 'next':navigation_html += `<li class="page-item next_link ${jquery_ui_default_class}"><a class="page-link" href="#">${options.nav_label_next}</a></li>`; break; case 'prev':navigation_html += `<li class="page-item previous_link ${jquery_ui_default_class}"><a class="page-link" href="#">${options.nav_label_prev}</a></li>`; break; case 'num':navigation_html += less; var current_link = 0; while (number_of_pages > current_link) { navigation_html += `<li class="page-item page_link ${jquery_ui_default_class}" longdesc="${current_link}"><a class="page-link" href="#">${current_link + 1}</a></li>`; current_link++ }navigation_html += more; break; default:break } }$nav_panels = $page_container.find(options.nav_panel_id); $nav_panels.html(navigation_html).each(function () { $(this).find('.page_link:first').addClass('first'); $(this).find('.page_link:last').addClass('last') }); $nav_panels.children('.ellipse').hide(); $nav_panels.find('.previous_link').next().next().addClass(`active ${jquery_ui_active_class}`); $items.hide(); $items.slice(0, meta.data(items_per_page)).show(); total_page_no_links = $page_container.find(`${options.nav_panel_id}:first`).children('.page_link').length; options.num_page_links_to_display = Math.min(options.num_page_links_to_display, total_page_no_links); $nav_panels.children('.page_link').hide(); $nav_panels.each(function () { $(this).children('.page_link').slice(0, options.num_page_links_to_display).show() }); $page_container.find('.first_link').click(function (e) { e.preventDefault(); movePageNumbersRight($(this), 0); gotopage(0) }); $page_container.find('.last_link').click(function (e) { e.preventDefault(); const lastPage = total_page_no_links - 1; movePageNumbersLeft($(this), lastPage); gotopage(lastPage) }); $page_container.find('.previous_link').click(function (e) { e.preventDefault(); showPrevPage($(this)) }); $page_container.find('.next_link').click(function (e) { e.preventDefault(); showNextPage($(this)) }); $page_container.find('.page_link').click(function (e) { e.preventDefault(); gotopage($(this).attr('longdesc')) }); gotopage(parseInt(options.start_page)); toggleMoreLess(); if (!options.wrap_around) { tagNextPrev() } }); function showPrevPage(e) { new_page = parseInt(meta.data(current_page)) - 1; if ($(e).siblings('.active').prev('.page_link').length == true) { movePageNumbersRight(e, new_page); gotopage(new_page) } else if (options.wrap_around) { gotopage(total_page_no_links - 1) } } function showNextPage(e) { new_page = parseInt(meta.data(current_page)) + 1; if ($(e).siblings('.active').next('.page_link').length == true) { movePageNumbersLeft(e, new_page); gotopage(new_page) } else if (options.wrap_around) { gotopage(0) } } function gotopage(page_num) { page_num = parseInt(page_num, 10); const ipp = parseInt(meta.data(items_per_page)); start_from = page_num * ipp; end_on = start_from + ipp; const items = $items.hide().slice(start_from, end_on); items.fadeIn(700); $page_container.find(options.nav_panel_id).children(`.page_link[longdesc=${page_num}]`).addClass(`active ${jquery_ui_active_class}`).siblings('.active').removeClass(`active ${jquery_ui_active_class}`); meta.data(current_page, page_num); const $current_page = parseInt(meta.data(current_page) + 1); const total_items = $item_container.children().length; const $number_of_pages = Math.ceil(total_items / options.items_per_page); $page_container.find(options.nav_info_id).html(options.nav_label_info.replace('{0}', start_from + 1).replace('{1}', start_from + items.length).replace('{2}', $items.length).replace('{3}', $current_page).replace('{4}', $number_of_pages)); toggleMoreLess(); tagNextPrev(); if (typeof (options.onPageDisplayed) !== 'undefined') { options.onPageDisplayed.call(this, page_num + 1) } } function movePageNumbersLeft(e, new_p) { const new_page = new_p; const $current_active_link = $(e).siblings('.active'); if ($current_active_link.siblings(`.page_link[longdesc=${new_page}]`).css('display') == 'none') { $nav_panels.each(function () { $(this).children('.page_link').hide().slice(parseInt(new_page - options.num_page_links_to_display + 1), new_page + 1).show() }) } } function movePageNumbersRight(e, new_p) { const new_page = new_p; const $current_active_link = $(e).siblings('.active'); if ($current_active_link.siblings(`.page_link[longdesc=${new_page}]`).css('display') == 'none') { $nav_panels.each(function () { $(this).children('.page_link').hide().slice(new_page, new_page + parseInt(options.num_page_links_to_display)).show() }) } } function toggleMoreLess() {} function tagNextPrev() { if ($nav_panels.children('.last').hasClass('active')) { $nav_panels.children('.next_link').add('.last_link').addClass(`no_more ${jquery_ui_disabled_class}`) } else { $nav_panels.children('.next_link').add('.last_link').removeClass(`no_more ${jquery_ui_disabled_class}`) } if ($nav_panels.children('.first').hasClass('active')) { $nav_panels.children('.previous_link').add('.first_link').addClass(`no_more ${jquery_ui_disabled_class}`) } else { $nav_panels.children('.previous_link').add('.first_link').removeClass(`no_more ${jquery_ui_disabled_class}`) } } } })(jQuery)

/*!
 * Infinite Scroll PACKAGED v3.0.5
 * Automatically add next page
 *
 * Licensed GPLv3 for open source use
 * or Infinite Scroll Commercial License for commercial use
 *
 * https://infinite-scroll.com
 * Copyright 2018 Metafizzy
 */

!(function (t, e) { typeof define === 'function' && define.amd ? define('jquery-bridget/jquery-bridget', ['jquery'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('jquery')) : t.jQueryBridget = e(t, t.jQuery) }(window, (t, e) => {
  function i(i, r, l) { function a(t, e, n) { let o; const r = `$().${i}("${e}")`; return t.each((t, a) => { const h = l.data(a, i); if (!h) return void s(`${i} not initialized. Cannot call methods, i.e. ${r}`); const c = h[e]; if (!c || e.charAt(0) == '_') return void s(`${r} is not a valid method`); const u = c.apply(h, n); o = void 0 === o ? u : o }), void 0 !== o ? o : t } function h(t, e) { t.each((t, n) => { let o = l.data(n, i); o ? (o.option(e), o._init()) : (o = new r(n, e), l.data(n, i, o)) }) }l = l || e || t.jQuery, l && (r.prototype.option || (r.prototype.option = function (t) { l.isPlainObject(t) && (this.options = l.extend(!0, this.options, t)) }), l.fn[i] = function (t) { if (typeof t === 'string') { const e = o.call(arguments, 1); return a(this, t, e) } return h(this, t), this }, n(l)) } function n(t) { !t || t && t.bridget || (t.bridget = i) } var o = Array.prototype.slice; const r = t.console; var s = typeof r === 'undefined' ? function () {} : function (t) { r.error(t) }; return n(e || t.jQuery), i
})), (function (t, e) { typeof define === 'function' && define.amd ? define('ev-emitter/ev-emitter', e) : typeof module === 'object' && module.exports ? module.exports = e() : t.EvEmitter = e() }(typeof window !== 'undefined' ? window : this, () => { function t() {} const e = t.prototype; return e.on = function (t, e) { if (t && e) { const i = this._events = this._events || {}; const n = i[t] = i[t] || []; return n.indexOf(e) == -1 && n.push(e), this } }, e.once = function (t, e) { if (t && e) { this.on(t, e); const i = this._onceEvents = this._onceEvents || {}; const n = i[t] = i[t] || {}; return n[e] = !0, this } }, e.off = function (t, e) { const i = this._events && this._events[t]; if (i && i.length) { const n = i.indexOf(e); return n != -1 && i.splice(n, 1), this } }, e.emitEvent = function (t, e) { let i = this._events && this._events[t]; if (i && i.length) { i = i.slice(0), e = e || []; for (let n = this._onceEvents && this._onceEvents[t], o = 0; o < i.length; o++) { const r = i[o]; const s = n && n[r]; s && (this.off(t, r), delete n[r]), r.apply(this, e) } return this } }, e.allOff = function () { delete this._events, delete this._onceEvents }, t })), (function (t, e) {
  typeof define === 'function' && define.amd ? define('desandro-matches-selector/matches-selector', e) : typeof module === 'object' && module.exports ? module.exports = e() : t.matchesSelector = e()
}(window, () => {
  const t = (function () { const t = window.Element.prototype; if (t.matches) return 'matches'; if (t.matchesSelector) return 'matchesSelector'; for (let e = ['webkit', 'moz', 'ms', 'o'], i = 0; i < e.length; i++) { const n = e[i]; const o = `${n}MatchesSelector`; if (t[o]) return o } }()); return function (e, i) { return e[t](i) }
})), (function (t, e) { typeof define === 'function' && define.amd ? define('fizzy-ui-utils/utils', ['desandro-matches-selector/matches-selector'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('desandro-matches-selector')) : t.fizzyUIUtils = e(t, t.matchesSelector) }(window, (t, e) => { const i = {}; i.extend = function (t, e) { for (const i in e)t[i] = e[i]; return t }, i.modulo = function (t, e) { return (t % e + e) % e }; const n = Array.prototype.slice; i.makeArray = function (t) { if (Array.isArray(t)) return t; if (t === null || void 0 === t) return []; const e = typeof t === 'object' && typeof t.length === 'number'; return e ? n.call(t) : [t] }, i.removeFrom = function (t, e) { const i = t.indexOf(e); i != -1 && t.splice(i, 1) }, i.getParent = function (t, i) { for (;t.parentNode && t != document.body;) if (t = t.parentNode, e(t, i)) return t }, i.getQueryElement = function (t) { return typeof t === 'string' ? document.querySelector(t) : t }, i.handleEvent = function (t) { const e = `on${t.type}`; this[e] && this[e](t) }, i.filterFindElements = function (t, n) { t = i.makeArray(t); const o = []; return t.forEach((t) => { if (t instanceof HTMLElement) { if (!n) return void o.push(t); e(t, n) && o.push(t); for (let i = t.querySelectorAll(n), r = 0; r < i.length; r++)o.push(i[r]) } }), o }, i.debounceMethod = function (t, e, i) { i = i || 100; const n = t.prototype[e]; const o = `${e}Timeout`; t.prototype[e] = function () { const t = this[o]; clearTimeout(t); const e = arguments; const r = this; this[o] = setTimeout(() => { n.apply(r, e), delete r[o] }, i) } }, i.docReady = function (t) { const e = document.readyState; e == 'complete' || e == 'interactive' ? setTimeout(t) : document.addEventListener('DOMContentLoaded', t) }, i.toDashed = function (t) { return t.replace(/(.)([A-Z])/g, (t, e, i) => `${e}-${i}`).toLowerCase() }; const o = t.console; return i.htmlInit = function (e, n) { i.docReady(() => { const r = i.toDashed(n); const s = `data-${r}`; const l = document.querySelectorAll(`[${s}]`); const a = document.querySelectorAll(`.js-${r}`); const h = i.makeArray(l).concat(i.makeArray(a)); const c = `${s}-options`; const u = t.jQuery; h.forEach((t) => { let i; const r = t.getAttribute(s) || t.getAttribute(c); try { i = r && JSON.parse(r) } catch (l) { return void (o && o.error(`Error parsing ${s} on ${t.className}: ${l}`)) } const a = new e(t, i); u && u.data(t, n, a) }) }) }, i })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/core', ['ev-emitter/ev-emitter', 'fizzy-ui-utils/utils'], (i, n) => e(t, i, n)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('ev-emitter'), require('fizzy-ui-utils')) : t.InfiniteScroll = e(t, t.EvEmitter, t.fizzyUIUtils) }(window, (t, e, i) => { function n(t, e) { const s = i.getQueryElement(t); if (!s) return void console.error(`Bad element for InfiniteScroll: ${s || t}`); if (t = s, t.infiniteScrollGUID) { const l = r[t.infiniteScrollGUID]; return l.option(e), l } this.element = t, this.options = i.extend({}, n.defaults), this.option(e), o && (this.$element = o(this.element)), this.create() } var o = t.jQuery; var r = {}; n.defaults = {}, n.create = {}, n.destroy = {}; const s = n.prototype; i.extend(s, e.prototype); let l = 0; s.create = function () { const t = this.guid = ++l; this.element.infiniteScrollGUID = t, r[t] = this, this.pageIndex = 1, this.loadCount = 0, this.updateGetPath(); const e = this.getPath && this.getPath(); if (!e) return void console.error('Disabling InfiniteScroll'); this.updateGetAbsolutePath(), this.log('initialized', [this.element.className]), this.callOnInit(); for (const i in n.create)n.create[i].call(this) }, s.option = function (t) { i.extend(this.options, t) }, s.callOnInit = function () { const t = this.options.onInit; t && t.call(this, this) }, s.dispatchEvent = function (t, e, i) { this.log(t, i); const n = e ? [e].concat(i) : i; if (this.emitEvent(t, n), o && this.$element) { t += '.infiniteScroll'; let r = t; if (e) { const s = o.Event(e); s.type = t, r = s } this.$element.trigger(r, i) } }; const a = { initialized(t) { return `on ${t}` }, request(t) { return `URL: ${t}` }, load(t, e) { return `${t.title || ''}. URL: ${e}` }, error(t, e) { return `${t}. URL: ${e}` }, append(t, e, i) { return `${i.length} items. URL: ${e}` }, last(t, e) { return `URL: ${e}` }, history(t, e) { return `URL: ${e}` }, pageIndex(t, e) { return `current page determined to be: ${t} from ${e}` } }; s.log = function (t, e) { if (this.options.debug) { let i = `[InfiniteScroll] ${t}`; const n = a[t]; n && (i += `. ${n.apply(this, e)}`), console.log(i) } }, s.updateMeasurements = function () { this.windowHeight = t.innerHeight; const e = this.element.getBoundingClientRect(); this.top = e.top + t.pageYOffset }, s.updateScroller = function () { const e = this.options.elementScroll; if (!e) return void (this.scroller = t); if (this.scroller = e === !0 ? this.element : i.getQueryElement(e), !this.scroller) throw `Unable to find elementScroll: ${e}` }, s.updateGetPath = function () { const t = this.options.path; if (!t) return void console.error(`InfiniteScroll path option required. Set as: ${t}`); const e = typeof t; if (e == 'function') return void (this.getPath = t); const i = e == 'string' && t.match('{{#}}'); return i ? void this.updateGetPathTemplate(t) : void this.updateGetPathSelector(t) }, s.updateGetPathTemplate = function (t) { this.getPath = function () { const e = this.pageIndex + 1; return t.replace('{{#}}', e) }.bind(this); const e = t.replace('{{#}}', '(\\d\\d?\\d?)'); const i = new RegExp(e); const n = location.href.match(i); n && (this.pageIndex = parseInt(n[1], 10), this.log('pageIndex', [this.pageIndex, 'template string'])) }; const h = [/^(.*?\/?page\/?)(\d\d?\d?)(.*?$)/, /^(.*?\/?\?page=)(\d\d?\d?)(.*?$)/, /(.*?)(\d\d?\d?)(?!.*\d)(.*?$)/]; return s.updateGetPathSelector = function (t) { const e = document.querySelector(t); if (!e) return void console.error(`Bad InfiniteScroll path option. Next link not found: ${t}`); for (var i, n, o = e.getAttribute('href'), r = 0; o && r < h.length; r++) { n = h[r]; const s = o.match(n); if (s) { i = s.slice(1); break } } return i ? (this.isPathSelector = !0, this.getPath = function () { const t = this.pageIndex + 1; return i[0] + t + i[2] }.bind(this), this.pageIndex = parseInt(i[1], 10) - 1, void this.log('pageIndex', [this.pageIndex, 'next link'])) : void console.error(`InfiniteScroll unable to parse next link href: ${o}`) }, s.updateGetAbsolutePath = function () { const t = this.getPath(); const e = t.match(/^http/) || t.match(/^\//); if (e) return void (this.getAbsolutePath = this.getPath); const i = location.pathname; const n = i.substring(0, i.lastIndexOf('/')); this.getAbsolutePath = function () { return `${n}/${this.getPath()}` } }, n.create.hideNav = function () { const t = i.getQueryElement(this.options.hideNav); t && (t.style.display = 'none', this.nav = t) }, n.destroy.hideNav = function () { this.nav && (this.nav.style.display = '') }, s.destroy = function () { this.allOff(); for (const t in n.destroy)n.destroy[t].call(this); delete this.element.infiniteScrollGUID, delete r[this.guid], o && this.$element && o.removeData(this.element, 'infiniteScroll') }, n.throttle = function (t, e) { e = e || 200; let i, n; return function () { const o = +new Date(); const r = arguments; const s = function () { i = o, t.apply(this, r) }.bind(this); i && o < i + e ? (clearTimeout(n), n = setTimeout(s, e)) : s() } }, n.data = function (t) { t = i.getQueryElement(t); const e = t && t.infiniteScrollGUID; return e && r[e] }, n.setJQuery = function (t) { o = t }, i.htmlInit(n, 'infinite-scroll'), s._init = function () {}, o && o.bridget && o.bridget('infiniteScroll', n), n })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/page-load', ['./core'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('./core')) : e(t, t.InfiniteScroll) }(window, (t, e) => { function i(t) { for (var e = document.createDocumentFragment(), i = 0; t && i < t.length; i++)e.appendChild(t[i]); return e } function n(t) { for (let e = t.querySelectorAll('script'), i = 0; i < e.length; i++) { const n = e[i]; const r = document.createElement('script'); o(n, r), r.innerHTML = n.innerHTML, n.parentNode.replaceChild(r, n) } } function o(t, e) { for (let i = t.attributes, n = 0; n < i.length; n++) { const o = i[n]; e.setAttribute(o.name, o.value) } } function r(t, e, i, n) { const o = new XMLHttpRequest(); o.open('GET', t, !0), o.responseType = e || '', o.setRequestHeader('X-Requested-With', 'XMLHttpRequest'), o.onload = function () { if (o.status == 200)i(o.response); else { const t = new Error(o.statusText); n(t) } }, o.onerror = function () { const e = new Error(`Network error requesting ${t}`); n(e) }, o.send() } const s = e.prototype; return e.defaults.loadOnScroll = !0, e.defaults.checkLastPage = !0, e.defaults.responseType = 'document', e.create.pageLoad = function () { this.canLoad = !0, this.on('scrollThreshold', this.onScrollThresholdLoad), this.on('load', this.checkLastPage), this.options.outlayer && this.on('append', this.onAppendOutlayer) }, s.onScrollThresholdLoad = function () { this.options.loadOnScroll && this.loadNextPage() }, s.loadNextPage = function () { if (!this.isLoading && this.canLoad) { const t = this.getAbsolutePath(); this.isLoading = !0; const e = function (e) { this.onPageLoad(e, t) }.bind(this); const i = function (e) { this.onPageError(e, t) }.bind(this); r(t, this.options.responseType, e, i), this.dispatchEvent('request', null, [t]) } }, s.onPageLoad = function (t, e) { return this.options.append || (this.isLoading = !1), this.pageIndex++, this.loadCount++, this.dispatchEvent('load', null, [t, e]), this.appendNextPage(t, e), t }, s.appendNextPage = function (t, e) { const n = this.options.append; const o = this.options.responseType == 'document'; if (o && n) { const r = t.querySelectorAll(n); const s = i(r); const l = function () { this.appendItems(r, s), this.isLoading = !1, this.dispatchEvent('append', null, [t, e, r]) }.bind(this); this.options.outlayer ? this.appendOutlayerItems(s, l) : l() } }, s.appendItems = function (t, e) { t && t.length && (e = e || i(t), n(e), this.element.appendChild(e)) }, s.appendOutlayerItems = function (i, n) { const o = e.imagesLoaded || t.imagesLoaded; return o ? void o(i, n) : (console.error('[InfiniteScroll] imagesLoaded required for outlayer option'), void (this.isLoading = !1)) }, s.onAppendOutlayer = function (t, e, i) { this.options.outlayer.appended(i) }, s.checkLastPage = function (t, e) { const i = this.options.checkLastPage; if (i) { const n = this.options.path; if (typeof n === 'function') { const o = this.getPath(); if (!o) return void this.lastPageReached(t, e) } let r; if (typeof i === 'string' ? r = i : this.isPathSelector && (r = n), r && t.querySelector) { const s = t.querySelector(r); s || this.lastPageReached(t, e) } } }, s.lastPageReached = function (t, e) { this.canLoad = !1, this.dispatchEvent('last', null, [t, e]) }, s.onPageError = function (t, e) { return this.isLoading = !1, this.canLoad = !1, this.dispatchEvent('error', null, [t, e]), t }, e.create.prefill = function () { if (this.options.prefill) { const t = this.options.append; if (!t) return void console.error(`append option required for prefill. Set as :${t}`); this.updateMeasurements(), this.updateScroller(), this.isPrefilling = !0, this.on('append', this.prefill), this.once('error', this.stopPrefill), this.once('last', this.stopPrefill), this.prefill() } }, s.prefill = function () { const t = this.getPrefillDistance(); this.isPrefilling = t >= 0, this.isPrefilling ? (this.log('prefill'), this.loadNextPage()) : this.stopPrefill() }, s.getPrefillDistance = function () { return this.options.elementScroll ? this.scroller.clientHeight - this.scroller.scrollHeight : this.windowHeight - this.element.clientHeight }, s.stopPrefill = function () { this.log('stopPrefill'), this.off('append', this.prefill) }, e })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/scroll-watch', ['./core', 'fizzy-ui-utils/utils'], (i, n) => e(t, i, n)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('./core'), require('fizzy-ui-utils')) : e(t, t.InfiniteScroll, t.fizzyUIUtils) }(window, (t, e, i) => { const n = e.prototype; return e.defaults.scrollThreshold = 400, e.create.scrollWatch = function () { this.pageScrollHandler = this.onPageScroll.bind(this), this.resizeHandler = this.onResize.bind(this); const t = this.options.scrollThreshold; const e = t || t === 0; e && this.enableScrollWatch() }, e.destroy.scrollWatch = function () { this.disableScrollWatch() }, n.enableScrollWatch = function () { this.isScrollWatching || (this.isScrollWatching = !0, this.updateMeasurements(), this.updateScroller(), this.on('last', this.disableScrollWatch), this.bindScrollWatchEvents(!0)) }, n.disableScrollWatch = function () { this.isScrollWatching && (this.bindScrollWatchEvents(!1), delete this.isScrollWatching) }, n.bindScrollWatchEvents = function (e) { const i = e ? 'addEventListener' : 'removeEventListener'; this.scroller[i]('scroll', this.pageScrollHandler), t[i]('resize', this.resizeHandler) }, n.onPageScroll = e.throttle(function () { const t = this.getBottomDistance(); t <= this.options.scrollThreshold && this.dispatchEvent('scrollThreshold') }), n.getBottomDistance = function () { return this.options.elementScroll ? this.getElementBottomDistance() : this.getWindowBottomDistance() }, n.getWindowBottomDistance = function () { const e = this.top + this.element.clientHeight; const i = t.pageYOffset + this.windowHeight; return e - i }, n.getElementBottomDistance = function () { const t = this.scroller.scrollHeight; const e = this.scroller.scrollTop + this.scroller.clientHeight; return t - e }, n.onResize = function () { this.updateMeasurements() }, i.debounceMethod(e, 'onResize', 150), e })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/history', ['./core', 'fizzy-ui-utils/utils'], (i, n) => e(t, i, n)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('./core'), require('fizzy-ui-utils')) : e(t, t.InfiniteScroll, t.fizzyUIUtils) }(window, (t, e, i) => { const n = e.prototype; e.defaults.history = 'replace'; const o = document.createElement('a'); return e.create.history = function () { if (this.options.history) { o.href = this.getAbsolutePath(); const t = o.origin || `${o.protocol}//${o.host}`; const e = t == location.origin; return e ? void (this.options.append ? this.createHistoryAppend() : this.createHistoryPageLoad()) : void console.error(`[InfiniteScroll] cannot set history with different origin: ${o.origin} on ${location.origin} . History behavior disabled.`) } }, n.createHistoryAppend = function () { this.updateMeasurements(), this.updateScroller(), this.scrollPages = [{ top: 0, path: location.href, title: document.title }], this.scrollPageIndex = 0, this.scrollHistoryHandler = this.onScrollHistory.bind(this), this.unloadHandler = this.onUnload.bind(this), this.scroller.addEventListener('scroll', this.scrollHistoryHandler), this.on('append', this.onAppendHistory), this.bindHistoryAppendEvents(!0) }, n.bindHistoryAppendEvents = function (e) { const i = e ? 'addEventListener' : 'removeEventListener'; this.scroller[i]('scroll', this.scrollHistoryHandler), t[i]('unload', this.unloadHandler) }, n.createHistoryPageLoad = function () { this.on('load', this.onPageLoadHistory) }, e.destroy.history = n.destroyHistory = function () { const t = this.options.history && this.options.append; t && this.bindHistoryAppendEvents(!1) }, n.onAppendHistory = function (t, e, i) { if (i && i.length) { const n = i[0]; const r = this.getElementScrollY(n); o.href = e, this.scrollPages.push({ top: r, path: o.href, title: t.title }) } }, n.getElementScrollY = function (t) { return this.options.elementScroll ? this.getElementElementScrollY(t) : this.getElementWindowScrollY(t) }, n.getElementWindowScrollY = function (e) { const i = e.getBoundingClientRect(); return i.top + t.pageYOffset }, n.getElementElementScrollY = function (t) { return t.offsetTop - this.top }, n.onScrollHistory = function () { for (var t, e, i = this.getScrollViewY(), n = 0; n < this.scrollPages.length; n++) { const o = this.scrollPages[n]; if (o.top >= i) break; t = n, e = o }t != this.scrollPageIndex && (this.scrollPageIndex = t, this.setHistory(e.title, e.path)) }, i.debounceMethod(e, 'onScrollHistory', 150), n.getScrollViewY = function () { return this.options.elementScroll ? this.scroller.scrollTop + this.scroller.clientHeight / 2 : t.pageYOffset + this.windowHeight / 2 }, n.setHistory = function (t, e) { const i = this.options.history; const n = i && history[`${i}State`]; n && (history[`${i}State`](null, t, e), this.options.historyTitle && (document.title = t), this.dispatchEvent('history', null, [t, e])) }, n.onUnload = function () { const e = this.scrollPageIndex; if (e !== 0) { const i = this.scrollPages[e]; const n = t.pageYOffset - i.top + this.top; this.destroyHistory(), scrollTo(0, n) } }, n.onPageLoadHistory = function (t, e) { this.setHistory(t.title, e) }, e })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/button', ['./core', 'fizzy-ui-utils/utils'], (i, n) => e(t, i, n)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('./core'), require('fizzy-ui-utils')) : e(t, t.InfiniteScroll, t.fizzyUIUtils) }(window, (t, e, i) => { function n(t, e) { this.element = t, this.infScroll = e, this.clickHandler = this.onClick.bind(this), this.element.addEventListener('click', this.clickHandler), e.on('request', this.disable.bind(this)), e.on('load', this.enable.bind(this)), e.on('error', this.hide.bind(this)), e.on('last', this.hide.bind(this)) } return e.create.button = function () { const t = i.getQueryElement(this.options.button); if (t) return void (this.button = new n(t, this)) }, e.destroy.button = function () { this.button && this.button.destroy() }, n.prototype.onClick = function (t) { t.preventDefault(), this.infScroll.loadNextPage() }, n.prototype.enable = function () { this.element.removeAttribute('disabled') }, n.prototype.disable = function () { this.element.disabled = 'disabled' }, n.prototype.hide = function () { this.element.style.display = 'none' }, n.prototype.destroy = function () { this.element.removeEventListener('click', this.clickHandler) }, e.Button = n, e })), (function (t, e) { typeof define === 'function' && define.amd ? define('infinite-scroll/js/status', ['./core', 'fizzy-ui-utils/utils'], (i, n) => e(t, i, n)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('./core'), require('fizzy-ui-utils')) : e(t, t.InfiniteScroll, t.fizzyUIUtils) }(window, (t, e, i) => { function n(t) { r(t, 'none') } function o(t) { r(t, 'block') } function r(t, e) { t && (t.style.display = e) } const s = e.prototype; return e.create.status = function () { const t = i.getQueryElement(this.options.status); t && (this.statusElement = t, this.statusEventElements = { request: t.querySelector('.infinite-scroll-request'), error: t.querySelector('.infinite-scroll-error'), last: t.querySelector('.infinite-scroll-last') }, this.on('request', this.showRequestStatus), this.on('error', this.showErrorStatus), this.on('last', this.showLastStatus), this.bindHideStatus('on')) }, s.bindHideStatus = function (t) { const e = this.options.append ? 'append' : 'load'; this[t](e, this.hideAllStatus) }, s.showRequestStatus = function () { this.showStatus('request') }, s.showErrorStatus = function () { this.showStatus('error') }, s.showLastStatus = function () { this.showStatus('last'), this.bindHideStatus('off') }, s.showStatus = function (t) { o(this.statusElement), this.hideStatusEventElements(); const e = this.statusEventElements[t]; o(e) }, s.hideAllStatus = function () { n(this.statusElement), this.hideStatusEventElements() }, s.hideStatusEventElements = function () { for (const t in this.statusEventElements) { const e = this.statusEventElements[t]; n(e) } }, e })), (function (t, e) { typeof define === 'function' && define.amd ? define(['infinite-scroll/js/core', 'infinite-scroll/js/page-load', 'infinite-scroll/js/scroll-watch', 'infinite-scroll/js/history', 'infinite-scroll/js/button', 'infinite-scroll/js/status'], e) : typeof module === 'object' && module.exports && (module.exports = e(require('./core'), require('./page-load'), require('./scroll-watch'), require('./history'), require('./button'), require('./status'))) }(window, (t) => t)), (function (t, e) {
  typeof define === 'function' && define.amd ? define('imagesloaded/imagesloaded', ['ev-emitter/ev-emitter'], (i) => e(t, i)) : typeof module === 'object' && module.exports ? module.exports = e(t, require('ev-emitter')) : t.imagesLoaded = e(t, t.EvEmitter)
}(typeof window !== 'undefined' ? window : this, (t, e) => { function i(t, e) { for (const i in e)t[i] = e[i]; return t } function n(t) { if (Array.isArray(t)) return t; const e = typeof t === 'object' && typeof t.length === 'number'; return e ? h.call(t) : [t] } function o(t, e, r) { if (!(this instanceof o)) return new o(t, e, r); let s = t; return typeof t === 'string' && (s = document.querySelectorAll(t)), s ? (this.elements = n(s), this.options = i({}, this.options), typeof e === 'function' ? r = e : i(this.options, e), r && this.on('always', r), this.getImages(), l && (this.jqDeferred = new l.Deferred()), void setTimeout(this.check.bind(this))) : void a.error(`Bad element for imagesLoaded ${s || t}`) } function r(t) { this.img = t } function s(t, e) { this.url = t, this.element = e, this.img = new Image() } var l = t.jQuery; var a = t.console; var h = Array.prototype.slice; o.prototype = Object.create(e.prototype), o.prototype.options = {}, o.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, o.prototype.addElementImages = function (t) { t.nodeName == 'IMG' && this.addImage(t), this.options.background === !0 && this.addElementBackgroundImages(t); const e = t.nodeType; if (e && c[e]) { for (var i = t.querySelectorAll('img'), n = 0; n < i.length; n++) { const o = i[n]; this.addImage(o) } if (typeof this.options.background === 'string') { const r = t.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { const s = r[n]; this.addElementBackgroundImages(s) } } } }; var c = { 1: !0, 9: !0, 11: !0 }; return o.prototype.addElementBackgroundImages = function (t) { const e = getComputedStyle(t); if (e) for (let i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(e.backgroundImage); n !== null;) { const o = n && n[2]; o && this.addBackground(o, t), n = i.exec(e.backgroundImage) } }, o.prototype.addImage = function (t) { const e = new r(t); this.images.push(e) }, o.prototype.addBackground = function (t, e) { const i = new s(t, e); this.images.push(i) }, o.prototype.check = function () { function t(t, i, n) { setTimeout(() => { e.progress(t, i, n) }) } var e = this; return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((e) => { e.once('progress', t), e.check() }) : void this.complete() }, o.prototype.progress = function (t, e, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded, this.emitEvent('progress', [this, t, e]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, t), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log(`progress: ${i}`, t, e) }, o.prototype.complete = function () { const t = this.hasAnyBroken ? 'fail' : 'done'; if (this.isComplete = !0, this.emitEvent(t, [this]), this.emitEvent('always', [this]), this.jqDeferred) { const e = this.hasAnyBroken ? 'reject' : 'resolve'; this.jqDeferred[e](this) } }, r.prototype = Object.create(e.prototype), r.prototype.check = function () { const t = this.getIsImageComplete(); return t ? void this.confirm(this.img.naturalWidth !== 0, 'naturalWidth') : (this.proxyImage = new Image(), this.proxyImage.addEventListener('load', this), this.proxyImage.addEventListener('error', this), this.img.addEventListener('load', this), this.img.addEventListener('error', this), void (this.proxyImage.src = this.img.src)) }, r.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, r.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent('progress', [this, this.img, e]) }, r.prototype.handleEvent = function (t) { const e = `on${t.type}`; this[e] && this[e](t) }, r.prototype.onload = function () { this.confirm(!0, 'onload'), this.unbindEvents() }, r.prototype.onerror = function () { this.confirm(!1, 'onerror'), this.unbindEvents() }, r.prototype.unbindEvents = function () { this.proxyImage.removeEventListener('load', this), this.proxyImage.removeEventListener('error', this), this.img.removeEventListener('load', this), this.img.removeEventListener('error', this) }, s.prototype = Object.create(r.prototype), s.prototype.check = function () { this.img.addEventListener('load', this), this.img.addEventListener('error', this), this.img.src = this.url; const t = this.getIsImageComplete(); t && (this.confirm(this.img.naturalWidth !== 0, 'naturalWidth'), this.unbindEvents()) }, s.prototype.unbindEvents = function () { this.img.removeEventListener('load', this), this.img.removeEventListener('error', this) }, s.prototype.confirm = function (t, e) { this.isLoaded = t, this.emitEvent('progress', [this, this.element, e]) }, o.makeJQueryPlugin = function (e) { e = e || t.jQuery, e && (l = e, l.fn.imagesLoaded = function (t, e) { const i = new o(this, t, e); return i.jqDeferred.promise(l(this)) }) }, o.makeJQueryPlugin(), o }));

/*! jQuery UI - v1.12.1 - 2018-01-02
* http://jqueryui.com
* Includes: widget.js, keycode.js, unique-id.js, widgets/tabs.js, effect.js, effects/effect-fade.js, effects/effect-slide.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */
(function (t) { typeof define === 'function' && define.amd ? define(['jquery'], t) : t(jQuery) })((t) => { t.ui = t.ui || {}, t.ui.version = '1.12.1'; let e = 0; const i = Array.prototype.slice; t.cleanData = (function (e) { return function (i) { let s, n, o; for (o = 0; (n = i[o]) != null; o++) try { s = t._data(n, 'events'), s && s.remove && t(n).triggerHandler('remove') } catch (a) {}e(i) } }(t.cleanData)), t.widget = function (e, i, s) { let n; let o; let a; const r = {}; const l = e.split('.')[0]; e = e.split('.')[1]; const h = `${l}-${e}`; return s || (s = i, i = t.Widget), t.isArray(s) && (s = t.extend.apply(null, [{}].concat(s))), t.expr[':'][h.toLowerCase()] = function (e) { return !!t.data(e, h) }, t[l] = t[l] || {}, n = t[l][e], o = t[l][e] = function (t, e) { return this._createWidget ? (arguments.length && this._createWidget(t, e), void 0) : new o(t, e) }, t.extend(o, n, { version: s.version, _proto: t.extend({}, s), _childConstructors: [] }), a = new i(), a.options = t.widget.extend({}, a.options), t.each(s, (e, s) => t.isFunction(s) ? (r[e] = (function () { function t() { return i.prototype[e].apply(this, arguments) } function n(t) { return i.prototype[e].apply(this, t) } return function () { let e; const i = this._super; const o = this._superApply; return this._super = t, this._superApply = n, e = s.apply(this, arguments), this._super = i, this._superApply = o, e } }()), void 0) : (r[e] = s, void 0)), o.prototype = t.widget.extend(a, { widgetEventPrefix: n ? a.widgetEventPrefix || e : e }, r, { constructor: o, namespace: l, widgetName: e, widgetFullName: h }), n ? (t.each(n._childConstructors, (e, i) => { const s = i.prototype; t.widget(`${s.namespace}.${s.widgetName}`, o, i._proto) }), delete n._childConstructors) : i._childConstructors.push(o), t.widget.bridge(e, o), o }, t.widget.extend = function (e) { for (var s, n, o = i.call(arguments, 1), a = 0, r = o.length; r > a; a++) for (s in o[a])n = o[a][s], o[a].hasOwnProperty(s) && void 0 !== n && (e[s] = t.isPlainObject(n) ? t.isPlainObject(e[s]) ? t.widget.extend({}, e[s], n) : t.widget.extend({}, n) : n); return e }, t.widget.bridge = function (e, s) { const n = s.prototype.widgetFullName || e; t.fn[e] = function (o) { const a = typeof o === 'string'; const r = i.call(arguments, 1); let l = this; return a ? this.length || o !== 'instance' ? this.each(function () { let i; const s = t.data(this, n); return o === 'instance' ? (l = s, !1) : s ? t.isFunction(s[o]) && o.charAt(0) !== '_' ? (i = s[o].apply(s, r), i !== s && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0) : t.error(`no such method '${o}' for ${e} widget instance`) : t.error(`cannot call methods on ${e} prior to initialization; ` + `attempted to call method '${o}'`) }) : l = void 0 : (r.length && (o = t.widget.extend.apply(null, [o].concat(r))), this.each(function () { const e = t.data(this, n); e ? (e.option(o || {}), e._init && e._init()) : t.data(this, n, new s(o, this)) })), l } }, t.Widget = function () {}, t.Widget._childConstructors = [], t.Widget.prototype = { widgetName: 'widget', widgetEventPrefix: '', defaultElement: '<div>', options: { classes: {}, disabled: !1, create: null }, _createWidget(i, s) { s = t(s || this.defaultElement || this)[0], this.element = t(s), this.uuid = e++, this.eventNamespace = `.${this.widgetName}${this.uuid}`, this.bindings = t(), this.hoverable = t(), this.focusable = t(), this.classesElementLookup = {}, s !== this && (t.data(s, this.widgetFullName, this), this._on(!0, this.element, { remove(t) { t.target === s && this.destroy() } }), this.document = t(s.style ? s.ownerDocument : s.document || s), this.window = t(this.document[0].defaultView || this.document[0].parentWindow)), this.options = t.widget.extend({}, this.options, this._getCreateOptions(), i), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger('create', null, this._getCreateEventData()), this._init() }, _getCreateOptions() { return {} }, _getCreateEventData: t.noop, _create: t.noop, _init: t.noop, destroy() { const e = this; this._destroy(), t.each(this.classesElementLookup, (t, i) => { e._removeClass(i, t) }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr('aria-disabled'), this.bindings.off(this.eventNamespace) }, _destroy: t.noop, widget() { return this.element }, option(e, i) { let s; let n; let o; let a = e; if (arguments.length === 0) return t.widget.extend({}, this.options); if (typeof e === 'string') if (a = {}, s = e.split('.'), e = s.shift(), s.length) { for (n = a[e] = t.widget.extend({}, this.options[e]), o = 0; s.length - 1 > o; o++)n[s[o]] = n[s[o]] || {}, n = n[s[o]]; if (e = s.pop(), arguments.length === 1) return void 0 === n[e] ? null : n[e]; n[e] = i } else { if (arguments.length === 1) return void 0 === this.options[e] ? null : this.options[e]; a[e] = i } return this._setOptions(a), this }, _setOptions(t) { let e; for (e in t) this._setOption(e, t[e]); return this }, _setOption(t, e) { return t === 'classes' && this._setOptionClasses(e), this.options[t] = e, t === 'disabled' && this._setOptionDisabled(e), this }, _setOptionClasses(e) { let i, s, n; for (i in e)n = this.classesElementLookup[i], e[i] !== this.options.classes[i] && n && n.length && (s = t(n.get()), this._removeClass(n, i), s.addClass(this._classes({ element: s, keys: i, classes: e, add: !0 }))) }, _setOptionDisabled(t) { this._toggleClass(this.widget(), `${this.widgetFullName}-disabled`, null, !!t), t && (this._removeClass(this.hoverable, null, 'ui-state-hover'), this._removeClass(this.focusable, null, 'ui-state-focus')) }, enable() { return this._setOptions({ disabled: !1 }) }, disable() { return this._setOptions({ disabled: !0 }) }, _classes(e) { function i(i, o) { let a, r; for (r = 0; i.length > r; r++)a = n.classesElementLookup[i[r]] || t(), a = e.add ? t(t.unique(a.get().concat(e.element.get()))) : t(a.not(e.element).get()), n.classesElementLookup[i[r]] = a, s.push(i[r]), o && e.classes[i[r]] && s.push(e.classes[i[r]]) } var s = []; var n = this; return e = t.extend({ element: this.element, classes: this.options.classes || {} }, e), this._on(e.element, { remove: '_untrackClassesElement' }), e.keys && i(e.keys.match(/\S+/g) || [], !0), e.extra && i(e.extra.match(/\S+/g) || []), s.join(' ') }, _untrackClassesElement(e) { const i = this; t.each(i.classesElementLookup, (s, n) => { t.inArray(e.target, n) !== -1 && (i.classesElementLookup[s] = t(n.not(e.target).get())) }) }, _removeClass(t, e, i) { return this._toggleClass(t, e, i, !1) }, _addClass(t, e, i) { return this._toggleClass(t, e, i, !0) }, _toggleClass(t, e, i, s) { s = typeof s === 'boolean' ? s : i; const n = typeof t === 'string' || t === null; const o = { extra: n ? e : i, keys: n ? t : e, element: n ? this.element : t, add: s }; return o.element.toggleClass(this._classes(o), s), this }, _on(e, i, s) { let n; const o = this; typeof e !== 'boolean' && (s = i, i = e, e = !1), s ? (i = n = t(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), t.each(s, (s, a) => { function r() { return e || o.options.disabled !== !0 && !t(this).hasClass('ui-state-disabled') ? (typeof a === 'string' ? o[a] : a).apply(o, arguments) : void 0 } typeof a !== 'string' && (r.guid = a.guid = a.guid || r.guid || t.guid++); const l = s.match(/^([\w:-]*)\s*(.*)$/); const h = l[1] + o.eventNamespace; const c = l[2]; c ? n.on(h, c, r) : i.on(h, r) }) }, _off(e, i) { i = (i || '').split(' ').join(`${this.eventNamespace} `) + this.eventNamespace, e.off(i).off(i), this.bindings = t(this.bindings.not(e).get()), this.focusable = t(this.focusable.not(e).get()), this.hoverable = t(this.hoverable.not(e).get()) }, _delay(t, e) { function i() { return (typeof t === 'string' ? s[t] : t).apply(s, arguments) } var s = this; return setTimeout(i, e || 0) }, _hoverable(e) { this.hoverable = this.hoverable.add(e), this._on(e, { mouseenter(e) { this._addClass(t(e.currentTarget), null, 'ui-state-hover') }, mouseleave(e) { this._removeClass(t(e.currentTarget), null, 'ui-state-hover') } }) }, _focusable(e) { this.focusable = this.focusable.add(e), this._on(e, { focusin(e) { this._addClass(t(e.currentTarget), null, 'ui-state-focus') }, focusout(e) { this._removeClass(t(e.currentTarget), null, 'ui-state-focus') } }) }, _trigger(e, i, s) { let n; let o; const a = this.options[e]; if (s = s || {}, i = t.Event(i), i.type = (e === this.widgetEventPrefix ? e : this.widgetEventPrefix + e).toLowerCase(), i.target = this.element[0], o = i.originalEvent) for (n in o)n in i || (i[n] = o[n]); return this.element.trigger(i, s), !(t.isFunction(a) && a.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented()) } }, t.each({ show: 'fadeIn', hide: 'fadeOut' }, (e, i) => { t.Widget.prototype[`_${e}`] = function (s, n, o) { typeof n === 'string' && (n = { effect: n }); let a; const r = n ? n === !0 || typeof n === 'number' ? i : n.effect || i : e; n = n || {}, typeof n === 'number' && (n = { duration: n }), a = !t.isEmptyObject(n), n.complete = o, n.delay && s.delay(n.delay), a && t.effects && t.effects.effect[r] ? s[e](n) : r !== e && s[r] ? s[r](n.duration, n.easing, o) : s.queue(function (i) { t(this)[e](), o && o.call(s[0]), i() }) } }), t.widget, t.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }, t.fn.extend({ uniqueId: (function () { let t = 0; return function () { return this.each(function () { this.id || (this.id = `ui-id-${++t}`) }) } }()), removeUniqueId() { return this.each(function () { /^ui-id-\d+$/.test(this.id) && t(this).removeAttr('id') }) } }), t.ui.escapeSelector = (function () { const t = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g; return function (e) { return e.replace(t, '\\$1') } }()), t.ui.safeActiveElement = function (t) { let e; try { e = t.activeElement } catch (i) { e = t.body } return e || (e = t.body), e.nodeName || (e = t.body), e }, t.widget('ui.tabs', { version: '1.12.1', delay: 300, options: { active: null, classes: { 'ui-tabs': 'ui-corner-all', 'ui-tabs-nav': 'ui-corner-all', 'ui-tabs-panel': 'ui-corner-bottom', 'ui-tabs-tab': 'ui-corner-top' }, collapsible: !1, event: 'click', heightStyle: 'content', hide: null, show: null, activate: null, beforeActivate: null, beforeLoad: null, load: null }, _isLocal: (function () { const t = /#.*$/; return function (e) { let i, s; i = e.href.replace(t, ''), s = location.href.replace(t, ''); try { i = decodeURIComponent(i) } catch (n) {} try { s = decodeURIComponent(s) } catch (n) {} return e.hash.length > 1 && i === s } }()), _create() { const e = this; const i = this.options; this.running = !1, this._addClass('ui-tabs', 'ui-widget ui-widget-content'), this._toggleClass('ui-tabs-collapsible', null, i.collapsible), this._processTabs(), i.active = this._initialActive(), t.isArray(i.disabled) && (i.disabled = t.unique(i.disabled.concat(t.map(this.tabs.filter('.ui-state-disabled'), (t) => e.tabs.index(t)))).sort()), this.active = this.options.active !== !1 && this.anchors.length ? this._findActive(i.active) : t(), this._refresh(), this.active.length && this.load(i.active) }, _initialActive() { let e = this.options.active; const i = this.options.collapsible; const s = location.hash.substring(1); return e === null && (s && this.tabs.each((i, n) => t(n).attr('aria-controls') === s ? (e = i, !1) : void 0), e === null && (e = this.tabs.index(this.tabs.filter('.ui-tabs-active'))), (e === null || e === -1) && (e = this.tabs.length ? 0 : !1)), e !== !1 && (e = this.tabs.index(this.tabs.eq(e)), e === -1 && (e = i ? !1 : 0)), !i && e === !1 && this.anchors.length && (e = 0), e }, _getCreateEventData() { return { tab: this.active, panel: this.active.length ? this._getPanelForTab(this.active) : t() } }, _tabKeydown(e) { const i = t(t.ui.safeActiveElement(this.document[0])).closest('li'); let s = this.tabs.index(i); let n = !0; if (!this._handlePageNav(e)) { switch (e.keyCode) { case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++; break; case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n = !1, s--; break; case t.ui.keyCode.END:s = this.anchors.length - 1; break; case t.ui.keyCode.HOME:s = 0; break; case t.ui.keyCode.SPACE:return e.preventDefault(), clearTimeout(this.activating), this._activate(s), void 0; case t.ui.keyCode.ENTER:return e.preventDefault(), clearTimeout(this.activating), this._activate(s === this.options.active ? !1 : s), void 0; default:return }e.preventDefault(), clearTimeout(this.activating), s = this._focusNextTab(s, n), e.ctrlKey || e.metaKey || (i.attr('aria-selected', 'false'), this.tabs.eq(s).attr('aria-selected', 'true'), this.activating = this._delay(function () { this.option('active', s) }, this.delay)) } }, _panelKeydown(e) { this._handlePageNav(e) || e.ctrlKey && e.keyCode === t.ui.keyCode.UP && (e.preventDefault(), this.active.trigger('focus')) }, _handlePageNav(e) { return e.altKey && e.keyCode === t.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : e.altKey && e.keyCode === t.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0 }, _findNextTab(e, i) { function s() { return e > n && (e = 0), e < 0 && (e = n), e } for (var n = this.tabs.length - 1; t.inArray(s(), this.options.disabled) !== -1;)e = i ? e + 1 : e - 1; return e }, _focusNextTab(t, e) { return t = this._findNextTab(t, e), this.tabs.eq(t).trigger('focus'), t }, _setOption(t, e) { return t === 'active' ? (this._activate(e), void 0) : (this._super(t, e), t === 'collapsible' && (this._toggleClass('ui-tabs-collapsible', null, e), e || this.options.active !== !1 || this._activate(0)), t === 'event' && this._setupEvents(e), t === 'heightStyle' && this._setupHeightStyle(e), void 0) }, _sanitizeSelector(t) { return t ? t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, '\\$&') : '' }, refresh() { const e = this.options; const i = this.tablist.children(':has(a[href])'); e.disabled = t.map(i.filter('.ui-state-disabled'), (t) => i.index(t)), this._processTabs(), e.active !== !1 && this.anchors.length ? this.active.length && !t.contains(this.tablist[0], this.active[0]) ? this.tabs.length === e.disabled.length ? (e.active = !1, this.active = t()) : this._activate(this._findNextTab(Math.max(0, e.active - 1), !1)) : e.active = this.tabs.index(this.active) : (e.active = !1, this.active = t()), this._refresh() }, _refresh() { this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({ 'aria-selected': 'false', 'aria-expanded': 'false', tabIndex: -1 }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({ 'aria-hidden': 'true' }), this.active.length ? (this.active.attr({ 'aria-selected': 'true', 'aria-expanded': 'true', tabIndex: 0 }), this._addClass(this.active, 'ui-tabs-active', 'ui-state-active'), this._getPanelForTab(this.active).show().attr({ 'aria-hidden': 'false' })) : this.tabs.eq(0).attr('tabIndex', 0) }, _processTabs() { const e = this; const i = this.tabs; const s = this.anchors; const n = this.panels; this.tablist = this._getList().attr('role', 'tablist'), this._addClass(this.tablist, 'ui-tabs-nav', 'ui-helper-reset ui-helper-clearfix ui-widget-header'), this.tablist.on(`mousedown${this.eventNamespace}`, '> li', function (e) { t(this).is('.ui-state-disabled') && e.preventDefault() }).on(`focus${this.eventNamespace}`, '.ui-tabs-anchor', function () { t(this).closest('li').is('.ui-state-disabled') && this.blur() }), this.tabs = this.tablist.find('> li:has(a[href])').attr({ role: 'tab', tabIndex: -1 }), this._addClass(this.tabs, 'ui-tabs-tab', 'ui-state-default'), this.anchors = this.tabs.map(function () { return t('a', this)[0] }).attr({ role: 'presentation', tabIndex: -1 }), this._addClass(this.anchors, 'ui-tabs-anchor'), this.panels = t(), this.anchors.each((i, s) => { let n; let o; let a; const r = t(s).uniqueId().attr('id'); const l = t(s).closest('li'); const h = l.attr('aria-controls'); e._isLocal(s) ? (n = s.hash, a = n.substring(1), o = e.element.find(e._sanitizeSelector(n))) : (a = l.attr('aria-controls') || t({}).uniqueId()[0].id, n = `#${a}`, o = e.element.find(n), o.length || (o = e._createPanel(a), o.insertAfter(e.panels[i - 1] || e.tablist)), o.attr('aria-live', 'polite')), o.length && (e.panels = e.panels.add(o)), h && l.data('ui-tabs-aria-controls', h), l.attr({ 'aria-controls': a, 'aria-labelledby': r }), o.attr('aria-labelledby', r) }), this.panels.attr('role', 'tabpanel'), this._addClass(this.panels, 'ui-tabs-panel', 'ui-widget-content'), i && (this._off(i.not(this.tabs)), this._off(s.not(this.anchors)), this._off(n.not(this.panels))) }, _getList() { return this.tablist || this.element.find('ol, ul').eq(0) }, _createPanel(e) { return t('<div>').attr('id', e).data('ui-tabs-destroy', !0) }, _setOptionDisabled(e) { let i, s, n; for (t.isArray(e) && (e.length ? e.length === this.anchors.length && (e = !0) : e = !1), n = 0; s = this.tabs[n]; n++)i = t(s), e === !0 || t.inArray(n, e) !== -1 ? (i.attr('aria-disabled', 'true'), this._addClass(i, null, 'ui-state-disabled')) : (i.removeAttr('aria-disabled'), this._removeClass(i, null, 'ui-state-disabled')); this.options.disabled = e, this._toggleClass(this.widget(), `${this.widgetFullName}-disabled`, null, e === !0) }, _setupEvents(e) { const i = {}; e && t.each(e.split(' '), (t, e) => { i[e] = '_eventHandler' }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, { click(t) { t.preventDefault() } }), this._on(this.anchors, i), this._on(this.tabs, { keydown: '_tabKeydown' }), this._on(this.panels, { keydown: '_panelKeydown' }), this._focusable(this.tabs), this._hoverable(this.tabs) }, _setupHeightStyle(e) { let i; const s = this.element.parent(); e === 'fill' ? (i = s.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(':visible').each(function () { const e = t(this); const s = e.css('position'); s !== 'absolute' && s !== 'fixed' && (i -= e.outerHeight(!0)) }), this.element.children().not(this.panels).each(function () { i -= t(this).outerHeight(!0) }), this.panels.each(function () { t(this).height(Math.max(0, i - t(this).innerHeight() + t(this).height())) }).css('overflow', 'auto')) : e === 'auto' && (i = 0, this.panels.each(function () { i = Math.max(i, t(this).height('').height()) }).height(i)) }, _eventHandler(e) { const i = this.options; const s = this.active; const n = t(e.currentTarget); const o = n.closest('li'); const a = o[0] === s[0]; const r = a && i.collapsible; const l = r ? t() : this._getPanelForTab(o); const h = s.length ? this._getPanelForTab(s) : t(); const c = { oldTab: s, oldPanel: h, newTab: r ? t() : o, newPanel: l }; e.preventDefault(), o.hasClass('ui-state-disabled') || o.hasClass('ui-tabs-loading') || this.running || a && !i.collapsible || this._trigger('beforeActivate', e, c) === !1 || (i.active = r ? !1 : this.tabs.index(o), this.active = a ? t() : o, this.xhr && this.xhr.abort(), h.length || l.length || t.error('jQuery UI Tabs: Mismatching fragment identifier.'), l.length && this.load(this.tabs.index(o), e), this._toggle(e, c)) }, _toggle(e, i) { function s() { o.running = !1, o._trigger('activate', e, i) } function n() { o._addClass(i.newTab.closest('li'), 'ui-tabs-active', 'ui-state-active'), a.length && o.options.show ? o._show(a, o.options.show, s) : (a.show(), s()) } var o = this; var a = i.newPanel; const r = i.oldPanel; this.running = !0, r.length && this.options.hide ? this._hide(r, this.options.hide, () => { o._removeClass(i.oldTab.closest('li'), 'ui-tabs-active', 'ui-state-active'), n() }) : (this._removeClass(i.oldTab.closest('li'), 'ui-tabs-active', 'ui-state-active'), r.hide(), n()), r.attr('aria-hidden', 'true'), i.oldTab.attr({ 'aria-selected': 'false', 'aria-expanded': 'false' }), a.length && r.length ? i.oldTab.attr('tabIndex', -1) : a.length && this.tabs.filter(function () { return t(this).attr('tabIndex') === 0 }).attr('tabIndex', -1), a.attr('aria-hidden', 'false'), i.newTab.attr({ 'aria-selected': 'true', 'aria-expanded': 'true', tabIndex: 0 }) }, _activate(e) { let i; let s = this._findActive(e); s[0] !== this.active[0] && (s.length || (s = this.active), i = s.find('.ui-tabs-anchor')[0], this._eventHandler({ target: i, currentTarget: i, preventDefault: t.noop })) }, _findActive(e) { return e === !1 ? t() : this.tabs.eq(e) }, _getIndex(e) { return typeof e === 'string' && (e = this.anchors.index(this.anchors.filter(`[href$='${t.ui.escapeSelector(e)}']`))), e }, _destroy() { this.xhr && this.xhr.abort(), this.tablist.removeAttr('role').off(this.eventNamespace), this.anchors.removeAttr('role tabIndex').removeUniqueId(), this.tabs.add(this.panels).each(function () { t.data(this, 'ui-tabs-destroy') ? t(this).remove() : t(this).removeAttr('role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded') }), this.tabs.each(function () { const e = t(this); const i = e.data('ui-tabs-aria-controls'); i ? e.attr('aria-controls', i).removeData('ui-tabs-aria-controls') : e.removeAttr('aria-controls') }), this.panels.show(), this.options.heightStyle !== 'content' && this.panels.css('height', '') }, enable(e) { let i = this.options.disabled; i !== !1 && (void 0 === e ? i = !1 : (e = this._getIndex(e), i = t.isArray(i) ? t.map(i, (t) => t !== e ? t : null) : t.map(this.tabs, (t, i) => i !== e ? i : null)), this._setOptionDisabled(i)) }, disable(e) { let i = this.options.disabled; if (i !== !0) { if (void 0 === e)i = !0; else { if (e = this._getIndex(e), t.inArray(e, i) !== -1) return; i = t.isArray(i) ? t.merge([e], i).sort() : [e] } this._setOptionDisabled(i) } }, load(e, i) { e = this._getIndex(e); const s = this; const n = this.tabs.eq(e); const o = n.find('.ui-tabs-anchor'); const a = this._getPanelForTab(n); const r = { tab: n, panel: a }; const l = function (t, e) { e === 'abort' && s.panels.stop(!1, !0), s._removeClass(n, 'ui-tabs-loading'), a.removeAttr('aria-busy'), t === s.xhr && delete s.xhr }; this._isLocal(o[0]) || (this.xhr = t.ajax(this._ajaxSettings(o, i, r)), this.xhr && this.xhr.statusText !== 'canceled' && (this._addClass(n, 'ui-tabs-loading'), a.attr('aria-busy', 'true'), this.xhr.done((t, e, n) => { setTimeout(() => { a.html(t), s._trigger('load', i, r), l(n, e) }, 1) }).fail((t, e) => { setTimeout(() => { l(t, e) }, 1) }))) }, _ajaxSettings(e, i, s) { const n = this; return { url: e.attr('href').replace(/#.*$/, ''), beforeSend(e, o) { return n._trigger('beforeLoad', i, t.extend({ jqXHR: e, ajaxSettings: o }, s)) } } }, _getPanelForTab(e) { const i = t(e).attr('aria-controls'); return this.element.find(this._sanitizeSelector(`#${i}`)) } }), t.uiBackCompat !== !1 && t.widget('ui.tabs', t.ui.tabs, { _processTabs() { this._superApply(arguments), this._addClass(this.tabs, 'ui-tab') } }), t.ui.tabs; const s = 'ui-effects-'; const n = 'ui-effects-style'; const o = 'ui-effects-animated'; const a = t; t.effects = { effect: {} }, (function (t, e) { function i(t, e, i) { const s = u[e.type] || {}; return t == null ? i || !e.def ? null : e.def : (t = s.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : s.mod ? (t + s.mod) % s.mod : t < 0 ? 0 : t > s.max ? s.max : t) } function s(i) { const s = h(); let n = s._rgba = []; return i = i.toLowerCase(), f(l, (t, o) => { let a; const r = o.re.exec(i); const l = r && o.parse(r); const h = o.space || 'rgba'; return l ? (a = s[h](l), s[c[h].cache] = a[c[h].cache], n = s._rgba = a._rgba, !1) : e }), n.length ? (n.join() === '0,0,0,0' && t.extend(n, o.transparent), s) : o[i] } function n(t, e, i) { return i = (i + 1) % 1, 6 * i < 1 ? t + 6 * (e - t) * i : 2 * i < 1 ? e : 3 * i < 2 ? t + 6 * (e - t) * (2 / 3 - i) : t } let o; const a = 'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor'; const r = /^([\-+])=\s*(\d+\.?\d*)/; var l = [{ re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse(t) { return [t[1], t[2], t[3], t[4]] } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse(t) { return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]] } }, { re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse(t) { return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] } }, { re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse(t) { return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)] } }, { re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, space: 'hsla', parse(t) { return [t[1], t[2] / 100, t[3] / 100, t[4]] } }]; var h = t.Color = function (e, i, s, n) { return new t.Color.fn.parse(e, i, s, n) }; var c = { rgba: { props: { red: { idx: 0, type: 'byte' }, green: { idx: 1, type: 'byte' }, blue: { idx: 2, type: 'byte' } } }, hsla: { props: { hue: { idx: 0, type: 'degrees' }, saturation: { idx: 1, type: 'percent' }, lightness: { idx: 2, type: 'percent' } } } }; var u = { byte: { floor: !0, max: 255 }, percent: { max: 1 }, degrees: { mod: 360, floor: !0 } }; const d = h.support = {}; const p = t('<p>')[0]; var f = t.each; p.style.cssText = 'background-color:rgba(1,1,1,.5)', d.rgba = p.style.backgroundColor.indexOf('rgba') > -1, f(c, (t, e) => { e.cache = `_${t}`, e.props.alpha = { idx: 3, type: 'percent', def: 1 } }), h.fn = t.extend(h.prototype, { parse(n, a, r, l) { if (n === e) return this._rgba = [null, null, null, null], this; (n.jquery || n.nodeType) && (n = t(n).css(a), a = e); const u = this; let d = t.type(n); const p = this._rgba = []; return a !== e && (n = [n, a, r, l], d = 'array'), d === 'string' ? this.parse(s(n) || o._default) : d === 'array' ? (f(c.rgba.props, (t, e) => { p[e.idx] = i(n[e.idx], e) }), this) : d === 'object' ? (n instanceof h ? f(c, (t, e) => { n[e.cache] && (u[e.cache] = n[e.cache].slice()) }) : f(c, (e, s) => { const o = s.cache; f(s.props, (t, e) => { if (!u[o] && s.to) { if (t === 'alpha' || n[t] == null) return; u[o] = s.to(u._rgba) }u[o][e.idx] = i(n[t], e, !0) }), u[o] && t.inArray(null, u[o].slice(0, 3)) < 0 && (u[o][3] = 1, s.from && (u._rgba = s.from(u[o]))) }), this) : e }, is(t) { const i = h(t); let s = !0; const n = this; return f(c, (t, o) => { let a; const r = i[o.cache]; return r && (a = n[o.cache] || o.to && o.to(n._rgba) || [], f(o.props, (t, i) => r[i.idx] != null ? s = r[i.idx] === a[i.idx] : e)), s }), s }, _space() { const t = []; const e = this; return f(c, (i, s) => { e[s.cache] && t.push(i) }), t.pop() }, transition(t, e) { let s = h(t); const n = s._space(); const o = c[n]; const a = this.alpha() === 0 ? h('transparent') : this; const r = a[o.cache] || o.to(a._rgba); const l = r.slice(); return s = s[o.cache], f(o.props, (t, n) => { const o = n.idx; let a = r[o]; const h = s[o]; const c = u[n.type] || {}; h !== null && (a === null ? l[o] = h : (c.mod && (h - a > c.mod / 2 ? a += c.mod : a - h > c.mod / 2 && (a -= c.mod)), l[o] = i((h - a) * e + a, n))) }), this[n](l) }, blend(e) { if (this._rgba[3] === 1) return this; const i = this._rgba.slice(); const s = i.pop(); const n = h(e)._rgba; return h(t.map(i, (t, e) => (1 - s) * n[e] + s * t)) }, toRgbaString() { let e = 'rgba('; const i = t.map(this._rgba, (t, e) => t == null ? e > 2 ? 1 : 0 : t); return i[3] === 1 && (i.pop(), e = 'rgb('), `${e + i.join()})` }, toHslaString() { let e = 'hsla('; const i = t.map(this.hsla(), (t, e) => t == null && (t = e > 2 ? 1 : 0), e && e < 3 && (t = `${Math.round(100 * t)}%`), t); return i[3] === 1 && (i.pop(), e = 'hsl('), `${e + i.join()})` }, toHexString(e) { const i = this._rgba.slice(); const s = i.pop(); return e && i.push(~~(255 * s)), `#${t.map(i, (t) => t = (t || 0).toString(16), t.length === 1 ? `0${t}` : t).join('')}` }, toString() { return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString() } }), h.fn.parse.prototype = h.fn, c.hsla.to = function (t) { if (t[0] == null || t[1] == null || t[2] == null) return [null, null, null, t[3]]; let e; let i; const s = t[0] / 255; const n = t[1] / 255; const o = t[2] / 255; const a = t[3]; const r = Math.max(s, n, o); const l = Math.min(s, n, o); const h = r - l; const c = r + l; const u = 0.5 * c; return e = l === r ? 0 : s === r ? 60 * (n - o) / h + 360 : n === r ? 60 * (o - s) / h + 120 : 60 * (s - n) / h + 240, i = h === 0 ? 0 : u <= 0.5 ? h / c : h / (2 - c), [Math.round(e) % 360, i, u, a == null ? 1 : a] }, c.hsla.from = function (t) { if (t[0] == null || t[1] == null || t[2] == null) return [null, null, null, t[3]]; const e = t[0] / 360; const i = t[1]; const s = t[2]; const o = t[3]; const a = s <= 0.5 ? s * (1 + i) : s + i - s * i; const r = 2 * s - a; return [Math.round(255 * n(r, a, e + 1 / 3)), Math.round(255 * n(r, a, e)), Math.round(255 * n(r, a, e - 1 / 3)), o] }, f(c, (s, n) => { const o = n.props; const a = n.cache; const l = n.to; const c = n.from; h.fn[s] = function (s) { if (l && !this[a] && (this[a] = l(this._rgba)), s === e) return this[a].slice(); let n; const r = t.type(s); const u = r === 'array' || r === 'object' ? s : arguments; const d = this[a].slice(); return f(o, (t, e) => { let s = u[r === 'object' ? t : e.idx]; s == null && (s = d[e.idx]), d[e.idx] = i(s, e) }), c ? (n = h(c(d)), n[a] = d, n) : h(d) }, f(o, (e, i) => { h.fn[e] || (h.fn[e] = function (n) { let o; let a = t.type(n); const l = e === 'alpha' ? this._hsla ? 'hsla' : 'rgba' : s; const h = this[l](); const c = h[i.idx]; return a === 'undefined' ? c : (a === 'function' && (n = n.call(this, c), a = t.type(n)), n == null && i.empty ? this : (a === 'string' && (o = r.exec(n), o && (n = c + parseFloat(o[2]) * (o[1] === '+' ? 1 : -1))), h[i.idx] = n, this[l](h))) }) }) }), h.hook = function (e) { const i = e.split(' '); f(i, (e, i) => { t.cssHooks[i] = { set(e, n) { let o; let a; let r = ''; if (n !== 'transparent' && (t.type(n) !== 'string' || (o = s(n)))) { if (n = h(o || n), !d.rgba && n._rgba[3] !== 1) { for (a = i === 'backgroundColor' ? e.parentNode : e; (r === '' || r === 'transparent') && a && a.style;) try { r = t.css(a, 'backgroundColor'), a = a.parentNode } catch (l) {}n = n.blend(r && r !== 'transparent' ? r : '_default') }n = n.toRgbaString() } try { e.style[i] = n } catch (l) {} } }, t.fx.step[i] = function (e) { e.colorInit || (e.start = h(e.elem, i), e.end = h(e.end), e.colorInit = !0), t.cssHooks[i].set(e.elem, e.start.transition(e.end, e.pos)) } }) }, h.hook(a), t.cssHooks.borderColor = { expand(t) { const e = {}; return f(['Top', 'Right', 'Bottom', 'Left'], (i, s) => { e[`border${s}Color`] = t }), e } }, o = t.Color.names = { aqua: '#00ffff', black: '#000000', blue: '#0000ff', fuchsia: '#ff00ff', gray: '#808080', green: '#008000', lime: '#00ff00', maroon: '#800000', navy: '#000080', olive: '#808000', purple: '#800080', red: '#ff0000', silver: '#c0c0c0', teal: '#008080', white: '#ffffff', yellow: '#ffff00', transparent: [null, null, null, 0], _default: '#ffffff' } }(a)), (function () { function e(e) { let i; let s; const n = e.ownerDocument.defaultView ? e.ownerDocument.defaultView.getComputedStyle(e, null) : e.currentStyle; const o = {}; if (n && n.length && n[0] && n[n[0]]) for (s = n.length; s--;)i = n[s], typeof n[i] === 'string' && (o[t.camelCase(i)] = n[i]); else for (i in n) typeof n[i] === 'string' && (o[i] = n[i]); return o } function i(e, i) { let s; let o; const a = {}; for (s in i)o = i[s], e[s] !== o && (n[s] || (t.fx.step[s] || !isNaN(parseFloat(o))) && (a[s] = o)); return a } const s = ['add', 'remove', 'toggle']; var n = { border: 1, borderBottom: 1, borderColor: 1, borderLeft: 1, borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 }; t.each(['borderLeftStyle', 'borderRightStyle', 'borderBottomStyle', 'borderTopStyle'], (e, i) => { t.fx.step[i] = function (t) { (t.end !== 'none' && !t.setAttr || t.pos === 1 && !t.setAttr) && (a.style(t.elem, i, t.end), t.setAttr = !0) } }), t.fn.addBack || (t.fn.addBack = function (t) { return this.add(t == null ? this.prevObject : this.prevObject.filter(t)) }), t.effects.animateClass = function (n, o, a, r) { const l = t.speed(o, a, r); return this.queue(function () { let o; const a = t(this); const r = a.attr('class') || ''; let h = l.children ? a.find('*').addBack() : a; h = h.map(function () { const i = t(this); return { el: i, start: e(this) } }), o = function () { t.each(s, (t, e) => { n[e] && a[`${e}Class`](n[e]) }) }, o(), h = h.map(function () { return this.end = e(this.el[0]), this.diff = i(this.start, this.end), this }), a.attr('class', r), h = h.map(function () { const e = this; const i = t.Deferred(); const s = t.extend({}, l, { queue: !1, complete() { i.resolve(e) } }); return this.el.animate(this.diff, s), i.promise() }), t.when.apply(t, h.get()).done(function () { o(), t.each(arguments, function () { const e = this.el; t.each(this.diff, (t) => { e.css(t, '') }) }), l.complete.call(a[0]) }) }) }, t.fn.extend({ addClass: (function (e) { return function (i, s, n, o) { return s ? t.effects.animateClass.call(this, { add: i }, s, n, o) : e.apply(this, arguments) } }(t.fn.addClass)), removeClass: (function (e) { return function (i, s, n, o) { return arguments.length > 1 ? t.effects.animateClass.call(this, { remove: i }, s, n, o) : e.apply(this, arguments) } }(t.fn.removeClass)), toggleClass: (function (e) { return function (i, s, n, o, a) { return typeof s === 'boolean' || void 0 === s ? n ? t.effects.animateClass.call(this, s ? { add: i } : { remove: i }, n, o, a) : e.apply(this, arguments) : t.effects.animateClass.call(this, { toggle: i }, s, n, o) } }(t.fn.toggleClass)), switchClass(e, i, s, n, o) { return t.effects.animateClass.call(this, { add: i, remove: e }, s, n, o) } }) }()), (function () { function e(e, i, s, n) { return t.isPlainObject(e) && (i = e, e = e.effect), e = { effect: e }, i == null && (i = {}), t.isFunction(i) && (n = i, s = null, i = {}), (typeof i === 'number' || t.fx.speeds[i]) && (n = s, s = i, i = {}), t.isFunction(s) && (n = s, s = null), i && t.extend(e, i), s = s || i.duration, e.duration = t.fx.off ? 0 : typeof s === 'number' ? s : s in t.fx.speeds ? t.fx.speeds[s] : t.fx.speeds._default, e.complete = n || i.complete, e } function i(e) { return !e || typeof e === 'number' || t.fx.speeds[e] ? !0 : typeof e !== 'string' || t.effects.effect[e] ? t.isFunction(e) ? !0 : typeof e !== 'object' || e.effect ? !1 : !0 : !0 } function a(t, e) { const i = e.outerWidth(); const s = e.outerHeight(); const n = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/; const o = n.exec(t) || ['', 0, i, s, 0]; return { top: parseFloat(o[1]) || 0, right: o[2] === 'auto' ? i : parseFloat(o[2]), bottom: o[3] === 'auto' ? s : parseFloat(o[3]), left: parseFloat(o[4]) || 0 } }t.expr && t.expr.filters && t.expr.filters.animated && (t.expr.filters.animated = (function (e) { return function (i) { return !!t(i).data(o) || e(i) } }(t.expr.filters.animated))), t.uiBackCompat !== !1 && t.extend(t.effects, { save(t, e) { for (let i = 0, n = e.length; n > i; i++)e[i] !== null && t.data(s + e[i], t[0].style[e[i]]) }, restore(t, e) { for (var i, n = 0, o = e.length; o > n; n++)e[n] !== null && (i = t.data(s + e[n]), t.css(e[n], i)) }, setMode(t, e) { return e === 'toggle' && (e = t.is(':hidden') ? 'show' : 'hide'), e }, createWrapper(e) { if (e.parent().is('.ui-effects-wrapper')) return e.parent(); const i = { width: e.outerWidth(!0), height: e.outerHeight(!0), float: e.css('float') }; let s = t('<div></div>').addClass('ui-effects-wrapper').css({ fontSize: '100%', background: 'transparent', border: 'none', margin: 0, padding: 0 }); const n = { width: e.width(), height: e.height() }; let o = document.activeElement; try { o.id } catch (a) { o = document.body } return e.wrap(s), (e[0] === o || t.contains(e[0], o)) && t(o).trigger('focus'), s = e.parent(), e.css('position') === 'static' ? (s.css({ position: 'relative' }), e.css({ position: 'relative' })) : (t.extend(i, { position: e.css('position'), zIndex: e.css('z-index') }), t.each(['top', 'left', 'bottom', 'right'], (t, s) => { i[s] = e.css(s), isNaN(parseInt(i[s], 10)) && (i[s] = 'auto') }), e.css({ position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' })), e.css(n), s.css(i).show() }, removeWrapper(e) { const i = document.activeElement; return e.parent().is('.ui-effects-wrapper') && (e.parent().replaceWith(e), (e[0] === i || t.contains(e[0], i)) && t(i).trigger('focus')), e } }), t.extend(t.effects, { version: '1.12.1', define(e, i, s) { return s || (s = i, i = 'effect'), t.effects.effect[e] = s, t.effects.effect[e].mode = i, s }, scaledDimensions(t, e, i) { if (e === 0) return { height: 0, width: 0, outerHeight: 0, outerWidth: 0 }; const s = i !== 'horizontal' ? (e || 100) / 100 : 1; const n = i !== 'vertical' ? (e || 100) / 100 : 1; return { height: t.height() * n, width: t.width() * s, outerHeight: t.outerHeight() * n, outerWidth: t.outerWidth() * s } }, clipToBox(t) { return { width: t.clip.right - t.clip.left, height: t.clip.bottom - t.clip.top, left: t.clip.left, top: t.clip.top } }, unshift(t, e, i) { const s = t.queue(); e > 1 && s.splice.apply(s, [1, 0].concat(s.splice(e, i))), t.dequeue() }, saveStyle(t) { t.data(n, t[0].style.cssText) }, restoreStyle(t) { t[0].style.cssText = t.data(n) || '', t.removeData(n) }, mode(t, e) { const i = t.is(':hidden'); return e === 'toggle' && (e = i ? 'show' : 'hide'), (i ? e === 'hide' : e === 'show') && (e = 'none'), e }, getBaseline(t, e) { let i, s; switch (t[0]) { case 'top':i = 0; break; case 'middle':i = 0.5; break; case 'bottom':i = 1; break; default:i = t[0] / e.height } switch (t[1]) { case 'left':s = 0; break; case 'center':s = 0.5; break; case 'right':s = 1; break; default:s = t[1] / e.width } return { x: s, y: i } }, createPlaceholder(e) { let i; let n = e.css('position'); const o = e.position(); return e.css({ marginTop: e.css('marginTop'), marginBottom: e.css('marginBottom'), marginLeft: e.css('marginLeft'), marginRight: e.css('marginRight') }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()), /^(static|relative)/.test(n) && (n = 'absolute', i = t(`<${e[0].nodeName}>`).insertAfter(e).css({ display: /^(inline|ruby)/.test(e.css('display')) ? 'inline-block' : 'block', visibility: 'hidden', marginTop: e.css('marginTop'), marginBottom: e.css('marginBottom'), marginLeft: e.css('marginLeft'), marginRight: e.css('marginRight'), float: e.css('float') }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass('ui-effects-placeholder'), e.data(`${s}placeholder`, i)), e.css({ position: n, left: o.left, top: o.top }), i }, removePlaceholder(t) { const e = `${s}placeholder`; const i = t.data(e); i && (i.remove(), t.removeData(e)) }, cleanUp(e) { t.effects.restoreStyle(e), t.effects.removePlaceholder(e) }, setTransition(e, i, s, n) { return n = n || {}, t.each(i, (t, i) => { const o = e.cssUnit(i); o[0] > 0 && (n[i] = o[0] * s + o[1]) }), n } }), t.fn.extend({ effect() { function i(e) { function i() { l.removeData(o), t.effects.cleanUp(l), s.mode === 'hide' && l.hide(), r() } function r() { t.isFunction(h) && h.call(l[0]), t.isFunction(e) && e() } var l = t(this); s.mode = u.shift(), t.uiBackCompat === !1 || a ? s.mode === 'none' ? (l[c](), r()) : n.call(l[0], s, i) : (l.is(':hidden') ? c === 'hide' : c === 'show') ? (l[c](), r()) : n.call(l[0], s, r) } var s = e.apply(this, arguments); var n = t.effects.effect[s.effect]; var a = n.mode; const r = s.queue; const l = r || 'fx'; var h = s.complete; var c = s.mode; var u = []; const d = function (e) { const i = t(this); const s = t.effects.mode(i, c) || a; i.data(o, !0), u.push(s), a && (s === 'show' || s === a && s === 'hide') && i.show(), a && s === 'none' || t.effects.saveStyle(i), t.isFunction(e) && e() }; return t.fx.off || !n ? c ? this[c](s.duration, h) : this.each(function () { h && h.call(this) }) : r === !1 ? this.each(d).each(i) : this.queue(l, d).queue(l, i) }, show: (function (t) { return function (s) { if (i(s)) return t.apply(this, arguments); const n = e.apply(this, arguments); return n.mode = 'show', this.effect.call(this, n) } }(t.fn.show)), hide: (function (t) { return function (s) { if (i(s)) return t.apply(this, arguments); const n = e.apply(this, arguments); return n.mode = 'hide', this.effect.call(this, n) } }(t.fn.hide)), toggle: (function (t) { return function (s) { if (i(s) || typeof s === 'boolean') return t.apply(this, arguments); const n = e.apply(this, arguments); return n.mode = 'toggle', this.effect.call(this, n) } }(t.fn.toggle)), cssUnit(e) { const i = this.css(e); let s = []; return t.each(['em', 'px', '%', 'pt'], (t, e) => { i.indexOf(e) > 0 && (s = [parseFloat(i), e]) }), s }, cssClip(t) { return t ? this.css('clip', `rect(${t.top}px ${t.right}px ${t.bottom}px ${t.left}px)`) : a(this.css('clip'), this) }, transfer(e, i) { const s = t(this); const n = t(e.to); const o = n.css('position') === 'fixed'; const a = t('body'); const r = o ? a.scrollTop() : 0; const l = o ? a.scrollLeft() : 0; const h = n.offset(); const c = { top: h.top - r, left: h.left - l, height: n.innerHeight(), width: n.innerWidth() }; const u = s.offset(); var d = t("<div class='ui-effects-transfer'></div>").appendTo('body').addClass(e.className).css({ top: u.top - r, left: u.left - l, height: s.innerHeight(), width: s.innerWidth(), position: o ? 'fixed' : 'absolute' }).animate(c, e.duration, e.easing, () => { d.remove(), t.isFunction(i) && i() }) } }), t.fx.step.clip = function (e) { e.clipInit || (e.start = t(e.elem).cssClip(), typeof e.end === 'string' && (e.end = a(e.end, e.elem)), e.clipInit = !0), t(e.elem).cssClip({ top: e.pos * (e.end.top - e.start.top) + e.start.top, right: e.pos * (e.end.right - e.start.right) + e.start.right, bottom: e.pos * (e.end.bottom - e.start.bottom) + e.start.bottom, left: e.pos * (e.end.left - e.start.left) + e.start.left }) } }()), (function () { const e = {}; t.each(['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'], (t, i) => { e[i] = function (e) { return Math.pow(e, t + 2) } }), t.extend(e, { Sine(t) { return 1 - Math.cos(t * Math.PI / 2) }, Circ(t) { return 1 - Math.sqrt(1 - t * t) }, Elastic(t) { return t === 0 || t === 1 ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15) }, Back(t) { return t * t * (3 * t - 2) }, Bounce(t) { for (var e, i = 4; ((e = Math.pow(2, --i)) - 1) / 11 > t;);return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2) } }), t.each(e, (e, i) => { t.easing[`easeIn${e}`] = i, t.easing[`easeOut${e}`] = function (t) { return 1 - i(1 - t) }, t.easing[`easeInOut${e}`] = function (t) { return t < 0.5 ? i(2 * t) / 2 : 1 - i(-2 * t + 2) / 2 } }) }()), t.effects, t.effects.define('fade', 'toggle', function (e, i) { const s = e.mode === 'show'; t(this).css('opacity', s ? 0 : 1).animate({ opacity: s ? 1 : 0 }, { queue: !1, duration: e.duration, easing: e.easing, complete: i }) }), t.effects.define('slide', 'show', function (e, i) { let s; let n; const o = t(this); const a = { up: ['bottom', 'top'], down: ['top', 'bottom'], left: ['right', 'left'], right: ['left', 'right'] }; const r = e.mode; const l = e.direction || 'left'; const h = l === 'up' || l === 'down' ? 'top' : 'left'; const c = l === 'up' || l === 'left'; const u = e.distance || o[h === 'top' ? 'outerHeight' : 'outerWidth'](!0); const d = {}; t.effects.createPlaceholder(o), s = o.cssClip(), n = o.position()[h], d[h] = (c ? -1 : 1) * u + n, d.clip = o.cssClip(), d.clip[a[l][1]] = d.clip[a[l][0]], r === 'show' && (o.cssClip(d.clip), o.css(h, d[h]), d.clip = s, d[h] = n), o.animate(d, { queue: !1, duration: e.duration, easing: e.easing, complete: i }) }) });

/*
 Copyright (C) Federico Zivolo 2019
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */
(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : e.Popper = t() })(this, () => {
  function e(e) { return e && {}.toString.call(e) === '[object Function]' } function t(e, t) { if (e.nodeType !== 1) return []; const o = e.ownerDocument.defaultView; const n = o.getComputedStyle(e, null); return t ? n[t] : n } function o(e) { return e.nodeName === 'HTML' ? e : e.parentNode || e.host } function n(e) { if (!e) return document.body; switch (e.nodeName) { case 'HTML':case 'BODY':return e.ownerDocument.body; case '#document':return e.body } const i = t(e); const r = i.overflow; const p = i.overflowX; const s = i.overflowY; return /(auto|scroll|overlay)/.test(r + s + p) ? e : n(o(e)) } function r(e) { return e === 11 ? pe : e === 10 ? se : pe || se } function p(e) { if (!e) return document.documentElement; for (var o = r(10) ? document.body : null, n = e.offsetParent || null; n === o && e.nextElementSibling;)n = (e = e.nextElementSibling).offsetParent; const i = n && n.nodeName; return i && i !== 'BODY' && i !== 'HTML' ? ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) !== -1 && t(n, 'position') === 'static' ? p(n) : n : e ? e.ownerDocument.documentElement : document.documentElement } function s(e) { const t = e.nodeName; return t !== 'BODY' && (t === 'HTML' || p(e.firstElementChild) === e) } function d(e) { return e.parentNode === null ? e : d(e.parentNode) } function a(e, t) { if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement; const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING; const n = o ? e : t; const i = o ? t : e; const r = document.createRange(); r.setStart(n, 0), r.setEnd(i, 0); const l = r.commonAncestorContainer; if (e !== l && t !== l || n.contains(i)) return s(l) ? l : p(l); const f = d(e); return f.host ? a(f.host, t) : a(e, d(t).host) } function l(e) { const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top'; const o = t === 'top' ? 'scrollTop' : 'scrollLeft'; const n = e.nodeName; if (n === 'BODY' || n === 'HTML') { const i = e.ownerDocument.documentElement; const r = e.ownerDocument.scrollingElement || i; return r[o] } return e[o] } function f(e, t) { const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const n = l(t, 'top'); const i = l(t, 'left'); const r = o ? -1 : 1; return e.top += n * r, e.bottom += n * r, e.left += i * r, e.right += i * r, e } function m(e, t) { const o = t === 'x' ? 'Left' : 'Top'; const n = o == 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${o}Width`], 10) + parseFloat(e[`border${n}Width`], 10) } function h(e, t, o, n) { return ee(t[`offset${e}`], t[`scroll${e}`], o[`client${e}`], o[`offset${e}`], o[`scroll${e}`], r(10) ? parseInt(o[`offset${e}`]) + parseInt(n[`margin${e === 'Height' ? 'Top' : 'Left'}`]) + parseInt(n[`margin${e === 'Height' ? 'Bottom' : 'Right'}`]) : 0) } function c(e) { const t = e.body; const o = e.documentElement; const n = r(10) && getComputedStyle(o); return { height: h('Height', t, o, n), width: h('Width', t, o, n) } } function g(e) { return { ...e, right: e.left + e.width, bottom: e.top + e.height } } function u(e) { let o = {}; try { if (r(10)) { o = e.getBoundingClientRect(); const n = l(e, 'top'); const i = l(e, 'left'); o.top += n, o.left += i, o.bottom += n, o.right += i } else o = e.getBoundingClientRect() } catch (t) {} const p = { left: o.left, top: o.top, width: o.right - o.left, height: o.bottom - o.top }; const s = e.nodeName === 'HTML' ? c(e.ownerDocument) : {}; const d = s.width || e.clientWidth || p.right - p.left; const a = s.height || e.clientHeight || p.bottom - p.top; let f = e.offsetWidth - d; let h = e.offsetHeight - a; if (f || h) { const u = t(e); f -= m(u, 'x'), h -= m(u, 'y'), p.width -= f, p.height -= h } return g(p) } function b(e, o) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const p = r(10); const s = o.nodeName === 'HTML'; const d = u(e); const a = u(o); const l = n(e); const m = t(o); const h = parseFloat(m.borderTopWidth, 10); const c = parseFloat(m.borderLeftWidth, 10); i && s && (a.top = ee(a.top, 0), a.left = ee(a.left, 0)); let b = g({ top: d.top - a.top - h, left: d.left - a.left - c, width: d.width, height: d.height }); if (b.marginTop = 0, b.marginLeft = 0, !p && s) { const w = parseFloat(m.marginTop, 10); const y = parseFloat(m.marginLeft, 10); b.top -= h - w, b.bottom -= h - w, b.left -= c - y, b.right -= c - y, b.marginTop = w, b.marginLeft = y } return (p && !i ? o.contains(l) : o === l && l.nodeName !== 'BODY') && (b = f(b, o)), b } function w(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const o = e.ownerDocument.documentElement; const n = b(e, o); const i = ee(o.clientWidth, window.innerWidth || 0); const r = ee(o.clientHeight, window.innerHeight || 0); const p = t ? 0 : l(o); const s = t ? 0 : l(o, 'left'); const d = { top: p - n.top + n.marginTop, left: s - n.left + n.marginLeft, width: i, height: r }; return g(d) } function y(e) { const n = e.nodeName; if (n === 'BODY' || n === 'HTML') return !1; if (t(e, 'position') === 'fixed') return !0; const i = o(e); return !!i && y(i) } function E(e) { if (!e || !e.parentElement || r()) return document.documentElement; for (var o = e.parentElement; o && t(o, 'transform') === 'none';)o = o.parentElement; return o || document.documentElement } function v(e, t, i, r) { const p = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let s = { top: 0, left: 0 }; const d = p ? E(e) : a(e, t); if (r === 'viewport')s = w(d, p); else { let l; r === 'scrollParent' ? (l = n(o(t)), l.nodeName === 'BODY' && (l = e.ownerDocument.documentElement)) : r === 'window' ? l = e.ownerDocument.documentElement : l = r; const f = b(l, d, p); if (l.nodeName === 'HTML' && !y(d)) { const m = c(e.ownerDocument); const h = m.height; const g = m.width; s.top += f.top - f.marginTop, s.bottom = h + f.top, s.left += f.left - f.marginLeft, s.right = g + f.left } else s = f }i = i || 0; const u = typeof i === 'number'; return s.left += u ? i : i.left || 0, s.top += u ? i : i.top || 0, s.right -= u ? i : i.right || 0, s.bottom -= u ? i : i.bottom || 0, s } function x(e) { const t = e.width; const o = e.height; return t * o } function O(e, t, o, n, i) { const r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (e.indexOf('auto') === -1) return e; const p = v(o, n, r, i); const s = { top: { width: p.width, height: t.top - p.top }, right: { width: p.right - t.right, height: p.height }, bottom: { width: p.width, height: p.bottom - t.bottom }, left: { width: t.left - p.left, height: p.height } }; const d = Object.keys(s).map((e) => ({ key: e, ...s[e], area: x(s[e]) })).sort((e, t) => t.area - e.area); const a = d.filter((e) => { const t = e.width; const n = e.height; return t >= o.clientWidth && n >= o.clientHeight }); const l = a.length > 0 ? a[0].key : d[0].key; const f = e.split('-')[1]; return l + (f ? `-${f}` : '') } function L(e, t, o) { const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const i = n ? E(t) : a(t, o); return b(o, i, n) } function S(e) { const t = e.ownerDocument.defaultView; const o = t.getComputedStyle(e); const n = parseFloat(o.marginTop || 0) + parseFloat(o.marginBottom || 0); const i = parseFloat(o.marginLeft || 0) + parseFloat(o.marginRight || 0); const r = { width: e.offsetWidth + i, height: e.offsetHeight + n }; return r } function T(e) { const t = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; return e.replace(/left|right|bottom|top/g, (e) => t[e]) } function D(e, t, o) { o = o.split('-')[0]; const n = S(e); const i = { width: n.width, height: n.height }; const r = ['right', 'left'].indexOf(o) !== -1; const p = r ? 'top' : 'left'; const s = r ? 'left' : 'top'; const d = r ? 'height' : 'width'; const a = r ? 'width' : 'height'; return i[p] = t[p] + t[d] / 2 - n[d] / 2, i[s] = o === s ? t[s] - n[a] : t[T(s)], i } function C(e, t) { return Array.prototype.find ? e.find(t) : e.filter(t)[0] } function N(e, t, o) { if (Array.prototype.findIndex) return e.findIndex((e) => e[t] === o); const n = C(e, (e) => e[t] === o); return e.indexOf(n) } function P(t, o, n) { const i = void 0 === n ? t : t.slice(0, N(t, 'name', n)); return i.forEach((t) => { t.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const n = t.function || t.fn; t.enabled && e(n) && (o.offsets.popper = g(o.offsets.popper), o.offsets.reference = g(o.offsets.reference), o = n(o, t)) }), o } function k() { if (!this.state.isDestroyed) { let e = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {} }; e.offsets.reference = L(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = D(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = P(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e)) } } function W(e, t) { return e.some((e) => { const o = e.name; const n = e.enabled; return n && o === t }) } function H(e) { for (let t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length; n++) { const i = t[n]; const r = i ? `${i}${o}` : e; if (typeof document.body.style[r] !== 'undefined') return r } return null } function B() { return this.state.isDestroyed = !0, W(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[H('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } function A(e) { const t = e.ownerDocument; return t ? t.defaultView : window } function M(e, t, o, i) { const r = e.nodeName === 'BODY'; const p = r ? e.ownerDocument.defaultView : e; p.addEventListener(t, o, { passive: !0 }), r || M(n(p.parentNode), t, o, i), i.push(p) } function F(e, t, o, i) { o.updateBound = i, A(e).addEventListener('resize', o.updateBound, { passive: !0 }); const r = n(e); return M(r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o } function I() { this.state.eventsEnabled || (this.state = F(this.reference, this.options, this.state, this.scheduleUpdate)) } function R(e, t) { return A(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.updateBound) }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t } function U() { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = R(this.reference, this.state)) } function Y(e) { return e !== '' && !isNaN(parseFloat(e)) && isFinite(e) } function j(e, t) { Object.keys(t).forEach((o) => { let n = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1 && Y(t[o]) && (n = 'px'), e.style[o] = t[o] + n }) } function V(e, t) { Object.keys(t).forEach((o) => { const n = t[o]; !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]) }) } function q(e, t) { const o = e.offsets; const n = o.popper; const i = o.reference; const r = $; const p = function (e) { return e }; const s = r(i.width); const d = r(n.width); const a = ['left', 'right'].indexOf(e.placement) !== -1; const l = e.placement.indexOf('-') !== -1; const f = t ? a || l || s % 2 == d % 2 ? r : Z : p; const m = t ? r : p; return { left: f(s % 2 == 1 && d % 2 == 1 && !l && t ? n.left - 1 : n.left), top: m(n.top), bottom: m(n.bottom), right: f(n.right) } } function K(e, t, o) { const n = C(e, (e) => { const o = e.name; return o === t }); const i = !!n && e.some((e) => e.name === o && e.enabled && e.order < n.order); if (!i) { const r = `\`${t}\``; console.warn(`\`${o}\`` + ` modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`) } return i } function z(e) { return e === 'end' ? 'start' : e === 'start' ? 'end' : e } function G(e) { const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const o = ce.indexOf(e); const n = ce.slice(o + 1).concat(ce.slice(0, o)); return t ? n.reverse() : n } function _(e, t, o, n) { const i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const r = +i[1]; const p = i[2]; if (!r) return e; if (p.indexOf('%') === 0) { let s; switch (p) { case '%p':s = o; break; case '%':case '%r':default:s = n } const d = g(s); return d[t] / 100 * r } if (p === 'vh' || p === 'vw') { let a; return a = p === 'vh' ? ee(document.documentElement.clientHeight, window.innerHeight || 0) : ee(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r } return r } function X(e, t, o, n) { const i = [0, 0]; const r = ['right', 'left'].indexOf(n) !== -1; const p = e.split(/(\+|\-)/).map((e) => e.trim()); const s = p.indexOf(C(p, (e) => e.search(/,|\s/) !== -1)); p[s] && p[s].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const d = /\s*,\s*|\s+/; let a = s === -1 ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))]; return a = a.map((e, n) => { const i = (n === 1 ? !r : r) ? 'height' : 'width'; let p = !1; return e.reduce((e, t) => e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1 ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t), []).map((e) => _(e, i, t, o)) }), a.forEach((e, t) => { e.forEach((o, n) => { Y(o) && (i[t] += o * (e[n - 1] === '-' ? -1 : 1)) }) }), i } function J(e, t) { let o; const n = t.offset; const i = e.placement; const r = e.offsets; const p = r.popper; const s = r.reference; const d = i.split('-')[0]; return o = Y(+n) ? [+n, 0] : X(n, p, s, d), d === 'left' ? (p.top += o[0], p.left -= o[1]) : d === 'right' ? (p.top += o[0], p.left += o[1]) : d === 'top' ? (p.left += o[0], p.top -= o[1]) : d === 'bottom' && (p.left += o[0], p.top += o[1]), e.popper = p, e } for (var Q = Math.min, Z = Math.floor, $ = Math.round, ee = Math.max, te = typeof window !== 'undefined' && typeof document !== 'undefined', oe = ['Edge', 'Trident', 'Firefox'], ne = 0, ie = 0; ie < oe.length; ie += 1) if (te && navigator.userAgent.indexOf(oe[ie]) >= 0) { ne = 1; break } const i = te && window.Promise; const re = i ? function (e) { let t = !1; return function () { t || (t = !0, window.Promise.resolve().then(() => { t = !1, e() })) } } : function (e) { let t = !1; return function () { t || (t = !0, setTimeout(() => { t = !1, e() }, ne)) } }; var pe = te && !!(window.MSInputMethodContext && document.documentMode); var se = te && /MSIE 10/.test(navigator.userAgent); const de = function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function') }; const ae = (function () { function e(e, t) { for (var o, n = 0; n < t.length; n++)o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } return function (t, o, n) { return o && e(t.prototype, o), n && e(t, n), t } }()); const le = function (e, t, o) { return t in e ? Object.defineProperty(e, t, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = o, e }; const fe = Object.assign || function (e) { for (var t, o = 1; o < arguments.length; o++) for (const n in t = arguments[o], t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }; const me = te && /Firefox/i.test(navigator.userAgent); const he = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; var ce = he.slice(3); const ge = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise' }; const ue = (function () { function t(o, n) { const i = this; const r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; de(this, t), this.scheduleUpdate = function () { return requestAnimationFrame(i.update) }, this.update = re(this.update.bind(this)), this.options = { ...t.Defaults, ...r }, this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = o && o.jquery ? o[0] : o, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys({ ...t.Defaults.modifiers, ...r.modifiers }).forEach((e) => { i.options.modifiers[e] = { ...t.Defaults.modifiers[e] || {}, ...(r.modifiers ? r.modifiers[e] : {}) } }), this.modifiers = Object.keys(this.options.modifiers).map((e) => ({ name: e, ...i.options.modifiers[e] })).sort((e, t) => e.order - t.order), this.modifiers.forEach((t) => { t.enabled && e(t.onLoad) && t.onLoad(i.reference, i.popper, i.options, t, i.state) }), this.update(); const p = this.options.eventsEnabled; p && this.enableEventListeners(), this.state.eventsEnabled = p } return ae(t, [{ key: 'update', value() { return k.call(this) } }, { key: 'destroy', value() { return B.call(this) } }, { key: 'enableEventListeners', value() { return I.call(this) } }, { key: 'disableEventListeners', value() { return U.call(this) } }]), t }()); return ue.Utils = (typeof window === 'undefined' ? global : window).PopperUtils, ue.placements = he, ue.Defaults = { placement: 'bottom', positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate() {}, onUpdate() {}, modifiers: { shift: { order: 100, enabled: !0, fn(e) { const t = e.placement; const o = t.split('-')[0]; const n = t.split('-')[1]; if (n) { const i = e.offsets; const r = i.reference; const p = i.popper; const s = ['bottom', 'top'].indexOf(o) !== -1; const d = s ? 'left' : 'top'; const a = s ? 'width' : 'height'; const l = { start: le({}, d, r[d]), end: le({}, d, r[d] + r[a] - p[a]) }; e.offsets.popper = { ...p, ...l[n] } } return e } }, offset: { order: 200, enabled: !0, fn: J, offset: 0 }, preventOverflow: { order: 300, enabled: !0, fn(e, t) { let o = t.boundariesElement || p(e.instance.popper); e.instance.reference === o && (o = p(o)); const n = H('transform'); const i = e.instance.popper.style; const r = i.top; const s = i.left; const d = i[n]; i.top = '', i.left = '', i[n] = ''; const a = v(e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = s, i[n] = d, t.boundaries = a; const l = t.priority; let f = e.offsets.popper; const m = { primary(e) { let o = f[e]; return f[e] < a[e] && !t.escapeWithReference && (o = ee(f[e], a[e])), le({}, e, o) }, secondary(e) { const o = e === 'right' ? 'left' : 'top'; let n = f[o]; return f[e] > a[e] && !t.escapeWithReference && (n = Q(f[o], a[e] - (e === 'right' ? f.width : f.height))), le({}, o, n) } }; return l.forEach((e) => { const t = ['left', 'top'].indexOf(e) === -1 ? 'secondary' : 'primary'; f = { ...f, ...m[t](e) } }), e.offsets.popper = f, e }, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent' }, keepTogether: { order: 400, enabled: !0, fn(e) { const t = e.offsets; const o = t.popper; const n = t.reference; const i = e.placement.split('-')[0]; const r = Z; const p = ['top', 'bottom'].indexOf(i) !== -1; const s = p ? 'right' : 'bottom'; const d = p ? 'left' : 'top'; const a = p ? 'width' : 'height'; return o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]), o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])), e } }, arrow: { order: 500, enabled: !0, fn(e, o) { let n; if (!K(e.instance.modifiers, 'arrow', 'keepTogether')) return e; let i = o.element; if (typeof i === 'string') { if (i = e.instance.popper.querySelector(i), !i) return e } else if (!e.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e; const r = e.placement.split('-')[0]; const p = e.offsets; const s = p.popper; const d = p.reference; const a = ['left', 'right'].indexOf(r) !== -1; const l = a ? 'height' : 'width'; const f = a ? 'Top' : 'Left'; const m = f.toLowerCase(); const h = a ? 'left' : 'top'; const c = a ? 'bottom' : 'right'; const u = S(i)[l]; d[c] - u < s[m] && (e.offsets.popper[m] -= s[m] - (d[c] - u)), d[m] + u > s[c] && (e.offsets.popper[m] += d[m] + u - s[c]), e.offsets.popper = g(e.offsets.popper); const b = d[m] + d[l] / 2 - u / 2; const w = t(e.instance.popper); const y = parseFloat(w[`margin${f}`], 10); const E = parseFloat(w[`border${f}Width`], 10); let v = b - e.offsets.popper[m] - y - E; return v = ee(Q(s[l] - u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, le(n, m, $(v)), le(n, h, ''), n), e }, element: '[x-arrow]' }, flip: { order: 600, enabled: !0, fn(e, t) { if (W(e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; const o = v(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed); let n = e.placement.split('-')[0]; let i = T(n); let r = e.placement.split('-')[1] || ''; let p = []; switch (t.behavior) { case ge.FLIP:p = [n, i]; break; case ge.CLOCKWISE:p = G(n); break; case ge.COUNTERCLOCKWISE:p = G(n, !0); break; default:p = t.behavior } return p.forEach((s, d) => { if (n !== s || p.length === d + 1) return e; n = e.placement.split('-')[0], i = T(n); const a = e.offsets.popper; const l = e.offsets.reference; const f = Z; const m = n === 'left' && f(a.right) > f(l.left) || n === 'right' && f(a.left) < f(l.right) || n === 'top' && f(a.bottom) > f(l.top) || n === 'bottom' && f(a.top) < f(l.bottom); const h = f(a.left) < f(o.left); const c = f(a.right) > f(o.right); const g = f(a.top) < f(o.top); const u = f(a.bottom) > f(o.bottom); const b = n === 'left' && h || n === 'right' && c || n === 'top' && g || n === 'bottom' && u; const w = ['top', 'bottom'].indexOf(n) !== -1; const y = !!t.flipVariations && (w && r === 'start' && h || w && r === 'end' && c || !w && r === 'start' && g || !w && r === 'end' && u); (m || b || y) && (e.flipped = !0, (m || b) && (n = p[d + 1]), y && (r = z(r)), e.placement = n + (r ? `-${r}` : ''), e.offsets.popper = { ...e.offsets.popper, ...D(e.instance.popper, e.offsets.reference, e.placement) }, e = P(e.instance.modifiers, e, 'flip')) }), e }, behavior: 'flip', padding: 5, boundariesElement: 'viewport' }, inner: { order: 700, enabled: !1, fn(e) { const t = e.placement; const o = t.split('-')[0]; const n = e.offsets; const i = n.popper; const r = n.reference; const p = ['left', 'right'].indexOf(o) !== -1; const s = ['top', 'left'].indexOf(o) === -1; return i[p ? 'left' : 'top'] = r[o] - (s ? i[p ? 'width' : 'height'] : 0), e.placement = T(t), e.offsets.popper = g(i), e } }, hide: { order: 800, enabled: !0, fn(e) { if (!K(e.instance.modifiers, 'hide', 'preventOverflow')) return e; const t = e.offsets.reference; const o = C(e.instance.modifiers, (e) => e.name === 'preventOverflow').boundaries; if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) { if (!0 === e.hide) return e; e.hide = !0, e.attributes['x-out-of-boundaries'] = '' } else { if (!1 === e.hide) return e; e.hide = !1, e.attributes['x-out-of-boundaries'] = !1 } return e } }, computeStyle: { order: 850, enabled: !0, fn(e, t) { const o = t.x; const n = t.y; const i = e.offsets.popper; const r = C(e.instance.modifiers, (e) => e.name === 'applyStyle').gpuAcceleration; void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); let s; let d; const a = void 0 === r ? t.gpuAcceleration : r; const l = p(e.instance.popper); const f = u(l); const m = { position: i.position }; const h = q(e, window.devicePixelRatio < 2 || !me); const c = o === 'bottom' ? 'top' : 'bottom'; const g = n === 'right' ? 'left' : 'right'; const b = H('transform'); if (d = c == 'bottom' ? l.nodeName === 'HTML' ? -l.clientHeight + h.bottom : -f.height + h.bottom : h.top, s = g == 'right' ? l.nodeName === 'HTML' ? -l.clientWidth + h.right : -f.width + h.right : h.left, a && b)m[b] = `translate3d(${s}px, ${d}px, 0)`, m[c] = 0, m[g] = 0, m.willChange = 'transform'; else { const w = c == 'bottom' ? -1 : 1; const y = g == 'right' ? -1 : 1; m[c] = d * w, m[g] = s * y, m.willChange = `${c}, ${g}` } const E = { 'x-placement': e.placement }; return e.attributes = { ...E, ...e.attributes }, e.styles = { ...m, ...e.styles }, e.arrowStyles = { ...e.offsets.arrow, ...e.arrowStyles }, e }, gpuAcceleration: !0, x: 'bottom', y: 'right' }, applyStyle: { order: 900, enabled: !0, fn(e) { return j(e.instance.popper, e.styles), V(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && j(e.arrowElement, e.arrowStyles), e }, onLoad(e, t, o, n, i) { const r = L(i, t, e, o.positionFixed); const p = O(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute('x-placement', p), j(t, { position: o.positionFixed ? 'fixed' : 'absolute' }), o }, gpuAcceleration: void 0 } } }, ue
})

/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports, require('jquery'), require('popper.js')) : typeof define === 'function' && define.amd ? define(['exports', 'jquery', 'popper.js'], e) : e((t = t || self).bootstrap = {}, t.jQuery, t.Popper) }(this, (t, g, u) => {
  function i(t, e) { for (let n = 0; n < e.length; n++) { const i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function s(t, e, n) { return e && i(t.prototype, e), n && i(t, n), t } function l(o) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; let e = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (e = e.concat(Object.getOwnPropertySymbols(r).filter((t) => Object.getOwnPropertyDescriptor(r, t).enumerable))), e.forEach((t) => { let e, n, i; e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[n] = i }) } return o }g = g && g.hasOwnProperty('default') ? g.default : g, u = u && u.hasOwnProperty('default') ? u.default : u; const e = 'transitionend'; function n(t) { const e = this; let n = !1; return g(this).one(_.TRANSITION_END, () => { n = !0 }), setTimeout(() => { n || _.triggerTransitionEnd(e) }, t), this } var _ = { TRANSITION_END: 'bsTransitionEnd', getUID(t) { for (;t += ~~(1e6 * Math.random()), document.getElementById(t););return t }, getSelectorFromElement(t) { let e = t.getAttribute('data-target'); if (!e || e === '#') { const n = t.getAttribute('href'); e = n && n !== '#' ? n.trim() : '' } try { return document.querySelector(e) ? e : null } catch (t) { return null } }, getTransitionDurationFromElement(t) { if (!t) return 0; let e = g(t).css('transition-duration'); let n = g(t).css('transition-delay'); const i = parseFloat(e); const o = parseFloat(n); return i || o ? (e = e.split(',')[0], n = n.split(',')[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0 }, reflow(t) { return t.offsetHeight }, triggerTransitionEnd(t) { g(t).trigger(e) }, supportsTransitionEnd() { return Boolean(e) }, isElement(t) { return (t[0] || t).nodeType }, typeCheckConfig(t, e, n) { for (const i in n) if (Object.prototype.hasOwnProperty.call(n, i)) { const o = n[i]; const r = e[i]; const s = r && _.isElement(r) ? 'element' : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase()); if (!new RegExp(o).test(s)) throw new Error(`${t.toUpperCase()}: Option "${i}" provided type "${s}" but expected type "${o}".`) } let a }, findShadowRoot(t) { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode !== 'function') return t instanceof ShadowRoot ? t : t.parentNode ? _.findShadowRoot(t.parentNode) : null; const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } }; g.fn.emulateTransitionEnd = n, g.event.special[_.TRANSITION_END] = { bindType: e, delegateType: e, handle(t) { if (g(t.target).is(this)) return t.handleObj.handler.apply(this, arguments) } }; const o = 'alert'; const r = 'bs.alert'; const a = `.${r}`; const c = g.fn[o]; const h = { CLOSE: `close${a}`, CLOSED: `closed${a}`, CLICK_DATA_API: `click${a}.data-api` }; const f = 'alert'; const d = 'fade'; const m = 'show'; const p = (function () { function i(t) { this._element = t } const t = i.prototype; return t.close = function (t) { let e = this._element; t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e) }, t.dispose = function () { g.removeData(this._element, r), this._element = null }, t._getRootElement = function (t) { const e = _.getSelectorFromElement(t); let n = !1; return e && (n = document.querySelector(e)), n || (n = g(t).closest(`.${f}`)[0]), n }, t._triggerCloseEvent = function (t) { const e = g.Event(h.CLOSE); return g(t).trigger(e), e }, t._removeElement = function (e) { const n = this; if (g(e).removeClass(m), g(e).hasClass(d)) { const t = _.getTransitionDurationFromElement(e); g(e).one(_.TRANSITION_END, (t) => n._destroyElement(e, t)).emulateTransitionEnd(t) } else this._destroyElement(e) }, t._destroyElement = function (t) { g(t).detach().trigger(h.CLOSED).remove() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(r); e || (e = new i(this), t.data(r, e)), n === 'close' && e[n](this) }) }, i._handleDismiss = function (e) { return function (t) { t && t.preventDefault(), e.close(this) } }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), i }()); g(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', p._handleDismiss(new p())), g.fn[o] = p._jQueryInterface, g.fn[o].Constructor = p, g.fn[o].noConflict = function () { return g.fn[o] = c, p._jQueryInterface }; const v = 'button'; const y = 'bs.button'; const E = `.${y}`; const C = '.data-api'; const T = g.fn[v]; const S = 'active'; const b = 'btn'; const I = 'focus'; const D = '[data-toggle^="button"]'; const w = '[data-toggle="buttons"]'; const A = 'input:not([type="hidden"])'; const N = '.active'; const O = '.btn'; const k = { CLICK_DATA_API: `click${E}${C}`, FOCUS_BLUR_DATA_API: `focus${E}${C} blur${E}${C}` }; const P = (function () { function n(t) { this._element = t } const t = n.prototype; return t.toggle = function () { let t = !0; let e = !0; const n = g(this._element).closest(w)[0]; if (n) { const i = this._element.querySelector(A); if (i) { if (i.type === 'radio') if (i.checked && this._element.classList.contains(S))t = !1; else { const o = n.querySelector(N); o && g(o).removeClass(S) } if (t) { if (i.hasAttribute('disabled') || n.hasAttribute('disabled') || i.classList.contains('disabled') || n.classList.contains('disabled')) return; i.checked = !this._element.classList.contains(S), g(i).trigger('change') }i.focus(), e = !1 } }e && this._element.setAttribute('aria-pressed', !this._element.classList.contains(S)), t && g(this._element).toggleClass(S) }, t.dispose = function () { g.removeData(this._element, y), this._element = null }, n._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(y); t || (t = new n(this), g(this).data(y, t)), e === 'toggle' && t[e]() }) }, s(n, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), n }()); g(document).on(k.CLICK_DATA_API, D, (t) => { t.preventDefault(); let e = t.target; g(e).hasClass(b) || (e = g(e).closest(O)), P._jQueryInterface.call(g(e), 'toggle') }).on(k.FOCUS_BLUR_DATA_API, D, (t) => { const e = g(t.target).closest(O)[0]; g(e).toggleClass(I, /^focus(in)?$/.test(t.type)) }), g.fn[v] = P._jQueryInterface, g.fn[v].Constructor = P, g.fn[v].noConflict = function () { return g.fn[v] = T, P._jQueryInterface }; const L = 'carousel'; const j = 'bs.carousel'; const H = `.${j}`; const R = '.data-api'; const x = g.fn[L]; const F = { interval: 5e3, keyboard: !0, slide: !1, pause: 'hover', wrap: !0, touch: !0 }; const U = { interval: '(number|boolean)', keyboard: 'boolean', slide: '(boolean|string)', pause: '(string|boolean)', wrap: 'boolean', touch: 'boolean' }; const W = 'next'; const q = 'prev'; const M = 'left'; const K = 'right'; const Q = { SLIDE: `slide${H}`, SLID: `slid${H}`, KEYDOWN: `keydown${H}`, MOUSEENTER: `mouseenter${H}`, MOUSELEAVE: `mouseleave${H}`, TOUCHSTART: `touchstart${H}`, TOUCHMOVE: `touchmove${H}`, TOUCHEND: `touchend${H}`, POINTERDOWN: `pointerdown${H}`, POINTERUP: `pointerup${H}`, DRAG_START: `dragstart${H}`, LOAD_DATA_API: `load${H}${R}`, CLICK_DATA_API: `click${H}${R}` }; const B = 'carousel'; const V = 'active'; const Y = 'slide'; const z = 'carousel-item-right'; const X = 'carousel-item-left'; const $ = 'carousel-item-next'; const G = 'carousel-item-prev'; const J = 'pointer-event'; const Z = '.active'; const tt = '.active.carousel-item'; const et = '.carousel-item'; const nt = '.carousel-item img'; const it = '.carousel-item-next, .carousel-item-prev'; const ot = '.carousel-indicators'; const rt = '[data-slide], [data-slide-to]'; const st = '[data-ride="carousel"]'; const at = { TOUCH: 'touch', PEN: 'pen' }; const lt = (function () { function r(t, e) { this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(ot), this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners() } const t = r.prototype; return t.next = function () { this._isSliding || this._slide(W) }, t.nextWhenVisible = function () { !document.hidden && g(this._element).is(':visible') && g(this._element).css('visibility') !== 'hidden' && this.next() }, t.prev = function () { this._isSliding || this._slide(q) }, t.pause = function (t) { t || (this._isPaused = !0), this._element.querySelector(it) && (_.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null }, t.cycle = function (t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) }, t.to = function (t) { const e = this; this._activeElement = this._element.querySelector(tt); const n = this._getItemIndex(this._activeElement); if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding)g(this._element).one(Q.SLID, () => e.to(t)); else { if (n === t) return this.pause(), void this.cycle(); const i = n < t ? W : q; this._slide(i, this._items[t]) } }, t.dispose = function () { g(this._element).off(H), g.removeData(this._element, j), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null }, t._getConfig = function (t) { return t = l({}, F, t), _.typeCheckConfig(L, t, U), t }, t._handleSwipe = function () { const t = Math.abs(this.touchDeltaX); if (!(t <= 40)) { const e = t / this.touchDeltaX; e > 0 && this.prev(), e < 0 && this.next() } }, t._addEventListeners = function () { const e = this; this._config.keyboard && g(this._element).on(Q.KEYDOWN, (t) => e._keydown(t)), this._config.pause === 'hover' && g(this._element).on(Q.MOUSEENTER, (t) => e.pause(t)).on(Q.MOUSELEAVE, (t) => e.cycle(t)), this._config.touch && this._addTouchEventListeners() }, t._addTouchEventListeners = function () { const n = this; if (this._touchSupported) { const e = function (t) { n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX) }; const i = function (t) { n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), n._config.pause === 'hover' && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout((t) => n.cycle(t), 500 + n._config.interval)) }; g(this._element.querySelectorAll(nt)).on(Q.DRAG_START, (t) => t.preventDefault()), this._pointerEvent ? (g(this._element).on(Q.POINTERDOWN, (t) => e(t)), g(this._element).on(Q.POINTERUP, (t) => i(t)), this._element.classList.add(J)) : (g(this._element).on(Q.TOUCHSTART, (t) => e(t)), g(this._element).on(Q.TOUCHMOVE, (t) => { let e; (e = t).originalEvent.touches && e.originalEvent.touches.length > 1 ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX }), g(this._element).on(Q.TOUCHEND, (t) => i(t))) } }, t._keydown = function (t) { if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) { case 37:t.preventDefault(), this.prev(); break; case 39:t.preventDefault(), this.next() } }, t._getItemIndex = function (t) { return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(et)) : [], this._items.indexOf(t) }, t._getItemByDirection = function (t, e) { const n = t === W; const i = t === q; const o = this._getItemIndex(e); const r = this._items.length - 1; if ((i && o === 0 || n && o === r) && !this._config.wrap) return e; const s = (o + (t === q ? -1 : 1)) % this._items.length; return s === -1 ? this._items[this._items.length - 1] : this._items[s] }, t._triggerSlideEvent = function (t, e) { const n = this._getItemIndex(t); const i = this._getItemIndex(this._element.querySelector(tt)); const o = g.Event(Q.SLIDE, { relatedTarget: t, direction: e, from: i, to: n }); return g(this._element).trigger(o), o }, t._setActiveIndicatorElement = function (t) { if (this._indicatorsElement) { const e = [].slice.call(this._indicatorsElement.querySelectorAll(Z)); g(e).removeClass(V); const n = this._indicatorsElement.children[this._getItemIndex(t)]; n && g(n).addClass(V) } }, t._slide = function (t, e) { let n; let i; let o; const r = this; const s = this._element.querySelector(tt); const a = this._getItemIndex(s); const l = e || s && this._getItemByDirection(t, s); const c = this._getItemIndex(l); const h = Boolean(this._interval); if (o = t === W ? (n = X, i = $, M) : (n = z, i = G, K), l && g(l).hasClass(V)) this._isSliding = !1; else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) { this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l); const u = g.Event(Q.SLID, { relatedTarget: l, direction: o, from: a, to: c }); if (g(this._element).hasClass(Y)) { g(l).addClass(i), _.reflow(l), g(s).addClass(n), g(l).addClass(n); const f = parseInt(l.getAttribute('data-interval'), 10); this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval; const d = _.getTransitionDurationFromElement(s); g(s).one(_.TRANSITION_END, () => { g(l).removeClass(`${n} ${i}`).addClass(V), g(s).removeClass(`${V} ${i} ${n}`), r._isSliding = !1, setTimeout(() => g(r._element).trigger(u), 0) }).emulateTransitionEnd(d) } else g(s).removeClass(V), g(l).addClass(V), this._isSliding = !1, g(this._element).trigger(u); h && this.cycle() } }, r._jQueryInterface = function (i) { return this.each(function () { let t = g(this).data(j); let e = l({}, F, g(this).data()); typeof i === 'object' && (e = l({}, e, i)); const n = typeof i === 'string' ? i : e.slide; if (t || (t = new r(this, e), g(this).data(j, t)), typeof i === 'number')t.to(i); else if (typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } else e.interval && e.ride && (t.pause(), t.cycle()) }) }, r._dataApiClickHandler = function (t) { const e = _.getSelectorFromElement(this); if (e) { const n = g(e)[0]; if (n && g(n).hasClass(B)) { const i = l({}, g(n).data(), g(this).data()); const o = this.getAttribute('data-slide-to'); o && (i.interval = !1), r._jQueryInterface.call(g(n), i), o && g(n).data(j).to(o), t.preventDefault() } } }, s(r, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return F } }]), r }()); g(document).on(Q.CLICK_DATA_API, rt, lt._dataApiClickHandler), g(window).on(Q.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(st)), e = 0, n = t.length; e < n; e++) { const i = g(t[e]); lt._jQueryInterface.call(i, i.data()) } }), g.fn[L] = lt._jQueryInterface, g.fn[L].Constructor = lt, g.fn[L].noConflict = function () { return g.fn[L] = x, lt._jQueryInterface }; const ct = 'collapse'; const ht = 'bs.collapse'; const ut = `.${ht}`; const ft = g.fn[ct]; const dt = { toggle: !0, parent: '' }; const gt = { toggle: 'boolean', parent: '(string|element)' }; const _t = { SHOW: `show${ut}`, SHOWN: `shown${ut}`, HIDE: `hide${ut}`, HIDDEN: `hidden${ut}`, CLICK_DATA_API: `click${ut}.data-api` }; const mt = 'show'; const pt = 'collapse'; const vt = 'collapsing'; const yt = 'collapsed'; const Et = 'width'; const Ct = 'height'; const Tt = '.show, .collapsing'; const St = '[data-toggle="collapse"]'; const bt = (function () { function a(e, t) { this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll(`[data-toggle="collapse"][href="#${e.id}"],[data-toggle="collapse"][data-target="#${e.id}"]`)); for (let n = [].slice.call(document.querySelectorAll(St)), i = 0, o = n.length; i < o; i++) { const r = n[i]; const s = _.getSelectorFromElement(r); const a = [].slice.call(document.querySelectorAll(s)).filter((t) => t === e); s !== null && a.length > 0 && (this._selector = s, this._triggerArray.push(r)) } this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle() } const t = a.prototype; return t.toggle = function () { g(this._element).hasClass(mt) ? this.hide() : this.show() }, t.show = function () { let t; let e; const n = this; if (!this._isTransitioning && !g(this._element).hasClass(mt) && (this._parent && (t = [].slice.call(this._parent.querySelectorAll(Tt)).filter((t) => typeof n._config.parent === 'string' ? t.getAttribute('data-parent') === n._config.parent : t.classList.contains(pt))).length === 0 && (t = null), !(t && (e = g(t).not(this._selector).data(ht)) && e._isTransitioning))) { const i = g.Event(_t.SHOW); if (g(this._element).trigger(i), !i.isDefaultPrevented()) { t && (a._jQueryInterface.call(g(t).not(this._selector), 'hide'), e || g(t).data(ht, null)); const o = this._getDimension(); g(this._element).removeClass(pt).addClass(vt), this._element.style[o] = 0, this._triggerArray.length && g(this._triggerArray).removeClass(yt).attr('aria-expanded', !0), this.setTransitioning(!0); const r = `scroll${o[0].toUpperCase() + o.slice(1)}`; const s = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, () => { g(n._element).removeClass(vt).addClass(pt).addClass(mt), n._element.style[o] = '', n.setTransitioning(!1), g(n._element).trigger(_t.SHOWN) }).emulateTransitionEnd(s), this._element.style[o] = `${this._element[r]}px` } } }, t.hide = function () { const t = this; if (!this._isTransitioning && g(this._element).hasClass(mt)) { const e = g.Event(_t.HIDE); if (g(this._element).trigger(e), !e.isDefaultPrevented()) { const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, _.reflow(this._element), g(this._element).addClass(vt).removeClass(pt).removeClass(mt); const i = this._triggerArray.length; if (i > 0) for (let o = 0; o < i; o++) { const r = this._triggerArray[o]; const s = _.getSelectorFromElement(r); if (s !== null)g([].slice.call(document.querySelectorAll(s))).hasClass(mt) || g(r).addClass(yt).attr('aria-expanded', !1) } this.setTransitioning(!0); this._element.style[n] = ''; const a = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, () => { t.setTransitioning(!1), g(t._element).removeClass(vt).addClass(pt).trigger(_t.HIDDEN) }).emulateTransitionEnd(a) } } }, t.setTransitioning = function (t) { this._isTransitioning = t }, t.dispose = function () { g.removeData(this._element, ht), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null }, t._getConfig = function (t) { return (t = l({}, dt, t)).toggle = Boolean(t.toggle), _.typeCheckConfig(ct, t, gt), t }, t._getDimension = function () { return g(this._element).hasClass(Et) ? Et : Ct }, t._getParent = function () { let t; const n = this; _.isElement(this._config.parent) ? (t = this._config.parent, typeof this._config.parent.jquery !== 'undefined' && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent); const e = `[data-toggle="collapse"][data-parent="${this._config.parent}"]`; const i = [].slice.call(t.querySelectorAll(e)); return g(i).each((t, e) => { n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]) }), t }, t._addAriaAndCollapsedClass = function (t, e) { const n = g(t).hasClass(mt); e.length && g(e).toggleClass(yt, !n).attr('aria-expanded', n) }, a._getTargetFromElement = function (t) { const e = _.getSelectorFromElement(t); return e ? document.querySelector(e) : null }, a._jQueryInterface = function (i) { return this.each(function () { const t = g(this); let e = t.data(ht); const n = l({}, dt, t.data(), typeof i === 'object' && i ? i : {}); if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ht, e)), typeof i === 'string') { if (typeof e[i] === 'undefined') throw new TypeError(`No method named "${i}"`); e[i]() } }) }, s(a, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return dt } }]), a }()); g(document).on(_t.CLICK_DATA_API, St, function (t) { t.currentTarget.tagName === 'A' && t.preventDefault(); const n = g(this); const e = _.getSelectorFromElement(this); const i = [].slice.call(document.querySelectorAll(e)); g(i).each(function () { const t = g(this); const e = t.data(ht) ? 'toggle' : n.data(); bt._jQueryInterface.call(t, e) }) }), g.fn[ct] = bt._jQueryInterface, g.fn[ct].Constructor = bt, g.fn[ct].noConflict = function () { return g.fn[ct] = ft, bt._jQueryInterface }; const It = 'dropdown'; const Dt = 'bs.dropdown'; const wt = `.${Dt}`; const At = '.data-api'; const Nt = g.fn[It]; const Ot = new RegExp('38|40|27'); const kt = { HIDE: `hide${wt}`, HIDDEN: `hidden${wt}`, SHOW: `show${wt}`, SHOWN: `shown${wt}`, CLICK: `click${wt}`, CLICK_DATA_API: `click${wt}${At}`, KEYDOWN_DATA_API: `keydown${wt}${At}`, KEYUP_DATA_API: `keyup${wt}${At}` }; const Pt = 'disabled'; const Lt = 'show'; const jt = 'dropup'; const Ht = 'dropright'; const Rt = 'dropleft'; const xt = 'dropdown-menu-right'; const Ft = 'position-static'; const Ut = '[data-toggle="dropdown"]'; const Wt = '.dropdown form'; const qt = '.dropdown-menu'; const Mt = '.navbar-nav'; const Kt = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'; const Qt = 'top-start'; const Bt = 'top-end'; const Vt = 'bottom-start'; const Yt = 'bottom-end'; const zt = 'right-start'; const Xt = 'left-start'; const $t = { offset: 0, flip: !0, boundary: 'scrollParent', reference: 'toggle', display: 'dynamic' }; const Gt = { offset: '(number|string|function)', flip: 'boolean', boundary: '(string|element)', reference: '(string|element)', display: 'string' }; const Jt = (function () { function c(t, e) { this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners() } const t = c.prototype; return t.toggle = function () { if (!this._element.disabled && !g(this._element).hasClass(Pt)) { const t = c._getParentFromElement(this._element); const e = g(this._menu).hasClass(Lt); if (c._clearMenus(), !e) { const n = { relatedTarget: this._element }; const i = g.Event(kt.SHOW, n); if (g(t).trigger(i), !i.isDefaultPrevented()) { if (!this._inNavbar) { if (typeof u === 'undefined') throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)"); let o = this._element; this._config.reference === 'parent' ? o = t : _.isElement(this._config.reference) && (o = this._config.reference, typeof this._config.reference.jquery !== 'undefined' && (o = this._config.reference[0])), this._config.boundary !== 'scrollParent' && g(t).addClass(Ft), this._popper = new u(o, this._menu, this._getPopperConfig()) }'ontouchstart' in document.documentElement && g(t).closest(Mt).length === 0 && g(document.body).children().on('mouseover', null, g.noop), this._element.focus(), this._element.setAttribute('aria-expanded', !0), g(this._menu).toggleClass(Lt), g(t).toggleClass(Lt).trigger(g.Event(kt.SHOWN, n)) } } } }, t.show = function () { if (!(this._element.disabled || g(this._element).hasClass(Pt) || g(this._menu).hasClass(Lt))) { const t = { relatedTarget: this._element }; const e = g.Event(kt.SHOW, t); const n = c._getParentFromElement(this._element); g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.SHOWN, t))) } }, t.hide = function () { if (!this._element.disabled && !g(this._element).hasClass(Pt) && g(this._menu).hasClass(Lt)) { const t = { relatedTarget: this._element }; const e = g.Event(kt.HIDE, t); const n = c._getParentFromElement(this._element); g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.HIDDEN, t))) } }, t.dispose = function () { g.removeData(this._element, Dt), g(this._element).off(wt), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null) }, t.update = function () { this._inNavbar = this._detectNavbar(), this._popper !== null && this._popper.scheduleUpdate() }, t._addEventListeners = function () { const e = this; g(this._element).on(kt.CLICK, (t) => { t.preventDefault(), t.stopPropagation(), e.toggle() }) }, t._getConfig = function (t) { return t = l({}, this.constructor.Default, g(this._element).data(), t), _.typeCheckConfig(It, t, this.constructor.DefaultType), t }, t._getMenuElement = function () { if (!this._menu) { const t = c._getParentFromElement(this._element); t && (this._menu = t.querySelector(qt)) } return this._menu }, t._getPlacement = function () { const t = g(this._element.parentNode); let e = Vt; return t.hasClass(jt) ? (e = Qt, g(this._menu).hasClass(xt) && (e = Bt)) : t.hasClass(Ht) ? e = zt : t.hasClass(Rt) ? e = Xt : g(this._menu).hasClass(xt) && (e = Yt), e }, t._detectNavbar = function () { return g(this._element).closest('.navbar').length > 0 }, t._getOffset = function () { const e = this; const t = {}; return typeof this._config.offset === 'function' ? t.fn = function (t) { return t.offsets = l({}, t.offsets, e._config.offset(t.offsets, e._element) || {}), t } : t.offset = this._config.offset, t }, t._getPopperConfig = function () { const t = { placement: this._getPlacement(), modifiers: { offset: this._getOffset(), flip: { enabled: this._config.flip }, preventOverflow: { boundariesElement: this._config.boundary } } }; return this._config.display === 'static' && (t.modifiers.applyStyle = { enabled: !1 }), t }, c._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(Dt); if (t || (t = new c(this, typeof e === 'object' ? e : null), g(this).data(Dt, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e]() } }) }, c._clearMenus = function (t) { if (!t || t.which !== 3 && (t.type !== 'keyup' || t.which === 9)) for (let e = [].slice.call(document.querySelectorAll(Ut)), n = 0, i = e.length; n < i; n++) { const o = c._getParentFromElement(e[n]); const r = g(e[n]).data(Dt); const s = { relatedTarget: e[n] }; if (t && t.type === 'click' && (s.clickEvent = t), r) { const a = r._menu; if (g(o).hasClass(Lt) && !(t && (t.type === 'click' && /input|textarea/i.test(t.target.tagName) || t.type === 'keyup' && t.which === 9) && g.contains(o, t.target))) { const l = g.Event(kt.HIDE, s); g(o).trigger(l), l.isDefaultPrevented() || ('ontouchstart' in document.documentElement && g(document.body).children().off('mouseover', null, g.noop), e[n].setAttribute('aria-expanded', 'false'), g(a).removeClass(Lt), g(o).removeClass(Lt).trigger(g.Event(kt.HIDDEN, s))) } } } }, c._getParentFromElement = function (t) { let e; const n = _.getSelectorFromElement(t); return n && (e = document.querySelector(n)), e || t.parentNode }, c._dataApiKeydownHandler = function (t) { if ((/input|textarea/i.test(t.target.tagName) ? !(t.which === 32 || t.which !== 27 && (t.which !== 40 && t.which !== 38 || g(t.target).closest(qt).length)) : Ot.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !g(this).hasClass(Pt))) { const e = c._getParentFromElement(this); const n = g(e).hasClass(Lt); if (n && (!n || t.which !== 27 && t.which !== 32)) { const i = [].slice.call(e.querySelectorAll(Kt)); if (i.length !== 0) { let o = i.indexOf(t.target); t.which === 38 && o > 0 && o--, t.which === 40 && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus() } } else { if (t.which === 27) { const r = e.querySelector(Ut); g(r).trigger('focus') }g(this).trigger('click') } } }, s(c, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return $t } }, { key: 'DefaultType', get() { return Gt } }]), c }()); g(document).on(kt.KEYDOWN_DATA_API, Ut, Jt._dataApiKeydownHandler).on(kt.KEYDOWN_DATA_API, qt, Jt._dataApiKeydownHandler).on(`${kt.CLICK_DATA_API} ${kt.KEYUP_DATA_API}`, Jt._clearMenus).on(kt.CLICK_DATA_API, Ut, function (t) { t.preventDefault(), t.stopPropagation(), Jt._jQueryInterface.call(g(this), 'toggle') }).on(kt.CLICK_DATA_API, Wt, (t) => { t.stopPropagation() }), g.fn[It] = Jt._jQueryInterface, g.fn[It].Constructor = Jt, g.fn[It].noConflict = function () { return g.fn[It] = Nt, Jt._jQueryInterface }; const Zt = 'modal'; const te = 'bs.modal'; const ee = `.${te}`; const ne = g.fn[Zt]; const ie = { backdrop: !0, keyboard: !0, focus: !0, show: !0 }; const oe = { backdrop: '(boolean|string)', keyboard: 'boolean', focus: 'boolean', show: 'boolean' }; const re = { HIDE: `hide${ee}`, HIDDEN: `hidden${ee}`, SHOW: `show${ee}`, SHOWN: `shown${ee}`, FOCUSIN: `focusin${ee}`, RESIZE: `resize${ee}`, CLICK_DISMISS: `click.dismiss${ee}`, KEYDOWN_DISMISS: `keydown.dismiss${ee}`, MOUSEUP_DISMISS: `mouseup.dismiss${ee}`, MOUSEDOWN_DISMISS: `mousedown.dismiss${ee}`, CLICK_DATA_API: `click${ee}.data-api` }; const se = 'modal-dialog-scrollable'; const ae = 'modal-scrollbar-measure'; const le = 'modal-backdrop'; const ce = 'modal-open'; const he = 'fade'; const ue = 'show'; const fe = '.modal-dialog'; const de = '.modal-body'; const ge = '[data-toggle="modal"]'; const _e = '[data-dismiss="modal"]'; const me = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'; const pe = '.sticky-top'; const ve = (function () { function o(t, e) { this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(fe), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0 } const t = o.prototype; return t.toggle = function (t) { return this._isShown ? this.hide() : this.show(t) }, t.show = function (t) { const e = this; if (!this._isShown && !this._isTransitioning) { g(this._element).hasClass(he) && (this._isTransitioning = !0); const n = g.Event(re.SHOW, { relatedTarget: t }); g(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), g(this._element).on(re.CLICK_DISMISS, _e, (t) => e.hide(t)), g(this._dialog).on(re.MOUSEDOWN_DISMISS, () => { g(e._element).one(re.MOUSEUP_DISMISS, (t) => { g(t.target).is(e._element) && (e._ignoreBackdropClick = !0) }) }), this._showBackdrop(() => e._showElement(t))) } }, t.hide = function (t) { const e = this; if (t && t.preventDefault(), this._isShown && !this._isTransitioning) { const n = g.Event(re.HIDE); if (g(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) { this._isShown = !1; const i = g(this._element).hasClass(he); if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), g(document).off(re.FOCUSIN), g(this._element).removeClass(ue), g(this._element).off(re.CLICK_DISMISS), g(this._dialog).off(re.MOUSEDOWN_DISMISS), i) { const o = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, (t) => e._hideModal(t)).emulateTransitionEnd(o) } else this._hideModal() } } }, t.dispose = function () { [window, this._element, this._dialog].forEach((t) => g(t).off(ee)), g(document).off(re.FOCUSIN), g.removeData(this._element, te), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null }, t.handleUpdate = function () { this._adjustDialog() }, t._getConfig = function (t) { return t = l({}, ie, t), _.typeCheckConfig(Zt, t, oe), t }, t._showElement = function (t) { const e = this; const n = g(this._element).hasClass(he); this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = 'block', this._element.removeAttribute('aria-hidden'), this._element.setAttribute('aria-modal', !0), g(this._dialog).hasClass(se) ? this._dialog.querySelector(de).scrollTop = 0 : this._element.scrollTop = 0, n && _.reflow(this._element), g(this._element).addClass(ue), this._config.focus && this._enforceFocus(); const i = g.Event(re.SHOWN, { relatedTarget: t }); const o = function () { e._config.focus && e._element.focus(), e._isTransitioning = !1, g(e._element).trigger(i) }; if (n) { const r = _.getTransitionDurationFromElement(this._dialog); g(this._dialog).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o() }, t._enforceFocus = function () { const e = this; g(document).off(re.FOCUSIN).on(re.FOCUSIN, (t) => { document !== t.target && e._element !== t.target && g(e._element).has(t.target).length === 0 && e._element.focus() }) }, t._setEscapeEvent = function () { const e = this; this._isShown && this._config.keyboard ? g(this._element).on(re.KEYDOWN_DISMISS, (t) => { t.which === 27 && (t.preventDefault(), e.hide()) }) : this._isShown || g(this._element).off(re.KEYDOWN_DISMISS) }, t._setResizeEvent = function () { const e = this; this._isShown ? g(window).on(re.RESIZE, (t) => e.handleUpdate(t)) : g(window).off(re.RESIZE) }, t._hideModal = function () { const t = this; this._element.style.display = 'none', this._element.setAttribute('aria-hidden', !0), this._element.removeAttribute('aria-modal'), this._isTransitioning = !1, this._showBackdrop(() => { g(document.body).removeClass(ce), t._resetAdjustments(), t._resetScrollbar(), g(t._element).trigger(re.HIDDEN) }) }, t._removeBackdrop = function () { this._backdrop && (g(this._backdrop).remove(), this._backdrop = null) }, t._showBackdrop = function (t) { const e = this; const n = g(this._element).hasClass(he) ? he : ''; if (this._isShown && this._config.backdrop) { if (this._backdrop = document.createElement('div'), this._backdrop.className = le, n && this._backdrop.classList.add(n), g(this._backdrop).appendTo(document.body), g(this._element).on(re.CLICK_DISMISS, (t) => { e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && (e._config.backdrop === 'static' ? e._element.focus() : e.hide()) }), n && _.reflow(this._backdrop), g(this._backdrop).addClass(ue), !t) return; if (!n) return void t(); const i = _.getTransitionDurationFromElement(this._backdrop); g(this._backdrop).one(_.TRANSITION_END, t).emulateTransitionEnd(i) } else if (!this._isShown && this._backdrop) { g(this._backdrop).removeClass(ue); const o = function () { e._removeBackdrop(), t && t() }; if (g(this._element).hasClass(he)) { const r = _.getTransitionDurationFromElement(this._backdrop); g(this._backdrop).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o() } else t && t() }, t._adjustDialog = function () { const t = this._element.scrollHeight > document.documentElement.clientHeight; !this._isBodyOverflowing && t && (this._element.style.paddingLeft = `${this._scrollbarWidth}px`), this._isBodyOverflowing && !t && (this._element.style.paddingRight = `${this._scrollbarWidth}px`) }, t._resetAdjustments = function () { this._element.style.paddingLeft = '', this._element.style.paddingRight = '' }, t._checkScrollbar = function () { const t = document.body.getBoundingClientRect(); this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth() }, t._setScrollbar = function () { const o = this; if (this._isBodyOverflowing) { const t = [].slice.call(document.querySelectorAll(me)); const e = [].slice.call(document.querySelectorAll(pe)); g(t).each((t, e) => { const n = e.style.paddingRight; const i = g(e).css('padding-right'); g(e).data('padding-right', n).css('padding-right', `${parseFloat(i) + o._scrollbarWidth}px`) }), g(e).each((t, e) => { const n = e.style.marginRight; const i = g(e).css('margin-right'); g(e).data('margin-right', n).css('margin-right', `${parseFloat(i) - o._scrollbarWidth}px`) }); const n = document.body.style.paddingRight; const i = g(document.body).css('padding-right'); g(document.body).data('padding-right', n).css('padding-right', `${parseFloat(i) + this._scrollbarWidth}px`) }g(document.body).addClass(ce) }, t._resetScrollbar = function () { const t = [].slice.call(document.querySelectorAll(me)); g(t).each((t, e) => { const n = g(e).data('padding-right'); g(e).removeData('padding-right'), e.style.paddingRight = n || '' }); const e = [].slice.call(document.querySelectorAll(`${pe}`)); g(e).each((t, e) => { const n = g(e).data('margin-right'); typeof n !== 'undefined' && g(e).css('margin-right', n).removeData('margin-right') }); const n = g(document.body).data('padding-right'); g(document.body).removeData('padding-right'), document.body.style.paddingRight = n || '' }, t._getScrollbarWidth = function () { const t = document.createElement('div'); t.className = ae, document.body.appendChild(t); const e = t.getBoundingClientRect().width - t.clientWidth; return document.body.removeChild(t), e }, o._jQueryInterface = function (n, i) { return this.each(function () { let t = g(this).data(te); const e = l({}, ie, g(this).data(), typeof n === 'object' && n ? n : {}); if (t || (t = new o(this, e), g(this).data(te, t)), typeof n === 'string') { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n](i) } else e.show && t.show(i) }) }, s(o, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return ie } }]), o }()); g(document).on(re.CLICK_DATA_API, ge, function (t) { let e; const n = this; const i = _.getSelectorFromElement(this); i && (e = document.querySelector(i)); const o = g(e).data(te) ? 'toggle' : l({}, g(e).data(), g(this).data()); this.tagName !== 'A' && this.tagName !== 'AREA' || t.preventDefault(); var r = g(e).one(re.SHOW, (t) => { t.isDefaultPrevented() || r.one(re.HIDDEN, () => { g(n).is(':visible') && n.focus() }) }); ve._jQueryInterface.call(g(e), o, this) }), g.fn[Zt] = ve._jQueryInterface, g.fn[Zt].Constructor = ve, g.fn[Zt].noConflict = function () { return g.fn[Zt] = ne, ve._jQueryInterface }; const ye = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']; const Ee = { '*': ['class', 'dir', 'id', 'lang', 'role', /^aria-[\w-]*$/i], a: ['target', 'href', 'title', 'rel'], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ['src', 'alt', 'title', 'width', 'height'], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; const Ce = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi; const Te = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i; function Se(t, s, e) { if (t.length === 0) return t; if (e && typeof e === 'function') return e(t); for (var n = (new window.DOMParser()).parseFromString(t, 'text/html'), a = Object.keys(s), l = [].slice.call(n.body.querySelectorAll('*')), i = function (t, e) { const n = l[t]; const i = n.nodeName.toLowerCase(); if (a.indexOf(n.nodeName.toLowerCase()) === -1) return n.parentNode.removeChild(n), 'continue'; const o = [].slice.call(n.attributes); const r = [].concat(s['*'] || [], s[i] || []); o.forEach((t) => { (function (t, e) { const n = t.nodeName.toLowerCase(); if (e.indexOf(n) !== -1) return ye.indexOf(n) === -1 || Boolean(t.nodeValue.match(Ce) || t.nodeValue.match(Te)); for (let i = e.filter((t) => t instanceof RegExp), o = 0, r = i.length; o < r; o++) if (n.match(i[o])) return !0; return !1 })(t, r) || n.removeAttribute(t.nodeName) }) }, o = 0, r = l.length; o < r; o++)i(o); return n.body.innerHTML } const be = 'tooltip'; const Ie = 'bs.tooltip'; const De = `.${Ie}`; const we = g.fn[be]; const Ae = 'bs-tooltip'; const Ne = new RegExp(`(^|\\s)${Ae}\\S+`, 'g'); const Oe = ['sanitize', 'whiteList', 'sanitizeFn']; const ke = { animation: 'boolean', template: 'string', title: '(string|element|function)', trigger: 'string', delay: '(number|object)', html: 'boolean', selector: '(string|boolean)', placement: '(string|function)', offset: '(number|string|function)', container: '(string|element|boolean)', fallbackPlacement: '(string|array)', boundary: '(string|element)', sanitize: 'boolean', sanitizeFn: '(null|function)', whiteList: 'object' }; const Pe = { AUTO: 'auto', TOP: 'top', RIGHT: 'right', BOTTOM: 'bottom', LEFT: 'left' }; const Le = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, selector: !1, placement: 'top', offset: 0, container: !1, fallbackPlacement: 'flip', boundary: 'scrollParent', sanitize: !0, sanitizeFn: null, whiteList: Ee }; const je = 'show'; const He = 'out'; const Re = { HIDE: `hide${De}`, HIDDEN: `hidden${De}`, SHOW: `show${De}`, SHOWN: `shown${De}`, INSERTED: `inserted${De}`, CLICK: `click${De}`, FOCUSIN: `focusin${De}`, FOCUSOUT: `focusout${De}`, MOUSEENTER: `mouseenter${De}`, MOUSELEAVE: `mouseleave${De}` }; const xe = 'fade'; const Fe = 'show'; const Ue = '.tooltip-inner'; const We = '.arrow'; const qe = 'hover'; const Me = 'focus'; const Ke = 'click'; const Qe = 'manual'; const Be = (function () { function i(t, e) { if (typeof u === 'undefined') throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)"); this._isEnabled = !0, this._timeout = 0, this._hoverState = '', this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners() } const t = i.prototype; return t.enable = function () { this._isEnabled = !0 }, t.disable = function () { this._isEnabled = !1 }, t.toggleEnabled = function () { this._isEnabled = !this._isEnabled }, t.toggle = function (t) { if (this._isEnabled) if (t) { const e = this.constructor.DATA_KEY; let n = g(t.currentTarget).data(e); n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n) } else { if (g(this.getTipElement()).hasClass(Fe)) return void this._leave(null, this); this._enter(null, this) } }, t.dispose = function () { clearTimeout(this._timeout), g.removeData(this.element, this.constructor.DATA_KEY), g(this.element).off(this.constructor.EVENT_KEY), g(this.element).closest('.modal').off('hide.bs.modal'), this.tip && g(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null }, t.show = function () { const e = this; if (g(this.element).css('display') === 'none') throw new Error('Please use show on visible elements'); const t = g.Event(this.constructor.Event.SHOW); if (this.isWithContent() && this._isEnabled) { g(this.element).trigger(t); const n = _.findShadowRoot(this.element); const i = g.contains(n !== null ? n : this.element.ownerDocument.documentElement, this.element); if (t.isDefaultPrevented() || !i) return; const o = this.getTipElement(); const r = _.getUID(this.constructor.NAME); o.setAttribute('id', r), this.element.setAttribute('aria-describedby', r), this.setContent(), this.config.animation && g(o).addClass(xe); const s = typeof this.config.placement === 'function' ? this.config.placement.call(this, o, this.element) : this.config.placement; const a = this._getAttachment(s); this.addAttachmentClass(a); const l = this._getContainer(); g(o).data(this.constructor.DATA_KEY, this), g.contains(this.element.ownerDocument.documentElement, this.tip) || g(o).appendTo(l), g(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new u(this.element, o, { placement: a, modifiers: { offset: this._getOffset(), flip: { behavior: this.config.fallbackPlacement }, arrow: { element: We }, preventOverflow: { boundariesElement: this.config.boundary } }, onCreate(t) { t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t) }, onUpdate(t) { return e._handlePopperPlacementChange(t) } }), g(o).addClass(Fe), 'ontouchstart' in document.documentElement && g(document.body).children().on('mouseover', null, g.noop); const c = function () { e.config.animation && e._fixTransition(); const t = e._hoverState; e._hoverState = null, g(e.element).trigger(e.constructor.Event.SHOWN), t === He && e._leave(null, e) }; if (g(this.tip).hasClass(xe)) { const h = _.getTransitionDurationFromElement(this.tip); g(this.tip).one(_.TRANSITION_END, c).emulateTransitionEnd(h) } else c() } }, t.hide = function (t) { const e = this; const n = this.getTipElement(); const i = g.Event(this.constructor.Event.HIDE); const o = function () { e._hoverState !== je && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute('aria-describedby'), g(e.element).trigger(e.constructor.Event.HIDDEN), e._popper !== null && e._popper.destroy(), t && t() }; if (g(this.element).trigger(i), !i.isDefaultPrevented()) { if (g(n).removeClass(Fe), 'ontouchstart' in document.documentElement && g(document.body).children().off('mouseover', null, g.noop), this._activeTrigger[Ke] = !1, this._activeTrigger[Me] = !1, this._activeTrigger[qe] = !1, g(this.tip).hasClass(xe)) { const r = _.getTransitionDurationFromElement(n); g(n).one(_.TRANSITION_END, o).emulateTransitionEnd(r) } else o(); this._hoverState = '' } }, t.update = function () { this._popper !== null && this._popper.scheduleUpdate() }, t.isWithContent = function () { return Boolean(this.getTitle()) }, t.addAttachmentClass = function (t) { g(this.getTipElement()).addClass(`${Ae}-${t}`) }, t.getTipElement = function () { return this.tip = this.tip || g(this.config.template)[0], this.tip }, t.setContent = function () { const t = this.getTipElement(); this.setElementContent(g(t.querySelectorAll(Ue)), this.getTitle()), g(t).removeClass(`${xe} ${Fe}`) }, t.setElementContent = function (t, e) { typeof e !== 'object' || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = Se(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? g(e).parent().is(t) || t.empty().append(e) : t.text(g(e).text()) }, t.getTitle = function () { let t = this.element.getAttribute('data-original-title'); return t || (t = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title), t }, t._getOffset = function () { const e = this; const t = {}; return typeof this.config.offset === 'function' ? t.fn = function (t) { return t.offsets = l({}, t.offsets, e.config.offset(t.offsets, e.element) || {}), t } : t.offset = this.config.offset, t }, t._getContainer = function () { return !1 === this.config.container ? document.body : _.isElement(this.config.container) ? g(this.config.container) : g(document).find(this.config.container) }, t._getAttachment = function (t) { return Pe[t.toUpperCase()] }, t._setListeners = function () { const i = this; this.config.trigger.split(' ').forEach((t) => { if (t === 'click')g(i.element).on(i.constructor.Event.CLICK, i.config.selector, (t) => i.toggle(t)); else if (t !== Qe) { const e = t === qe ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN; const n = t === qe ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT; g(i.element).on(e, i.config.selector, (t) => i._enter(t)).on(n, i.config.selector, (t) => i._leave(t)) } }), g(this.element).closest('.modal').on('hide.bs.modal', () => { i.element && i.hide() }), this.config.selector ? this.config = l({}, this.config, { trigger: 'manual', selector: '' }) : this._fixTitle() }, t._fixTitle = function () { const t = typeof this.element.getAttribute('data-original-title'); (this.element.getAttribute('title') || t !== 'string') && (this.element.setAttribute('data-original-title', this.element.getAttribute('title') || ''), this.element.setAttribute('title', '')) }, t._enter = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusin' ? Me : qe] = !0), g(e.getTipElement()).hasClass(Fe) || e._hoverState === je ? e._hoverState = je : (clearTimeout(e._timeout), e._hoverState = je, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(() => { e._hoverState === je && e.show() }, e.config.delay.show) : e.show()) }, t._leave = function (t, e) { const n = this.constructor.DATA_KEY; (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger[t.type === 'focusout' ? Me : qe] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = He, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(() => { e._hoverState === He && e.hide() }, e.config.delay.hide) : e.hide()) }, t._isWithActiveTrigger = function () { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1 }, t._getConfig = function (t) { const e = g(this.element).data(); return Object.keys(e).forEach((t) => { Oe.indexOf(t) !== -1 && delete e[t] }), typeof (t = l({}, this.constructor.Default, e, typeof t === 'object' && t ? t : {})).delay === 'number' && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title === 'number' && (t.title = t.title.toString()), typeof t.content === 'number' && (t.content = t.content.toString()), _.typeCheckConfig(be, t, this.constructor.DefaultType), t.sanitize && (t.template = Se(t.template, t.whiteList, t.sanitizeFn)), t }, t._getDelegateConfig = function () { const t = {}; if (this.config) for (const e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]); return t }, t._cleanTipClass = function () { const t = g(this.getTipElement()); const e = t.attr('class').match(Ne); e !== null && e.length && t.removeClass(e.join('')) }, t._handlePopperPlacementChange = function (t) { const e = t.instance; this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement)) }, t._fixTransition = function () { const t = this.getTipElement(); const e = this.config.animation; t.getAttribute('x-placement') === null && (g(t).removeClass(xe), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e) }, i._jQueryInterface = function (n) { return this.each(function () { let t = g(this).data(Ie); const e = typeof n === 'object' && n; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ie, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return Le } }, { key: 'NAME', get() { return be } }, { key: 'DATA_KEY', get() { return Ie } }, { key: 'Event', get() { return Re } }, { key: 'EVENT_KEY', get() { return De } }, { key: 'DefaultType', get() { return ke } }]), i }()); g.fn[be] = Be._jQueryInterface, g.fn[be].Constructor = Be, g.fn[be].noConflict = function () { return g.fn[be] = we, Be._jQueryInterface }; const Ve = 'popover'; const Ye = 'bs.popover'; const ze = `.${Ye}`; const Xe = g.fn[Ve]; const $e = 'bs-popover'; const Ge = new RegExp(`(^|\\s)${$e}\\S+`, 'g'); const Je = l({}, Be.Default, { placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }); const Ze = l({}, Be.DefaultType, { content: '(string|element|function)' }); const tn = 'fade'; const en = 'show'; const nn = '.popover-header'; const on = '.popover-body'; const rn = { HIDE: `hide${ze}`, HIDDEN: `hidden${ze}`, SHOW: `show${ze}`, SHOWN: `shown${ze}`, INSERTED: `inserted${ze}`, CLICK: `click${ze}`, FOCUSIN: `focusin${ze}`, FOCUSOUT: `focusout${ze}`, MOUSEENTER: `mouseenter${ze}`, MOUSELEAVE: `mouseleave${ze}` }; const sn = (function (t) { let e, n; function i() { return t.apply(this, arguments) || this }n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n; const o = i.prototype; return o.isWithContent = function () { return this.getTitle() || this._getContent() }, o.addAttachmentClass = function (t) { g(this.getTipElement()).addClass(`${$e}-${t}`) }, o.getTipElement = function () { return this.tip = this.tip || g(this.config.template)[0], this.tip }, o.setContent = function () { const t = g(this.getTipElement()); this.setElementContent(t.find(nn), this.getTitle()); let e = this._getContent(); typeof e === 'function' && (e = e.call(this.element)), this.setElementContent(t.find(on), e), t.removeClass(`${tn} ${en}`) }, o._getContent = function () { return this.element.getAttribute('data-content') || this.config.content }, o._cleanTipClass = function () { const t = g(this.getTipElement()); const e = t.attr('class').match(Ge); e !== null && e.length > 0 && t.removeClass(e.join('')) }, i._jQueryInterface = function (n) { return this.each(function () { let t = g(this).data(Ye); const e = typeof n === 'object' ? n : null; if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ye, t)), typeof n === 'string')) { if (typeof t[n] === 'undefined') throw new TypeError(`No method named "${n}"`); t[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return Je } }, { key: 'NAME', get() { return Ve } }, { key: 'DATA_KEY', get() { return Ye } }, { key: 'Event', get() { return rn } }, { key: 'EVENT_KEY', get() { return ze } }, { key: 'DefaultType', get() { return Ze } }]), i }(Be)); g.fn[Ve] = sn._jQueryInterface, g.fn[Ve].Constructor = sn, g.fn[Ve].noConflict = function () { return g.fn[Ve] = Xe, sn._jQueryInterface }; const an = 'scrollspy'; const ln = 'bs.scrollspy'; const cn = `.${ln}`; const hn = g.fn[an]; const un = { offset: 10, method: 'auto', target: '' }; const fn = { offset: 'number', method: 'string', target: '(string|element)' }; const dn = { ACTIVATE: `activate${cn}`, SCROLL: `scroll${cn}`, LOAD_DATA_API: `load${cn}.data-api` }; const gn = 'dropdown-item'; const _n = 'active'; const mn = '[data-spy="scroll"]'; const pn = '.nav, .list-group'; const vn = '.nav-link'; const yn = '.nav-item'; const En = '.list-group-item'; const Cn = '.dropdown'; const Tn = '.dropdown-item'; const Sn = '.dropdown-toggle'; const bn = 'offset'; const In = 'position'; const Dn = (function () { function n(t, e) { const n = this; this._element = t, this._scrollElement = t.tagName === 'BODY' ? window : t, this._config = this._getConfig(e), this._selector = `${this._config.target} ${vn},${this._config.target} ${En},${this._config.target} ${Tn}`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, g(this._scrollElement).on(dn.SCROLL, (t) => n._process(t)), this.refresh(), this._process() } const t = n.prototype; return t.refresh = function () { const e = this; const t = this._scrollElement === this._scrollElement.window ? bn : In; const o = this._config.method === 'auto' ? t : this._config.method; const r = o === In ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map((t) => { let e; const n = _.getSelectorFromElement(t); if (n && (e = document.querySelector(n)), e) { const i = e.getBoundingClientRect(); if (i.width || i.height) return [g(e)[o]().top + r, n] } return null }).filter((t) => t).sort((t, e) => t[0] - e[0]).forEach((t) => { e._offsets.push(t[0]), e._targets.push(t[1]) }) }, t.dispose = function () { g.removeData(this._element, ln), g(this._scrollElement).off(cn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null }, t._getConfig = function (t) { if (typeof (t = l({}, un, typeof t === 'object' && t ? t : {})).target !== 'string') { let e = g(t.target).attr('id'); e || (e = _.getUID(an), g(t.target).attr('id', e)), t.target = `#${e}` } return _.typeCheckConfig(an, t, fn), t }, t._getScrollTop = function () { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop }, t._getScrollHeight = function () { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) }, t._getOffsetHeight = function () { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height }, t._process = function () { const t = this._getScrollTop() + this._config.offset; const e = this._getScrollHeight(); const n = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), n <= t) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i) } else { if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear(); for (let o = this._offsets.length; o--;) { this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (typeof this._offsets[o + 1] === 'undefined' || t < this._offsets[o + 1]) && this._activate(this._targets[o]) } } }, t._activate = function (e) { this._activeTarget = e, this._clear(); const t = this._selector.split(',').map((t) => `${t}[data-target="${e}"],${t}[href="${e}"]`); const n = g([].slice.call(document.querySelectorAll(t.join(',')))); n.hasClass(gn) ? (n.closest(Cn).find(Sn).addClass(_n), n.addClass(_n)) : (n.addClass(_n), n.parents(pn).prev(`${vn}, ${En}`).addClass(_n), n.parents(pn).prev(yn).children(vn).addClass(_n)), g(this._scrollElement).trigger(dn.ACTIVATE, { relatedTarget: e }) }, t._clear = function () { [].slice.call(document.querySelectorAll(this._selector)).filter((t) => t.classList.contains(_n)).forEach((t) => t.classList.remove(_n)) }, n._jQueryInterface = function (e) { return this.each(function () { let t = g(this).data(ln); if (t || (t = new n(this, typeof e === 'object' && e), g(this).data(ln, t)), typeof e === 'string') { if (typeof t[e] === 'undefined') throw new TypeError(`No method named "${e}"`); t[e]() } }) }, s(n, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'Default', get() { return un } }]), n }()); g(window).on(dn.LOAD_DATA_API, () => { for (let t = [].slice.call(document.querySelectorAll(mn)), e = t.length; e--;) { const n = g(t[e]); Dn._jQueryInterface.call(n, n.data()) } }), g.fn[an] = Dn._jQueryInterface, g.fn[an].Constructor = Dn, g.fn[an].noConflict = function () { return g.fn[an] = hn, Dn._jQueryInterface }; const wn = 'bs.tab'; const An = `.${wn}`; const Nn = g.fn.tab; const On = { HIDE: `hide${An}`, HIDDEN: `hidden${An}`, SHOW: `show${An}`, SHOWN: `shown${An}`, CLICK_DATA_API: `click${An}.data-api` }; const kn = 'dropdown-menu'; const Pn = 'active'; const Ln = 'disabled'; const jn = 'fade'; const Hn = 'show'; const Rn = '.dropdown'; const xn = '.nav, .list-group'; const Fn = '.active'; const Un = '> li > .active'; const Wn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]'; const qn = '.dropdown-toggle'; const Mn = '> .dropdown-menu .active'; const Kn = (function () { function i(t) { this._element = t } const t = i.prototype; return t.show = function () { const n = this; if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && g(this._element).hasClass(Pn) || g(this._element).hasClass(Ln))) { let t; let i; const e = g(this._element).closest(xn)[0]; const o = _.getSelectorFromElement(this._element); if (e) { const r = e.nodeName === 'UL' || e.nodeName === 'OL' ? Un : Fn; i = (i = g.makeArray(g(e).find(r)))[i.length - 1] } const s = g.Event(On.HIDE, { relatedTarget: this._element }); const a = g.Event(On.SHOW, { relatedTarget: i }); if (i && g(i).trigger(s), g(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) { o && (t = document.querySelector(o)), this._activate(this._element, e); const l = function () { const t = g.Event(On.HIDDEN, { relatedTarget: n._element }); const e = g.Event(On.SHOWN, { relatedTarget: i }); g(i).trigger(t), g(n._element).trigger(e) }; t ? this._activate(t, t.parentNode, l) : l() } } }, t.dispose = function () { g.removeData(this._element, wn), this._element = null }, t._activate = function (t, e, n) { const i = this; const o = (!e || e.nodeName !== 'UL' && e.nodeName !== 'OL' ? g(e).children(Fn) : g(e).find(Un))[0]; const r = n && o && g(o).hasClass(jn); const s = function () { return i._transitionComplete(t, o, n) }; if (o && r) { const a = _.getTransitionDurationFromElement(o); g(o).removeClass(Hn).one(_.TRANSITION_END, s).emulateTransitionEnd(a) } else s() }, t._transitionComplete = function (t, e, n) { if (e) { g(e).removeClass(Pn); const i = g(e.parentNode).find(Mn)[0]; i && g(i).removeClass(Pn), e.getAttribute('role') === 'tab' && e.setAttribute('aria-selected', !1) } if (g(t).addClass(Pn), t.getAttribute('role') === 'tab' && t.setAttribute('aria-selected', !0), _.reflow(t), t.classList.contains(jn) && t.classList.add(Hn), t.parentNode && g(t.parentNode).hasClass(kn)) { const o = g(t).closest(Rn)[0]; if (o) { const r = [].slice.call(o.querySelectorAll(qn)); g(r).addClass(Pn) }t.setAttribute('aria-expanded', !0) }n && n() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(wn); if (e || (e = new i(this), t.data(wn, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n]() } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }]), i }()); g(document).on(On.CLICK_DATA_API, Wn, function (t) { t.preventDefault(), Kn._jQueryInterface.call(g(this), 'show') }), g.fn.tab = Kn._jQueryInterface, g.fn.tab.Constructor = Kn, g.fn.tab.noConflict = function () { return g.fn.tab = Nn, Kn._jQueryInterface }; const Qn = 'toast'; const Bn = 'bs.toast'; const Vn = `.${Bn}`; const Yn = g.fn[Qn]; const zn = { CLICK_DISMISS: `click.dismiss${Vn}`, HIDE: `hide${Vn}`, HIDDEN: `hidden${Vn}`, SHOW: `show${Vn}`, SHOWN: `shown${Vn}` }; const Xn = 'fade'; const $n = 'hide'; const Gn = 'show'; const Jn = 'showing'; const Zn = { animation: 'boolean', autohide: 'boolean', delay: 'number' }; const ti = { animation: !0, autohide: !0, delay: 500 }; const ei = '[data-dismiss="toast"]'; const ni = (function () { function i(t, e) { this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners() } const t = i.prototype; return t.show = function () { const t = this; g(this._element).trigger(zn.SHOW), this._config.animation && this._element.classList.add(Xn); const e = function () { t._element.classList.remove(Jn), t._element.classList.add(Gn), g(t._element).trigger(zn.SHOWN), t._config.autohide && t.hide() }; if (this._element.classList.remove($n), this._element.classList.add(Jn), this._config.animation) { const n = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n) } else e() }, t.hide = function (t) { const e = this; this._element.classList.contains(Gn) && (g(this._element).trigger(zn.HIDE), t ? this._close() : this._timeout = setTimeout(() => { e._close() }, this._config.delay)) }, t.dispose = function () { clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Gn) && this._element.classList.remove(Gn), g(this._element).off(zn.CLICK_DISMISS), g.removeData(this._element, Bn), this._element = null, this._config = null }, t._getConfig = function (t) { return t = l({}, ti, g(this._element).data(), typeof t === 'object' && t ? t : {}), _.typeCheckConfig(Qn, t, this.constructor.DefaultType), t }, t._setListeners = function () { const t = this; g(this._element).on(zn.CLICK_DISMISS, ei, () => t.hide(!0)) }, t._close = function () { const t = this; const e = function () { t._element.classList.add($n), g(t._element).trigger(zn.HIDDEN) }; if (this._element.classList.remove(Gn), this._config.animation) { const n = _.getTransitionDurationFromElement(this._element); g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n) } else e() }, i._jQueryInterface = function (n) { return this.each(function () { const t = g(this); let e = t.data(Bn); if (e || (e = new i(this, typeof n === 'object' && n), t.data(Bn, e)), typeof n === 'string') { if (typeof e[n] === 'undefined') throw new TypeError(`No method named "${n}"`); e[n](this) } }) }, s(i, null, [{ key: 'VERSION', get() { return '4.3.1' } }, { key: 'DefaultType', get() { return Zn } }, { key: 'Default', get() { return ti } }]), i }()); g.fn[Qn] = ni._jQueryInterface, g.fn[Qn].Constructor = ni, g.fn[Qn].noConflict = function () { return g.fn[Qn] = Yn, ni._jQueryInterface }, (function () { if (typeof g === 'undefined') throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript."); const t = g.fn.jquery.split(' ')[0].split('.'); if (t[0] < 2 && t[1] < 9 || t[0] === 1 && t[1] === 9 && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0") }()), t.Util = _, t.Alert = p, t.Button = P, t.Carousel = lt, t.Collapse = bt, t.Dropdown = Jt, t.Modal = ve, t.Popover = sn, t.Scrollspy = Dn, t.Tab = Kn, t.Toast = ni, t.Tooltip = Be, Object.defineProperty(t, '__esModule', { value: !0 })
}))

/*! jQuery Validation Plugin - v1.17.0 - 7/29/2017
 * https://jqueryvalidation.org/
 * Copyright (c) 2017 Jörn Zaefferer; Licensed MIT */
!(function (a) { typeof define === 'function' && define.amd ? define(['jquery'], a) : typeof module === 'object' && module.exports ? module.exports = a(require('jquery')) : a(jQuery) }((a) => { a.extend(a.fn, { validate(b) { if (!this.length) return void (b && b.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")); let c = a.data(this[0], 'validator'); return c || (this.attr('novalidate', 'novalidate'), c = new a.validator(b, this[0]), a.data(this[0], 'validator', c), c.settings.onsubmit && (this.on('click.validate', ':submit', function (b) { c.submitButton = b.currentTarget, a(this).hasClass('cancel') && (c.cancelSubmit = !0), void 0 !== a(this).attr('formnovalidate') && (c.cancelSubmit = !0) }), this.on('submit.validate', (b) => { function d() { let d, e; return c.submitButton && (c.settings.submitHandler || c.formSubmitted) && (d = a("<input type='hidden'/>").attr('name', c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)), !c.settings.submitHandler || (e = c.settings.submitHandler.call(c, c.currentForm, b), d && d.remove(), void 0 !== e && e) } return c.settings.debug && b.preventDefault(), c.cancelSubmit ? (c.cancelSubmit = !1, d()) : c.form() ? c.pendingRequest ? (c.formSubmitted = !0, !1) : d() : (c.focusInvalid(), !1) })), c) }, valid() { let b, c, d; return a(this[0]).is('form') ? b = this.validate().form() : (d = [], b = !0, c = a(this[0].form).validate(), this.each(function () { b = c.element(this) && b, b || (d = d.concat(c.errorList)) }), c.errorList = d), b }, rules(b, c) { let d; let e; let f; let g; let h; let i; const j = this[0]; if (j != null && (!j.form && j.hasAttribute('contenteditable') && (j.form = this.closest('form')[0], j.name = this.attr('name')), j.form != null)) { if (b) switch (d = a.data(j.form, 'validator').settings, e = d.rules, f = a.validator.staticRules(j), b) { case 'add':a.extend(f, a.validator.normalizeRule(c)), delete f.messages, e[j.name] = f, c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages)); break; case 'remove':return c ? (i = {}, a.each(c.split(/\s/), (a, b) => { i[b] = f[b], delete f[b] }), i) : (delete e[j.name], f) } return g = a.validator.normalizeRules(a.extend({}, a.validator.classRules(j), a.validator.attributeRules(j), a.validator.dataRules(j), a.validator.staticRules(j)), j), g.required && (h = g.required, delete g.required, g = a.extend({ required: h }, g)), g.remote && (h = g.remote, delete g.remote, g = a.extend(g, { remote: h })), g } } }), a.extend(a.expr.pseudos || a.expr[':'], { blank(b) { return !a.trim(`${a(b).val()}`) }, filled(b) { const c = a(b).val(); return c !== null && !!a.trim(`${c}`) }, unchecked(b) { return !a(b).prop('checked') } }), a.validator = function (b, c) { this.settings = a.extend(!0, {}, a.validator.defaults, b), this.currentForm = c, this.init() }, a.validator.format = function (b, c) { return arguments.length === 1 ? function () { const c = a.makeArray(arguments); return c.unshift(b), a.validator.format.apply(this, c) } : void 0 === c ? b : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)), c.constructor !== Array && (c = [c]), a.each(c, (a, c) => { b = b.replace(new RegExp(`\\{${a}\\}`, 'g'), () => c) }), b) }, a.extend(a.validator, { defaults: { messages: {}, groups: {}, rules: {}, errorClass: 'error', pendingClass: 'pending', validClass: 'valid', errorElement: 'label', focusCleanup: !1, focusInvalid: !0, errorContainer: a([]), errorLabelContainer: a([]), onsubmit: !0, ignore: ':hidden', ignoreTitle: !1, onfocusin(a) { this.lastActive = a, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(a))) }, onfocusout(a) { this.checkable(a) || !(a.name in this.submitted) && this.optional(a) || this.element(a) }, onkeyup(b, c) { const d = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225]; c.which === 9 && this.elementValue(b) === '' || a.inArray(c.keyCode, d) !== -1 || (b.name in this.submitted || b.name in this.invalid) && this.element(b) }, onclick(a) { a.name in this.submitted ? this.element(a) : a.parentNode.name in this.submitted && this.element(a.parentNode) }, highlight(b, c, d) { b.type === 'radio' ? this.findByName(b.name).addClass(c).removeClass(d) : a(b).addClass(c).removeClass(d) }, unhighlight(b, c, d) { b.type === 'radio' ? this.findByName(b.name).removeClass(c).addClass(d) : a(b).removeClass(c).addClass(d) } }, setDefaults(b) { a.extend(a.validator.defaults, b) }, messages: { required: 'This field is required.', remote: 'Please fix this field.', email: 'Please enter a valid email address.', url: 'Please enter a valid URL.', date: 'Please enter a valid date.', dateISO: 'Please enter a valid date (ISO).', number: 'Please enter a valid number.', digits: 'Please enter only digits.', equalTo: 'Please enter the same value again.', maxlength: a.validator.format('Please enter no more than {0} characters.'), minlength: a.validator.format('Please enter at least {0} characters.'), rangelength: a.validator.format('Please enter a value between {0} and {1} characters long.'), range: a.validator.format('Please enter a value between {0} and {1}.'), max: a.validator.format('Please enter a value less than or equal to {0}.'), min: a.validator.format('Please enter a value greater than or equal to {0}.'), step: a.validator.format('Please enter a multiple of {0}.') }, autoCreateRanges: !1, prototype: { init() { function b(b) { !this.form && this.hasAttribute('contenteditable') && (this.form = a(this).closest('form')[0], this.name = a(this).attr('name')); const c = a.data(this.form, 'validator'); const d = `on${b.type.replace(/^validate/, '')}`; const e = c.settings; e[d] && !a(this).is(e.ignore) && e[d].call(c, this, b) } this.labelContainer = a(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || a(this.currentForm), this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset(); let c; const d = this.groups = {}; a.each(this.settings.groups, (b, c) => { typeof c === 'string' && (c = c.split(/\s/)), a.each(c, (a, c) => { d[c] = b }) }), c = this.settings.rules, a.each(c, (b, d) => { c[b] = a.validator.normalizeRule(d) }), a(this.currentForm).on('focusin.validate focusout.validate keyup.validate', ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", b).on('click.validate', "select, option, [type='radio'], [type='checkbox']", b), this.settings.invalidHandler && a(this.currentForm).on('invalid-form.validate', this.settings.invalidHandler) }, form() { return this.checkForm(), a.extend(this.submitted, this.errorMap), this.invalid = a.extend({}, this.errorMap), this.valid() || a(this.currentForm).triggerHandler('invalid-form', [this]), this.showErrors(), this.valid() }, checkForm() { this.prepareForm(); for (let a = 0, b = this.currentElements = this.elements(); b[a]; a++) this.check(b[a]); return this.valid() }, element(b) { let c; let d; let e = this.clean(b); const f = this.validationTargetFor(e); const g = this; let h = !0; return void 0 === f ? delete this.invalid[e.name] : (this.prepareElement(f), this.currentElements = a(f), d = this.groups[f.name], d && a.each(this.groups, (a, b) => { b === d && a !== f.name && (e = g.validationTargetFor(g.clean(g.findByName(a))), e && e.name in g.invalid && (g.currentElements.push(e), h = g.check(e) && h)) }), c = this.check(f) !== !1, h = h && c, c ? this.invalid[f.name] = !1 : this.invalid[f.name] = !0, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), a(b).attr('aria-invalid', !c)), h }, showErrors(b) { if (b) { const c = this; a.extend(this.errorMap, b), this.errorList = a.map(this.errorMap, (a, b) => ({ message: a, element: c.findByName(b)[0] })), this.successList = a.grep(this.successList, (a) => !(a.name in b)) } this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors() }, resetForm() { a.fn.resetForm && a(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors(); const b = this.elements().removeData('previousValue').removeAttr('aria-invalid'); this.resetElements(b) }, resetElements(a) { let b; if (this.settings.unhighlight) for (b = 0; a[b]; b++) this.settings.unhighlight.call(this, a[b], this.settings.errorClass, ''), this.findByName(a[b].name).removeClass(this.settings.validClass); else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass) }, numberOfInvalids() { return this.objectLength(this.invalid) }, objectLength(a) { let b; let c = 0; for (b in a) void 0 !== a[b] && a[b] !== null && a[b] !== !1 && c++; return c }, hideErrors() { this.hideThese(this.toHide) }, hideThese(a) { a.not(this.containers).text(''), this.addWrapper(a).hide() }, valid() { return this.size() === 0 }, size() { return this.errorList.length }, focusInvalid() { if (this.settings.focusInvalid) try { a(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(':visible').focus().trigger('focusin') } catch (b) {} }, findLastActive() { const b = this.lastActive; return b && a.grep(this.errorList, (a) => a.element.name === b.name).length === 1 && b }, elements() { const b = this; const c = {}; return a(this.currentForm).find('input, select, textarea, [contenteditable]').not(':submit, :reset, :image, :disabled').not(this.settings.ignore).filter(function () { const d = this.name || a(this).attr('name'); return !d && b.settings.debug && window.console && console.error('%o has no name assigned', this), this.hasAttribute('contenteditable') && (this.form = a(this).closest('form')[0], this.name = d), !(d in c || !b.objectLength(a(this).rules())) && (c[d] = !0, !0) }) }, clean(b) { return a(b)[0] }, errors() { const b = this.settings.errorClass.split(' ').join('.'); return a(`${this.settings.errorElement}.${b}`, this.errorContext) }, resetInternals() { this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = a([]), this.toHide = a([]) }, reset() { this.resetInternals(), this.currentElements = a([]) }, prepareForm() { this.reset(), this.toHide = this.errors().add(this.containers) }, prepareElement(a) { this.reset(), this.toHide = this.errorsFor(a) }, elementValue(b) { let c; let d; const e = a(b); const f = b.type; return f === 'radio' || f === 'checkbox' ? this.findByName(b.name).filter(':checked').val() : f === 'number' && typeof b.validity !== 'undefined' ? b.validity.badInput ? 'NaN' : e.val() : (c = b.hasAttribute('contenteditable') ? e.text() : e.val(), f === 'file' ? c.substr(0, 12) === 'C:\\fakepath\\' ? c.substr(12) : (d = c.lastIndexOf('/'), d >= 0 ? c.substr(d + 1) : (d = c.lastIndexOf('\\'), d >= 0 ? c.substr(d + 1) : c)) : typeof c === 'string' ? c.replace(/\r/g, '') : c) }, check(b) { b = this.validationTargetFor(this.clean(b)); let c; let d; let e; let f; const g = a(b).rules(); const h = a.map(g, (a, b) => b).length; let i = !1; let j = this.elementValue(b); if (typeof g.normalizer === 'function' ? f = g.normalizer : typeof this.settings.normalizer === 'function' && (f = this.settings.normalizer), f) { if (j = f.call(b, j), typeof j !== 'string') throw new TypeError('The normalizer should return a string value.'); delete g.normalizer } for (d in g) { e = { method: d, parameters: g[d] }; try { if (c = a.validator.methods[d].call(this, j, b, e.parameters), c === 'dependency-mismatch' && h === 1) { i = !0; continue } if (i = !1, c === 'pending') return void (this.toHide = this.toHide.not(this.errorsFor(b))); if (!c) return this.formatAndAdd(b, e), !1 } catch (k) { throw this.settings.debug && window.console && console.log(`Exception occurred when checking element ${b.id}, check the '${e.method}' method.`, k), k instanceof TypeError && (k.message += `.  Exception occurred when checking element ${b.id}, check the '${e.method}' method.`), k } } if (!i) return this.objectLength(g) && this.successList.push(b), !0 }, customDataMessage(b, c) { return a(b).data(`msg${c.charAt(0).toUpperCase()}${c.substring(1).toLowerCase()}`) || a(b).data('msg') }, customMessage(a, b) { const c = this.settings.messages[a]; return c && (c.constructor === String ? c : c[b]) }, findDefined() { for (let a = 0; a < arguments.length; a++) if (void 0 !== arguments[a]) return arguments[a] }, defaultMessage(b, c) { typeof c === 'string' && (c = { method: c }); let d = this.findDefined(this.customMessage(b.name, c.method), this.customDataMessage(b, c.method), !this.settings.ignoreTitle && b.title || void 0, a.validator.messages[c.method], `<strong>Warning: No message defined for ${b.name}</strong>`); const e = /\$?\{(\d+)\}/g; return typeof d === 'function' ? d = d.call(this, c.parameters, b) : e.test(d) && (d = a.validator.format(d.replace(e, '{$1}'), c.parameters)), d }, formatAndAdd(a, b) { const c = this.defaultMessage(a, b); this.errorList.push({ message: c, element: a, method: b.method }), this.errorMap[a.name] = c, this.submitted[a.name] = c }, addWrapper(a) { return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a }, defaultShowErrors() { let a, b, c; for (a = 0; this.errorList[a]; a++)c = this.errorList[a], this.settings.highlight && this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass), this.showLabel(c.element, c.message); if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (a = 0; this.successList[a]; a++) this.showLabel(this.successList[a]); if (this.settings.unhighlight) for (a = 0, b = this.validElements(); b[a]; a++) this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass); this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show() }, validElements() { return this.currentElements.not(this.invalidElements()) }, invalidElements() { return a(this.errorList).map(function () { return this.element }) }, showLabel(b, c) { let d; let e; let f; let g; let h = this.errorsFor(b); const i = this.idOrName(b); let j = a(b).attr('aria-describedby'); h.length ? (h.removeClass(this.settings.validClass).addClass(this.settings.errorClass), h.html(c)) : (h = a(`<${this.settings.errorElement}>`).attr('id', `${i}-error`).addClass(this.settings.errorClass).html(c || ''), d = h, this.settings.wrapper && (d = h.hide().show().wrap(`<${this.settings.wrapper}/>`).parent()), this.labelContainer.length ? this.labelContainer.append(d) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, d, a(b)) : d.insertAfter(b), h.is('label') ? h.attr('for', i) : h.parents(`label[for='${this.escapeCssMeta(i)}']`).length === 0 && (f = h.attr('id'), j ? j.match(new RegExp(`\\b${this.escapeCssMeta(f)}\\b`)) || (j += ` ${f}`) : j = f, a(b).attr('aria-describedby', j), e = this.groups[b.name], e && (g = this, a.each(g.groups, (b, c) => { c === e && a(`[name='${g.escapeCssMeta(b)}']`, g.currentForm).attr('aria-describedby', h.attr('id')) })))), !c && this.settings.success && (h.text(''), typeof this.settings.success === 'string' ? h.addClass(this.settings.success) : this.settings.success(h, b)), this.toShow = this.toShow.add(h) }, errorsFor(b) { const c = this.escapeCssMeta(this.idOrName(b)); const d = a(b).attr('aria-describedby'); let e = `label[for='${c}'], label[for='${c}'] *`; return d && (e = `${e}, #${this.escapeCssMeta(d).replace(/\s+/g, ', #')}`), this.errors().filter(e) }, escapeCssMeta(a) { return a.replace(/([\\!"#$%&'()*+,.\/:;<=>?@\[\]^`{|}~])/g, '\\$1') }, idOrName(a) { return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name) }, validationTargetFor(b) { return this.checkable(b) && (b = this.findByName(b.name)), a(b).not(this.settings.ignore)[0] }, checkable(a) { return /radio|checkbox/i.test(a.type) }, findByName(b) { return a(this.currentForm).find(`[name='${this.escapeCssMeta(b)}']`) }, getLength(b, c) { switch (c.nodeName.toLowerCase()) { case 'select':return a('option:selected', c).length; case 'input':if (this.checkable(c)) return this.findByName(c.name).filter(':checked').length } return b.length }, depend(a, b) { return !this.dependTypes[typeof a] || this.dependTypes[typeof a](a, b) }, dependTypes: { boolean(a) { return a }, string(b, c) { return !!a(b, c.form).length }, function(a, b) { return a(b) } }, optional(b) { const c = this.elementValue(b); return !a.validator.methods.required.call(this, c, b) && 'dependency-mismatch' }, startRequest(b) { this.pending[b.name] || (this.pendingRequest++, a(b).addClass(this.settings.pendingClass), this.pending[b.name] = !0) }, stopRequest(b, c) { this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[b.name], a(b).removeClass(this.settings.pendingClass), c && this.pendingRequest === 0 && this.formSubmitted && this.form() ? (a(this.currentForm).submit(), this.submitButton && a(`input:hidden[name='${this.submitButton.name}']`, this.currentForm).remove(), this.formSubmitted = !1) : !c && this.pendingRequest === 0 && this.formSubmitted && (a(this.currentForm).triggerHandler('invalid-form', [this]), this.formSubmitted = !1) }, previousValue(b, c) { return c = typeof c === 'string' && c || 'remote', a.data(b, 'previousValue') || a.data(b, 'previousValue', { old: null, valid: !0, message: this.defaultMessage(b, { method: c }) }) }, destroy() { this.resetForm(), a(this.currentForm).off('.validate').removeData('validator').find('.validate-equalTo-blur').off('.validate-equalTo').removeClass('validate-equalTo-blur') } }, classRuleSettings: { required: { required: !0 }, email: { email: !0 }, url: { url: !0 }, date: { date: !0 }, dateISO: { dateISO: !0 }, number: { number: !0 }, digits: { digits: !0 }, creditcard: { creditcard: !0 } }, addClassRules(b, c) { b.constructor === String ? this.classRuleSettings[b] = c : a.extend(this.classRuleSettings, b) }, classRules(b) { const c = {}; const d = a(b).attr('class'); return d && a.each(d.split(' '), function () { this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this]) }), c }, normalizeAttributeRule(a, b, c, d) { /min|max|step/.test(c) && (b === null || /number|range|text/.test(b)) && (d = Number(d), isNaN(d) && (d = void 0)), d || d === 0 ? a[c] = d : b === c && b !== 'range' && (a[c] = !0) }, attributeRules(b) { let c; let d; const e = {}; const f = a(b); const g = b.getAttribute('type'); for (c in a.validator.methods)c === 'required' ? (d = b.getAttribute(c), d === '' && (d = !0), d = !!d) : d = f.attr(c), this.normalizeAttributeRule(e, g, c, d); return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e }, dataRules(b) { let c; let d; const e = {}; const f = a(b); const g = b.getAttribute('type'); for (c in a.validator.methods)d = f.data(`rule${c.charAt(0).toUpperCase()}${c.substring(1).toLowerCase()}`), this.normalizeAttributeRule(e, g, c, d); return e }, staticRules(b) { let c = {}; const d = a.data(b.form, 'validator'); return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c }, normalizeRules(b, c) { return a.each(b, (d, e) => { if (e === !1) return void delete b[d]; if (e.param || e.depends) { let f = !0; switch (typeof e.depends) { case 'string':f = !!a(e.depends, c.form).length; break; case 'function':f = e.depends.call(c, c) }f ? b[d] = void 0 === e.param || e.param : (a.data(c.form, 'validator').resetElements(a(c)), delete b[d]) } }), a.each(b, (d, e) => { b[d] = a.isFunction(e) && d !== 'normalizer' ? e(c) : e }), a.each(['minlength', 'maxlength'], function () { b[this] && (b[this] = Number(b[this])) }), a.each(['rangelength', 'range'], function () { let c; b[this] && (a.isArray(b[this]) ? b[this] = [Number(b[this][0]), Number(b[this][1])] : typeof b[this] === 'string' && (c = b[this].replace(/[\[\]]/g, '').split(/[\s,]+/), b[this] = [Number(c[0]), Number(c[1])])) }), a.validator.autoCreateRanges && (b.min != null && b.max != null && (b.range = [b.min, b.max], delete b.min, delete b.max), b.minlength != null && b.maxlength != null && (b.rangelength = [b.minlength, b.maxlength], delete b.minlength, delete b.maxlength)), b }, normalizeRule(b) { if (typeof b === 'string') { const c = {}; a.each(b.split(/\s/), function () { c[this] = !0 }), b = c } return b }, addMethod(b, c, d) { a.validator.methods[b] = c, a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b], c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b)) }, methods: { required(b, c, d) { if (!this.depend(d, c)) return 'dependency-mismatch'; if (c.nodeName.toLowerCase() === 'select') { const e = a(c).val(); return e && e.length > 0 } return this.checkable(c) ? this.getLength(b, c) > 0 : b.length > 0 }, email(a, b) { return this.optional(b) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a) }, url(a, b) { return this.optional(b) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i.test(a) }, date(a, b) { return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString()) }, dateISO(a, b) { return this.optional(b) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a) }, number(a, b) { return this.optional(b) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a) }, digits(a, b) { return this.optional(b) || /^\d+$/.test(a) }, minlength(b, c, d) { const e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e >= d }, maxlength(b, c, d) { const e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e <= d }, rangelength(b, c, d) { const e = a.isArray(b) ? b.length : this.getLength(b, c); return this.optional(c) || e >= d[0] && e <= d[1] }, min(a, b, c) { return this.optional(b) || a >= c }, max(a, b, c) { return this.optional(b) || a <= c }, range(a, b, c) { return this.optional(b) || a >= c[0] && a <= c[1] }, step(b, c, d) { let e; const f = a(c).attr('type'); const g = `Step attribute on input type ${f} is not supported.`; const h = ['text', 'number', 'range']; const i = new RegExp(`\\b${f}\\b`); const j = f && !i.test(h.join()); const k = function (a) { const b = (`${a}`).match(/(?:\.(\d+))?$/); return b && b[1] ? b[1].length : 0 }; const l = function (a) { return Math.round(a * Math.pow(10, e)) }; let m = !0; if (j) throw new Error(g); return e = k(d), (k(b) > e || l(b) % l(d) !== 0) && (m = !1), this.optional(c) || m }, equalTo(b, c, d) { const e = a(d); return this.settings.onfocusout && e.not('.validate-equalTo-blur').length && e.addClass('validate-equalTo-blur').on('blur.validate-equalTo', () => { a(c).valid() }), b === e.val() }, remote(b, c, d, e) { if (this.optional(c)) return 'dependency-mismatch'; e = typeof e === 'string' && e || 'remote'; let f; let g; let h; const i = this.previousValue(c, e); return this.settings.messages[c.name] || (this.settings.messages[c.name] = {}), i.originalMessage = i.originalMessage || this.settings.messages[c.name][e], this.settings.messages[c.name][e] = i.message, d = typeof d === 'string' && { url: d } || d, h = a.param(a.extend({ data: b }, d.data)), i.old === h ? i.valid : (i.old = h, f = this, this.startRequest(c), g = {}, g[c.name] = b, a.ajax(a.extend(!0, { mode: 'abort', port: `validate${c.name}`, dataType: 'json', data: g, context: f.currentForm, success(a) { let d; let g; let h; const j = a === !0 || a === 'true'; f.settings.messages[c.name][e] = i.originalMessage, j ? (h = f.formSubmitted, f.resetInternals(), f.toHide = f.errorsFor(c), f.formSubmitted = h, f.successList.push(c), f.invalid[c.name] = !1, f.showErrors()) : (d = {}, g = a || f.defaultMessage(c, { method: e, parameters: b }), d[c.name] = i.message = g, f.invalid[c.name] = !0, f.showErrors(d)), i.valid = j, f.stopRequest(c, j) } }, d)), 'pending') } } }); let b; const c = {}; return a.ajaxPrefilter ? a.ajaxPrefilter((a, b, d) => { const e = a.port; a.mode === 'abort' && (c[e] && c[e].abort(), c[e] = d) }) : (b = a.ajax, a.ajax = function (d) { const e = ('mode' in d ? d : a.ajaxSettings).mode; const f = ('port' in d ? d : a.ajaxSettings).port; return e === 'abort' ? (c[f] && c[f].abort(), c[f] = b.apply(this, arguments), c[f]) : b.apply(this, arguments) }), a }))
