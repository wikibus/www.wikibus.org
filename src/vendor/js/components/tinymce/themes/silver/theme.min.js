!(function () {
  const N = function () { for (let t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e] }; const g = function (n, o) { return function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return n(o.apply(null, t)) } }; const U = function (t) { return function () { return t } }; const d = function (t) { return t }; function f(o) { for (var r = [], t = 1; t < arguments.length; t++)r[t - 1] = arguments[t]; return function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; const n = r.concat(t); return o.apply(null, n) } } let t; let e; let n; let o; let r; let s; let i; const m = function (n) { return function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return !n.apply(null, t) } }; const a = function (t) { return function () { throw new Error(t) } }; const u = U(!1); const c = U(!0); const l = u; const h = c; const v = function () { return p }; var p = (o = { fold(t, e) { return t() }, is: l, isSome: l, isNone: h, getOr: n = function (t) { return t }, getOrThunk: e = function (t) { return t() }, getOrDie(t) { throw new Error(t || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: n, orThunk: e, map: v, ap: v, each() {}, bind: v, flatten: v, exists: l, forall: h, filter: v, equals: t = function (t) { return t.isNone() }, equals_: t, toArray() { return [] }, toString: U('none()') }, Object.freeze && Object.freeze(o), o); var b = function (n) { const t = function () { return n }; const e = function () { return r }; const o = function (t) { return t(n) }; var r = { fold(t, e) { return e(n) }, is(t) { return n === t }, isSome: h, isNone: l, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: e, orThunk: e, map(t) { return b(t(n)) }, ap(t) { return t.fold(v, (t) => b(t(n))) }, each(t) { t(n) }, bind: o, flatten: t, exists: o, forall: o, filter(t) { return t(n) ? r : p }, equals(t) { return t.is(n) }, equals_(t, e) { return t.fold(l, (t) => e(n, t)) }, toArray() { return [n] }, toString() { return `some(${n})` } }; return r }; const P = { some: b, none: v, from(t) { return t === null || t === undefined ? p : b(t) } }; const y = function (e) { return function (t) { return (function (t) { if (t === null) return 'null'; const e = typeof t; return e === 'object' && Array.prototype.isPrototypeOf(t) ? 'array' : e === 'object' && String.prototype.isPrototypeOf(t) ? 'string' : e }(t)) === e } }; const x = y('string'); const w = y('object'); const O = y('array'); const z = y('boolean'); const S = y('function'); const k = y('number'); const C = (r = Array.prototype.indexOf) === undefined ? function (t, e) { return L(t, e) } : function (t, e) { return r.call(t, e) }; const M = function (t, e) { return C(t, e) > -1 }; const H = function (t, e) { return F(t, e).isSome() }; const V = function (t, e) { for (var n = [], o = 0; o < t.length; o += e) { const r = t.slice(o, o + e); n.push(r) } return n }; const E = function (t, e) { for (var n = t.length, o = new Array(n), r = 0; r < n; r++) { const i = t[r]; o[r] = e(i, r, t) } return o }; const A = function (t, e) { for (let n = 0, o = t.length; n < o; n++)e(t[n], n, t) }; const T = function (t, e) { for (var n = [], o = 0, r = t.length; o < r; o++) { const i = t[o]; e(i, o, t) && n.push(i) } return n }; const B = function (t, e, n) { return (function (t, e) { for (let n = t.length - 1; n >= 0; n--)e(t[n], n, t) }(t, (t) => { n = e(n, t) })), n }; const D = function (t, e, n) { return A(t, (t) => { n = e(n, t) }), n }; const _ = function (t, e) { for (let n = 0, o = t.length; n < o; n++) { const r = t[n]; if (e(r, n, t)) return P.some(r) } return P.none() }; var F = function (t, e) { for (let n = 0, o = t.length; n < o; n++) if (e(t[n], n, t)) return P.some(n); return P.none() }; var L = function (t, e) { for (let n = 0, o = t.length; n < o; ++n) if (t[n] === e) return n; return -1 }; const I = Array.prototype.push; const R = function (t) { for (var e = [], n = 0, o = t.length; n < o; ++n) { if (!Array.prototype.isPrototypeOf(t[n])) throw new Error(`Arr.flatten item ${n} was not an array, input: ${t}`); I.apply(e, t[n]) } return e }; const j = function (t, e) { const n = E(t, e); return R(n) }; const W = function (t, e) { for (let n = 0, o = t.length; n < o; ++n) if (!0 !== e(t[n], n, t)) return !1; return !0 }; const G = Array.prototype.slice; const X = function (t) { const e = G.call(t, 0); return e.reverse(), e }; const Y = function (t, e) { return T(t, (t) => !M(e, t)) }; const q = function (t) { return [t] }; const K = function (t) { return t.length === 0 ? P.none() : P.some(t[0]) }; const J = function (t) { return t.length === 0 ? P.none() : P.some(t[t.length - 1]) }; const $ = S(Array.from) ? Array.from : function (t) { return G.call(t) }; const Q = Object.keys; const Z = Object.hasOwnProperty; const tt = function (t, e) { for (let n = Q(t), o = 0, r = n.length; o < r; o++) { const i = n[o]; e(t[i], i, t) } }; const et = function (t, o) { return nt(t, (t, e, n) => ({ k: e, v: o(t, e, n) })) }; var nt = function (o, r) { const i = {}; return tt(o, (t, e) => { const n = r(t, e, o); i[n.k] = n.v }), i }; const ot = function (t, n) { const o = []; return tt(t, (t, e) => { o.push(n(t, e)) }), o }; const rt = function (t) { return ot(t, (t) => t) }; const it = function (t, e) { return Z.call(t, e) }; const at = function (e) { return function (t) { return it(t, e) ? P.from(t[e]) : P.none() } }; const ut = function (t, e) { return at(e)(t) }; const ct = function (t, e) { const n = {}; return n[t] = e, n }; var st = function (n) { return { is(t) { return n === t }, isValue: c, isError: u, getOr: U(n), getOrThunk: U(n), getOrDie: U(n), or(t) { return st(n) }, orThunk(t) { return st(n) }, fold(t, e) { return e(n) }, map(t) { return st(t(n)) }, mapError(t) { return st(n) }, each(t) { t(n) }, bind(t) { return t(n) }, exists(t) { return t(n) }, forall(t) { return t(n) }, toOption() { return P.some(n) } } }; var lt = function (n) { return { is: u, isValue: u, isError: c, getOr: d, getOrThunk(t) { return t() }, getOrDie() { return a(String(n))() }, or(t) { return t }, orThunk(t) { return t() }, fold(t, e) { return t(n) }, map(t) { return lt(n) }, mapError(t) { return lt(t(n)) }, each: N, bind(t) { return lt(n) }, exists: u, forall: c, toOption: P.none } }; const ft = { value: st, error: lt }; const dt = function (a) { if (!O(a)) throw new Error('cases must be an array'); if (a.length === 0) throw new Error('there must be at least one case'); const u = []; const n = {}; return A(a, (t, o) => { const e = Q(t); if (e.length !== 1) throw new Error('one and only one name per case'); const r = e[0]; const i = t[r]; if (n[r] !== undefined) throw new Error(`duplicate key detected:${r}`); if (r === 'cata') throw new Error('cannot have a case named cata (sorry)'); if (!O(i)) throw new Error('case arguments must be an array'); u.push(r), n[r] = function () { const t = arguments.length; if (t !== i.length) throw new Error(`Wrong number of arguments to case ${r}. Expected ${i.length} (${i}), got ${t}`); for (var n = new Array(t), e = 0; e < n.length; e++)n[e] = arguments[e]; return { fold() { if (arguments.length !== a.length) throw new Error(`Wrong number of arguments to fold. Expected ${a.length}, got ${arguments.length}`); return arguments[o].apply(null, n) }, match(t) { const e = Q(t); if (u.length !== e.length) throw new Error(`Wrong number of arguments to match. Expected: ${u.join(',')}\nActual: ${e.join(',')}`); if (!W(u, (t) => M(e, t))) throw new Error(`Not all branches were specified when using match. Specified: ${e.join(', ')}\nRequired: ${u.join(', ')}`); return t[r].apply(null, n) }, log(t) { console.log(t, { constructors: u, constructor: r, params: n }) } } } }), n }; const mt = (dt([{ bothErrors: ['error1', 'error2'] }, { firstError: ['error1', 'value2'] }, { secondError: ['value1', 'error2'] }, { bothValues: ['value1', 'value2'] }]), Object.prototype.hasOwnProperty); const ht = function (a) { return function () { for (var t = new Array(arguments.length), e = 0; e < t.length; e++)t[e] = arguments[e]; if (t.length === 0) throw new Error("Can't merge zero objects"); for (var n = {}, o = 0; o < t.length; o++) { const r = t[o]; for (const i in r)mt.call(r, i) && (n[i] = a(n[i], r[i])) } return n } }; var gt = ht((t, e) => w(t) && w(e) ? gt(t, e) : e); const vt = ht((t, e) => e); const pt = function (t, e) { return n = e, o = {}, tt(t, (t, e) => { M(n, e) || (o[e] = t) }), o; let n, o }; const bt = function (t) { return at(t) }; const yt = function (t, e) { return n = t, o = e, function (t) { return it(t, n) ? t[n] : o }; let n, o }; const xt = function (t, e) { return ut(t, e) }; const wt = function (t, e) { return ct(t, e) }; const zt = function (t) { return e = {}, A(t, (t) => { e[t.key] = t.value }), e; let e }; const St = function (t, e) { let n; let o; let r; let i; let a; const u = (n = [], o = [], A(t, (t) => { t.fold((t) => { n.push(t) }, (t) => { o.push(t) }) }), { errors: n, values: o }); return u.errors.length > 0 ? (a = u.errors, g(ft.error, R)(a)) : (i = e, (r = u.values).length === 0 ? ft.value(i) : ft.value(gt(i, vt.apply(undefined, r)))) }; const kt = function (t, e) { return it(n = t, o = e) && n[o] !== undefined && n[o] !== null; let n, o }; var Ct = function (t) { let e = t; const n = function () { return e }; return { get: n, set(t) { e = t }, clone() { return Ct(n()) } } }; const Ot = function (t) { for (var e = [], n = function (t) { e.push(t) }, o = 0; o < t.length; o++)t[o].each(n); return e }; const Mt = function (t, e) { for (let n = 0; n < t.length; n++) { const o = e(t[n], n); if (o.isSome()) return o } return P.none() }; const Ht = U('touchstart'); const Vt = U('touchmove'); const Et = U('touchend'); const At = U('mousedown'); const Tt = U('mousemove'); const Bt = U('mouseout'); const Dt = U('mouseup'); const _t = U('mouseover'); const Ft = U('focusin'); const Lt = U('focusout'); const It = U('keydown'); const Rt = U('keyup'); const Nt = U('input'); const Pt = U('change'); const jt = U('click'); const Ut = U('transitionend'); const Wt = U('selectstart'); const Gt = U('paste'); const Xt = function (n) { let o; let r = !1; return function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return r || (r = !0, o = n.apply(null, t)), o } }; const Yt = function (t, e) { const n = (function (t, e) { for (let n = 0; n < t.length; n++) { const o = t[n]; if (o.test(e)) return o } return undefined }(t, e)); if (!n) return { major: 0, minor: 0 }; const o = function (t) { return Number(e.replace(n, `$${t}`)) }; return Kt(o(1), o(2)) }; const qt = function () { return Kt(0, 0) }; var Kt = function (t, e) { return { major: t, minor: e } }; const Jt = { nu: Kt, detect(t, e) { const n = String(e).toLowerCase(); return t.length === 0 ? qt() : Yt(t, n) }, unknown: qt }; const $t = 'Firefox'; const Qt = function (t, e) { return function () { return e === t } }; const Zt = function (t) { const e = t.current; return { current: e, version: t.version, isEdge: Qt('Edge', e), isChrome: Qt('Chrome', e), isIE: Qt('IE', e), isOpera: Qt('Opera', e), isFirefox: Qt($t, e), isSafari: Qt('Safari', e) } }; const te = { unknown() { return Zt({ current: undefined, version: Jt.unknown() }) }, nu: Zt, edge: U('Edge'), chrome: U('Chrome'), ie: U('IE'), opera: U('Opera'), firefox: U($t), safari: U('Safari') }; const ee = 'Windows'; const ne = 'Android'; const oe = 'Solaris'; const re = 'FreeBSD'; const ie = function (t, e) { return function () { return e === t } }; const ae = function (t) { const e = t.current; return { current: e, version: t.version, isWindows: ie(ee, e), isiOS: ie('iOS', e), isAndroid: ie(ne, e), isOSX: ie('OSX', e), isLinux: ie('Linux', e), isSolaris: ie(oe, e), isFreeBSD: ie(re, e) } }; const ue = { unknown() { return ae({ current: undefined, version: Jt.unknown() }) }, nu: ae, windows: U(ee), ios: U('iOS'), android: U(ne), linux: U('Linux'), osx: U('OSX'), solaris: U(oe), freebsd: U(re) }; const ce = function (t, e) { const n = String(e).toLowerCase(); return _(t, (t) => t.search(n)) }; const se = function (t, n) { return ce(t, n).map((t) => { const e = Jt.detect(t.versionRegexes, n); return { current: t.name, version: e } }) }; const le = function (t, n) { return ce(t, n).map((t) => { const e = Jt.detect(t.versionRegexes, n); return { current: t.name, version: e } }) }; const fe = function (t, e) { return t.indexOf(e) !== -1 }; const de = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const me = function (e) { return function (t) { return fe(t, e) } }; const he = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search(t) { return fe(t, 'edge/') && fe(t, 'chrome') && fe(t, 'safari') && fe(t, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, de], search(t) { return fe(t, 'chrome') && !fe(t, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search(t) { return fe(t, 'msie') || fe(t, 'trident') } }, { name: 'Opera', versionRegexes: [de, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: me('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: me('firefox') }, { name: 'Safari', versionRegexes: [de, /.*?cpu os ([0-9]+)_([0-9]+).*/], search(t) { return (fe(t, 'safari') || fe(t, 'mobile/')) && fe(t, 'applewebkit') } }]; const ge = [{ name: 'Windows', search: me('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search(t) { return fe(t, 'iphone') || fe(t, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: me('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: me('os x'), versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: me('linux'), versionRegexes: [] }, { name: 'Solaris', search: me('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: me('freebsd'), versionRegexes: [] }]; const ve = { browsers: U(he), oses: U(ge) }; const pe = function (t) { let e; let n; let o; let r; let i; let a; let u; let c; let s; let l; let f; const d = ve.browsers(); const m = ve.oses(); const h = se(d, t).fold(te.unknown, te.nu); const g = le(m, t).fold(ue.unknown, ue.nu); return { browser: h, os: g, deviceType: (n = h, o = t, r = (e = g).isiOS() && !0 === /ipad/i.test(o), i = e.isiOS() && !r, a = e.isAndroid() && e.version.major === 3, u = e.isAndroid() && e.version.major === 4, c = r || a || u && !0 === /mobile/i.test(o), s = e.isiOS() || e.isAndroid(), l = s && !c, f = n.isSafari() && e.isiOS() && !1 === /safari/i.test(o), { isiPad: U(r), isiPhone: U(i), isTablet: U(c), isPhone: U(l), isTouch: U(s), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: U(f) }) } }; const be = { detect: Xt(() => { const t = navigator.userAgent; return pe(t) }) }; const ye = { tap: U('alloy.tap') }; const xe = U('alloy.focus'); const we = U('alloy.blur.post'); const ze = U('alloy.receive'); const Se = U('alloy.execute'); const ke = U('alloy.focus.item'); const Ce = ye.tap; const Oe = be.detect().deviceType.isTouch() ? ye.tap : jt; const Me = U('alloy.longpress'); const He = U('alloy.sandbox.close'); const Ve = U('alloy.typeahead.cancel'); const Ee = U('alloy.system.init'); const Ae = U('alloy.system.scroll'); const Te = U('alloy.system.attached'); const Be = U('alloy.system.detached'); const De = U('alloy.system.dismissRequested'); const _e = U('alloy.focusmanager.shifted'); const Fe = U('alloy.slotcontainer.visibility'); const Le = U('alloy.change.tab'); const Ie = U('alloy.dismiss.tab'); const Re = function (t) { if (t === null || t === undefined) throw new Error('Node cannot be null or undefined'); return { dom: U(t) } }; const Ne = { fromHtml(t, e) { const n = (e || document).createElement('div'); if (n.innerHTML = t, !n.hasChildNodes() || n.childNodes.length > 1) throw console.error('HTML does not have a single root node', t), new Error('HTML must have a single root node'); return Re(n.childNodes[0]) }, fromTag(t, e) { const n = (e || document).createElement(t); return Re(n) }, fromText(t, e) { const n = (e || document).createTextNode(t); return Re(n) }, fromDom: Re, fromPoint(t, e, n) { const o = t.dom(); return P.from(o.elementFromPoint(e, n)).map(Re) } }; const Pe = function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return function () { for (var n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t]; if (e.length !== n.length) throw new Error(`Wrong number of arguments to struct. Expected "[${e.length}]", got ${n.length} arguments`); const o = {}; return A(e, (t, e) => { o[t] = U(n[e]) }), o } }; const je = function (t) { return t.slice(0).sort() }; const Ue = function (e, t) { if (!O(t)) throw new Error(`The ${e} fields must be an array. Was: ${t}.`); A(t, (t) => { if (!x(t)) throw new Error(`The value ${t} in the ${e} fields was not a string.`) }) }; const We = function (r, i) { let n; const a = r.concat(i); if (a.length === 0) throw new Error('You must specify at least one required or optional field.'); return Ue('required', r), Ue('optional', i), n = je(a), _(n, (t, e) => e < n.length - 1 && t === n[e + 1]).each((t) => { throw new Error(`The field: ${t} occurs more than once in the combined fields: [${n.join(', ')}].`) }), function (e) { const n = Q(e); W(r, (t) => M(n, t)) || (function (t, e) { throw new Error(`All required keys (${je(t).join(', ')}) were not specified. Specified keys were: ${je(e).join(', ')}.`) }(r, n)); const t = T(n, (t) => !M(a, t)); t.length > 0 && (function (t) { throw new Error(`Unsupported keys for object: ${je(t).join(', ')}`) }(t)); const o = {}; return A(r, (t) => { o[t] = U(e[t]) }), A(i, (t) => { o[t] = U(Object.prototype.hasOwnProperty.call(e, t) ? P.some(e[t]) : P.none()) }), o } }; const Ge = typeof window !== 'undefined' ? window : Function('return this;')(); const Xe = function (t, e) { return (function (t, e) { for (var n = e !== undefined && e !== null ? e : Ge, o = 0; o < t.length && n !== undefined && n !== null; ++o)n = n[t[o]]; return n }(t.split('.'), e)) }; const Ye = { getOrDie(t, e) { const n = Xe(t, e); if (n === undefined || n === null) throw `${t} not available on this browser`; return n } }; const qe = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE); const Ke = (Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE); const Je = Node.TEXT_NODE; const $e = (Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, Ke); const Qe = qe; const Ze = function (t, e) { const n = t.dom(); if (n.nodeType !== $e) return !1; if (n.matches !== undefined) return n.matches(e); if (n.msMatchesSelector !== undefined) return n.msMatchesSelector(e); if (n.webkitMatchesSelector !== undefined) return n.webkitMatchesSelector(e); if (n.mozMatchesSelector !== undefined) return n.mozMatchesSelector(e); throw new Error('Browser lacks native selectors') }; const tn = function (t) { return t.nodeType !== $e && t.nodeType !== Qe || t.childElementCount === 0 }; const en = function (t, e) { const n = e === undefined ? document : e.dom(); return tn(n) ? [] : E(n.querySelectorAll(t), Ne.fromDom) }; const nn = function (t, e) { return t.dom() === e.dom() }; const on = (be.detect().browser.isIE(), function (t) { return Ne.fromDom(t.dom().ownerDocument) }); const rn = function (t) { const e = t.dom().ownerDocument.defaultView; return Ne.fromDom(e) }; const an = function (t) { const e = t.dom(); return P.from(e.parentNode).map(Ne.fromDom) }; const un = function (t) { const e = t.dom(); return P.from(e.offsetParent).map(Ne.fromDom) }; const cn = function (t) { const e = t.dom(); return E(e.childNodes, Ne.fromDom) }; const sn = function (t, e) { const n = t.dom().childNodes; return P.from(n[e]).map(Ne.fromDom) }; const ln = (Pe('element', 'offset'), function (e, n) { an(e).each((t) => { t.dom().insertBefore(n.dom(), e.dom()) }) }); const fn = function (t, e) { let n; (n = t.dom(), P.from(n.nextSibling).map(Ne.fromDom)).fold(() => { an(t).each((t) => { mn(t, e) }) }, (t) => { ln(t, e) }) }; const dn = function (e, n) { sn(e, 0).fold(() => { mn(e, n) }, (t) => { e.dom().insertBefore(n.dom(), t.dom()) }) }; var mn = function (t, e) { t.dom().appendChild(e.dom()) }; const hn = function (e, t) { A(t, (t) => { mn(e, t) }) }; const gn = function (t) { t.dom().textContent = '', A(cn(t), (t) => { vn(t) }) }; var vn = function (t) { const e = t.dom(); e.parentNode !== null && e.parentNode.removeChild(e) }; const pn = function (t) { return t.dom().innerHTML }; const bn = function (t, e) { let n; let o; const r = on(t).dom(); const i = Ne.fromDom(r.createDocumentFragment()); const a = (n = e, (o = (r || document).createElement('div')).innerHTML = n, cn(Ne.fromDom(o))); hn(i, a), gn(t), mn(t, i) }; const yn = function (t) { return t.dom().nodeName.toLowerCase() }; const xn = function (e) { return function (t) { return t.dom().nodeType === e } }; const wn = xn(Ke); const zn = xn(Je); const Sn = xn(qe); const kn = function (t, e, n) { if (!(x(n) || z(n) || k(n))) throw console.error('Invalid call to Attr.set. Key ', e, ':: Value ', n, ':: Element ', t), new Error('Attribute value was not simple'); t.setAttribute(e, `${n}`) }; const Cn = function (t, e, n) { kn(t.dom(), e, n) }; const On = function (t, e) { const n = t.dom(); tt(e, (t, e) => { kn(n, e, t) }) }; const Mn = function (t, e) { const n = t.dom().getAttribute(e); return n === null ? undefined : n }; const Hn = function (t, e) { const n = t.dom(); return !(!n || !n.hasAttribute) && n.hasAttribute(e) }; const Vn = function (t, e) { t.dom().removeAttribute(e) }; const En = function (t) { return e = t, n = !1, Ne.fromDom(e.dom().cloneNode(n)); let e, n }; const An = function (t) { let e; let n; let o; const r = En(t); return e = r, n = Ne.fromTag('div'), o = Ne.fromDom(e.dom().cloneNode(!0)), mn(n, o), pn(n) }; const Tn = function (t) { return An(t) }; const Bn = 'unknown'; const Dn = '__CHROME_INSPECTOR_CONNECTION_TO_ALLOY__'; (i = s || (s = {}))[i.STOP = 0] = 'STOP', i[i.NORMAL = 1] = 'NORMAL', i[i.LOGGING = 2] = 'LOGGING'; const _n = Ct({}); const Fn = function (e, t, n) { let o, r, i, a; switch (xt(_n.get(), e).orThunk(() => { const t = Q(_n.get()); return Mt(t, (t) => e.indexOf(t) > -1 ? P.some(_n.get()[t]) : P.none()) }).getOr(s.NORMAL)) { case s.NORMAL:return n(Pn()); case s.LOGGING:var u = (o = e, r = t, i = [], a = (new Date()).getTime(), { logEventCut(t, e, n) { i.push({ outcome: 'cut', target: e, purpose: n }) }, logEventStopped(t, e, n) { i.push({ outcome: 'stopped', target: e, purpose: n }) }, logNoParent(t, e, n) { i.push({ outcome: 'no-parent', target: e, purpose: n }) }, logEventNoHandlers(t, e) { i.push({ outcome: 'no-handlers-left', target: e }) }, logEventResponse(t, e, n) { i.push({ outcome: 'response', purpose: n, target: e }) }, write() { const t = (new Date()).getTime(); M(['mousemove', 'mouseover', 'mouseout', Ee()], o) || console.log(o, { event: o, time: t - a, target: r.dom(), sequence: E(i, (t) => M(['cut', 'stopped', 'response'], t.outcome) ? `{${t.purpose}} ${t.outcome} at (${Tn(t.target)})` : t.outcome) }) } }); var c = n(u); return u.write(), c; case s.STOP:return !0 } }; const Ln = ['alloy/data/Fields', 'alloy/debugging/Debugging']; const In = function (t, e, n) { return Fn(t, e, n) }; const Rn = function () { if (window[Dn] !== undefined) return window[Dn]; const e = function (t, e) { const n = _n.get(); n[t] = e, _n.set(n) }; return window[Dn] = { systems: {}, lookup(e) { const n = window[Dn].systems; const t = Q(n); return Mt(t, (t) => n[t].getByUid(e).toOption().map((t) => { return wt(Tn(t.element()), (e = function (n) { const t = n.spec(); return { '(original.spec)': t, '(dom.ref)': n.element().dom(), '(element)': Tn(n.element()), '(initComponents)': E(t.components !== undefined ? t.components : [], e), '(components)': E(n.components(), e), '(bound.events)': ot(n.events(), (t, e) => [e]).join(', '), '(behaviours)': t.behaviours !== undefined ? et(t.behaviours, (t, e) => t === undefined ? '--revoked--' : { config: t.configAsRaw(), 'original-config': t.initialConfig, state: n.readState(e) }) : 'none' } })(t)); let e })).orThunk(() => P.some({ error: `Systems (${t.join(', ')}) did not contain uid: ${e}` })) }, events: { setToNormal(t) { e(t, s.NORMAL) }, setToLogging(t) { e(t, s.LOGGING) }, setToStop(t) { e(t, s.STOP) } } }, window[Dn] }; const Nn = function (t, e) { Rn().systems[t] = e }; var Pn = U({ logEventCut: N, logEventStopped: N, logNoParent: N, logEventNoHandlers: N, logEventResponse: N, write: N }); let jn = 0; const Un = function (t) { const e = (new Date()).getTime(); return `${t}_${Math.floor(1e9 * Math.random())}${++jn}${String(e)}` }; const Wn = tinymce.util.Tools.resolve('tinymce.ThemeManager'); var Gn = function () { return (Gn = Object.assign || function (t) { for (var e, n = 1, o = arguments.length; n < o; n++) for (const r in e = arguments[n])Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t }).apply(this, arguments) }; function Xn(t, e) { const n = {}; for (var o in t)Object.prototype.hasOwnProperty.call(t, o) && e.indexOf(o) < 0 && (n[o] = t[o]); if (t != null && typeof Object.getOwnPropertySymbols === 'function') { let r = 0; for (o = Object.getOwnPropertySymbols(t); r < o.length; r++)e.indexOf(o[r]) < 0 && (n[o[r]] = t[o[r]]) } return n } let Yn; let qn; const Kn = dt([{ strict: [] }, { defaultedThunk: ['fallbackThunk'] }, { asOption: [] }, { asDefaultedOptionThunk: ['fallbackThunk'] }, { mergeWithThunk: ['baseThunk'] }]); const Jn = function (t) { return Kn.defaultedThunk(U(t)) }; const $n = Kn.strict; const Qn = Kn.asOption; const Zn = Kn.defaultedThunk; const to = Kn.mergeWithThunk; (qn = Yn || (Yn = {}))[qn.Error = 0] = 'Error', qn[qn.Value = 1] = 'Value'; const eo = function (t, e, n) { return t.stype === Yn.Error ? e(t.serror) : n(t.svalue) }; const no = function (t) { return { stype: Yn.Value, svalue: t } }; const oo = function (t) { return { stype: Yn.Error, serror: t } }; const ro = function (t) { return t.fold(oo, no) }; const io = function (t) { return eo(t, ft.error, ft.value) }; const ao = no; const uo = function (t) { const e = []; const n = []; return A(t, (t) => { eo(t, (t) => n.push(t), (t) => e.push(t)) }), { values: e, errors: n } }; const co = oo; const so = function (t, e) { return t.stype === Yn.Value ? e(t.svalue) : t }; const lo = function (t, e) { return t.stype === Yn.Error ? e(t.serror) : t }; const fo = function (t, e) { return t.stype === Yn.Value ? { stype: Yn.Value, svalue: e(t.svalue) } : t }; const mo = function (t, e) { return t.stype === Yn.Error ? { stype: Yn.Error, serror: e(t.serror) } : t }; const ho = function (t) { return g(co, R)(t) }; const go = function (t, e) { let n; let o; const r = uo(t); return r.errors.length > 0 ? ho(r.errors) : (n = r.values, o = e, n.length > 0 ? ao(gt(o, vt.apply(undefined, n))) : ao(o)) }; const vo = function (t) { const e = uo(t); return e.errors.length > 0 ? ho(e.errors) : ao(e.values) }; const po = dt([{ setOf: ['validator', 'valueType'] }, { arrOf: ['valueType'] }, { objOf: ['fields'] }, { itemOf: ['validator'] }, { choiceOf: ['key', 'branches'] }, { thunk: ['description'] }, { func: ['args', 'outputSchema'] }]); const bo = dt([{ field: ['name', 'presence', 'type'] }, { state: ['name'] }]); const yo = function () { return Ye.getOrDie('JSON') }; const xo = function (t, e, n) { return yo().stringify(t, e, n) }; const wo = function (t) { return w(t) && Q(t).length > 100 ? ' removed due to size' : xo(t, null, 2) }; const zo = function (t, e) { return co([{ path: t, getErrorInfo: e }]) }; const So = dt([{ field: ['key', 'okey', 'presence', 'prop'] }, { state: ['okey', 'instantiator'] }]); const ko = function (n, o, r) { return ut(o, r).fold(() => { return t = r, e = o, zo(n, () => `Could not find valid *strict* value for "${t}" in ${wo(e)}`); let t, e }, ao) }; const Co = function (t, e, n) { const o = ut(t, e).fold(() => n(t), d); return ao(o) }; const Oo = function (u, c, t, s) { return t.fold((r, n, t, o) => { const i = function (t) { const e = o.extract(u.concat([r]), s, t); return fo(e, (t) => ct(n, s(t))) }; const a = function (t) { return t.fold(() => { const t = ct(n, s(P.none())); return ao(t) }, (t) => { const e = o.extract(u.concat([r]), s, t); return fo(e, (t) => ct(n, s(P.some(t)))) }) }; return t.fold(() => so(ko(u, c, r), i), (t) => so(Co(c, r, t), i), () => so(ao(ut(c, r)), a), (t) => { return so((n = t, o = ut(e = c, r).map((t) => !0 === t ? n(e) : t), ao(o)), a); let e, n, o }, (t) => { const e = t(c); const n = fo(Co(c, r, U({})), (t) => gt(e, t)); return so(n, i) }) }, (t, e) => { const n = e(c); return ao(ct(t, s(n))) }) }; const Mo = function (o) { return { extract(n, t, e) { return lo(o(e, t), (t) => { return e = t, zo(n, () => e); let e }) }, toString() { return 'val' }, toDsl() { return po.itemOf(o) } } }; const Ho = function (t) { const c = Vo(t); const s = B(t, (e, t) => t.fold((t) => gt(e, wt(t, !0)), U(e)), {}); return { extract(t, e, n) { let o; let r; let i; const a = z(n) ? [] : (r = Q(o = n), T(r, (t) => kt(o, t))); const u = T(a, (t) => !kt(s, t)); return u.length === 0 ? c.extract(t, e, n) : (i = u, zo(t, () => `There are unsupported fields: [${i.join(', ')}] specified`)) }, toString: c.toString, toDsl: c.toDsl } }; var Vo = function (u) { return { extract(t, e, n) { return o = t, r = n, i = e, a = E(u, (t) => Oo(o, r, t, i)), go(a, {}); let o, r, i, a }, toString() { return `obj{\n${E(u, (t) => t.fold((t, e, n, o) => `${t} -> ${o.toString()}`, (t, e) => `state(${t})`)).join('\n')}}` }, toDsl() { return po.objOf(E(u, (t) => t.fold((t, e, n, o) => bo.field(t, n, o), (t, e) => bo.state(t)))) } } }; const Eo = function (r) { return { extract(n, o, t) { const e = E(t, (t, e) => r.extract(n.concat([`[${e}]`]), o, t)); return vo(e) }, toString() { return `array(${r.toString()})` }, toDsl() { return po.arrOf(r) } } }; const Ao = function (u, c) { return { extract(n, o, r) { let t; let e; const i = Q(r); const a = (t = n, e = i, Eo(Mo(u)).extract(t, d, e)); return so(a, (t) => { const e = E(t, (t) => So.field(t, t, $n(), c)); return Vo(e).extract(n, o, r) }) }, toString() { return `setOf(${c.toString()})` }, toDsl() { return po.setOf(u, c) } } }; const To = U(Mo(ao)); const Bo = g(Eo, Vo); const Do = So.state; const _o = So.field; const Fo = function (n, e, o, r, i) { return xt(r, i).fold(() => { return t = r, e = i, zo(n, () => `The chosen schema: "${e}" did not exist in branches: ${wo(t)}`); let t, e }, (t) => Vo(t).extract(n.concat([`branch: ${i}`]), e, o)) }; const Lo = function (r, i) { return { extract(e, n, o) { return xt(o, r).fold(() => { return t = r, zo(e, () => `Choice schema did not contain choice key: "${t}"`); let t }, (t) => Fo(e, n, o, i, t)) }, toString() { return `chooseOn(${r}). Possible values: ${Q(i)}` }, toDsl() { return po.choiceOf(r, i) } } }; const Io = Mo(ao); const Ro = function (e) { return Mo((t) => e(t).fold(co, ao)) }; const No = function (e, t) { return Ao((t) => ro(e(t)), t) }; const Po = function (t, e, n) { return io((o = t, r = d, i = n, a = e.extract([o], r, i), mo(a, (t) => ({ input: i, errors: t })))); let o, r, i, a }; const jo = function (t) { return t.fold((t) => { throw new Error(Wo(t)) }, d) }; const Uo = function (t, e, n) { return jo(Po(t, e, n)) }; var Wo = function (t) { return `Errors: \n${e = t.errors, n = e.length > 10 ? e.slice(0, 10).concat([{ path: [], getErrorInfo() { return '... (only showing first ten failures)' } }]) : e, E(n, (t) => `Failed path: (${t.path.join(' > ')})\n${t.getErrorInfo()}`)}\n\nInput object: ${wo(t.input)}`; let e, n }; const Go = function (t, e) { return Lo(t, e) }; const Xo = U(Io); const Yo = function (n, o) { return Mo((t) => { const e = typeof t; return n(t) ? ao(t) : co(`Expected type: ${o} but got: ${e}`) }) }; const qo = Yo(k, 'number'); const Ko = Yo(x, 'string'); const Jo = Yo(z, 'boolean'); const $o = Yo(S, 'function'); const Qo = function (e) { return Ro((t) => M(e, t) ? ft.value(t) : ft.error(`Unsupported value: "${t}", choose one of "${e.join(', ')}".`)) }; const Zo = function (t) { return _o(t, t, $n(), To()) }; const tr = function (t, e) { return _o(t, t, $n(), e) }; const er = function (t) { return tr(t, Ko) }; const nr = function (t, e) { return _o(t, t, $n(), Qo(e)) }; const or = function (t) { return tr(t, $o) }; const rr = function (t, e) { return _o(t, t, $n(), Vo(e)) }; const ir = function (t, e) { return _o(t, t, $n(), Bo(e)) }; const ar = function (t, e) { return _o(t, t, $n(), Eo(e)) }; const ur = function (t) { return _o(t, t, Qn(), To()) }; const cr = function (t, e) { return _o(t, t, Qn(), e) }; const sr = function (t) { return cr(t, Ko) }; const lr = function (t) { return cr(t, $o) }; const fr = function (t, e) { return _o(t, t, Qn(), Vo(e)) }; const dr = function (t, e) { return _o(t, t, Jn(e), To()) }; const mr = function (t, e, n) { return _o(t, t, Jn(e), n) }; const hr = function (t, e) { return mr(t, e, qo) }; const gr = function (t, e) { return mr(t, e, Ko) }; const vr = function (t, e, n) { return mr(t, e, Qo(n)) }; const pr = function (t, e) { return mr(t, e, Jo) }; const br = function (t, e) { return mr(t, e, $o) }; const yr = function (t, e, n) { return _o(t, t, Jn(e), Vo(n)) }; const xr = function (t, e) { return Do(t, e) }; const wr = function (t, e) { return nn(t.element(), e.event().target()) }; const zr = function (t) { if (!kt(t, 'can') && !kt(t, 'abort') && !kt(t, 'run')) throw new Error(`EventHandler defined by: ${xo(t, null, 2)} does not have can, abort, or run!`); return Uo('Extracting event.handler', Ho([dr('can', U(!0)), dr('abort', U(!1)), dr('run', N)]), t) }; const Sr = function (n) { let e; let o; let r; let i; const t = (e = n, o = function (t) { return t.can }, function () { for (var n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t]; return D(e, (t, e) => t && o(e).apply(undefined, n), !0) }); const a = (r = n, i = function (t) { return t.abort }, function () { for (var n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t]; return D(r, (t, e) => t || i(e).apply(undefined, n), !1) }); return zr({ can: t, abort: a, run() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; A(n, (t) => { t.run.apply(undefined, e) }) } }) }; const kr = function (t, e) { Hr(t, t.element(), e, {}) }; const Cr = function (t, e, n) { Hr(t, t.element(), e, n) }; const Or = function (t) { kr(t, Se()) }; const Mr = function (t, e, n) { Hr(t, e, n, {}) }; var Hr = function (t, e, n, o) { const r = Gn({ target: e }, o); t.getSystem().triggerEvent(n, e, et(r, U)) }; const Vr = function (t, e, n, o) { t.getSystem().triggerEvent(n, e, o.event()) }; function Er(t, e, n, o, r) { return t(n, o) ? P.some(n) : S(r) && r(n) ? P.none() : e(n, o, r) } let Ar; let Tr; let Br; const Dr = function (t) { const e = zn(t) ? t.dom().parentNode : t.dom(); return e !== undefined && e !== null && e.ownerDocument.body.contains(e) }; const _r = Xt(() => Fr(Ne.fromDom(document))); var Fr = function (t) { const e = t.dom().body; if (e === null || e === undefined) throw new Error('Body is not available yet'); return Ne.fromDom(e) }; const Lr = function (t, e, n) { for (let o = t.dom(), r = S(n) ? n : U(!1); o.parentNode;) { o = o.parentNode; const i = Ne.fromDom(o); if (e(i)) return P.some(i); if (r(i)) break } return P.none() }; const Ir = function (t, e, n) { return Er((t) => e(t), Lr, t, e, n) }; const Rr = function (t, o) { var r = function (t) { for (let e = 0; e < t.childNodes.length; e++) { if (o(Ne.fromDom(t.childNodes[e]))) return P.some(Ne.fromDom(t.childNodes[e])); const n = r(t.childNodes[e]); if (n.isSome()) return n } return P.none() }; return r(t.dom()) }; const Nr = function (t, e, n) { return Ir(t, (t) => e(t).isSome(), n).bind(e) }; const Pr = function (t) { return zt(t) }; const jr = function (t, e) { return { key: t, value: zr({ abort: e }) } }; const Ur = function (t) { return { key: t, value: zr({ run(t, e) { e.event().prevent() } }) } }; const Wr = function (t, e) { return { key: t, value: zr({ run: e }) } }; const Gr = function (t, e, n) { return { key: t, value: zr({ run(t) { e.apply(undefined, [t].concat(n)) } }) } }; const Xr = function (t) { return function (n) { return { key: t, value: zr({ run(t, e) { wr(t, e) && n(t, e) } }) } } }; const Yr = function (t, e, n) { let o; let r; const i = e.partUids[n]; return r = i, Wr(o = t, (t, e) => { t.getSystem().getByUid(r).each((t) => { Vr(t, t.element(), o, e) }) }) }; const qr = function (t, r) { return Wr(t, (e, t) => { const n = t.event(); const o = e.getSystem().getByDom(n.target()).fold(() => Nr(n.target(), (t) => e.getSystem().getByDom(t).toOption(), U(!1)).getOr(e), (t) => t); r(e, o, t) }) }; const Kr = function (t) { return Wr(t, (t, e) => { e.cut() }) }; const Jr = function (t) { return Wr(t, (t, e) => { e.stop() }) }; const $r = function (t, e) { return Xr(t)(e) }; const Qr = Xr(Te()); const Zr = Xr(Be()); const ti = Xr(Ee()); const ei = (Ar = Se(), function (t) { return Wr(Ar, t) }); const ni = Pr([(Tr = xe(), Br = function (t, e) { let n; let o; const r = e.event().originator(); const i = e.event().target(); return o = i, !(nn(n = r, t.element()) && !nn(n, o) && (console.warn(`${xe()} did not get interpreted by the desired target. \nOriginator: ${Tn(r)}\nTarget: ${Tn(i)}\nCheck the ${xe()} event handlers`), 1)) }, { key: Tr, value: zr({ can: Br }) })]); const oi = Object.freeze({ events: ni }); const ri = U('alloy-id-'); const ii = U('data-alloy-id'); const ai = ri(); const ui = ii(); const ci = function (t, e) { Object.defineProperty(t.dom(), ui, { value: e, writable: !0 }) }; const si = function (t) { const e = wn(t) ? t.dom()[ui] : null; return P.from(e) }; const li = function (t) { return Un(t) }; const fi = d; const di = function (e) { const t = function (t) { return function () { throw new Error(`The component must be in a context to send: ${t}\n${Tn(e().element())} is not in context.`) } }; return { debugInfo: U('fake'), triggerEvent: t('triggerEvent'), triggerFocus: t('triggerFocus'), triggerEscape: t('triggerEscape'), build: t('build'), addToWorld: t('addToWorld'), removeFromWorld: t('removeFromWorld'), addToGui: t('addToGui'), removeFromGui: t('removeFromGui'), getByUid: t('getByUid'), getByDom: t('getByDom'), broadcast: t('broadcast'), broadcastOn: t('broadcastOn'), broadcastEvent: t('broadcastEvent'), isConnected: U(!1) } }; const mi = di(); const hi = function (t) { return E(t, (t) => { return o = e = '/*', r = (n = t).length - e.length, o !== '' && (n.length < o.length || n.substr(r, r + o.length) !== o) ? t : t.substring(0, t.length - '/*'.length); let e, n, o, r }) }; const gi = function (t, e) { const n = t.toString(); const o = n.indexOf(')') + 1; const r = n.indexOf('('); const i = n.substring(r + 1, o - 1).split(/,\s*/); return t.toFunctionAnnotation = function () { return { name: e, parameters: hi(i) } }, t }; const vi = Un('alloy-premade'); const pi = function (t) { return wt(vi, t) }; const bi = function (o) { return t = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; return o.apply(undefined, [t.getApis()].concat([t].concat(e))) }, e = o.toString(), n = e.indexOf(')') + 1, r = e.indexOf('('), i = e.substring(r + 1, n - 1).split(/,\s*/), t.toFunctionAnnotation = function () { return { name: 'OVERRIDE', parameters: hi(i.slice(1)) } }, t; let t, e, n, r, i }; const yi = { init() { return xi({ readState() { return 'No State required' } }) } }; var xi = function (t) { return t }; const wi = function (t, r) { const i = {}; return tt(t, (t, o) => { tt(t, (t, e) => { const n = yt(e, [])(i); i[e] = n.concat([r(o, t)]) }) }), i }; const zi = function (t) { return { classes: t.classes !== undefined ? t.classes : [], attributes: t.attributes !== undefined ? t.attributes : {}, styles: t.styles !== undefined ? t.styles : {} } }; const Si = function (t, e) { return n = f.apply(undefined, [t.handler].concat(e)), o = t.purpose(), { cHandler: n, purpose: U(o) }; let n, o }; const ki = function (t) { return t.cHandler }; const Ci = function (t, e) { return { name: U(t), handler: U(e) } }; const Oi = function (t, e, n) { let o; let r; const i = Gn({}, n, (o = t, r = {}, A(e, (t) => { r[t.name()] = t.handlers(o) }), r)); return wi(i, Ci) }; const Mi = function (t) { let e; const i = S(e = t) ? { can: U(!0), abort: U(!1), run: e } : e; return function (t, e) { for (var n = [], o = 2; o < arguments.length; o++)n[o - 2] = arguments[o]; const r = [t, e].concat(n); i.abort.apply(undefined, r) ? e.stop() : i.can.apply(undefined, r) && i.run.apply(undefined, r) } }; const Hi = function (t, e, n) { let o; let r; const i = e[n]; return i ? (function (a, u, t, c) { const e = t.slice(0); try { const n = e.sort((t, e) => { const n = t[u](); const o = e[u](); const r = c.indexOf(n); const i = c.indexOf(o); if (r === -1) throw new Error(`The ordering for ${a} does not have an entry for ${n}.\nOrder specified: ${xo(c, null, 2)}`); if (i === -1) throw new Error(`The ordering for ${a} does not have an entry for ${o}.\nOrder specified: ${xo(c, null, 2)}`); return r < i ? -1 : i < r ? 1 : 0 }); return ft.value(n) } catch (o) { return ft.error([o]) } }(`Event: ${n}`, 'name', t, i)).map((t) => { const e = E(t, (t) => t.handler()); return Sr(e) }) : (o = n, r = t, ft.error([`The event (${o}) has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ${xo(E(r, (t) => t.name()), null, 2)}`])) }; const Vi = function (t, i) { const e = ot(t, (o, r) => (o.length === 1 ? ft.value(o[0].handler()) : Hi(o, i, r)).map((t) => { const e = Mi(t); const n = o.length > 1 ? T(i, (e) => M(o, (t) => t.name() === e)).join(' > ') : o[0].name(); return wt(r, { handler: e, purpose: U(n) }) })); return St(e, {}) }; const Ei = function (t) { return Po('custom.definition', Vo([_o('dom', 'dom', $n(), Vo([Zo('tag'), dr('styles', {}), dr('classes', []), dr('attributes', {}), ur('value'), ur('innerHtml')])), Zo('components'), Zo('uid'), dr('events', {}), dr('apis', {}), _o('eventOrder', 'eventOrder', (e = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'typeaheadevents'], 'alloy.focus': ['alloy.base.behaviour', 'focusing', 'keying'], 'alloy.system.init': ['alloy.base.behaviour', 'disabling', 'toggling', 'representing'], input: ['alloy.base.behaviour', 'representing', 'streaming', 'invalidating'], 'alloy.system.detached': ['alloy.base.behaviour', 'representing'], mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events'] }, Kn.mergeWithThunk(U(e))), Xo()), ur('domModification')]), t); let e }; const Ai = function (t, e) { const n = Mn(t, e); return n === undefined || n === '' ? [] : n.split(' ') }; const Ti = function (t) { return t.dom().classList !== undefined }; const Bi = function (t, e) { return r = e, i = Ai(n = t, o = 'class').concat([r]), Cn(n, o, i.join(' ')), !0; let n, o, r, i }; const Di = function (t, e) { return r = e, (i = T(Ai(n = t, o = 'class'), (t) => t !== r)).length > 0 ? Cn(n, o, i.join(' ')) : Vn(n, o), !1; let n, o, r, i }; const _i = function (t, e) { Ti(t) ? t.dom().classList.add(e) : Bi(t, e) }; const Fi = function (t) { (Ti(t) ? t.dom().classList : Ai(t, 'class')).length === 0 && Vn(t, 'class') }; const Li = function (t, e) { Ti(t) ? t.dom().classList.remove(e) : Di(t, e), Fi(t) }; const Ii = function (t, e) { return Ti(t) && t.dom().classList.contains(e) }; const Ri = function (e, t) { A(t, (t) => { _i(e, t) }) }; const Ni = function (e, t) { A(t, (t) => { Li(e, t) }) }; const Pi = function (t) { return t.style !== undefined }; const ji = function (t, e, n) { if (!x(n)) throw console.error('Invalid call to CSS.set. Property ', e, ':: Value ', n, ':: Element ', t), new Error(`CSS value must be a string: ${n}`); Pi(t) && t.style.setProperty(e, n) }; const Ui = function (t, e) { Pi(t) && t.style.removeProperty(e) }; const Wi = function (t, e, n) { const o = t.dom(); ji(o, e, n) }; const Gi = function (t, e) { const n = t.dom(); tt(e, (t, e) => { ji(n, e, t) }) }; const Xi = function (t, e) { const n = t.dom(); const o = window.getComputedStyle(n).getPropertyValue(e); const r = o !== '' || Dr(t) ? o : Yi(n, e); return r === null ? undefined : r }; var Yi = function (t, e) { return Pi(t) ? t.style.getPropertyValue(e) : '' }; const qi = function (t, e) { const n = t.dom(); const o = Yi(n, e); return P.from(o).filter((t) => t.length > 0) }; const Ki = function (t, e, n) { const o = Ne.fromTag(t); return Wi(o, e, n), qi(o, e).isSome() }; const Ji = function (t, e) { const n = t.dom(); Ui(n, e), Hn(t, 'style') && Mn(t, 'style').replace(/^\s+|\s+$/g, '') === '' && Vn(t, 'style') }; const $i = function (t) { return t.dom().offsetWidth }; const Qi = function (t) { return t.dom().value }; const Zi = function (t, e) { if (e === undefined) throw new Error('Value.set was undefined'); t.dom().value = e }; const ta = function (t, e) { return n = t, r = E(o = e, (t) => fr(t.name(), [Zo('config'), dr('state', yi)])), i = Po('component.behaviours', Vo(r), n.behaviours).fold((t) => { throw new Error(`${Wo(t)}\nComplete spec:\n${xo(n, null, 2)}`) }, (t) => t), { list: o, data: et(i, (t) => { const e = t.map((t) => ({ config: t.config, state: t.state.init(t.config) })); return function () { return e } }) }; let n, o, r, i }; const ea = function (t) { let e; let n; let o; const r = (e = t, n = yt('behaviours', {})(e), o = T(Q(n), (t) => n[t] !== undefined), E(o, (t) => n[t].me)); return ta(t, r) }; const na = function (t, e, n) { let o; let r; let i; const a = Gn({}, (o = t).dom, { uid: o.uid, domChildren: E(o.components, (t) => t.element()) }); const u = t.domModification.fold(() => zi({}), zi); const c = { 'alloy.base.modification': u }; const s = e.length > 0 ? (function (e, t, n, o) { const r = Gn({}, t); A(n, (t) => { r[t.name()] = t.exhibit(e, o) }); const i = wi(r, (t, e) => ({ name: t, modification: e })); const a = function (t) { return B(t, (t, e) => Gn({}, e.modification, t), {}) }; const u = B(i.classes, (t, e) => e.modification.concat(t), []); const c = a(i.attributes); const s = a(i.styles); return zi({ classes: u, attributes: c, styles: s }) }(n, c, e, a)) : u; return i = s, Gn({}, r = a, { attributes: Gn({}, r.attributes, i.attributes), styles: Gn({}, r.styles, i.styles), classes: r.classes.concat(i.classes) }) }; const oa = function (t, e, n) { let o; let r; let i; let a; let u; let c; const s = { 'alloy.base.behaviour': (o = t, o.events) }; return (r = n, i = t.eventOrder, a = e, u = s, c = Oi(r, a, u), Vi(c, i)).getOrDie() }; const ra = function (n) { const t = function () { return l }; const o = Ct(mi); const e = jo(Ei(n)); const r = ea(n); const i = r.list; const a = r.data; const u = (function (t) { const e = Ne.fromTag(t.tag); On(e, t.attributes), Ri(e, t.classes), Gi(e, t.styles), t.innerHtml.each((t) => bn(e, t)); const n = t.domChildren; return hn(e, n), t.value.each((t) => { Zi(e, t) }), t.uid, ci(e, t.uid), e }(na(e, i, a))); const c = oa(e, i, a); const s = Ct(e.components); var l = { getSystem: o.get, config(t) { const e = a; return (S(e[t.name()]) ? e[t.name()] : function () { throw new Error(`Could not find ${t.name()} in ${xo(n, null, 2)}`) })() }, hasConfigured(t) { return S(a[t.name()]) }, spec: U(n), readState(t) { return a[t]().map((t) => t.state.readState()).getOr('not enabled') }, getApis() { return e.apis }, connect(t) { o.set(t) }, disconnect() { o.set(di(t)) }, element: U(u), syncComponents() { const t = cn(u); const e = j(t, (t) => o.get().getByDom(t).fold(() => [], (t) => [t])); s.set(e) }, components: s.get, events: U(c) }; return l }; const ia = function (t) { let e; let n; const o = fi(t); const r = o.events; const i = Xn(o, ['events']); const a = (e = i, n = yt('components', [])(e), E(n, sa)); const u = Gn({}, i, { events: Gn({}, oi, r), components: a }); return ft.value(ra(u)) }; const aa = function (t) { const e = Ne.fromText(t); return ua({ element: e }) }; var ua = function (t) { const e = Uo('external.component', Ho([Zo('element'), ur('uid')]), t); const n = Ct(di()); e.uid.each((t) => { ci(e.element, t) }); var o = { getSystem: n.get, config: P.none, hasConfigured: U(!1), connect(t) { n.set(t) }, disconnect() { n.set(di(() => o)) }, getApis() { return {} }, element: U(e.element), spec: U(t), readState: U('No state'), syncComponents: N, components: U([]), events: U({}) }; return pi(o) }; const ca = li; var sa = function (e) { return (t = e, xt(t, vi)).fold(() => { const t = e.hasOwnProperty('uid') ? e : Gn({ uid: ca('') }, e); return ia(t).getOrDie() }, (t) => t); let t }; const la = pi; const fa = function (t, e, n) { return Lr(t, (t) => Ze(t, e), n) }; const da = function (t, e) { return n = e, r = (o = t) === undefined ? document : o.dom(), tn(r) ? P.none() : P.from(r.querySelector(n)).map(Ne.fromDom); let n, o, r }; const ma = function (t, e, n) { return Er(Ze, fa, t, e, n) }; const ha = function (e, t) { return (n = t, Ir(n, (t) => { if (!wn(t)) return !1; const e = Mn(t, 'id'); return e !== undefined && e.indexOf('aria-owns') > -1 }).bind((t) => { const e = Mn(t, 'id'); const n = on(t); return da(n, `[aria-owns="${e}"]`) })).exists((t) => ga(e, t)); let n }; var ga = function (e, t) { return n = t, r = U(!(o = function (t) { return nn(t, e.element()) })), Ir(n, o, r).isSome() || ha(e, t); let n, o, r }; const va = U([Zo('menu'), Zo('selectedMenu')]); const pa = U([Zo('item'), Zo('selectedItem')]); const ba = (U(Vo(pa().concat(va()))), U(Vo(pa()))); const ya = rr('initSize', [Zo('numColumns'), Zo('numRows')]); const xa = function () { return rr('markers', [Zo('backgroundMenu')].concat(va()).concat(pa())) }; const wa = function (t) { return rr('markers', E(t, Zo)) }; const za = function (t, e, n) { return (function () { const t = new Error(); if (t.stack !== undefined) { const e = t.stack.split('\n'); _(e, (e) => e.indexOf('alloy') > 0 && !H(Ln, (t) => e.indexOf(t) > -1)).getOr(Bn) } }()), _o(e, e, n, Ro((n) => ft.value(function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return n.apply(undefined, t) }))) }; const Sa = function (t) { return za(0, t, Jn(N)) }; const ka = function (t) { return za(0, t, Jn(P.none)) }; const Ca = function (t) { return za(0, t, $n()) }; const Oa = function (t) { return za(0, t, $n()) }; const Ma = function (t, e) { return xr(t, U(e)) }; const Ha = function (t) { return xr(t, d) }; const Va = U(ya); const Ea = function (n, o, r) { return ti((t, e) => { r(t, n, o) }) }; const Aa = function (t, e, n, o, r, i) { let a; let u; const c = Ho(t); const s = fr(e, [(a = 'config', u = t, _o(a, a, Qn(), Ho(u)))]); return Da(c, s, e, n, o, r, i) }; const Ta = function (r, i, a) { let t, e, n, o, u, c; return t = function (n) { for (var t = [], e = 1; e < arguments.length; e++)t[e - 1] = arguments[e]; const o = [n].concat(t); return n.config({ name: U(r) }).fold(() => { throw new Error(`We could not find any behaviour configuration for: ${r}. Using API: ${a}`) }, (t) => { const e = Array.prototype.slice.call(o, 1); return i.apply(undefined, [n, t.config, t.state].concat(e)) }) }, e = a, n = i.toString(), o = n.indexOf(')') + 1, u = n.indexOf('('), c = n.substring(u + 1, o - 1).split(/,\s*/), t.toFunctionAnnotation = function () { return { name: e, parameters: hi(c.slice(0, 1).concat(c.slice(3))) } }, t }; const Ba = function (t) { return { key: t, value: undefined } }; var Da = function (n, t, o, r, e, i, a) { const u = function (t) { return kt(t, o) ? t[o]() : P.none() }; const c = et(e, (t, e) => Ta(o, t, e)); const s = et(i, (t, e) => gi(t, e)); var l = Gn({}, s, c, { revoke: f(Ba, o), config(t) { const e = Uo(`${o}-config`, n, t); return { key: o, value: { config: e, me: l, configAsRaw: Xt(() => Uo(`${o}-config`, n, t)), initialConfig: t, state: a } } }, schema() { return t }, exhibit(t, n) { return u(t).bind((e) => xt(r, 'exhibit').map((t) => t(n, e.config, e.state))).getOr(zi({})) }, name() { return o }, handlers(t) { return u(t).map((t) => yt('events', (t, e) => ({}))(r)(t.config, t.state)).getOr({}) } }); return l }; const _a = function (t) { return zt(t) }; const Fa = Ho([Zo('fields'), Zo('name'), dr('active', {}), dr('apis', {}), dr('state', yi), dr('extra', {})]); const La = function (t) { const e = Uo(`Creating behaviour: ${t.name}`, Fa, t); return Aa(e.fields, e.name, e.active, e.apis, e.extra, e.state) }; const Ia = Ho([Zo('branchKey'), Zo('branches'), Zo('name'), dr('active', {}), dr('apis', {}), dr('state', yi), dr('extra', {})]); const Ra = function (t) { let e; let n; let o; let r; let i; let a; let u; let c; const s = Uo(`Creating behaviour: ${t.name}`, Ia, t); return e = Go(s.branchKey, s.branches), n = s.name, o = s.active, r = s.apis, i = s.extra, a = s.state, c = fr(n, [cr('config', u = e)]), Da(u, c, n, o, r, i, a) }; const Na = U(undefined); const Pa = Object.freeze({ events(u) { return Pr([Wr(ze(), (r, i) => { let t; let e; const a = u.channels; const n = Q(a); const o = (t = n, (e = i).universal() ? t : T(t, (t) => M(e.channels(), t))); A(o, (t) => { const e = a[t]; const n = e.schema; const o = Uo(`channel[${t}] data\nReceiver: ${Tn(r.element())}`, n, i.data()); e.onReceive(r, o) }) })]) } }); const ja = [tr('channels', No(ft.value, Ho([Ca('onReceive'), dr('schema', Xo())])))]; const Ua = La({ fields: ja, name: 'receiving', active: Pa }); const Wa = Object.freeze({ exhibit(t, e) { return zi({ classes: [], styles: e.useFixed ? {} : { position: 'relative' } }) } }); var Ga = function (n, o) { return { left: U(n), top: U(o), translate(t, e) { return Ga(n + t, o + e) } } }; const Xa = Ga; const Ya = function (t, e) { return t !== undefined ? t : e !== undefined ? e : 0 }; const qa = function (t) { let e; let n; const o = t.dom().ownerDocument; const r = o.body; const i = (e = Ne.fromDom(o), (n = e.dom()) === n.window && e instanceof Window ? e : Sn(e) ? n.defaultView || n.parentWindow : null); const a = o.documentElement; const u = Ya(i.pageYOffset, a.scrollTop); const c = Ya(i.pageXOffset, a.scrollLeft); const s = Ya(a.clientTop, r.clientTop); const l = Ya(a.clientLeft, r.clientLeft); return Ka(t).translate(c - l, u - s) }; var Ka = function (t) { let e; let n; let o; const r = t.dom(); const i = r.ownerDocument; const a = i.body; const u = Ne.fromDom(i.documentElement); return a === r ? Xa(a.offsetLeft, a.offsetTop) : (e = t, n = u || Ne.fromDom(document.documentElement), Lr(e, f(nn, n)).isSome() ? (o = r.getBoundingClientRect(), Xa(o.left, o.top)) : Xa(0, 0)) }; const Ja = (be.detect().browser.isSafari(), function (t) { const e = t !== undefined ? t.dom() : document; const n = e.body.scrollLeft || e.documentElement.scrollLeft; const o = e.body.scrollTop || e.documentElement.scrollTop; return Xa(n, o) }); function $a(o, r) { const t = function (t) { const e = r(t); if (e <= 0 || e === null) { const n = Xi(t, o); return parseFloat(n) || 0 } return e }; const i = function (r, t) { return D(t, (t, e) => { const n = Xi(r, e); const o = n === undefined ? 0 : parseInt(n, 10); return isNaN(o) ? t : t + o }, 0) }; return { set(t, e) { if (!k(e) && !e.match(/^[0-9]+$/)) throw new Error(`${o}.set accepts only positive integer values. Value was ${e}`); const n = t.dom(); Pi(n) && (n.style[o] = `${e}px`) }, get: t, getOuter: t, aggregate: i, max(t, e, n) { const o = i(t, n); return o < e ? e - o : 0 } } } let Qa; let Za; const tu = $a('width', (t) => t.dom().offsetWidth); const eu = function (t) { return tu.get(t) }; const nu = function (t) { return tu.getOuter(t) }; const ou = $a('height', (t) => { const e = t.dom(); return Dr(t) ? e.getBoundingClientRect().height : e.offsetHeight }); const ru = function (t) { return ou.get(t) }; const iu = function (t) { return ou.getOuter(t) }; const au = We(['x', 'y', 'width', 'height', 'maxHeight', 'direction', 'classes', 'label', 'candidateYforTest'], []); const uu = Pe('position', 'left', 'top', 'right', 'bottom'); const cu = dt([{ southeast: [] }, { southwest: [] }, { northeast: [] }, { northwest: [] }, { south: [] }, { north: [] }, { east: [] }, { west: [] }]); const su = cu.southeast; const lu = cu.southwest; const fu = cu.northeast; const du = cu.northwest; const mu = cu.south; const hu = cu.north; const gu = cu.east; const vu = cu.west; const pu = Pe('point', 'width', 'height'); const bu = Pe('x', 'y', 'width', 'height'); const yu = function (t, e, n, o) { return { x: U(t), y: U(e), width: U(n), height: U(o), right: U(t + n), bottom: U(e + o) } }; const xu = function (t) { const e = qa(t); const n = nu(t); const o = iu(t); return yu(e.left(), e.top(), n, o) }; var wu = function (o, t) { return o.view(t).fold(U([]), (t) => { const e = o.owner(t); const n = wu(o, e); return [t].concat(n) }) }; const zu = Object.freeze({ view(t) { return (t.dom() === document ? P.none() : P.from(t.dom().defaultView.frameElement)).map(Ne.fromDom) }, owner(t) { return on(t) } }); const Su = function (o) { let t; let e; let n; let r; const i = Ne.fromDom(document); const a = Ja(i); return (t = o, n = (e = zu).owner(t), r = wu(e, n), P.some(r)).fold(f(qa, o), (t) => { const e = Ka(o); const n = B(t, (t, e) => { const n = Ka(e); return { left: t.left + n.left(), top: t.top + n.top() } }, { left: 0, top: 0 }); return Xa(n.left + e.left() + a.left(), n.top + e.top() + a.top()) }) }; const ku = function () { const t = window.innerWidth; const e = window.innerHeight; const n = Ne.fromDom(document); const o = Ja(n); return yu(o.left(), o.top(), t, e) }; const Cu = dt([{ none: [] }, { relative: ['x', 'y', 'width', 'height'] }, { fixed: ['x', 'y', 'width', 'height'] }]); const Ou = function (t, e, n, o, r, i) { let a; let u; let c; let s; let l; let f; let d; let m; let h; const g = e.x() - n; const v = e.y() - o; const p = r - (g + e.width()); const b = i - (v + e.height()); const y = P.some(g); const x = P.some(v); const w = P.some(p); const z = P.some(b); const S = P.none(); return a = e.direction(), u = function () { return uu(t, y, x, S, S) }, c = function () { return uu(t, S, x, w, S) }, s = function () { return uu(t, y, S, S, z) }, l = function () { return uu(t, S, S, w, z) }, f = function () { return uu(t, y, x, S, S) }, d = function () { return uu(t, y, S, S, z) }, m = function () { return uu(t, y, x, S, S) }, h = function () { return uu(t, S, x, w, S) }, a.fold(u, c, s, l, f, d, m, h) }; const Mu = function (t, e) { const n = f(Su, e); const o = t.fold(n, n, () => { const t = Ja(); return Su(e).translate(-t.left(), -t.top()) }); const r = nu(e); const i = iu(e); return yu(o.left(), o.top(), r, i) }; const Hu = Cu.relative; const Vu = Cu.fixed; const Eu = Pe('anchorBox', 'origin'); const Au = dt([{ fit: ['reposition'] }, { nofit: ['reposition', 'deltaW', 'deltaH'] }]); const Tu = function (t, L, I, R, N) { const P = I.width(); const j = I.height(); const o = function (t, o, r, i) { let e; let n; let a; let u; let c; let s; let l; let f; let d; let m; let h; let g; let v; let p; let b; let y; let x; let w; let z; let S; let k; let C; let O; let M; let H; let V; let E; let A; let T; let B; let D; let _; const F = t(L, I, R); return (n = P, a = j, u = N, d = (e = F).x(), m = e.y(), h = e.bubble().offset().left(), g = e.bubble().offset().top(), v = u.x(), p = u.y(), b = u.width(), y = u.height(), S = p <= (w = m + g), k = (z = v <= (x = d + h)) && S, C = x + n <= v + b && w + a <= p + y, O = z ? Math.min(n, v + b - x) : Math.abs(v - (x + n)), M = S ? Math.min(a, p + y - w) : Math.abs(p - (w + a)), H = u.x() + u.width(), V = Math.max(u.x(), x), E = Math.min(V, H), T = U((A = S ? w : w + (a - M)) + M - p), B = U(p + y - A), c = e.direction(), l = s = B, f = T, D = c.fold(s, s, f, f, s, f, l, l), _ = au({ x: E, y: A, width: O, height: M, maxHeight: D, direction: e.direction(), classes: { on: e.bubble().classesOn(), off: e.bubble().classesOff() }, label: e.label(), candidateYforTest: w }), k && C ? Au.fit(_) : Au.nofit(_, O, M)).fold(Au.fit, (t, e, n) => i < n || r < e ? Au.nofit(t, e, n) : Au.nofit(o, r, i)) }; return D(t, (t, e) => { const n = f(o, e); return t.fold(Au.fit, n) }, Au.nofit(au({ x: L.x(), y: L.y(), width: I.width(), height: I.height(), maxHeight: I.height(), direction: su(), classes: [], label: 'none', candidateYforTest: L.y() }), -1, -1)).fold(d, d) }; const Bu = function (t, e, n, o) { Ji(e, 'max-height'); let r; const i = { width: U(nu(r = e)), height: U(iu(r)) }; return Tu(o.preference(), t, i, n, o.bounds()) }; const Du = function (t, e, n) { let o; let r; let i; let a; let u; const c = function (t) { return `${t}px` }; const s = (o = n.origin(), r = e, o.fold(() => uu('absolute', P.some(r.x()), P.some(r.y()), P.none(), P.none()), (t, e, n, o) => Ou('absolute', r, t, e, n, o), (t, e, n, o) => Ou('fixed', r, t, e, n, o))); i = t, a = { position: P.some(s.position()), left: s.left().map(c), top: s.top().map(c), right: s.right().map(c), bottom: s.bottom().map(c) }, u = i.dom(), tt(a, (t, e) => { t.fold(() => { Ui(u, e) }, (t) => { ji(u, e, t) }) }) }; const _u = function (t, e) { let n, o, r; n = t, o = Math.floor(e), r = ou.max(n, o, ['margin-top', 'border-top-width', 'padding-top', 'padding-bottom', 'border-bottom-width', 'margin-bottom']), Wi(n, 'max-height', `${r}px`) }; const Fu = U((t, e) => { _u(t, e), Gi(t, { 'overflow-x': 'hidden', 'overflow-y': 'auto' }) }); const Lu = U((t, e) => { _u(t, e) }); const Iu = We(['bounds', 'origin', 'preference', 'maxHeightFunction'], []); const Ru = function (t, e, n, o, r, i) { let a; let u; let c; let s; let l; const f = (a = i, u = 'maxHeightFunction', c = Fu(), a[u] === undefined ? c : a[u]); const d = t.anchorBox(); const m = t.origin(); const h = Iu({ bounds: (s = m, l = r, l.fold(() => s.fold(ku, ku, yu), (t) => s.fold(t, t, yu))), origin: m, preference: o, maxHeightFunction: f }); Nu(d, e, n, h) }; var Nu = function (t, e, n, o) { let r; let i; let a; let u; const c = Bu(t, e, n, o); Du(e, c, o), r = e, i = c.classes(), Ni(r, i.off), Ri(r, i.on), a = e, u = c, o.maxHeightFunction()(a, u.maxHeight()) }; const Pu = ['valignCentre', 'alignLeft', 'alignRight', 'alignCentre', 'top', 'bottom', 'left', 'right']; const ju = function (t, e, n) { const r = function (t) { return xt(n, t).getOr([]) }; const o = function (t, e, n) { const o = Y(Pu, n); return { offset() { return Xa(t, e) }, classesOn() { return j(n, r) }, classesOff() { return j(o, r) } } }; return { southeast() { return o(-t, e, ['top', 'alignLeft']) }, southwest() { return o(t, e, ['top', 'alignRight']) }, south() { return o(-t / 2, e, ['top', 'alignCentre']) }, northeast() { return o(-t, -e, ['bottom', 'alignLeft']) }, northwest() { return o(t, -e, ['bottom', 'alignRight']) }, north() { return o(-t / 2, -e, ['bottom', 'alignCentre']) }, east() { return o(t, -e / 2, ['valignCentre', 'left']) }, west() { return o(-t, -e / 2, ['valignCentre', 'right']) } } }; const Uu = function () { return ju(0, 0, {}) }; const Wu = Pe('x', 'y', 'bubble', 'direction', 'label'); const Gu = function (t) { return t.x() }; const Xu = function (t, e) { return t.x() + t.width() / 2 - e.width() / 2 }; const Yu = function (t, e) { return t.x() + t.width() - e.width() }; const qu = function (t, e) { return t.y() - e.height() }; const Ku = function (t) { return t.y() + t.height() }; const Ju = function (t, e) { return t.y() + t.height() / 2 - e.height() / 2 }; const $u = function (t, e, n) { return Wu(Gu(t), Ku(t), n.southeast(), su(), 'layout-se') }; const Qu = function (t, e, n) { return Wu(Yu(t, e), Ku(t), n.southwest(), lu(), 'layout-sw') }; const Zu = function (t, e, n) { return Wu(Gu(t), qu(t, e), n.northeast(), fu(), 'layout-ne') }; const tc = function (t, e, n) { return Wu(Yu(t, e), qu(t, e), n.northwest(), du(), 'layout-nw') }; const ec = function (t, e, n) { return Wu(Xu(t, e), qu(t, e), n.north(), hu(), 'layout-n') }; const nc = function (t, e, n) { return Wu(Xu(t, e), Ku(t), n.south(), mu(), 'layout-s') }; const oc = function (t, e, n) { return Wu((o = t).x() + o.width(), Ju(t, e), n.east(), gu(), 'layout-e'); let o }; const rc = function (t, e, n) { return Wu((o = e, t.x() - o.width()), Ju(t, e), n.west(), vu(), 'layout-w'); let o }; const ic = function () { return [$u, Qu, Zu, tc, nc, ec, oc, rc] }; const ac = function () { return [Qu, $u, tc, Zu, nc, ec, oc, rc] }; const uc = function (t) { return t }; const cc = function (e, n) { return function (t) { return sc(t) === 'rtl' ? n : e } }; var sc = function (t) { return Xi(t, 'direction') === 'rtl' ? 'rtl' : 'ltr' }; const lc = function () { return fr('layouts', [Zo('onLtr'), Zo('onRtl')]) }; const fc = function (e, t, n, o) { const r = t.layouts.map((t) => t.onLtr(e)).getOr(n); const i = t.layouts.map((t) => t.onRtl(e)).getOr(o); return cc(r, i)(e) }; const dc = [Zo('hotspot'), lc(), Ma('placement', (t, e, n) => { const o = e.hotspot; const r = Mu(n, o.element()); const i = fc(t.element(), e, ic(), ac()); return P.some(uc({ anchorBox: r, bubble: Uu(), overrides: {}, layouts: i, placer: P.none() })) })]; const mc = [Zo('x'), Zo('y'), dr('height', 0), dr('width', 0), dr('bubble', Uu()), lc(), Ma('placement', (t, e, n) => { const o = yu(e.x, e.y, e.width, e.height); const r = fc(t.element(), e, ic(), ac()); return P.some(uc({ anchorBox: o, bubble: e.bubble, overrides: {}, layouts: r, placer: P.none() })) })]; const hc = (dt([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]), dt([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }])); const gc = Pe('start', 'soffset', 'finish', 'foffset'); const vc = (hc.domRange, hc.relative, hc.exact); const pc = function (t, e, n, o) { let r; let i; let a; let u; let c; const s = (i = e, a = n, u = o, (c = on(r = t).dom().createRange()).setStart(r.dom(), i), c.setEnd(a.dom(), u), c); const l = nn(t, n) && e === o; return s.collapsed && !l }; const bc = function (t, e, n) { let o; let r; const i = t.document.createRange(); return o = i, e.fold((t) => { o.setStartBefore(t.dom()) }, (t, e) => { o.setStart(t.dom(), e) }, (t) => { o.setStartAfter(t.dom()) }), r = i, n.fold((t) => { r.setEndBefore(t.dom()) }, (t, e) => { r.setEnd(t.dom(), e) }, (t) => { r.setEndAfter(t.dom()) }), i }; const yc = function (t, e, n, o, r) { const i = t.document.createRange(); return i.setStart(e.dom(), n), i.setEnd(o.dom(), r), i }; const xc = function (t) { return { left: U(t.left), top: U(t.top), right: U(t.right), bottom: U(t.bottom), width: U(t.width), height: U(t.height) } }; const wc = dt([{ ltr: ['start', 'soffset', 'finish', 'foffset'] }, { rtl: ['start', 'soffset', 'finish', 'foffset'] }]); const zc = function (t, e, n) { return e(Ne.fromDom(n.startContainer), n.startOffset, Ne.fromDom(n.endContainer), n.endOffset) }; const Sc = function (t, e) { let r; let n; let o; const i = (r = t, e.match({ domRange(t) { return { ltr: U(t), rtl: P.none } }, relative(t, e) { return { ltr: Xt(() => bc(r, t, e)), rtl: Xt(() => P.some(bc(r, e, t))) } }, exact(t, e, n, o) { return { ltr: Xt(() => yc(r, t, e, n, o)), rtl: Xt(() => P.some(yc(r, n, o, t, e))) } } })); return (o = (n = i).ltr()).collapsed ? n.rtl().filter((t) => !1 === t.collapsed).map((t) => wc.rtl(Ne.fromDom(t.endContainer), t.endOffset, Ne.fromDom(t.startContainer), t.startOffset)).getOrThunk(() => zc(0, wc.ltr, o)) : zc(0, wc.ltr, o) }; const kc = (function cV(n, o) { const r = function (t) { return n(t) ? P.from(t.dom().nodeValue) : P.none() }; const t = be.detect().browser; const e = t.isIE() && t.version.major === 10 ? function (t) { try { return r(t) } catch (e) { return P.none() } } : r; return { get(t) { if (!n(t)) throw new Error(`Can only get ${o} value of a ${o} node`); return e(t).getOr('') }, getOption: e, set(t, e) { if (!n(t)) throw new Error(`Can only set raw ${o} value of a ${o} node`); t.dom().nodeValue = e } } }(zn, 'text')); const Cc = function (t) { return kc.get(t) }; const Oc = (document.caretPositionFromPoint || document.caretRangeFromPoint, function (t, e) { return en(e, t) }); const Mc = function (t) { const e = Ne.fromDom(t.anchorNode); const n = Ne.fromDom(t.focusNode); return pc(e, t.anchorOffset, n, t.focusOffset) ? P.some(gc(Ne.fromDom(t.anchorNode), t.anchorOffset, Ne.fromDom(t.focusNode), t.focusOffset)) : (function (t) { if (t.rangeCount > 0) { const e = t.getRangeAt(0); const n = t.getRangeAt(t.rangeCount - 1); return P.some(gc(Ne.fromDom(e.startContainer), e.startOffset, Ne.fromDom(n.endContainer), n.endOffset)) } return P.none() }(t)) }; const Hc = function (t, e) { let i; let n; let o; let r; const a = Sc(i = t, e).match({ ltr(t, e, n, o) { const r = i.document.createRange(); return r.setStart(t.dom(), e), r.setEnd(n.dom(), o), r }, rtl(t, e, n, o) { const r = i.document.createRange(); return r.setStart(n.dom(), o), r.setEnd(t.dom(), e), r } }); return o = (n = a).getClientRects(), (r = o.length > 0 ? o[0] : n.getBoundingClientRect()).width > 0 || r.height > 0 ? P.some(r).map(xc) : P.none() }; const Vc = Pe('element', 'offset'); const Ec = dt([{ screen: ['point'] }, { absolute: ['point', 'scrollLeft', 'scrollTop'] }]); const Ac = function (t) { return t.fold((t) => t, (t, e, n) => t.translate(-e, -n)) }; const Tc = function (t) { return t.fold((t) => t, (t, e, n) => t) }; const Bc = function (t) { return D(t, (t, e) => t.translate(e.left(), e.top()), Xa(0, 0)) }; const Dc = function (t) { const e = E(t, Tc); return Bc(e) }; const _c = Ec.screen; const Fc = Ec.absolute; const Lc = function (t, e, n) { let o; let r; let i; const a = on(t.element()); const u = Ja(a); const c = (o = t, r = n, i = rn(r.root).dom(), P.from(i.frameElement).map(Ne.fromDom).filter((t) => { const e = on(t); const n = on(o.element()); return nn(e, n) }).map(qa)).getOr(u); return Fc(c, u.left(), u.top()) }; const Ic = function (t, e, n, o) { let r = t; let i = e; let a = n; let u = o; t < 0 && (r = 0, a = n + t), e < 0 && (i = 0, u = o + e); const c = _c(Xa(r, i)); return P.some(pu(c, a, u)) }; const Rc = function (t, c, s, l, f) { return t.map((t) => { let e; let n; let o; const r = [c, t.point()]; const i = (e = function () { return Dc(r) }, n = function () { return Dc(r) }, o = function () { return t = E(r, Ac), Bc(t); let t }, l.fold(e, n, o)); const a = bu(i.left(), i.top(), t.width(), t.height()); const u = fc(f, s, s.showAbove ? [Zu, tc, $u, Qu, ec, nc] : [$u, Qu, Zu, tc, nc, nc], s.showAbove ? [tc, Zu, Qu, $u, ec, nc] : [Qu, $u, tc, Zu, nc, ec]); return uc({ anchorBox: a, bubble: s.bubble.getOr(Uu()), overrides: s.overrides, layouts: u, placer: P.none() }) }) }; const Nc = Pe('element', 'offset'); const Pc = function (t, e) { return zn(t) ? Nc(t, e) : (function (t, e) { const n = cn(t); if (n.length === 0) return Vc(t, e); if (e < n.length) return Vc(n[e], 0); const o = n[n.length - 1]; const r = zn(o) ? Cc(o).length : cn(o).length; return Vc(o, r) }(t, e)) }; const jc = function (e, t) { return t.getSelection.getOrThunk(() => function () { return t = e, P.from(t.getSelection()).filter((t) => t.rangeCount > 0).bind(Mc); let t })().map((t) => { const e = Pc(t.start(), t.soffset()); const n = Pc(t.finish(), t.foffset()); return gc(e.element(), e.offset(), n.element(), n.offset()) }) }; const Uc = [ur('getSelection'), Zo('root'), ur('bubble'), lc(), dr('overrides', {}), dr('showAbove', !1), Ma('placement', (t, e, n) => { const o = rn(e.root).dom(); const r = Lc(t, 0, e); const i = jc(o, e).bind((t) => { let e; return Hc(o, (e = t, hc.exact(e.start(), e.soffset(), e.finish(), e.foffset()))).orThunk(() => { const e = Ne.fromText('\ufeff'); return ln(t.start(), e), Hc(o, vc(e, 0, e, 1)).map((t) => vn(e), t) }).bind((t) => Ic(t.left(), t.top(), t.width(), t.height())) }); const a = jc(o, e).bind((t) => wn(t.start()) ? P.some(t.start()) : an(t.start())).getOr(t.element()); return Rc(i, r, e, n, a) })]; const Wc = [Zo('node'), Zo('root'), ur('bubble'), lc(), dr('overrides', {}), dr('showAbove', !1), Ma('placement', (r, i, a) => { const u = Lc(r, 0, i); return i.node.bind((t) => { const e = t.dom().getBoundingClientRect(); const n = Ic(e.left, e.top, e.width, e.height); const o = i.node.getOr(r.element()); return Rc(n, u, i, a, o) }) })]; const Gc = function (t) { return t.x() + t.width() }; const Xc = function (t, e) { return t.x() - e.width() }; const Yc = function (t, e) { return t.y() - e.height() + t.height() }; const qc = function (t) { return t.y() }; const Kc = function (t, e, n) { return Wu(Gc(t), qc(t), n.southeast(), su(), 'link-layout-se') }; const Jc = function (t, e, n) { return Wu(Xc(t, e), qc(t), n.southwest(), lu(), 'link-layout-sw') }; const $c = function (t, e, n) { return Wu(Gc(t), Yc(t, e), n.northeast(), fu(), 'link-layout-ne') }; const Qc = function (t, e, n) { return Wu(Xc(t, e), Yc(t, e), n.northwest(), du(), 'link-layout-nw') }; const Zc = [Zo('item'), lc(), Ma('placement', (t, e, n) => { const o = Mu(n, e.item.element()); const r = fc(t.element(), e, [Kc, Jc, $c, Qc], [Jc, Kc, Qc, $c]); return P.some(uc({ anchorBox: o, bubble: Uu(), overrides: {}, layouts: r, placer: P.none() })) })]; const ts = Go('anchor', { selection: Uc, node: Wc, hotspot: dc, submenu: Zc, makeshift: mc }); const es = function (t, e, n, o, r) { let i; const a = (i = n.anchorBox, Eu(i, e)); Ru(a, r.element(), n.bubble, n.layouts, o, n.overrides) }; const ns = function (e, t, n, o, r, i) { const a = Uo('positioning anchor.info', ts, o); Wi(r.element(), 'position', 'fixed'); const u = qi(r.element(), 'visibility'); Wi(r.element(), 'visibility', 'hidden'); let c; let s; let l; const f = t.useFixed ? Vu(0, 0, window.innerWidth, window.innerHeight) : (s = qa((c = e).element()), l = c.element().dom().getBoundingClientRect(), Hu(s.left(), s.top(), l.width, l.height)); const d = a.placement; const m = i.map((t) => function () { return xu(t) }).or(t.getBounds); d(e, a, f).each((t) => { t.placer.getOr(es)(e, f, t, m, r) }), u.fold(() => { Ji(r.element(), 'visibility') }, (t) => { Wi(r.element(), 'visibility', t) }), qi(r.element(), 'left').isNone() && qi(r.element(), 'top').isNone() && qi(r.element(), 'right').isNone() && qi(r.element(), 'bottom').isNone() && qi(r.element(), 'position').is('fixed') && Ji(r.element(), 'position') }; const os = Object.freeze({ position(t, e, n, o, r) { const i = P.none(); ns(t, e, n, o, r, i) }, positionWithin: ns, getMode(t, e, n) { return e.useFixed ? 'fixed' : 'absolute' } }); const rs = [dr('useFixed', !1), ur('getBounds')]; const is = La({ fields: rs, name: 'positioning', active: Wa, apis: os }); var as = function (t) { kr(t, Be()); const e = t.components(); A(e, as) }; var us = function (t) { const e = t.components(); A(e, us), kr(t, Te()) }; const cs = function (t, e) { ss(t, e, mn) }; var ss = function (t, e, n) { t.getSystem().addToWorld(e), n(t.element(), e.element()), Dr(t.element()) && us(e), t.syncComponents() }; const ls = function (t) { as(t), vn(t.element()), t.getSystem().removeFromWorld(t) }; const fs = function (e) { const t = an(e.element()).bind((t) => e.getSystem().getByDom(t).fold(P.none, P.some)); ls(e), t.each((t) => { t.syncComponents() }) }; const ds = function (t) { const e = t.components(); A(e, ls), gn(t.element()), t.syncComponents() }; const ms = function (t, e) { hs(t, e, mn) }; var hs = function (t, e, n) { n(t, e.element()); const o = cn(e.element()); A(o, (t) => { e.getByDom(t).each(us) }) }; const gs = function (e) { const t = cn(e.element()); A(t, (t) => { e.getByDom(t).each(as) }), vn(e.element()) }; const vs = function (t, e, n, o) { const r = (function (e, t, n, o) { n.get().each((t) => { ds(e) }); const r = t.getAttachPoint(e); cs(r, e); const i = e.getSystem().build(o); return cs(e, i), n.set(i), i }(t, e, n, o)); return e.onOpen(t, r), r }; const ps = function (e, n, o) { o.get().each((t) => { ds(e), fs(e), n.onClose(e, t), o.clear() }) }; const bs = function (t, e, n) { return n.isOpen() }; const ys = function (t, e, n) { let o; let r; let i; let a; const u = e.getAttachPoint(t); Wi(t.element(), 'position', is.getMode(u)), o = t, r = 'visibility', i = e.cloakVisibilityAttr, a = 'hidden', qi(o.element(), r).fold(() => { Vn(o.element(), i) }, (t) => { Cn(o.element(), i, t) }), Wi(o.element(), r, a) }; const xs = function (t, e, n) { let o; o = t.element(), H(['top', 'left', 'right', 'bottom'], (t) => qi(o, t).isSome()) || Ji(t.element(), 'position'), (function (t, e, n) { if (Hn(t.element(), n)) { const o = Mn(t.element(), n); Wi(t.element(), e, o) } else Ji(t.element(), e) }(t, 'visibility', e.cloakVisibilityAttr)) }; const ws = Object.freeze({ cloak: ys, decloak: xs, open: vs, openWhileCloaked(t, e, n, o, r) { ys(t, e, n), vs(t, e, n, o), r(), xs(t, e, n) }, close: ps, isOpen: bs, isPartOf(e, n, t, o) { return bs(0, 0, t) && t.get().exists((t) => n.isPartOf(e, t, o)) }, getState(t, e, n) { return n.get() } }); const zs = Object.freeze({ events(n, o) { return Pr([Wr(He(), (t, e) => { ps(t, n, o) })]) } }); const Ss = [Sa('onOpen'), Sa('onClose'), Zo('isPartOf'), Zo('getAttachPoint'), dr('cloakVisibilityAttr', 'data-precloak-visibility')]; const ks = La({ fields: Ss, name: 'sandboxing', active: zs, apis: ws, state: Object.freeze({ init() { const e = Ct(P.none()); const t = U('not-implemented'); return xi({ readState: t, isOpen() { return e.get().isSome() }, clear() { e.set(P.none()) }, set(t) { e.set(P.some(t)) }, get(t) { return e.get() } }) } }) }); const Cs = U('dismiss.popups'); const Os = U('mouse.released'); const Ms = Ho([dr('isExtraPart', U(!1)), fr('fireEventInstead', [dr('event', De())])]); const Hs = function (t) { const e = Vs(t); return Ua.config(e) }; var Vs = function (t) { const n = Uo('Dismissal', Ms, t); return { channels: wt(Cs(), { schema: Ho([Zo('target')]), onReceive(e, t) { ks.isOpen(e) && (ks.isPartOf(e, t.target) || n.isExtraPart(e, t.target) || n.fireEventInstead.fold(() => ks.close(e), (t) => kr(e, t.event))) } }) } }; const Es = function (o, t) { return yr(o, {}, E(t, (t) => { return e = t.name(), n = `Cannot configure ${t.name()} for ${o}`, _o(e, e, Qn(), Mo((t) => co(`The field: ${e} is forbidden. ${n}`))); let e, n }).concat([xr('dump', d)])) }; const As = function (t) { return t.dump }; const Ts = function (t, e) { return Gn({}, t.dump, _a(e)) }; const Bs = Es; const Ds = Ts; const _s = 'placeholder'; const Fs = dt([{ single: ['required', 'valueThunk'] }, { multiple: ['required', 'valueThunks'] }]); const Ls = function (t, e, n, o) { return n.uiType === _s ? (i = n, a = o, (r = t).exists((t) => t !== i.owner) ? Fs.single(!0, U(i)) : xt(a, i.name).fold(() => { throw new Error(`Unknown placeholder component: ${i.name}\nKnown: [${Q(a)}]\nNamespace: ${r.getOr('none')}\nSpec: ${xo(i, null, 2)}`) }, (t) => t.replace())) : Fs.single(!1, U(n)); let r, i, a }; var Is = function (i, a, u, c) { return Ls(i, 0, u, c).fold((t, e) => { const n = e(a, u.config, u.validated); const o = xt(n, 'components').getOr([]); const r = j(o, (t) => Is(i, a, t, c)); return [Gn({}, n, { components: r })] }, (t, e) => { const n = e(a, u.config, u.validated); return u.validated.preprocess.getOr(d)(n) }) }; const Rs = function (e, n, t, o) { let r; let i; let a; const u = et(o, (t, e) => { return o = t, r = !1, { name: U(n = e), required() { return o.fold((t, e) => t, (t, e) => t) }, used() { return r }, replace() { if (!0 === r) throw new Error(`Trying to use the same placeholder more than once: ${n}`); return r = !0, o } }; let n, o, r }); const c = (r = e, i = n, a = u, j(t, (t) => Is(r, i, t, a))); return tt(u, (t) => { if (!1 === t.used() && t.required()) throw new Error(`Placeholder: ${t.name()} was not found in components list\nNamespace: ${e.getOr('none')}\nComponents: ${xo(n.components, null, 2)}`) }), c }; const Ns = Fs.single; const Ps = Fs.multiple; const js = U(_s); const Us = dt([{ required: ['data'] }, { external: ['data'] }, { optional: ['data'] }, { group: ['data'] }]); const Ws = dr('factory', { sketch: d }); const Gs = dr('schema', []); const Xs = Zo('name'); const Ys = _o('pname', 'pname', Zn((t) => `<alloy.${Un(t.name)}>`), Xo()); const qs = xr('schema', () => [ur('preprocess')]); const Ks = dr('defaults', U({})); const Js = dr('overrides', U({})); const $s = Vo([Ws, Gs, Xs, Ys, Ks, Js]); const Qs = Vo([Ws, Gs, Xs, Ks, Js]); const Zs = Vo([Ws, Gs, Xs, Ys, Ks, Js]); const tl = Vo([Ws, qs, Xs, Zo('unit'), Ys, Ks, Js]); const el = function (t) { return t.fold(P.some, P.none, P.some, P.some) }; const nl = function (t) { const e = function (t) { return t.name }; return t.fold(e, e, e, e) }; const ol = function (n, o) { return function (t) { const e = Uo('Converting part type', o, t); return n(e) } }; const rl = ol(Us.required, $s); const il = ol(Us.external, Qs); const al = ol(Us.optional, Zs); const ul = ol(Us.group, tl); const cl = U('entirety'); const sl = Object.freeze({ required: rl, external: il, optional: al, group: ul, asNamedPart: el, name: nl, asCommon(t) { return t.fold(d, d, d, d) }, original: cl }); const ll = function (t, e, n, o) { return gt(e.defaults(t, n, o), n, { uid: t.partUids[e.name] }, e.overrides(t, n, o)) }; const fl = function (r, t) { const e = {}; return A(t, (t) => { el(t).each((n) => { const o = dl(r, n.pname); e[n.name] = function (t) { const e = Uo(`Part: ${n.name} in ${r}`, Vo(n.schema), t); return Gn({}, o, { config: t, validated: e }) } }) }), e }; var dl = function (t, e) { return { uiType: js(), owner: t, name: e } }; const ml = function (t, e, n) { return { uiType: js(), owner: t, name: e, config: n, validated: {} } }; const hl = function (t) { return j(t, (t) => t.fold(P.none, P.some, P.none, P.none).map((t) => rr(t.name, t.schema.concat([Ha(cl())]))).toArray()) }; const gl = function (t) { return E(t, nl) }; const vl = function (t, e, n) { return o = e, i = {}, r = {}, A(n, (t) => { t.fold((o) => { i[o.pname] = Ns(!0, (t, e, n) => o.factory.sketch(ll(t, o, e, n))) }, (t) => { const e = o.parts[t.name]; r[t.name] = U(t.factory.sketch(ll(o, t, e[cl()]), e)) }, (o) => { i[o.pname] = Ns(!1, (t, e, n) => o.factory.sketch(ll(t, o, e, n))) }, (r) => { i[r.pname] = Ps(!0, (e, t, n) => { const o = e[r.name]; return E(o, (t) => r.factory.sketch(gt(r.defaults(e, t, n), t, r.overrides(e, t)))) }) }) }), { internals: U(i), externals: U(r) }; let o, i, r }; const pl = function (t, e, n) { return Rs(P.some(t), e, e.components, n) }; const bl = function (t, e, n) { const o = e.partUids[n]; return t.getSystem().getByUid(o).toOption() }; const yl = function (t, e, n) { return bl(t, e, n).getOrDie(`Could not find part: ${n}`) }; const xl = function (t, e, n) { const o = {}; const r = e.partUids; const i = t.getSystem(); return A(n, (t) => { o[t] = i.getByUid(r[t]) }), et(o, U) }; const wl = function (t, e) { const n = t.getSystem(); return et(e.partUids, (t, e) => U(n.getByUid(t))) }; const zl = function (t) { return Q(t.partUids) }; const Sl = function (t, e, n) { const o = {}; const r = e.partUids; const i = t.getSystem(); return A(n, (t) => { o[t] = i.getByUid(r[t]).getOrDie() }), et(o, U) }; const kl = function (e, t) { const n = gl(t); return zt(E(n, (t) => ({ key: t, value: `${e}-${t}` }))) }; const Cl = function (e) { return _o('partUids', 'partUids', to((t) => kl(t.uid, e)), Xo()) }; const Ol = Object.freeze({ generate: fl, generateOne: ml, schemas: hl, names: gl, substitutes: vl, components: pl, defaultUids: kl, defaultUidsSchema: Cl, getAllParts: wl, getAllPartNames: zl, getPart: bl, getPartOrDie: yl, getParts: xl, getPartsOrDie: Sl }); const Ml = function (t, e, n, o, r) { let i; let a; const u = (a = r, ((i = o).length > 0 ? [rr('parts', i)] : []).concat([Zo('uid'), dr('dom', {}), dr('components', []), Ha('originalSpec'), dr('debug.sketcher', {})]).concat(a)); return Uo(`${t} [SpecSchema]`, Ho(u.concat(e)), n) }; const Hl = function (t, e, n, o, r) { const i = Vl(r); const a = hl(n); const u = Cl(n); const c = Ml(t, e, i, a, [u]); const s = vl(0, c, n); return o(c, pl(t, c, s.internals()), i, s.externals()) }; var Vl = function (t) { return t.hasOwnProperty('uid') ? t : Gn({}, t, { uid: li('uid') }) }; const El = Ho([Zo('name'), Zo('factory'), Zo('configFields'), dr('apis', {}), dr('extraApis', {})]); const Al = Ho([Zo('name'), Zo('factory'), Zo('configFields'), Zo('partFields'), dr('apis', {}), dr('extraApis', {})]); const Tl = function (t) { const i = Uo(`Sketcher for ${t.name}`, El, t); const e = et(i.apis, bi); const n = et(i.extraApis, (t, e) => gi(t, e)); return Gn({ name: U(i.name), partFields: U([]), configFields: U(i.configFields), sketch(t) { return e = i.name, n = i.configFields, o = i.factory, r = Vl(t), o(Ml(e, n, r, [], []), r); let e, n, o, r } }, e, n) }; const Bl = function (t) { const e = Uo(`Sketcher for ${t.name}`, Al, t); const n = fl(e.name, e.partFields); const o = et(e.apis, bi); const r = et(e.extraApis, (t, e) => gi(t, e)); return Gn({ name: U(e.name), partFields: U(e.partFields), configFields: U(e.configFields), sketch(t) { return Hl(e.name, e.configFields, e.partFields, e.factory, t) }, parts: U(n) }, o, r) }; const Dl = function (t) { return yn(t) === 'input' && Mn(t, 'type') !== 'radio' || yn(t) === 'textarea' }; const _l = Object.freeze({ getCurrent(t, e, n) { return e.find(t) } }); const Fl = [Zo('find')]; const Ll = La({ fields: Fl, name: 'composing', apis: _l }); const Il = function (t, e, n, o) { const r = t + e; return o < r ? n : r < n ? o : r }; const Rl = function (t, e, n) { return t <= e ? e : n <= t ? n : t }; const Nl = function (e, n, t) { const o = Oc(e.element(), `.${n.highlightClass}`); A(o, (t) => { Li(t, n.highlightClass), e.getSystem().getByDom(t).each((t) => { n.onDehighlight(e, t) }) }) }; const Pl = function (t, e, n, o) { const r = jl(t, e, n, o); Nl(t, e), _i(o.element(), e.highlightClass), r || e.onHighlight(t, o) }; var jl = function (t, e, n, o) { return Ii(o.element(), e.highlightClass) }; const Ul = function (t, e, n, o) { const r = Oc(t.element(), `.${e.itemClass}`); return P.from(r[o]).fold(() => ft.error(`No element found with index ${o}`), t.getSystem().getByDom) }; const Wl = function (e, t, n) { return da(e.element(), `.${t.itemClass}`).bind((t) => e.getSystem().getByDom(t).toOption()) }; const Gl = function (e, t, n) { const o = Oc(e.element(), `.${t.itemClass}`); return (o.length > 0 ? P.some(o[o.length - 1]) : P.none()).bind((t) => e.getSystem().getByDom(t).toOption()) }; const Xl = function (n, e, t, o) { const r = Oc(n.element(), `.${e.itemClass}`); return F(r, (t) => Ii(t, e.highlightClass)).bind((t) => { const e = Il(t, o, 0, r.length - 1); return n.getSystem().getByDom(r[e]).toOption() }) }; const Yl = function (e, t, n) { const o = Oc(e.element(), `.${t.itemClass}`); return Ot(E(o, (t) => e.getSystem().getByDom(t).toOption())) }; const ql = Object.freeze({ dehighlightAll: Nl, dehighlight(t, e, n, o) { const r = jl(t, e, n, o); Li(o.element(), e.highlightClass), r && e.onDehighlight(t, o) }, highlight: Pl, highlightFirst(e, n, o) { Wl(e, n, o).each((t) => { Pl(e, n, o, t) }) }, highlightLast(e, n, o) { Gl(e, n, o).each((t) => { Pl(e, n, o, t) }) }, highlightAt(e, n, o, t) { Ul(e, n, o, t).fold((t) => { throw new Error(t) }, (t) => { Pl(e, n, o, t) }) }, highlightBy(e, n, o, t) { const r = Yl(e, n, o); _(r, t).each((t) => { Pl(e, n, o, t) }) }, isHighlighted: jl, getHighlighted(e, t, n) { return da(e.element(), `.${t.highlightClass}`).bind((t) => e.getSystem().getByDom(t).toOption()) }, getFirst: Wl, getLast: Gl, getPrevious(t, e, n) { return Xl(t, e, 0, -1) }, getNext(t, e, n) { return Xl(t, e, 0, 1) }, getCandidates: Yl }); const Kl = [Zo('highlightClass'), Zo('itemClass'), Sa('onHighlight'), Sa('onDehighlight')]; const Jl = La({ fields: Kl, name: 'highlighting', apis: ql }); const $l = function (t, e, n) { const o = X(t.slice(0, e)); const r = X(t.slice(e + 1)); return _(o.concat(r), n) }; const Ql = function (t, e, n) { const o = X(t.slice(0, e)); return _(o, n) }; const Zl = function (t, e, n) { const o = t.slice(0, e); const r = t.slice(e + 1); return _(r.concat(o), n) }; const tf = function (t, e, n) { const o = t.slice(e + 1); return _(o, n) }; const ef = function (n) { return function (t) { const e = t.raw(); return M(n, e.which) } }; const nf = function (t) { return function (e) { return W(t, (t) => t(e)) } }; const of = function (t) { return !0 === t.raw().shiftKey }; const rf = function (t) { return !0 === t.raw().ctrlKey }; const af = m(of); const uf = function (t, e) { return { matches: t, classification: e } }; const cf = function (t) { t.dom().focus() }; const sf = function (t) { const e = t !== undefined ? t.dom() : document; return P.from(e.activeElement).map(Ne.fromDom) }; const lf = function (e) { return sf(on(e)).filter((t) => e.dom().contains(t.dom())) }; const ff = function (t, e, n) { e.exists((e) => n.exists((t) => nn(t, e))) || Cr(t, _e(), { prevFocus: e, newFocus: n }) }; const df = function () { const r = function (t) { return lf(t.element()) }; return { get: r, set(t, e) { const n = r(t); t.getSystem().triggerFocus(e, t.element()); const o = r(t); ff(t, n, o) } } }; const mf = function () { const r = function (t) { return Jl.getHighlighted(t).map((t) => t.element()) }; return { get: r, set(e, t) { const n = r(e); e.getSystem().getByDom(t).fold(N, (t) => { Jl.highlight(e, t) }); const o = r(e); ff(e, n, o) } } }; (Za = Qa || (Qa = {})).OnFocusMode = 'onFocus', Za.OnEnterOrSpaceMode = 'onEnterOrSpace', Za.OnApiMode = 'onApi'; const hf = function (t, e, n, o, u) { const c = function (e, n, t, o, r) { let i; let a; const u = t(e, n, o, r); return (i = u, a = n.event(), _(i, (t) => t.matches(a)).map((t) => t.classification)).bind((t) => t(e, n, o, r)) }; var r = { schema() { return t.concat([dr('focusManager', df()), mr('focusInside', 'onFocus', Ro((t) => M(['onFocus', 'onEnterOrSpace', 'onApi'], t) ? ft.value(t) : ft.error('Invalid value for focusInside'))), Ma('handler', r), Ma('state', e), Ma('sendFocusIn', u)]) }, processKey: c, toEvents(i, a) { const t = i.focusInside !== Qa.OnFocusMode ? P.none() : u(i).map((n) => Wr(xe(), (t, e) => { n(t, i, a), e.stop() })); return Pr(t.toArray().concat([Wr(It(), (o, r) => { c(o, r, n, i, a).fold(() => { let e, n, t; e = o, n = r, t = ef([32].concat([13]))(n.event()), i.focusInside === Qa.OnEnterOrSpaceMode && t && wr(e, n) && u(i).each((t) => { t(e, i, a), n.stop() }) }, (t) => { r.stop() }) }), Wr(Rt(), (t, e) => { c(t, e, o, i, a).each((t) => { e.stop() }) })])) } }; return r }; const gf = function (t) { const e = [ur('onEscape'), ur('onEnter'), dr('selector', '[data-alloy-tabstop="true"]'), dr('firstTabstop', 0), dr('useTabstopAt', U(!0)), ur('visibilitySelector')].concat([t]); const a = function (t, e) { const n = t.visibilitySelector.bind((t) => ma(e, t)).getOr(e); return ru(n) > 0 }; const n = function (e, n) { let t, o, r, i; (t = e, o = n, r = Oc(t.element(), o.selector), i = T(r, (t) => a(o, t)), P.from(i[o.firstTabstop])).each((t) => { n.focusManager.set(e, t) }) }; const u = function (e, t, n, o, r) { return r(t, n, (t) => { return a(e = o, n = t) && e.useTabstopAt(n); let e, n }).fold(() => o.cyclic ? P.some(!0) : P.none(), (t) => o.focusManager.set(e, t), P.some(!0)) }; const i = function (e, t, n, o) { let r; let i; const a = Oc(e.element(), n.selector); return (r = e, i = n, i.focusManager.get(r).bind((t) => ma(t, i.selector))).bind((t) => F(a, f(nn, t)).bind((t) => u(e, a, t, n, o))) }; const o = U([uf(nf([of, ef([9])]), (t, e, n, o) => { const r = n.cyclic ? $l : Ql; return i(t, 0, n, r) }), uf(ef([9]), (t, e, n, o) => { const r = n.cyclic ? Zl : tf; return i(t, 0, n, r) }), uf(ef([27]), (e, n, t, o) => t.onEscape.bind((t) => t(e, n))), uf(nf([af, ef([13])]), (e, n, t, o) => t.onEnter.bind((t) => t(e, n)))]); const r = U([]); return hf(e, yi.init, o, r, () => P.some(n)) }; const vf = gf(xr('cyclic', U(!1))); const pf = gf(xr('cyclic', U(!0))); const bf = function (t, e, n) { return Dl(n) && ef([32])(e.event()) ? P.none() : (Mr(t, n, Se()), P.some(!0)) }; const yf = function (t, e) { return P.some(!0) }; const xf = [dr('execute', bf), dr('useSpace', !1), dr('useEnter', !0), dr('useControlEnter', !1), dr('useDown', !1)]; const wf = function (t, e, n) { return n.execute(t, e, t.element()) }; const zf = hf(xf, yi.init, (t, e, n, o) => { const r = n.useSpace && !Dl(t.element()) ? [32] : []; const i = n.useEnter ? [13] : []; const a = n.useDown ? [40] : []; const u = r.concat(i).concat(a); return [uf(ef(u), wf)].concat(n.useControlEnter ? [uf(nf([rf, ef([13])]), wf)] : []) }, (t, e, n, o) => n.useSpace && !Dl(t.element()) ? [uf(ef([32]), yf)] : [], () => P.none()); const Sf = function (t) { const n = Ct(P.none()); return xi({ readState() { return n.get().map((t) => ({ numRows: t.numRows(), numColumns: t.numColumns() })).getOr({ numRows: '?', numColumns: '?' }) }, setGridSize(t, e) { n.set(P.some({ numRows: U(t), numColumns: U(e) })) }, getNumRows() { return n.get().map((t) => t.numRows()) }, getNumColumns() { return n.get().map((t) => t.numColumns()) } }) }; const kf = Object.freeze({ flatgrid: Sf, init(t) { return t.state(t) } }); const Cf = function (i) { return function (t, e, n, o) { const r = i(t.element()); return Vf(r, t, e, n, o) } }; const Of = function (t, e) { const n = cc(t, e); return Cf(n) }; const Mf = function (t, e) { const n = cc(e, t); return Cf(n) }; const Hf = function (r) { return function (t, e, n, o) { return Vf(r, t, e, n, o) } }; var Vf = function (e, n, t, o, r) { return o.focusManager.get(n).bind((t) => e(n.element(), t, o, r)).map((t) => o.focusManager.set(n, t), !0) }; const Ef = Hf; const Af = Hf; const Tf = Hf; const Bf = function (t) { let e; const n = t.dom(); return !((e = n).offsetWidth <= 0 && e.offsetHeight <= 0) }; const Df = We(['index', 'candidates'], []); const _f = function (t, e, n) { return Ff(t, e, n, Bf) }; var Ff = function (t, e, n, o) { let r; const i = f(nn, e); const a = Oc(t, n); const u = T(a, Bf); return F(r = u, i).map((t) => Df({ index: t, candidates: r })) }; const Lf = function (t, e) { return F(t, (t) => nn(e, t)) }; const If = function (n, t, o, e) { return e(Math.floor(t / o), t % o).bind((t) => { const e = t.row() * o + t.column(); return e >= 0 && e < n.length ? P.some(n[e]) : P.none() }) }; const Rf = function (r, t, i, a, u) { return If(r, t, a, (t, e) => { const n = t === i - 1 ? r.length - t * a : a; const o = Il(e, u, 0, n - 1); return P.some({ row: U(t), column: U(o) }) }) }; const Nf = function (i, t, a, u, c) { return If(i, t, u, (t, e) => { const n = Il(t, c, 0, a - 1); const o = n === a - 1 ? i.length - n * u : u; const r = Rl(e, 0, o - 1); return P.some({ row: U(n), column: U(r) }) }) }; const Pf = [Zo('selector'), dr('execute', bf), ka('onEscape'), dr('captureTab', !1), Va()]; const jf = function (e, n, t) { da(e.element(), n.selector).each((t) => { n.focusManager.set(e, t) }) }; const Uf = function (r) { return function (t, e, n, o) { return _f(t, e, n.selector).bind((t) => r(t.candidates(), t.index(), o.getNumRows().getOr(n.initSize.numRows), o.getNumColumns().getOr(n.initSize.numColumns))) } }; const Wf = function (t, e, n, o) { return n.captureTab ? P.some(!0) : P.none() }; const Gf = Uf((t, e, n, o) => Rf(t, e, n, o, -1)); const Xf = Uf((t, e, n, o) => Rf(t, e, n, o, 1)); const Yf = Uf((t, e, n, o) => Nf(t, e, n, o, -1)); const qf = Uf((t, e, n, o) => Nf(t, e, n, o, 1)); const Kf = U([uf(ef([37]), Of(Gf, Xf)), uf(ef([39]), Mf(Gf, Xf)), uf(ef([38]), Ef(Yf)), uf(ef([40]), Af(qf)), uf(nf([of, ef([9])]), Wf), uf(nf([af, ef([9])]), Wf), uf(ef([27]), (t, e, n, o) => n.onEscape(t, e)), uf(ef([32].concat([13])), (e, n, o, t) => { return (r = e, i = o, i.focusManager.get(r).bind((t) => ma(t, i.selector))).bind((t) => o.execute(e, n, t)); let r, i })]); const Jf = U([uf(ef([32]), yf)]); const $f = hf(Pf, Sf, Kf, Jf, () => P.some(jf)); const Qf = function (t, e, n, i) { var a = function (t, e, n) { let o; const r = Il(e, i, 0, n.length - 1); return r === t ? P.none() : (o = n[r], yn(o) === 'button' && Mn(o, 'disabled') === 'disabled' ? a(t, r, n) : P.from(n[r])) }; return _f(t, n, e).bind((t) => { const e = t.index(); const n = t.candidates(); return a(e, e, n) }) }; const Zf = [Zo('selector'), dr('getInitial', P.none), dr('execute', bf), ka('onEscape'), dr('executeOnMove', !1), dr('allowVertical', !0)]; const td = function (e, n, o) { return (t = e, r = o, r.focusManager.get(t).bind((t) => ma(t, r.selector))).bind((t) => o.execute(e, n, t)); let t, r }; const ed = function (e, n) { n.getInitial(e).orThunk(() => da(e.element(), n.selector)).each((t) => { n.focusManager.set(e, t) }) }; const nd = function (t, e, n) { return Qf(t, n.selector, e, -1) }; const od = function (t, e, n) { return Qf(t, n.selector, e, 1) }; const rd = function (o) { return function (t, e, n) { return o(t, e, n).bind(() => n.executeOnMove ? td(t, e, n) : P.some(!0)) } }; const id = function (t, e, n, o) { return n.onEscape(t, e) }; const ad = U([uf(ef([32]), yf)]); const ud = hf(Zf, yi.init, (t, e, n, o) => { const r = [37].concat(n.allowVertical ? [38] : []); const i = [39].concat(n.allowVertical ? [40] : []); return [uf(ef(r), rd(Of(nd, od))), uf(ef(i), rd(Mf(nd, od))), uf(ef([13]), td), uf(ef([32]), td), uf(ef([27]), id)] }, ad, () => P.some(ed)); const cd = We(['rowIndex', 'columnIndex', 'cell'], []); const sd = function (t, e, n) { return P.from(t[e]).bind((t) => P.from(t[n]).map((t) => cd({ rowIndex: e, columnIndex: n, cell: t }))) }; const ld = function (t, e, n, o) { const r = t[e].length; const i = Il(n, o, 0, r - 1); return sd(t, e, i) }; const fd = function (t, e, n, o) { const r = Il(n, o, 0, t.length - 1); const i = t[r].length; const a = Rl(e, 0, i - 1); return sd(t, r, a) }; const dd = function (t, e, n, o) { const r = t[e].length; const i = Rl(n + o, 0, r - 1); return sd(t, e, i) }; const md = function (t, e, n, o) { const r = Rl(n + o, 0, t.length - 1); const i = t[r].length; const a = Rl(e, 0, i - 1); return sd(t, r, a) }; const hd = [rr('selectors', [Zo('row'), Zo('cell')]), dr('cycles', !0), dr('previousSelector', P.none), dr('execute', bf)]; const gd = function (e, n) { n.previousSelector(e).orThunk(() => { const t = n.selectors; return da(e.element(), t.cell) }).each((t) => { n.focusManager.set(e, t) }) }; const vd = function (t, e) { return function (n, o, i) { const a = i.cycles ? t : e; return ma(o, i.selectors.row).bind((t) => { const e = Oc(t, i.selectors.cell); return Lf(e, o).bind((o) => { const r = Oc(n, i.selectors.row); return Lf(r, t).bind((t) => { let e; const n = (e = i, E(r, (t) => Oc(t, e.selectors.cell))); return a(n, t, o).map((t) => t.cell()) }) }) }) } }; const pd = vd((t, e, n) => ld(t, e, n, -1), (t, e, n) => dd(t, e, n, -1)); const bd = vd((t, e, n) => ld(t, e, n, 1), (t, e, n) => dd(t, e, n, 1)); const yd = vd((t, e, n) => fd(t, n, e, -1), (t, e, n) => md(t, n, e, -1)); const xd = vd((t, e, n) => fd(t, n, e, 1), (t, e, n) => md(t, n, e, 1)); const wd = U([uf(ef([37]), Of(pd, bd)), uf(ef([39]), Mf(pd, bd)), uf(ef([38]), Ef(yd)), uf(ef([40]), Af(xd)), uf(ef([32].concat([13])), (e, n, o) => lf(e.element()).bind((t) => o.execute(e, n, t)))]); const zd = U([uf(ef([32]), yf)]); const Sd = hf(hd, yi.init, wd, zd, () => P.some(gd)); const kd = [Zo('selector'), dr('execute', bf), dr('moveOnTab', !1)]; const Cd = function (e, n, o) { return o.focusManager.get(e).bind((t) => o.execute(e, n, t)) }; const Od = function (e, n) { da(e.element(), n.selector).each((t) => { n.focusManager.set(e, t) }) }; const Md = function (t, e, n) { return Qf(t, n.selector, e, -1) }; const Hd = function (t, e, n) { return Qf(t, n.selector, e, 1) }; const Vd = U([uf(ef([38]), Tf(Md)), uf(ef([40]), Tf(Hd)), uf(nf([of, ef([9])]), (t, e, n) => n.moveOnTab ? Tf(Md)(t, e, n) : P.none()), uf(nf([af, ef([9])]), (t, e, n) => n.moveOnTab ? Tf(Hd)(t, e, n) : P.none()), uf(ef([13]), Cd), uf(ef([32]), Cd)]); const Ed = U([uf(ef([32]), yf)]); const Ad = hf(kd, yi.init, Vd, Ed, () => P.some(Od)); const Td = [ka('onSpace'), ka('onEnter'), ka('onShiftEnter'), ka('onLeft'), ka('onRight'), ka('onTab'), ka('onShiftTab'), ka('onUp'), ka('onDown'), ka('onEscape'), dr('stopSpaceKeyup', !1), ur('focusIn')]; const Bd = hf(Td, yi.init, (t, e, n) => [uf(ef([32]), n.onSpace), uf(nf([af, ef([13])]), n.onEnter), uf(nf([of, ef([13])]), n.onShiftEnter), uf(nf([of, ef([9])]), n.onShiftTab), uf(nf([af, ef([9])]), n.onTab), uf(ef([38]), n.onUp), uf(ef([40]), n.onDown), uf(ef([37]), n.onLeft), uf(ef([39]), n.onRight), uf(ef([32]), n.onSpace), uf(ef([27]), n.onEscape)], (t, e, n) => n.stopSpaceKeyup ? [uf(ef([32]), yf)] : [], (t) => t.focusIn); const Dd = vf.schema(); const _d = pf.schema(); const Fd = ud.schema(); const Ld = $f.schema(); const Id = Sd.schema(); const Rd = zf.schema(); const Nd = Ad.schema(); const Pd = Bd.schema(); const jd = Ra({ branchKey: 'mode', branches: Object.freeze({ acyclic: Dd, cyclic: _d, flow: Fd, flatgrid: Ld, matrix: Id, execution: Rd, menu: Nd, special: Pd }), name: 'keying', active: { events(t, e) { return t.handler.toEvents(t, e) } }, apis: { focusIn(e, n, o) { n.sendFocusIn(n).fold(() => { e.getSystem().triggerFocus(e.element(), e.element()) }, (t) => { t(e, n, o) }) }, setGridSize(t, e, n, o, r) { kt(n, 'setGridSize') ? n.setGridSize(o, r) : console.error('Layout does not support setGridSize') } }, state: kf }); const Ud = function (t, e, n, o) { const r = t.getSystem().build(o); ss(t, r, n) }; const Wd = function (t, e, n, o) { const r = Gd(t, e); _(r, (t) => nn(o.element(), t.element())).each(fs) }; var Gd = function (t, e) { return t.components() }; const Xd = function (e, n, t, r, o) { const i = Gd(e, n); return P.from(i[r]).map((t) => Wd(e, n, 0, t), o.each((t) => { Ud(e, 0, (t, e) => { let n, o; o = e, sn(n = t, r).fold(() => { mn(n, o) }, (t) => { ln(t, o) }) }, t) }), t) }; const Yd = La({ fields: [], name: 'replacing', apis: Object.freeze({ append(t, e, n, o) { Ud(t, 0, mn, o) }, prepend(t, e, n, o) { Ud(t, 0, dn, o) }, remove: Wd, replaceAt: Xd, replaceBy(e, n, t, o, r) { const i = Gd(e, n); return F(i, o).bind((t) => Xd(e, n, 0, t, r)) }, set(e, t, n, o) { let r, i, a, u; ds(e), r = function () { const t = E(o, e.getSystem().build); A(t, (t) => { cs(e, t) }) }, i = e.element(), a = on(i), u = sf(a).bind((e) => { const t = function (t) { return nn(e, t) }; return t(i) ? P.some(i) : Rr(i, t) }), r(i), u.each((e) => { sf(a).filter((t) => nn(t, e)).fold(() => { cf(e) }, N) }) }, contents: Gd }) }); const qd = function (t, e, n) { e.store.manager.onLoad(t, e, n) }; const Kd = function (t, e, n) { e.store.manager.onUnload(t, e, n) }; const Jd = Object.freeze({ onLoad: qd, onUnload: Kd, setValue(t, e, n, o) { e.store.manager.setValue(t, e, n, o) }, getValue(t, e, n) { return e.store.manager.getValue(t, e, n) }, getState(t, e, n) { return n } }); const $d = Object.freeze({ events(n, o) { const t = n.resetOnDom ? [Qr((t, e) => { qd(t, n, o) }), Zr((t, e) => { Kd(t, n, o) })] : [Ea(n, o, qd)]; return Pr(t) } }); const Qd = function () { const t = Ct(null); return xi({ set: t.set, get: t.get, isNotSet() { return t.get() === null }, clear() { t.set(null) }, readState() { return { mode: 'memory', value: t.get() } } }) }; const Zd = function () { const i = Ct({}); const a = Ct({}); return xi({ readState() { return { mode: 'dataset', dataByValue: i.get(), dataByText: a.get() } }, lookup(t) { return xt(i.get(), t).orThunk(() => xt(a.get(), t)) }, update(t) { const e = i.get(); const n = a.get(); const o = {}; const r = {}; A(t, (e) => { o[e.value] = e, xt(e, 'meta').each((t) => { xt(t, 'text').each((t) => { r[t] = e }) }) }), i.set(Gn({}, e, o)), a.set(Gn({}, n, r)) }, clear() { i.set({}), a.set({}) } }) }; const tm = Object.freeze({ memory: Qd, dataset: Zd, manual() { return xi({ readState() {} }) }, init(t) { return t.store.manager.state(t) } }); const em = function (t, e, n, o) { const r = e.store; n.update([o]), r.setValue(t, o), e.onSetValue(t, o) }; const nm = [ur('initialValue'), Zo('getFallbackEntry'), Zo('getDataKey'), Zo('setValue'), Ma('manager', { setValue: em, getValue(t, e, n) { const o = e.store; const r = o.getDataKey(t); return n.lookup(r).fold(() => o.getFallbackEntry(r), (t) => t) }, onLoad(e, n, o) { n.store.initialValue.each((t) => { em(e, n, o, t) }) }, onUnload(t, e, n) { n.clear() }, state: Zd })]; const om = [Zo('getValue'), dr('setValue', N), ur('initialValue'), Ma('manager', { setValue(t, e, n, o) { e.store.setValue(t, o), e.onSetValue(t, o) }, getValue(t, e, n) { return e.store.getValue(t) }, onLoad(e, n, t) { n.store.initialValue.each((t) => { n.store.setValue(e, t) }) }, onUnload: N, state: yi.init })]; const rm = [ur('initialValue'), Ma('manager', { setValue(t, e, n, o) { n.set(o), e.onSetValue(t, o) }, getValue(t, e, n) { return n.get() }, onLoad(t, e, n) { e.store.initialValue.each((t) => { n.isNotSet() && n.set(t) }) }, onUnload(t, e, n) { n.clear() }, state: Qd })]; const im = [mr('store', { mode: 'memory' }, Go('mode', { memory: rm, manual: om, dataset: nm })), Sa('onSetValue'), dr('resetOnDom', !1)]; var am = La({ fields: im, name: 'representing', active: $d, apis: Jd, extra: { setValueFrom(t, e) { const n = am.getValue(e); am.setValue(t, n) } }, state: tm }); const um = function (t, e) { e.ignore || (cf(t.element()), e.onFocus(t)) }; const cm = Object.freeze({ focus: um, blur(t, e) { e.ignore || t.element().dom().blur() }, isFocused(t) { return e = t.element(), n = on(e).dom(), e.dom() === n.activeElement; let e, n } }); const sm = Object.freeze({ exhibit(t, e) { const n = e.ignore ? {} : { attributes: { tabindex: '-1' } }; return zi(n) }, events(n) { return Pr([Wr(xe(), (t, e) => { um(t, n), e.stop() })].concat(n.stopMousedown ? [Wr(At(), (t, e) => { e.event().prevent() })] : [])) } }); const lm = [Sa('onFocus'), dr('stopMousedown', !1), dr('ignore', !1)]; const fm = La({ fields: lm, name: 'focusing', active: sm, apis: cm }); const dm = function (t, e, n) { const o = e.aria; o.update(t, o, n.get()) }; const mm = function (e, t, n) { t.toggleClass.each((t) => { n.get() ? _i(e.element(), t) : Li(e.element(), t) }) }; const hm = function (t, e, n) { pm(t, e, n, !n.get()) }; const gm = function (t, e, n) { n.set(!0), mm(t, e, n), dm(t, e, n) }; const vm = function (t, e, n) { n.set(!1), mm(t, e, n), dm(t, e, n) }; var pm = function (t, e, n, o) { (o ? gm : vm)(t, e, n) }; const bm = function (t, e, n) { pm(t, e, n, e.selected) }; const ym = Object.freeze({ onLoad: bm, toggle: hm, isOn(t, e, n) { return n.get() }, on: gm, off: vm, set: pm }); const xm = Object.freeze({ exhibit(t, e, n) { return zi({}) }, events(t, e) { let n; let o; let r; const i = (n = t, o = e, r = hm, ei((t) => { r(t, n, o) })); const a = Ea(t, e, bm); return Pr(R([t.toggleOnExecute ? [i] : [], [a]])) } }); const wm = Object.freeze({ init(t) { const e = Ct(!1); return { readState() { return e.get() }, get() { return e.get() }, set(t) { return e.set(t) }, clear() { return e.set(!1) } } } }); const zm = function (t, e, n) { Cn(t.element(), 'aria-expanded', n) }; const Sm = [dr('selected', !1), ur('toggleClass'), dr('toggleOnExecute', !0), mr('aria', { mode: 'none' }, Go('mode', { pressed: [dr('syncWithExpanded', !1), Ma('update', (t, e, n) => { Cn(t.element(), 'aria-pressed', n), e.syncWithExpanded && zm(t, e, n) })], checked: [Ma('update', (t, e, n) => { Cn(t.element(), 'aria-checked', n) })], expanded: [Ma('update', zm)], selected: [Ma('update', (t, e, n) => { Cn(t.element(), 'aria-selected', n) })], none: [Ma('update', N)] }))]; const km = La({ fields: Sm, name: 'toggling', active: xm, apis: ym, state: wm }); const Cm = 'alloy.item-hover'; const Om = 'alloy.item-focus'; const Mm = function (t) { (lf(t.element()).isNone() || fm.isFocused(t)) && (fm.isFocused(t) || fm.focus(t), Cr(t, Cm, { item: t })) }; const Hm = function (t) { Cr(t, Om, { item: t }) }; const Vm = U(Cm); const Em = U(Om); const Am = function (t, e) { let n, o; return { key: t, value: { config: {}, me: (n = t, o = Pr(e), La({ fields: [Zo('enabled')], name: n, active: { events: U(o) } })), configAsRaw: U({}), initialConfig: {}, state: yi } } }; const Tm = [Zo('data'), Zo('components'), Zo('dom'), dr('hasSubmenu', !1), ur('toggling'), Bs('itemBehaviours', [km, fm, jd, am]), dr('ignoreFocus', !1), dr('domModification', {}), Ma('builder', (t) => ({ dom: t.dom, domModification: Gn({}, t.domModification, { attributes: Gn({ role: t.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem' }, t.domModification.attributes, { 'aria-haspopup': t.hasSubmenu }, t.hasSubmenu ? { 'aria-expanded': !1 } : {}) }), behaviours: Ds(t.itemBehaviours, [t.toggling.fold(km.revoke, (t) => km.config(Gn({ aria: { mode: 'checked' } }, t))), fm.config({ ignore: t.ignoreFocus, stopMousedown: t.ignoreFocus, onFocus(t) { Hm(t) } }), jd.config({ mode: 'execution' }), am.config({ store: { mode: 'memory', initialValue: t.data } }), Am('item-type-events', [Wr(Oe(), Or), Kr(At()), Wr(_t(), Mm), Wr(ke(), fm.focus)])]), components: t.components, eventOrder: t.eventOrder })), dr('eventOrder', {})]; const Bm = [Zo('dom'), Zo('components'), Ma('builder', (t) => ({ dom: t.dom, components: t.components, events: Pr([Jr(ke())]) }))]; const Dm = U([rl({ name: 'widget', overrides(e) { return { behaviours: _a([am.config({ store: { mode: 'manual', getValue(t) { return e.data }, setValue() {} } })]) } } })]); const _m = [Zo('uid'), Zo('data'), Zo('components'), Zo('dom'), dr('autofocus', !1), dr('ignoreFocus', !1), Bs('widgetBehaviours', [am, fm, jd]), dr('domModification', {}), Cl(Dm()), Ma('builder', (n) => { const t = vl(0, n, Dm()); const e = pl('item-widget', n, t.internals()); const o = function (t) { return bl(t, n, 'widget').map((t) => jd.focusIn(t), t) }; const r = function (t, e) { return Dl(e.event().target()) || n.autofocus && e.setSource(t.element()), P.none() }; return { dom: n.dom, components: e, domModification: n.domModification, events: Pr([ei((t, e) => { o(t).each((t) => { e.stop() }) }), Wr(_t(), Mm), Wr(ke(), (t, e) => { n.autofocus ? o(t) : fm.focus(t) })]), behaviours: Ds(n.widgetBehaviours, [am.config({ store: { mode: 'memory', initialValue: n.data } }), fm.config({ ignore: n.ignoreFocus, onFocus(t) { Hm(t) } }), jd.config({ mode: 'special', focusIn: n.autofocus ? function (t) { o(t) } : Na(), onLeft: r, onRight: r, onEscape(t, e) { return fm.isFocused(t) || n.autofocus ? (n.autofocus && e.setSource(t.element()), P.none()) : (fm.focus(t), P.some(!0)) } })]) } })]; const Fm = Go('type', { widget: _m, item: Tm, separator: Bm }); const Lm = U([ul({ factory: { sketch(t) { const e = Uo('menu.spec item', Fm, t); return e.builder(e) } }, name: 'items', unit: 'item', defaults(t, e) { return e.hasOwnProperty('uid') ? e : Gn({}, e, { uid: li('item') }) }, overrides(t, e) { return { type: e.type, ignoreFocus: t.fakeFocus, domModification: { classes: [t.markers.item] } } } })]); const Im = U([Zo('value'), Zo('items'), Zo('dom'), Zo('components'), dr('eventOrder', {}), Es('menuBehaviours', [Jl, am, Ll, jd]), mr('movement', { mode: 'menu', moveOnTab: !0 }, Go('mode', { grid: [Va(), Ma('config', (t, e) => ({ mode: 'flatgrid', selector: `.${t.markers.item}`, initSize: { numColumns: e.initSize.numColumns, numRows: e.initSize.numRows }, focusManager: t.focusManager }))], matrix: [Ma('config', (t, e) => ({ mode: 'matrix', selectors: { row: e.rowSelector, cell: `.${t.markers.item}` }, focusManager: t.focusManager })), Zo('rowSelector')], menu: [dr('moveOnTab', !0), Ma('config', (t, e) => ({ mode: 'menu', selector: `.${t.markers.item}`, moveOnTab: e.moveOnTab, focusManager: t.focusManager }))] })), tr('markers', ba()), dr('fakeFocus', !1), dr('focusManager', df()), Sa('onHighlight')]); const Rm = U('alloy.menu-focus'); const Nm = Bl({ name: 'Menu', configFields: Im(), partFields: Lm(), factory(t, e, n, o) { return { uid: t.uid, dom: t.dom, markers: t.markers, behaviours: Ts(t.menuBehaviours, [Jl.config({ highlightClass: t.markers.selectedItem, itemClass: t.markers.item, onHighlight: t.onHighlight }), am.config({ store: { mode: 'memory', initialValue: t.value } }), Ll.config({ find: P.some }), jd.config(t.movement.config(t, t.movement))]), events: Pr([Wr(Em(), (e, n) => { const t = n.event(); e.getSystem().getByDom(t.target()).each((t) => { Jl.highlight(e, t), n.stop(), Cr(e, Rm(), { menu: e, item: t }) }) }), Wr(Vm(), (t, e) => { const n = e.event().item(); Jl.highlight(t, n) })]), components: e, eventOrder: t.eventOrder, domModification: { attributes: { role: 'menu' } } } } }); var Pm = function (n, o, r, t) { return xt(r, t).bind((t) => xt(n, t).bind((t) => { const e = Pm(n, o, r, t); return P.some([t].concat(e)) })).getOr([]) }; const jm = function (t, e) { const n = {}; tt(t, (t, e) => { A(t, (t) => { n[t] = e }) }); const o = e; const r = nt(e, (t, e) => ({ k: t, v: e })); const i = et(r, (t, e) => [e].concat(Pm(n, o, r, e))); return et(n, (t) => xt(i, t).getOr([t])) }; const Um = function () { const i = Ct({}); const a = Ct({}); const u = Ct({}); const c = Ct(P.none()); const s = Ct({}); const e = function (t) { return xt(a.get(), t) }; return { setMenuBuilt(t, e) { let n; a.set(Gn({}, a.get(), ((n = {})[t] = { type: 'prepared', menu: e }, n))) }, setContents(t, e, n, o) { c.set(P.some(t)), i.set(n), a.set(e), s.set(o); const r = jm(o, n); u.set(r) }, expand(n) { return xt(i.get(), n).map((t) => { const e = xt(u.get(), n).getOr([]); return [t].concat(e) }) }, refresh(t) { return xt(u.get(), t) }, collapse(t) { return xt(u.get(), t).bind((t) => t.length > 1 ? P.some(t.slice(1)) : P.none()) }, lookupMenu: e, otherMenus(t) { const e = s.get(); return Y(Q(e), t) }, getPrimary() { return c.get().bind((t) => e(t).bind((t) => t.type === 'prepared' ? P.some(t.menu) : P.none())) }, getMenus() { return a.get() }, clear() { i.set({}), a.set({}), u.set({}), c.set(P.none()) }, isClear() { return c.get().isNone() } } }; const Wm = U('collapse-item'); const Gm = Tl({ name: 'TieredMenu', configFields: [Oa('onExecute'), Oa('onEscape'), Ca('onOpenMenu'), Ca('onOpenSubmenu'), Sa('onCollapseMenu'), dr('highlightImmediately', !0), rr('data', [Zo('primary'), Zo('menus'), Zo('expansions')]), dr('fakeFocus', !1), Sa('onHighlight'), Sa('onHover'), xa(), Zo('dom'), dr('navigateOnHover', !0), dr('stayInDom', !1), Es('tmenuBehaviours', [jd, Jl, Ll, Yd]), dr('eventOrder', {})], apis: { collapseMenu(t, e) { t.collapseMenu(e) }, highlightPrimary(t, e) { t.highlightPrimary(e) } }, factory(u, t) { let c; let e; const i = Ct(P.none()); const s = Um(); const n = function (t) { let o; let r; let e; const n = (o = t, r = u.data.primary, e = u.data.menus, et(e, (t, e) => { const n = function () { return Nm.sketch(Gn({ dom: t.dom }, t, { value: e, items: t.items, markers: u.markers, fakeFocus: u.fakeFocus, onHighlight: u.onHighlight, focusManager: u.fakeFocus ? mf() : df() })) }; return e === r ? { type: 'prepared', menu: o.getSystem().build(n()) } : { type: 'notbuilt', nbMenu: n } })); const i = a(t); return s.setContents(u.data.primary, n, u.data.expansions, i), s.getPrimary() }; const l = function (t) { return am.getValue(t).value }; var a = function (t) { return et(u.data.menus, (t, e) => j(t.items, (t) => t.type === 'separator' ? [] : [t.data.value])) }; const f = function (e, t) { Jl.highlight(e, t), Jl.getHighlighted(t).orThunk(() => Jl.getFirst(t)).each((t) => { Mr(e, t.element(), ke()) }) }; const d = function (e, t) { return Ot(E(t, (t) => e.lookupMenu(t).bind((t) => t.type === 'prepared' ? P.some(t.menu) : P.none()))) }; const m = function (e, t, n) { const o = d(t, t.otherMenus(n)); A(o, (t) => { Ni(t.element(), [u.markers.backgroundMenu]), u.stayInDom || Yd.remove(e, t) }) }; const h = function (t, o) { let r; const e = (r = t, i.get().getOrThunk(() => { const n = {}; const t = Oc(r.element(), `.${u.markers.item}`); const e = T(t, (t) => Mn(t, 'aria-haspopup') === 'true'); return A(e, (t) => { r.getSystem().getByDom(t).each((t) => { const e = l(t); n[e] = t }) }), i.set(P.some(n)), n })); tt(e, (t, e) => { const n = M(o, e); Cn(t.element(), 'aria-expanded', n) }) }; const g = function (o, r, i) { return P.from(i[0]).bind((t) => r.lookupMenu(t).bind((t) => { if (t.type === 'notbuilt') return P.none(); const e = t.menu; const n = d(r, i.slice(1)); return A(n, (t) => { _i(t.element(), u.markers.backgroundMenu) }), Dr(e.element()) || Yd.append(o, la(e)), Ni(e.element(), [u.markers.backgroundMenu]), f(o, e), m(o, r, i), P.some(e) })) }; (e = c || (c = {}))[e.HighlightSubmenu = 0] = 'HighlightSubmenu', e[e.HighlightParent = 1] = 'HighlightParent'; const v = function (r, i, a) { void 0 === a && (a = c.HighlightSubmenu); const t = l(i); return s.expand(t).bind((o) => h(r, o), P.from(o[0]).bind((n) => s.lookupMenu(n).bind((t) => { const e = (function (t, e, n) { if (n.type !== 'notbuilt') return n.menu; const o = t.getSystem().build(n.nbMenu()); return s.setMenuBuilt(e, o), o }(r, n, t)); return Dr(e.element()) || Yd.append(r, la(e)), u.onOpenSubmenu(r, i, e), a === c.HighlightSubmenu ? (Jl.highlightFirst(e), g(r, s, o)) : (Jl.dehighlightAll(e), P.some(i)) }))) }; const o = function (e, n) { const t = l(n); return s.collapse(t).bind((t) => h(e, t), g(e, s, t).map((t) => u.onCollapseMenu(e, n, t), t)) }; const r = function (n) { return function (e, t) { return ma(t.getSource(), `.${u.markers.item}`).bind((t) => e.getSystem().getByDom(t).toOption().bind((t) => n(e, t).map(() => !0))) } }; const p = Pr([Wr(Rm(), (e, t) => { const n = t.event().menu(); Jl.highlight(e, n); const o = l(t.event().item()); s.refresh(o).each((t) => m(e, s, t)) }), ei((e, t) => { const n = t.event().target(); e.getSystem().getByDom(n).each((t) => { l(t).indexOf('collapse-item') === 0 && o(e, t), v(e, t, c.HighlightSubmenu).fold(() => { u.onExecute(e, t) }, () => {}) }) }), Qr((e, t) => { n(e).each((t) => { Yd.append(e, la(t)), u.onOpenMenu(e, t), u.highlightImmediately && f(e, t) }) })].concat(u.navigateOnHover ? [Wr(Vm(), (t, e) => { let n; let o; const r = e.event().item(); n = t, o = l(r), s.refresh(o).bind((t) => h(n, t), g(n, s, t)), v(t, r, c.HighlightParent), u.onHover(t, r) })] : [])); const b = { collapseMenu(e) { Jl.getHighlighted(e).each((t) => { Jl.getHighlighted(t).each((t) => { o(e, t) }) }) }, highlightPrimary(e) { s.getPrimary().each((t) => { f(e, t) }) } }; return { uid: u.uid, dom: u.dom, markers: u.markers, behaviours: Ts(u.tmenuBehaviours, [jd.config({ mode: 'special', onRight: r((t, e) => Dl(e.element()) ? P.none() : v(t, e, c.HighlightSubmenu)), onLeft: r((t, e) => Dl(e.element()) ? P.none() : o(t, e)), onEscape: r((t, e) => o(t, e).orThunk(() => u.onEscape(t, e).map(() => t))), focusIn(e, t) { s.getPrimary().each((t) => { Mr(e, t.element(), ke()) }) } }), Jl.config({ highlightClass: u.markers.selectedMenu, itemClass: u.markers.menu }), Ll.config({ find(t) { return Jl.getHighlighted(t) } }), Yd.config({})]), eventOrder: u.eventOrder, apis: b, events: p } }, extraApis: { tieredData(t, e, n) { return { primary: t, menus: e, expansions: n } }, singleData(t, e) { return { primary: t, menus: wt(t, e), expansions: {} } }, collapseItem(t) { return { value: Un(Wm()), meta: { text: t } } } } }); const Xm = Tl({ name: 'InlineView', configFields: [Zo('lazySink'), Sa('onShow'), Sa('onHide'), lr('onEscape'), Es('inlineBehaviours', [ks, Ua]), fr('fireDismissalEventInstead', [dr('event', De())]), dr('getRelated', P.none), dr('eventOrder', P.none)], factory(s, t) { const r = function (t, e, n, o) { const r = s.lazySink(t).getOrDie(); ks.openWhileCloaked(t, n, () => is.positionWithin(r, e, t, o)), s.onShow(t) }; const e = { setContent(t, e) { ks.open(t, e) }, showAt(t, e, n) { const o = P.none(); r(t, e, n, o) }, showWithin: r, showMenuAt(t, e, n) { let o; let r; let i; let a; let u; const c = (o = s, r = t, i = e, a = n, u = function () { return o.lazySink(r) }, Gm.sketch({ dom: { tag: 'div' }, data: a.data, markers: a.menu.markers, onEscape() { return ks.close(r), o.onEscape.map((t) => t(r)), P.some(!0) }, onExecute() { return P.some(!0) }, onOpenMenu(t, e) { is.position(u().getOrDie(), i, e) }, onOpenSubmenu(t, e, n) { const o = u().getOrDie(); is.position(o, { anchor: 'submenu', item: e }, n) } })); ks.open(t, c), s.onShow(t) }, hide(t) { ks.close(t), s.onHide(t) }, getContent(t) { return ks.getState(t) }, isOpen: ks.isOpen }; return { uid: s.uid, dom: s.dom, behaviours: Ts(s.inlineBehaviours, [ks.config({ isPartOf(t, e, n) { return ga(e, n) || (o = t, r = n, s.getRelated(o).exists((t) => ga(t, r))); let o, r }, getAttachPoint(t) { return s.lazySink(t).getOrDie() } }), Hs(Gn({ isExtraPart: U(!1) }, s.fireDismissalEventInstead.map((t) => ({ fireEventInstead: { event: t.event } })).getOr({})))]), eventOrder: s.eventOrder, apis: e } }, apis: { showAt(t, e, n, o) { t.showAt(e, n, o) }, showWithin(t, e, n, o, r) { t.showWithin(e, n, o, r) }, showMenuAt(t, e, n, o) { t.showMenuAt(e, n, o) }, hide(t, e) { t.hide(e) }, isOpen(t, e) { return t.isOpen(e) }, getContent(t, e) { return t.getContent(e) }, setContent(t, e, n) { t.setContent(e, n) } } }); const Ym = function (t) { const e = function (t, e) { e.stop(), Or(t) }; const n = be.detect().deviceType.isTouch() ? [Wr(Ce(), e)] : [Wr(jt(), e), Wr(At(), (t, e) => { e.cut() })]; return Pr(R([t.map((n) => Wr(Se(), (t, e) => { n(t), e.stop() })).toArray(), n])) }; const qm = Tl({ name: 'Button', factory(t) { const e = Ym(t.action); const n = t.dom.tag; const o = function (e) { return xt(t.dom, 'attributes').bind((t) => xt(t, e)) }; return { uid: t.uid, dom: t.dom, components: t.components, events: e, behaviours: Ds(t.buttonBehaviours, [fm.config({}), jd.config({ mode: 'execution', useSpace: !0, useEnter: !0 })]), domModification: { attributes: (function () { if (n !== 'button') return { role: o('role').getOr('button') }; const t = o('type').getOr('button'); const e = o('role').map((t) => ({ role: t })).getOr({}); return Gn({ type: t }, e) }()) }, eventOrder: t.eventOrder } }, configFields: [dr('uid', undefined), Zo('dom'), dr('components', []), Bs('buttonBehaviours', [fm, jd]), ur('action'), ur('role'), dr('eventOrder', {})] }); const Km = function (t) { const e = (function n(t) { return t.uid !== undefined }(t)) && kt(t, 'uid') ? t.uid : li('memento'); return { get(t) { return t.getSystem().getByUid(e).getOrDie() }, getOpt(t) { return t.getSystem().getByUid(e).fold(P.none, P.some) }, asSpec() { return Gn({}, t, { uid: e }) } } }; const Jm = { 'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>', 'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'align-none': '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 1 1 0-2h9.2zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h6.8zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h4.4zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 0 1 0-2h2zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>', 'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', 'arrow-left': '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8z" fill-rule="evenodd"/></svg>', 'arrow-right': '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8z" fill-rule="evenodd"/></svg>', bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>', bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1z" fill-rule="nonzero"/></svg>', 'border-width': '<svg width="24" height="24"><path d="M5 14.8h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm-.5 3.7h15c.3 0 .5.2.5.5s-.2.5-.5.5h-15a.5.5 0 1 1 0-1zm.5-8.3h14c.6 0 1 .4 1 1v1c0 .5-.4 1-1 1H5a1 1 0 0 1-1-1v-1c0-.6.4-1 1-1zm0-5.7h14c.6 0 1 .4 1 1v2c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-2c0-.6.4-1 1-1z" fill-rule="evenodd"/></svg>', brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0zm-10-7l-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>', browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6z" fill-rule="nonzero"/></svg>', cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8zM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>', 'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 1 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>', 'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>', checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>', checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>', 'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>', 'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>', 'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>', 'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>', close: '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5z" fill-rule="evenodd"/></svg>', 'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>', 'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5z" fill-rule="evenodd"/></svg>', 'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z" fill-rule="nonzero"/></svg>', 'color-swatch-remove-color': '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>', 'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>', comment: '<svg width="24" height="24"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23z" fill-rule="nonzero"/></svg>', contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6z" fill-rule="evenodd"/></svg>', copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>', crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>', cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>', 'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>', drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>', duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1z"/></g></svg>', 'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9zM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>', 'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2z" fill-rule="nonzero"/></svg>', embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4z" fill-rule="nonzero"/></svg>', emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13z" fill-rule="nonzero"/></svg>', fill: '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>', 'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2zm14-2v2h2a2 2 0 0 0-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 0 0 2-2h-2v2z" fill-rule="nonzero"/></svg>', 'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2zm2 14h-2v2a2 2 0 0 0 2-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>', 'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>', fullscreen: '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>', gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0z" fill-rule="nonzero"/></svg>', help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1zM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>', 'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>', home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>', 'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>', 'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" fill-rule="nonzero"/></svg>', image: '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" fill-rule="nonzero"/></svg>', indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>', indeterminate: '<svg width="24" height="24"><path d="M12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18zM9 11a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2H9z" fill-rule="evenodd"/></svg>', info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>', 'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5z" fill-rule="evenodd"/></svg>', 'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 2H5a3 3 0 0 0-3 3v14a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V5a3 3 0 0 0-3-3zm-7 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16z"/><path d="M15 12h-3V7a.5.5 0 0 0-1 0v6h4a.5.5 0 0 0 0-1z"/></g></svg>', invert: '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>', italic: '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>', line: '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>', link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2.1 2a2 2 0 1 0 2.7 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2z" fill-rule="nonzero"/></svg>', 'list-bull-circle': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-bull-default': '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-bull-square': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', 'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>', 'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>', 'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', 'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>', lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7z" fill-rule="evenodd"/></svg>', ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>', 'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>', 'new-tab': '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>', 'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>', notice: '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>', 'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>', orientation: '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1z" fill-rule="nonzero"/></svg>', outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>', 'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>', paragraph: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5z" fill-rule="evenodd"/></svg>', 'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>', paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>', 'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>', plus: '<svg width="24" height="24"><g fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="#000" stroke-width="2"><path d="M12 5v14M5 12h14"/></g></svg>', preferences: '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" fill-rule="evenodd"/></svg>', preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6z" fill-rule="nonzero"/></svg>', print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>', quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3z" fill-rule="nonzero"/></svg>', redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>', reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1z"/></g></svg>', 'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8zM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1z" fill-rule="evenodd"/></svg>', remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4z" fill-rule="nonzero"/></svg>', 'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7zM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3z"/></g></svg>', resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5z" fill-rule="evenodd"/></svg>', 'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></g></svg>', 'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></svg>', 'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>', rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>', save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6z" fill-rule="nonzero"/></svg>', search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12z" fill-rule="nonzero"/></svg>', 'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 0 0-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 0 0 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>', selected: '<svg width="24" height="24"><path d="M12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm-2.4-6.1L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3z" fill-rule="evenodd"/></svg>', settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>', sharpen: '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>', sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>', 'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>', 'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2z" fill-rule="nonzero"/></g></svg>', subscript: '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>', superscript: '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>', 'table-cell-properties': '<svg width="24" height="24"><path d="M4 5h16v14H4V5zm10 10h-4v3h4v-3zm0-8h-4v3h4V7zM9 7H5v3h4V7zm-4 4v3h4v-3H5zm10 0v3h4v-3h-4zm0-1h4V7h-4v3zM5 15v3h4v-3H5zm10 3h4v-3h-4v3z" fill-rule="evenodd"/></svg>', 'table-cell-select-all': '<svg width="24" height="24"><path d="M12.5 5.5v6h6v-6h-6zm-1 0h-6v6h6v-6zm1 13h6v-6h-6v6zm-1 0v-6h-6v6h6zm-7-14h15v15h-15v-15z" fill-rule="nonzero"/></svg>', 'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5.5 5.5v13h13v-13h-13zm-1-1h15v15h-15v-15z" opacity=".2"/><path d="M11.5 11.5v-7h1v7h7v1h-7v7h-1v-7h-7v-1h7z"/></g></svg>', 'table-delete-column': '<svg width="24" height="24"><path d="M9 11.2l1 1v.2l-1 1v-2.2zm5 1l1-1v2.2l-1-1v-.2zM20 5v14H4V5h16zm-1 2h-4v.8l-.2-.2-.8.8V7h-4v1.4l-.8-.8-.2.2V7H5v11h4v-1.8l.5.5.5-.4V18h4v-1.8l.8.8.2-.3V18h4V7zm-3.9 3.4l-1.8 1.9 1.8 1.9c.4.3.4.9 0 1.2-.3.3-.8.3-1.2 0L12 13.5l-1.8 1.9a.8.8 0 0 1-1.2 0 .9.9 0 0 1 0-1.2l1.8-1.9-1.9-2a.9.9 0 0 1 1.2-1.2l2 2 1.8-1.8c.3-.4.9-.4 1.2 0a.8.8 0 0 1 0 1.1z" fill-rule="evenodd"/></svg>', 'table-delete-row': '<svg width="24" height="24"><path d="M16.7 8.8l1.1 1.2-2.4 2.5L18 15l-1.2 1.2-2.5-2.5-2.4 2.5-1.3-1.2 2.5-2.5-2.5-2.5 1.2-1.3 2.6 2.6 2.4-2.5zM4 5h16v14H4V5zm15 5V7H5v3h4.8l1 1H5v3h5.8l-1 1H5v3h14v-3h-.4l-1-1H19v-3h-1.3l1-1h.3z" fill-rule="evenodd"/></svg>', 'table-delete-table': '<svg width="24" height="26"><path d="M4 6h16v14H4V6zm1 2v11h14V8H5zm11.7 8.7l-1.5 1.5L12 15l-3.3 3.2-1.4-1.5 3.2-3.2-3.3-3.2 1.5-1.5L12 12l3.2-3.2 1.5 1.5-3.2 3.2 3.2 3.2z" fill-rule="evenodd"/></svg>', 'table-insert-column-after': '<svg width="24" height="24"><path d="M14.3 9c.4 0 .7.3.7.6v2.2h2.1c.4 0 .7.3.7.7 0 .4-.3.7-.7.7H15v2.2c0 .3-.3.6-.7.6a.7.7 0 0 1-.6-.6v-2.2h-2.2a.7.7 0 0 1 0-1.4h2.2V9.6c0-.3.3-.6.6-.6zM4 5h16v14H4V5zm5 13v-3H5v3h4zm0-4v-3H5v3h4zm0-4V7H5v3h4zm10 8V7h-9v11h9z" fill-rule="evenodd"/></svg>', 'table-insert-column-before': '<svg width="24" height="24"><path d="M9.7 16a.7.7 0 0 1-.7-.6v-2.2H6.9a.7.7 0 0 1 0-1.4H9V9.6c0-.3.3-.6.7-.6.3 0 .6.3.6.6v2.2h2.2c.4 0 .8.3.8.7 0 .4-.4.7-.8.7h-2.2v2.2c0 .3-.3.6-.6.6zM4 5h16v14H4V5zm10 13V7H5v11h9zm5 0v-3h-4v3h4zm0-4v-3h-4v3h4zm0-4V7h-4v3h4z" fill-rule="evenodd"/></svg>', 'table-insert-row-above': '<svg width="24" height="24"><path d="M14.8 10.5c0 .3-.2.5-.5.5h-1.8v1.8c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.6V11H9.7a.5.5 0 0 1 0-1h1.8V8.3c0-.3.2-.6.5-.6s.5.3.5.6V10h1.8c.3 0 .5.2.5.5zM4 5h16v14H4V5zm5 13v-3H5v3h4zm5 0v-3h-4v3h4zm5 0v-3h-4v3h4zm0-4V7H5v7h14z" fill-rule="evenodd"/></svg>', 'table-insert-row-after': '<svg width="24" height="24"><path d="M9.2 14.5c0-.3.2-.5.5-.5h1.8v-1.8c0-.3.2-.5.5-.5s.5.2.5.6V14h1.8c.3 0 .5.2.5.5s-.2.5-.5.5h-1.8v1.7c0 .3-.2.6-.5.6a.5.5 0 0 1-.5-.6V15H9.7a.5.5 0 0 1-.5-.5zM4 5h16v14H4V5zm6 2v3h4V7h-4zM5 7v3h4V7H5zm14 11v-7H5v7h14zm0-8V7h-4v3h4z" fill-rule="evenodd"/></svg>', 'table-left-header': '<svg width="24" height="24"><path d="M4 5h16v13H4V5zm10 12v-3h-4v3h4zm0-4v-3h-4v3h4zm0-4V6h-4v3h4zm5 8v-3h-4v3h4zm0-4v-3h-4v3h4zm0-4V6h-4v3h4z" fill-rule="evenodd"/></svg>', 'table-merge-cells': '<svg width="24" height="24"><path d="M4 5h16v14H4V5zm6 13h9v-7h-9v7zm4-11h-4v3h4V7zM9 7H5v3h4V7zm-4 4v3h4v-3H5zm10-1h4V7h-4v3zM5 15v3h4v-3H5z" fill-rule="evenodd"/></svg>', 'table-row-properties': '<svg width="24" height="24"><path d="M4 5h16v14H4V5zm10 10h-4v3h4v-3zm0-8h-4v3h4V7zM9 7H5v3h4V7zm6 3h4V7h-4v3zM5 15v3h4v-3H5zm10 3h4v-3h-4v3z" fill-rule="evenodd"/></svg>', 'table-split-cells': '<svg width="24" height="24"><path d="M4 5h16v14H4V5zm6 2v3h4V7h-4zM9 18v-3H5v3h4zm0-4v-3H5v3h4zm0-4V7H5v3h4zm10 8v-7h-9v7h9zm0-8V7h-4v3h4zm-3.5 4.5l1.5 1.6c.3.2.3.7 0 1-.2.2-.7.2-1 0l-1.5-1.6-1.6 1.5c-.2.3-.7.3-1 0a.7.7 0 0 1 0-1l1.6-1.5-1.5-1.6a.7.7 0 0 1 1-1l1.5 1.6 1.6-1.5c.2-.3.7-.3 1 0 .2.2.2.7 0 1l-1.6 1.5z" fill-rule="evenodd"/></svg>', 'table-top-header': '<svg width="24" height="24"><path d="M4 5h16v13H4V5zm5 12v-3H5v3h4zm0-4v-3H5v3h4zm5 4v-3h-4v3h4zm0-4v-3h-4v3h4zm5 4v-3h-4v3h4zm0-4v-3h-4v3h4z" fill-rule="evenodd"/></svg>', table: '<svg width="24" height="24"><path d="M4 5h16v14H4V5zm6 9h4v-3h-4v3zm4 1h-4v3h4v-3zm0-8h-4v3h4V7zM9 7H5v3h4V7zm-4 4v3h4v-3H5zm10 0v3h4v-3h-4zm0-1h4V7h-4v3zM5 15v3h4v-3H5zm10 3h4v-3h-4v3z" fill-rule="evenodd"/></svg>', template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>', 'temporary-placeholder': '<svg width="24" height="24"><path d="M20.5 2.5c-.8 0-1.5.7-1.5 1.5a1.5 1.5 0 0 1-3 0 3 3 0 0 0-6 0v2H8.5c-.3 0-.5.2-.5.5v1a8 8 0 1 0 6 0v-1c0-.3-.2-.5-.5-.5H11V4a2 2 0 0 1 4 0 2.5 2.5 0 0 0 5 0c0-.3.2-.5.5-.5a.5.5 0 0 0 0-1zM8.1 10.9a5 5 0 0 0-1.2 7 .5.5 0 0 1-.8.5 6 6 0 0 1 1.5-8.3.5.5 0 1 1 .5.8z" fill-rule="nonzero"/></svg>', 'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>', toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', translate: '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 1 1 2 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>', underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>', undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>', unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2zM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1zM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19z" fill-rule="nonzero"/></svg>', unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>', 'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>', unselected: '<svg width="24" height="24"><path d="M12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18zm0-1a8 8 0 1 0 0-16 8 8 0 0 0 0 16z" fill-rule="evenodd"/></svg>', upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12zM11 6.4L8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4z" fill-rule="nonzero"/></svg>', user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>', warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>', 'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>', 'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>' }; const $m = P.from(Jm['temporary-placeholder']).getOr('!not found!'); const Qm = function (e, t) { return P.from(t()[e]).getOrThunk(() => { return t = e, P.from(Jm[t]).getOr($m); let t }) }; const Zm = function (n, t, o) { return P.from(t()[n]).getOrThunk(() => { return t = n, e = o, P.from(Jm[t]).getOrThunk(() => e.getOr($m)); let t, e }) }; const th = function (t, e) { return Mt(t, (t) => P.from(e()[t])).getOrThunk(() => Mt(t, (t) => P.from(Jm[t])).getOr($m)) }; const eh = { success: 'checkmark', error: 'warning', err: 'error', warning: 'warning', warn: 'warning', info: 'info' }; const nh = Tl({ name: 'Notification', factory(e) { const o = Km({ dom: { tag: 'p', innerHtml: e.translationProvider(e.text) }, behaviours: _a([Yd.config({})]) }); const n = function (t) { return { dom: { tag: 'div', classes: ['tox-bar'], attributes: { style: `width: ${t}%` } } } }; const r = function (t) { return { dom: { tag: 'div', classes: ['tox-text'], innerHtml: `${t}%` } } }; const i = Km({ dom: { tag: 'div', classes: e.progress ? ['tox-progress-bar', 'tox-progress-indicator'] : ['tox-progress-bar'] }, components: [{ dom: { tag: 'div', classes: ['tox-bar-container'] }, components: [n(0)] }, r(0)], behaviours: _a([Yd.config({})]) }); const t = { updateProgress(t, e) { t.getSystem().isConnected() && i.getOpt(t).each((t) => { Yd.set(t, [{ dom: { tag: 'div', classes: ['tox-bar-container'] }, components: [n(e)] }, r(e)]) }) }, updateText(t, e) { if (t.getSystem().isConnected()) { const n = o.get(t); Yd.set(n, [aa(e)]) } } }; const a = R([e.icon.toArray(), e.level.toArray(), e.level.bind((t) => P.from(eh[t])).toArray()]); return { uid: e.uid, dom: { tag: 'div', attributes: { role: 'alert' }, classes: e.level.map((t) => ['tox-notification', 'tox-notification--in', `tox-notification--${t}`]).getOr(['tox-notification', 'tox-notification--in']) }, components: [{ dom: { tag: 'div', classes: ['tox-notification__icon'], innerHtml: th(a, e.iconProvider) } }, { dom: { tag: 'div', classes: ['tox-notification__body'] }, components: [o.asSpec()], behaviours: _a([Yd.config({})]) }].concat(e.progress ? [i.asSpec()] : []).concat(qm.sketch({ dom: { tag: 'button', classes: ['tox-notification__dismiss', 'tox-button', 'tox-button--naked', 'tox-button--icon'] }, components: [{ dom: { tag: 'div', classes: ['tox-icon'], innerHtml: Qm('close', e.iconProvider), attributes: { 'aria-label': e.translationProvider('Close') } } }], action(t) { e.onAction(t) } })), apis: t } }, configFields: [ur('level'), Zo('progress'), Zo('icon'), Zo('onAction'), Zo('text'), Zo('iconProvider'), Zo('translationProvider')], apis: { updateProgress(t, e, n) { t.updateProgress(e, n) }, updateText(t, e, n) { t.updateText(e, n) } } }); function oh(r, i, a) { const u = i.backstage; return { open(t, e) { const n = function () { e(), Xm.hide(r) }; const o = sa(nh.sketch({ text: t.text, level: M(['success', 'error', 'warning', 'info'], t.type) ? t.type : undefined, progress: !0 === t.progressBar, icon: P.from(t.icon), onAction: n, iconProvider: u.shared.providers.icons, translationProvider: u.shared.providers.translate })); var r = sa(Xm.sketch({ dom: { tag: 'div', classes: ['tox-notifications-container'] }, lazySink: i.backstage.shared.getSink, fireDismissalEventInstead: {} })); return a.add(r), t.timeout && setTimeout(() => { n() }, t.timeout), { close: n, moveTo(t, e) { Xm.showAt(r, { anchor: 'makeshift', x: t, y: e }, la(o)) }, moveRel(t, e) { Xm.showAt(r, i.backstage.shared.anchors.banner(), la(o)) }, text(t) { nh.updateText(o, t) }, settings: t, getEl() {}, progressBar: { value(t) { nh.updateProgress(o, t) } } } }, close(t) { t.close() }, reposition(t) { A(t, (t) => { t.moveTo(0, 0) }), (function (n) { if (n.length > 0) { const t = n.slice(0, 1)[0]; const e = (o = r).inline ? o.getElement() : o.getContentAreaContainer(); t.moveRel(e, 'tc-tc'), A(n, (t, e) => { e > 0 && t.moveRel(n[e - 1].getEl(), 'bc-tc') }) } let o }(t)) }, getArgs(t) { return t.settings } } } let rh; let ih; const ah = function (n, o) { let r = null; return { cancel() { r !== null && (clearTimeout(r), r = null) }, throttle() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; r !== null && clearTimeout(r), r = setTimeout(() => { n.apply(null, t), r = null }, o) } } }; const uh = /[\u00a0 \t\r\n]/; const ch = function (n, t, e, o, r) { return void 0 === r && (r = 0), (i = n).collapsed && i.startContainer.nodeType === 3 ? (function (t, e, n, o) { let r; for (r = e - 1; r >= 0; r--) { if (uh.test(t.charAt(r))) return P.none(); if (t.charAt(r) === n) break } return r === -1 || e - r < o ? P.none() : P.some(t.substring(r + 1, e)) }(e, o, t, r)).map((t) => { const e = n.cloneRange(); return e.setStart(n.startContainer, n.startOffset - t.length - 1), e.setEnd(n.startContainer, n.startOffset), { text: t, rng: e } }) : P.none(); let i }; const sh = function (n, t) { t.on('keypress', n.onKeypress.throttle), t.on('remove', n.onKeypress.cancel); const o = function (t, e) { Cr(t, It(), { raw: e }) }; t.on('keydown', (e) => { const t = function () { return n.getView().bind(Jl.getHighlighted) }; e.which === 8 && n.onKeypress.throttle(e), n.isActive() && (e.which === 27 ? n.closeIfNecessary() : e.which === 32 ? n.closeIfNecessary() : e.which === 13 ? (t().each(Or), e.preventDefault()) : e.which === 40 ? (t().fold(() => { n.getView().each(Jl.highlightFirst) }, (t) => { o(t, e) }), e.preventDefault()) : e.which !== 37 && e.which !== 38 && e.which !== 39 || t().each((t) => { o(t, e), e.preventDefault() })) }) }; const lh = tinymce.util.Tools.resolve('tinymce.util.Promise'); const fh = function (t, e) { let n; let o; let r; const i = e(); const a = t.selection.getRng(); const u = a.startContainer.nodeValue; return (n = a, o = u, r = i, Mt(r.triggerChars, (e) => ch(n, e, o, n.startOffset).map((t) => ({ range: t.rng, text: t.text, triggerChar: e })))).map((n) => { const t = T(i.lookupByChar(n.triggerChar), (t) => n.text.length >= t.minChars && t.matches(n.range, u, n.text)); return { lookupData: lh.all(E(t, (e) => e.fetch(n.text, e.maxResults).then((t) => ({ items: t, columns: e.columns, onAction: e.onAction })))), triggerChar: n.triggerChar, range: n.range } }) }; const dh = Vo([xr('type', () => 'autocompleteitem'), xr('active', () => !1), xr('disabled', () => !1), dr('meta', {}), er('value'), sr('text'), sr('icon')]); const mh = Vo([er('type'), er('ch'), hr('minChars', 0), dr('columns', 1), hr('maxResults', 10), br('matches', () => !0), or('fetch'), or('onAction')]); const hh = function (t) { let e; let n; const o = t.ui.registry.getAll().popups; const r = et(o, (t) => { return (e = t, Po('Autocompleter', mh, e)).fold((t) => { throw new Error(Wo(t)) }, (t) => t); let e }); const i = (e = ot(r, (t) => t.ch), n = {}, A(e, (t) => { n[t] = {} }), Q(n)); const a = rt(r); return { dataset: r, triggerChars: i, lookupByChar(e) { return T(a, (t) => t.ch === e) } } }; const gh = [pr('disabled', !1), sr('text'), sr('shortcut'), _o('value', 'value', Zn(() => Un('menuitem-value')), Xo()), dr('meta', {})]; const vh = Vo([er('type'), br('onSetup', () => N), br('onAction', N), sr('icon')].concat(gh)); const ph = function (t) { return Po('menuitem', vh, t) }; const bh = Vo([er('type'), or('getSubmenuItems'), br('onSetup', () => N), sr('icon')].concat(gh)); const yh = Vo([er('type'), pr('active', !1), br('onSetup', () => N), or('onAction')].concat(gh)); const xh = function (t) { return Po('togglemenuitem', yh, t) }; const wh = Vo([er('type'), pr('active', !1), sr('icon')].concat(gh)); const zh = Vo([er('type'), sr('text')]); const Sh = Vo([er('type'), nr('fancytype', ['inserttable']), br('onAction', N)]); const kh = function (t, o, e) { const r = Oc(t.element(), `.${e}`); if (r.length > 0) { const n = F(r, (t) => { const e = t.dom().getBoundingClientRect().top; const n = r[0].dom().getBoundingClientRect().top; return Math.abs(e - n) > o }).getOr(r.length); return P.some({ numColumns: n, numRows: Math.ceil(r.length / n) }) } return P.none() }; const Ch = function (t, e) { return _a([Am(t, e)]) }; const Oh = function (t) { return Ch(Un('unnamed-events'), t) }; const Mh = 'tox-menu-nav__js'; const Hh = 'tox-collection__item'; const Vh = 'tox-swatch'; const Eh = { normal: Mh, color: Vh }; const Ah = 'tox-collection__item--enabled'; const Th = 'tox-collection__item-icon'; const Bh = 'tox-collection__item-label'; const Dh = 'tox-collection__item--active'; const _h = function (t) { return xt(Eh, t).getOr(Mh) }; const Fh = function (t) { let e; let n; let o; const r = Ne.fromHtml(t); const i = cn(r); const a = (n = (e = r).dom().attributes !== undefined ? e.dom().attributes : [], D(n, (t, e) => { let n; return e.name === 'class' ? t : Gn({}, t, ((n = {})[e.name] = e.value, n)) }, {})); const u = (o = r, Array.prototype.slice.call(o.dom().classList, 0)); const c = i.length === 0 ? {} : { innerHtml: pn(r) }; return Gn({ tag: yn(r), classes: u, attributes: a }, c) }; const Lh = tinymce.util.Tools.resolve('tinymce.util.I18n'); const Ih = tinymce.util.Tools.resolve('tinymce.Env'); const Rh = function (t) { const n = Ih.mac ? { alt: '&#x2325;', ctrl: '&#x2303;', shift: '&#x21E7;', meta: '&#x2318;' } : { meta: 'Ctrl' }; const e = t.split('+'); const o = E(e, (t) => { const e = t.toLowerCase().trim(); return it(n, e) ? n[e] : t }); return Ih.mac ? o.join('') : o.join('+') }; const Nh = function (t) { return { dom: { tag: 'span', classes: [Th], innerHtml: t } } }; const Ph = function (t) { return { dom: { tag: 'span', classes: [Bh] }, components: [aa(Lh.translate(t))] } }; const jh = function (t) { return { dom: { tag: 'span', classes: ['tox-collection__item-accessory'], innerHtml: Rh(t) } } }; const Uh = function (t) { return { dom: { tag: 'span', classes: [Th, 'tox-collection__item-checkmark'], innerHtml: Qm('checkmark', t) } } }; const Wh = function (t, e, n) { void 0 === n && (n = P.none()); let o; let r; let i; let a; let u; let c; let s; let l; let f; const d = t.iconContent.map((t) => Zm(t, e.icons, n)); return t.presets === 'color' ? (u = t.ariaLabel, c = t.value, { dom: (s = Vh, l = d.getOr(''), f = u.map((t) => ` title="${t}"`).getOr(''), Fh(c === 'custom' ? `<button class="${s} tox-swatches__picker-btn"${f}>${l}</button>` : c === 'remove' ? `<div class="${s} tox-swatch--remove"${f}>${l}</div>` : `<div class="${s}" style="background-color: ${c}" data-mce-color="${c}"${f}></div>`)), optComponents: [] }) : (r = d, i = (o = t).checkMark.orThunk(() => r.or(P.some('')).map(Nh)), a = o.ariaLabel.map((t) => ({ attributes: { title: Lh.translate(t) } })).getOr({}), { dom: vt({ tag: 'div', classes: [Mh, Hh] }, a), optComponents: [i, o.textContent.map(Ph), o.shortcutContent.map(jh), o.caret] }) }; const Gh = ['input', 'button', 'textarea']; const Xh = function (t, e, n) { e.disabled && Qh(t, e, n) }; const Yh = function (t) { return M(Gh, yn(t.element())) }; const qh = function (t) { Cn(t.element(), 'disabled', 'disabled') }; const Kh = function (t) { Vn(t.element(), 'disabled') }; const Jh = function (t) { Cn(t.element(), 'aria-disabled', 'true') }; const $h = function (t) { Cn(t.element(), 'aria-disabled', 'false') }; var Qh = function (e, t, n) { t.disableClass.each((t) => { _i(e.element(), t) }), (Yh(e) ? qh : Jh)(e) }; const Zh = function (t) { return Yh(t) ? Hn(t.element(), 'disabled') : Mn(t.element(), 'aria-disabled') === 'true' }; const tg = Object.freeze({ enable(e, t, n) { t.disableClass.each((t) => { Li(e.element(), t) }), (Yh(e) ? Kh : $h)(e) }, disable: Qh, isDisabled: Zh, onLoad: Xh }); const eg = Object.freeze({ exhibit(t, e, n) { return zi({ classes: e.disabled ? e.disableClass.map(q).getOr([]) : [] }) }, events(t, e) { return Pr([jr(Se(), (t, e) => Zh(t)), Ea(t, e, Xh)]) } }); const ng = [dr('disabled', !1), ur('disableClass')]; const og = La({ fields: ng, name: 'disabling', active: eg, apis: tg }); const rg = function (t) { return og.config({ disabled: t, disableClass: 'tox-collection__item--state-disabled' }) }; const ig = function (t) { return og.config({ disabled: t }) }; const ag = function (t) { return og.config({ disabled: t, disableClass: 'tox-tbtn--disabled' }) }; const ug = function (t, e) { const n = t.getApi(e); return function (t) { t(n) } }; const cg = function (n, o) { return Qr((t) => { ug(n, t)((t) => { const e = n.onSetup(t); e !== null && e !== undefined && o.set(e) }) }) }; const sg = function (e, n) { return Zr((t) => ug(e, t)(n.get())) }; (ih = rh || (rh = {}))[ih.CLOSE_ON_EXECUTE = 0] = 'CLOSE_ON_EXECUTE', ih[ih.BUBBLE_TO_SANDBOX = 1] = 'BUBBLE_TO_SANDBOX'; let lg; let fg; const dg = rh; const mg = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'item-events'] }; const hg = function (t) { return j(t, (t) => t.toArray()) }; const gg = function (t, e, n) { let o; let r; const i = Ct(N); return { type: 'item', dom: e.dom, components: hg(e.optComponents), data: t.data, eventOrder: mg, hasSubmenu: t.triggersSubmenu, itemBehaviours: _a([Am('item-events', [(o = t, r = n, ei((t, e) => { ug(o, t)(o.onAction), o.triggersSubmenu || r !== dg.CLOSE_ON_EXECUTE || (kr(t, He()), e.stop()) })), cg(t, i), sg(t, i)]), rg(t.disabled), Yd.config({})].concat(t.itemBehaviours)) } }; const vg = function (t) { return { value: t.value, meta: vt({ text: t.text.getOr('') }, t.meta) } }; const pg = U(fl('item-widget', Dm())); const bg = Un('cell-over'); const yg = Un('cell-execute'); const xg = function (e, n, t) { let o; const r = function (t) { return Cr(t, yg, { row: e, col: n }) }; return sa({ dom: { tag: 'div', attributes: (o = { role: 'button' }, o['aria-labelledby'] = t, o) }, behaviours: _a([Am('insert-table-picker-cell', [Wr(_t(), fm.focus), Wr(Se(), r), Wr(Oe(), r)]), km.config({ toggleClass: 'tox-insert-table-picker__selected', toggleOnExecute: !1 }), fm.config({ onFocus(t) { return Cr(t, bg, { row: e, col: n }) } })]) }) }; const wg = { inserttable: function sV(o) { let t; const e = Un('size-label'); const u = (function (t, e, n) { for (var o = [], r = 0; r < e; r++) { for (var i = [], a = 0; a < n; a++)i.push(xg(r, a, t)); o.push(i) } return o }(e, 10, 10)); const c = Km({ dom: { tag: 'span', classes: ['tox-insert-table-picker__label'], attributes: { id: e } }, components: [aa('0x0')], behaviours: _a([Yd.config({})]) }); return { type: 'widget', data: { value: Un('widget-id') }, dom: { tag: 'div', classes: ['tox-fancymenuitem'] }, autofocus: !0, components: [pg().widget({ dom: { tag: 'div', classes: ['tox-insert-table-picker'] }, components: (t = u, j(t, (t) => E(t, la))).concat(c.asSpec()), behaviours: _a([Am('insert-table-picker', [qr(bg, (t, e, n) => { let o; let r; const i = n.event().row(); const a = n.event().col(); !(function (t, e, n, o, r) { for (let i = 0; i < o; i++) for (let a = 0; a < r; a++)km.set(t[i][a], i <= e && a <= n) }(u, i, a, 10, 10)), Yd.set(c.get(t), [(o = i, r = a, aa(`${r + 1}x${o + 1}`))]) }), qr(yg, (t, e, n) => { o.onAction({ numRows: n.event().row() + 1, numColumns: n.event().col() + 1 }), kr(t, He()) })]), jd.config({ initSize: { numRows: 10, numColumns: 10 }, mode: 'flatgrid', selector: '[role="button"]' })]) })] } } }; const zg = function (t, a, e) { return { dom: { tag: 'div', classes: [Mh, Hh] }, optComponents: [P.some(e), t.map((t) => { return e = a.tag, n = a.styleAttr, o = 'span', r = [Bh], i = [{ dom: { tag: e, attributes: { style: n } }, components: [aa(t)] }], { dom: { tag: o, classes: r }, components: i }; let e, n, o, r, i })] } }; const Sg = function (e, t, n, o, r, i, a) { const u = Wh({ presets: n, textContent: t ? e.text : P.none(), ariaLabel: e.text, iconContent: e.icon, shortcutContent: t ? e.shortcut : P.none(), checkMark: t ? P.some(Uh(a.icons)) : P.none(), caret: P.none(), value: e.value }, a); return gt(gg({ data: vg(e), disabled: e.disabled, getApi(e) { return { setActive(t) { km.set(e, t) }, isActive() { return km.isOn(e) }, isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }, onAction(t) { return o(e.value) }, onSetup(t) { return t.setActive(r), function () {} }, triggersSubmenu: !1, itemBehaviours: [] }, u, i), { toggling: { toggleClass: Ah, toggleOnExecute: !1, selected: e.active } }) }; const kg = function (e, t, n, o, r, i) { const a = Wh({ presets: n, textContent: t ? e.text : P.none(), ariaLabel: e.text, iconContent: e.icon, shortcutContent: P.none(), checkMark: P.none(), caret: P.none(), value: e.value }, i, e.icon); return gg({ data: vg(e), disabled: e.disabled, getApi() { return {} }, onAction(t) { return o(e.value, e.meta) }, onSetup() { return function () {} }, triggersSubmenu: !1, itemBehaviours: [] }, a, r) }; const Cg = function (t) { const e = t.text.fold(() => ({}), (t) => ({ innerHtml: t })); return { type: 'separator', dom: Gn({ tag: 'div', classes: [Hh, 'tox-collection__group-heading'] }, e), components: [] } }; const Og = function (t, e, n) { const o = t.type === 'togglemenuitem' && t.active ? Uh(n.icons) : Nh(''); const r = zg(t.text, t.meta, o); return gt(gg({ data: vg(t), disabled: t.disabled, getApi() { return 10 }, onAction: t.onAction, onSetup() { return function () {} }, triggersSubmenu: !1, itemBehaviours: [] }, r, e), t.type === 'togglemenuitem' ? { toggling: { toggleClass: Ah, toggleOnExecute: !1, selected: t.active } } : {}) }; const Mg = function (t, e, n) { const o = Wh({ presets: 'normal', iconContent: t.icon, textContent: t.text, ariaLabel: t.text, caret: P.none(), checkMark: P.none(), shortcutContent: t.shortcut }, n); return gg({ data: vg(t), getApi(e) { return { isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }, disabled: t.disabled, onAction: t.onAction, onSetup: t.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, o, e) }; const Hg = function (t, e, n) { let o; const r = (o = n.icons, { dom: { tag: 'span', classes: ['tox-collection__item-caret'], innerHtml: Qm('chevron-right', o) } }); const i = Wh({ presets: 'normal', iconContent: t.icon, textContent: t.text, ariaLabel: t.text, caret: P.some(r), checkMark: P.none(), shortcutContent: t.shortcut }, n); return gg({ data: vg(t), getApi(e) { return { isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }, disabled: t.disabled, onAction: N, onSetup: t.onSetup, triggersSubmenu: !0, itemBehaviours: [] }, i, e) }; const Vg = function (t, e, n) { const o = Wh({ iconContent: P.none(), textContent: t.text, ariaLabel: t.text, checkMark: P.some(Uh(n.icons)), caret: P.none(), shortcutContent: t.shortcut, presets: 'normal' }, n); return gt(gg({ data: vg(t), disabled: t.disabled, getApi(e) { return { setActive(t) { km.set(e, t) }, isActive() { return km.isOn(e) }, isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }, onAction: t.onAction, onSetup: t.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, o, e), { toggling: { toggleClass: Ah, toggleOnExecute: !1, selected: t.active } }) }; const Eg = function (e) { return (t = wg, n = e.fancytype, Object.prototype.hasOwnProperty.call(t, n) ? P.some(t[n]) : P.none()).map((t) => t(e)); let t, n }; const Ag = function (t) { return { backgroundMenu: 'tox-background-menu', selectedMenu: 'tox-selected-menu', selectedItem: 'tox-collection__item--active', hasIcons: 'tox-menu--has-icons', menu: (e = t, e === 'color' ? 'tox-swatches' : 'tox-menu'), tieredMenu: 'tox-tiered-menu' }; let e }; const Tg = function (t) { const e = Ag(t); return { backgroundMenu: e.backgroundMenu, selectedMenu: e.selectedMenu, menu: e.menu, selectedItem: e.selectedItem, item: _h(t) } }; const Bg = [Nm.parts().items({})]; const Dg = function (t, e, n) { const o = Ag(n); return { dom: { tag: 'div', classes: R([[o.tieredMenu]]) }, markers: Tg(n) } }; const _g = function (t, e) { const n = Tg(e); return t === 1 ? { mode: 'menu', moveOnTab: !0 } : t === 'auto' ? { mode: 'grid', selector: `.${n.item}`, initSize: { numColumns: 1, numRows: 1 } } : { mode: 'matrix', rowSelector: `.${e === 'color' ? 'tox-swatches__row' : 'tox-collection__group'}` } }; const Fg = function (n, o) { return function (t) { const e = V(t, o); return E(e, (t) => ({ dom: n, components: t })) } }; const Lg = function (e, i) { return { dom: { tag: 'div', classes: ['tox-menu', 'tox-collection'].concat(e === 1 ? ['tox-collection--list'] : ['tox-collection--grid']) }, components: [Nm.parts().items({ preprocess(t) { return e !== 'auto' && e > 1 ? Fg({ tag: 'div', classes: ['tox-collection__group'] }, e)(t) : (n = function (t, e) { return i[e].type === 'separator' }, o = [], r = [], A(t, (t, e) => { n(t, e) ? (r.length > 0 && o.push(r), r = [], it(t.dom, 'innerHtml') && r.push(t)) : r.push(t) }), r.length > 0 && o.push(r), E(o, (t) => ({ dom: { tag: 'div', classes: ['tox-collection__group'] }, components: t }))); let n, o, r } })] } }; (fg = lg || (lg = {}))[fg.ContentFocus = 0] = 'ContentFocus', fg[fg.UiFocus = 1] = 'UiFocus'; const Ig = function (t) { return console.error(Wo(t)), console.log(t), P.none() }; const Rg = function (t) { return t.icon !== undefined }; const Ng = function (t) { return H(t, Rg) }; const Pg = function (t, e, n) { switch (t.type) { case 'menuitem':return ph(t).fold(Ig, (t) => P.some(Mg(t, e, n))); case 'nestedmenuitem':return (i = t, Po('nestedmenuitem', bh, i)).fold(Ig, (t) => P.some(Hg(t, e, n))); case 'styleitem':return t.item.type === 'menuitem' ? ph(t.item).fold(Ig, (t) => P.some(Og(t, e, n))) : t.item.type === 'togglemenuitem' ? xh(t.item).fold(Ig, (t) => P.some(Og(t, e, n))) : (console.error('Unsupported style item delegate', t.item), P.none()); case 'togglemenuitem':return xh(t).fold(Ig, (t) => P.some(Vg(t, e, n))); case 'separator':return (r = t, Po('separatormenuitem', zh, r)).fold(Ig, (t) => P.some(Cg(t))); case 'fancymenuitem':return (o = t, Po('fancymenuitem', Sh, o)).fold(Ig, (t) => Eg(t)); default:return console.error('Unknown item in general menu', t), P.none() } let o, r, i }; const jg = function (t, e, n, o, r) { let i, a, u, c, s, l, f; return r === 'color' ? { value: t, dom: (i = o, f = { dom: { tag: 'div', classes: ['tox-menu'] }, components: [{ dom: { tag: 'div', classes: ['tox-swatches'] }, components: [Nm.parts().items({ preprocess: i !== 'auto' ? Fg({ tag: 'div', classes: ['tox-swatches__row'] }, i) : d })] }] }).dom, components: f.components, items: n } : r === 'normal' && o === 'auto' ? { value: t, dom: (f = Lg(o, n)).dom, components: f.components, items: n } : r === 'normal' && o === 1 ? { value: t, dom: (f = Lg(1, n)).dom, components: f.components, items: n } : r === 'normal' ? { value: t, dom: (f = Lg(o, n)).dom, components: f.components, items: n } : r !== 'toolbar' || o === 'auto' ? { value: t, dom: (u = e, c = o, s = r, l = Ag(s), { tag: 'div', classes: R([[l.menu, `tox-menu-${c}-column`], u ? [l.hasIcons] : []]) }), components: Bg, items: n } : { value: t, dom: (a = o, f = { dom: { tag: 'div', classes: ['tox-menu', 'tox-collection', 'tox-collection--toolbar', 'tox-collection--toolbar-lg'] }, components: [Nm.parts().items({ preprocess: Fg({ tag: 'div', classes: ['tox-collection__group'] }, a) })] }).dom, components: f.components, items: n } }; const Ug = function (t, n, o, r, i, a, u) { return Ot(E(t, (e) => { return e.type === 'choiceitem' ? (t = e, Po('choicemenuitem', wh, t)).fold(Ig, (t) => P.some(Sg(t, o === 1, r, n, a(e.value), i, u))) : P.none(); let t })) }; const Wg = function (t, n, o, r, i) { return Ot(E(t, (t) => { return (e = t, Po('Autocompleter.Item', dh, e)).fold(Ig, (t) => P.some(kg(t, o === 1, 'normal', n, r, i))); let e })) }; const Gg = function (t, e, n, o, r, i, a, u) { const c = Ng(e); const s = Ug(e, n, o, r !== 'color' ? 'normal' : 'color', i, a, u); return jg(t, c, s, o, r) }; const Xg = function (t, e, n, o) { const r = Ng(e); const i = Ot(E(e, (t) => Pg(t, n, o))); return jg(t, r, i, 1, 'normal') }; const Yg = function (t) { return Gm.singleData(t.value, t) }; const qg = function (h, g) { const v = sa(Xm.sketch({ dom: { tag: 'div', classes: ['tox-autocompleter'] }, components: [], lazySink: g.getSink })); const t = function () { return Xm.isOpen(v) }; const p = function () { t() && Xm.hide(v) }; const e = Xt(() => hh(h)); const n = ah((t) => { (t.key === ' ' ? P.none() : fh(h, e)).fold(p, (m) => { m.lookupData.then((t) => { let n; let e; let o; let r; let i; let a; let u; let c; let s; let l; const f = (n = m.triggerChar, o = Mt(e = t, (t) => P.from(t.columns)).getOr(1), j(e, (i) => { const t = i.items; return Wg(t, (o, r) => { const t = h.selection.getRng(); const e = t.startContainer; ch(t, n, e.data, t.startOffset).fold(() => console.error('Lost context. Cursor probably moved'), (t) => { const e = t.rng; const n = { hide: p }; i.onAction(n, e, o, r) }) }, o, dg.BUBBLE_TO_SANDBOX, g.providers) })); if (f.length > 0) { const d = Mt(t, (t) => P.from(t.columns)).getOr(1); Xm.showAt(v, { anchor: 'selection', root: Ne.fromDom(h.getBody()), getSelection() { return P.some({ start() { return Ne.fromDom(m.range.startContainer) }, soffset() { return m.range.startOffset }, finish() { return Ne.fromDom(m.range.endContainer) }, foffset() { return m.range.endOffset } }) } }, Nm.sketch((r = jg('autocompleter-value', !0, f, d, 'normal'), i = d, a = lg.ContentFocus, u = 'normal', c = a === lg.ContentFocus ? mf() : df(), s = _g(i, u), l = Tg(u), { dom: r.dom, components: r.components, items: r.items, value: r.value, markers: { selectedItem: l.selectedItem, item: l.item }, movement: s, fakeFocus: a === lg.ContentFocus, focusManager: c, menuBehaviours: Oh(i !== 'auto' ? [] : [Qr((o, t) => { kh(o, 4, l.item).each((t) => { const e = t.numColumns; const n = t.numRows; jd.setGridSize(o, n, e) }) })]) }))), Xm.getContent(v).each(Jl.highlightFirst) } else p() }) }) }, 50); sh({ onKeypress: n, closeIfNecessary: p, isActive: t, getView() { return Xm.getContent(v) } }, h) }; const Kg = function (m, h) { return function (t) { if (m(t)) { let e; let n; let o; let r; let i; let a; let u; const c = Ne.fromDom(t.target); const s = function () { t.stopPropagation() }; const l = function () { t.preventDefault() }; const f = g(l, s); const d = (e = c, n = t.clientX, o = t.clientY, r = s, i = l, a = f, u = t, { target: U(e), x: U(n), y: U(o), stop: r, prevent: i, kill: a, raw: U(u) }); h(d) } } }; const Jg = function (t, e, n, o, r) { const i = Kg(n, o); return t.dom().addEventListener(e, i, r), { unbind: f($g, t, e, i, r) } }; var $g = function (t, e, n, o) { t.dom().removeEventListener(e, n, o) }; const Qg = U(!0); const Zg = function (t, e, n) { return Jg(t, e, Qg, n, !1) }; const tv = function (t, e, n) { return Jg(t, e, Qg, n, !0) }; const ev = function (t, e, n) { return ma(t, e, n).isSome() }; function nv(n, o) { let r = null; return { cancel() { r !== null && (clearTimeout(r), r = null) }, schedule() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; r = setTimeout(() => { n.apply(null, t), r = null }, o) } } } const ov = function (t) { const e = t.raw(); return e.touches === undefined || e.touches.length !== 1 ? P.none() : P.some(e.touches[0]) }; const rv = function (n) { const a = Ct(P.none()); const o = nv((t) => { a.set(P.none()), n.triggerEvent(Me(), t) }, 400); const r = zt([{ key: Ht(), value(n) { return ov(n).each((t) => { o.cancel(); const e = { x: U(t.clientX), y: U(t.clientY), target: n.target }; o.schedule(n), a.set(P.some(e)) }), P.none() } }, { key: Vt(), value(t) { return o.cancel(), ov(t).each((i) => { a.get().each((t) => { let e, n, o, r; e = i, n = t, o = Math.abs(e.clientX - n.x()), r = Math.abs(e.clientY - n.y()), (o > 5 || r > 5) && a.set(P.none()) }) }), P.none() } }, { key: Et(), value(e) { return o.cancel(), a.get().filter((t) => nn(t.target(), e.target())).map((t) => n.triggerEvent(Ce(), e)) } }]); return { fireIfReady(e, t) { return xt(r, t).bind((t) => t(e)) } } }; const iv = be.detect().browser.isFirefox(); const av = Ho([or('triggerEvent'), dr('stopBackspace', !0)]); const uv = function (e, t) { let n; let o; let r; let i; const a = Uo('Getting GUI events settings', av, t); const u = be.detect().deviceType.isTouch() ? ['touchstart', 'touchmove', 'touchend', 'gesturestart'] : ['mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout', 'click']; const c = rv(a); const s = E(u.concat(['selectstart', 'input', 'contextmenu', 'change', 'paste', 'transitionend', 'drag', 'dragstart', 'dragend', 'dragenter', 'dragleave', 'dragover', 'drop', 'keyup']), (t) => Zg(e, t, (e) => { c.fireIfReady(e, t).each((t) => { t && e.kill() }), a.triggerEvent(t, e) && e.kill() })); const l = Zg(e, 'keydown', (t) => { let e; a.triggerEvent('keydown', t) ? t.kill() : !0 !== a.stopBackspace || (e = t).raw().which !== 8 || M(['input', 'textarea'], yn(e.target())) || ev(e.target(), '[contenteditable="true"]') || t.prevent() }); const f = (n = e, o = function (t) { a.triggerEvent('focusin', t) && t.kill() }, iv ? tv(n, 'focus', o) : Zg(n, 'focusin', o)); const d = (r = e, i = function (t) { a.triggerEvent('focusout', t) && t.kill(), setTimeout(() => { a.triggerEvent(we(), t) }, 0) }, iv ? tv(r, 'blur', i) : Zg(r, 'focusout', i)); return { unbind() { A(s, (t) => { t.unbind() }), l.unbind(), f.unbind(), d.unbind() } } }; const cv = function (t, e) { const n = xt(t, 'target').map((t) => t()).getOr(e); return Ct(n) }; const sv = dt([{ stopped: [] }, { resume: ['element'] }, { complete: [] }]); const lv = function (t, o, e, n, r, i) { let a; let u; let c; let s; const l = t(o, n); const f = (a = e, u = r, c = Ct(!1), s = Ct(!1), { stop() { c.set(!0) }, cut() { s.set(!0) }, isStopped: c.get, isCut: s.get, event: U(a), setSource: u.set, getSource: u.get }); return l.fold(() => i.logEventNoHandlers(o, n), sv.complete(), (e) => { const n = e.descHandler(); return ki(n)(f), f.isStopped() ? (i.logEventStopped(o, e.element(), n.purpose()), sv.stopped()) : f.isCut() ? (i.logEventCut(o, e.element(), n.purpose()), sv.complete()) : an(e.element()).fold(() => i.logNoParent(o, e.element(), n.purpose()), sv.complete(), (t) => i.logEventResponse(o, e.element(), n.purpose()), sv.resume(t)) }) }; var fv = function (e, n, o, t, r, i) { return lv(e, n, o, t, r, i).fold(() => !0, (t) => fv(e, n, o, t, r, i), () => !1) }; const dv = function (t, e, n) { let o; let r; const i = (o = e, r = Ct(!1), { stop() { r.set(!0) }, cut: N, isStopped: r.get, isCut: U(!1), event: U(o), setSource: a('Cannot set source of a broadcasted event'), getSource: a('Cannot get source of a broadcasted event') }); return A(t, (t) => { const e = t.descHandler(); ki(e)(i) }), i.isStopped() }; const mv = function (t, e, n, o, r) { const i = cv(n, o); return fv(t, e, n, o, i, r) }; const hv = Pe('element', 'descHandler'); const gv = function (t, e) { return { id: U(t), descHandler: U(e) } }; function vv() { const i = {}; return { registerId(o, r, t) { tt(t, (t, e) => { const n = i[e] !== undefined ? i[e] : {}; n[r] = Si(t, o), i[e] = n }) }, unregisterId(n) { tt(i, (t, e) => { t.hasOwnProperty(n) && delete t[n] }) }, filterByType(t) { return xt(i, t).map((t) => ot(t, (t, e) => gv(e, t))).getOr([]) }, find(t, e, n) { const r = bt(e)(i); return Nr(n, (t) => { return n = r, si(o = t).fold(() => P.none(), (t) => { const e = bt(t); return n.bind(e).map((t) => hv(o, t)) }); let n, o }, t) } } } function pv() { const o = vv(); const r = {}; const i = function (o) { const t = o.element(); return si(t).fold(() => { return t = 'uid-', e = o.element(), n = Un(ai + t), ci(e, n), n; let t, e, n }, (t) => t) }; const a = function (t) { si(t.element()).each((t) => { r[t] = undefined, o.unregisterId(t) }) }; return { find(t, e, n) { return o.find(t, e, n) }, filter(t) { return o.filterByType(t) }, register(t) { const e = i(t); kt(r, e) && (function (t, e) { const n = r[e]; if (n !== t) throw new Error(`The tagId "${e}" is already used by: ${Tn(n.element())}\nCannot use it for: ${Tn(t.element())}\nThe conflicting element is${Dr(n.element()) ? ' ' : ' not '}already in the DOM`); a(t) }(t, e)); const n = [t]; o.registerId(n, e, t.events()), r[e] = t }, unregister: a, getById(t) { return bt(t)(r) } } } let bv; let yv; const xv = Tl({ name: 'Container', factory(t) { const e = t.dom; const n = e.attributes; const o = Xn(e, ['attributes']); return { uid: t.uid, dom: Gn({ tag: 'div', attributes: Gn({ role: 'presentation' }, n) }, o), components: t.components, behaviours: As(t.containerBehaviours), events: t.events, domModification: t.domModification, eventOrder: t.eventOrder } }, configFields: [dr('components', []), Es('containerBehaviours', []), dr('events', {}), dr('domModification', {}), dr('eventOrder', {})] }); const wv = function (n) { const o = function (e) { return an(n.element()).fold(() => !0, (t) => nn(e, t)) }; const r = pv(); const s = function (t, e) { return r.find(o, t, e) }; const t = uv(n.element(), { triggerEvent(a, u) { return In(a, u.target(), (t) => { return e = s, n = a, r = t, i = (o = u).target(), mv(e, n, o, i, r); let e, n, o, r, i }) } }); var i = { debugInfo: U('real'), triggerEvent(e, n, o) { In(e, n, (t) => { mv(s, e, o, n, t) }) }, triggerFocus(u, c) { si(u).fold(() => { cf(u) }, (t) => { In(xe(), u, (t) => { let e, n, o, r, i, a; e = s, n = xe(), o = { originator: U(c), kill: N, prevent: N, target: U(u) }, i = t, a = cv(o, r = u), lv(e, n, o, r, a, i) }) }) }, triggerEscape(t, e) { i.triggerEvent('keydown', t.element(), e.event()) }, getByUid(t) { return h(t) }, getByDom(t) { return g(t) }, build: sa, addToGui(t) { u(t) }, removeFromGui(t) { c(t) }, addToWorld(t) { e(t) }, removeFromWorld(t) { a(t) }, broadcast(t) { f(t) }, broadcastOn(t, e) { d(t, e) }, broadcastEvent(t, e) { m(t, e) }, isConnected: U(!0) }; var e = function (t) { t.connect(i), zn(t.element()) || (r.register(t), A(t.components(), e), i.triggerEvent(Ee(), t.element(), { target: U(t.element()) })) }; var a = function (t) { zn(t.element()) || (A(t.components(), a), r.unregister(t)), t.disconnect() }; var u = function (t) { cs(n, t) }; var c = function (t) { fs(t) }; const l = function (n) { const t = r.filter(ze()); A(t, (t) => { const e = t.descHandler(); ki(e)(n) }) }; var f = function (t) { l({ universal: U(!0), data: U(t) }) }; var d = function (t, e) { l({ universal: U(!1), channels: U(t), data: U(e) }) }; var m = function (t, e) { const n = r.filter(t); return dv(n, e) }; var h = function (t) { return r.getById(t).fold(() => ft.error(new Error(`Could not find component with uid: "${t}" in system.`)), ft.value) }; var g = function (t) { const e = si(t).getOr('not found'); return h(e) }; return e(n), { root: U(n), element: n.element, destroy() { t.unbind(), vn(n.element()) }, add: u, remove: c, getByUid: h, getByDom: g, addToWorld: e, removeFromWorld: a, broadcast: f, broadcastOn: d, broadcastEvent: m } }; const zv = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const Sv = tinymce.util.Tools.resolve('tinymce.EditorManager'); const kv = function (t) { return P.from(t.settings.min_width).filter(k) }; const Cv = function (t) { return P.from(t.settings.min_height).filter(k) }; const Ov = function (e) { const t = Q(e.settings); const n = T(t, (t) => /^toolbar([1-9])$/.test(t)); const o = E(n, (t) => e.getParam(t, !1, 'string')); const r = T(o, (t) => typeof t === 'string'); return r.length > 0 ? P.some(r) : P.none() }; const Mv = Un('form-component-change'); const Hv = Un('form-close'); const Vv = Un('form-cancel'); const Ev = Un('form-action'); const Av = Un('form-submit'); const Tv = Un('form-block'); const Bv = Un('form-unblock'); const Dv = Un('form-tabchange'); const _v = Un('form-resize'); const Fv = U([dr('prefix', 'form-field'), Es('fieldBehaviours', [Ll, am])]); const Lv = U([al({ schema: [Zo('dom')], name: 'label' }), al({ factory: { sketch(t) { return { uid: t.uid, dom: { tag: 'span', styles: { display: 'none' }, attributes: { 'aria-hidden': 'true' }, innerHtml: t.text } } } }, schema: [Zo('text')], name: 'aria-descriptor' }), rl({ factory: { sketch(t) { const e = pt(t, ['factory']); return t.factory.sketch(e) } }, schema: [Zo('factory')], name: 'field' })]); const Iv = Bl({ name: 'FormField', configFields: Fv(), partFields: Lv(), factory(r, t, e, n) { const o = Ts(r.fieldBehaviours, [Ll.config({ find(t) { return bl(t, r, 'field') } }), am.config({ store: { mode: 'manual', getValue(t) { return Ll.getCurrent(t).bind(am.getValue) }, setValue(t, e) { Ll.getCurrent(t).each((t) => { am.setValue(t, e) }) } } })]); const i = Pr([Qr((t, e) => { const o = xl(t, r, ['label', 'field', 'aria-descriptor']); o.field().each((n) => { const e = Un(r.prefix); o.label().each((t) => { Cn(t.element(), 'for', e), Cn(n.element(), 'id', e) }), o['aria-descriptor']().each((t) => { const e = Un(r.prefix); Cn(t.element(), 'id', e), Cn(n.element(), 'aria-describedby', e) }) }) })]); const a = { getField(t) { return bl(t, r, 'field') }, getLabel(t) { return bl(t, r, 'label') } }; return { uid: r.uid, dom: r.dom, components: t, behaviours: o, events: i, apis: a } }, apis: { getField(t, e) { return t.getField(e) }, getLabel(t, e) { return t.getLabel(e) } } }); const Rv = Object.freeze({ getCoupled(t, e, n, o) { return n.getOrCreate(t, e, o) } }); const Nv = [tr('others', No(ft.value, Xo()))]; const Pv = La({ fields: Nv, name: 'coupling', apis: Rv, state: Object.freeze({ init(t) { const i = {}; const e = U({}); return xi({ readState: e, getOrCreate(n, o, r) { const t = Q(o.others); if (t) return xt(i, r).getOrThunk(() => { const t = xt(o.others, r).getOrDie(`No information found for coupled component: ${r}`)(n); const e = n.getSystem().build(t); return i[r] = e }); throw new Error(`Cannot find coupled component: ${r}. Known coupled components: ${xo(t, null, 2)}`) } }) } }) }); const jv = Object.freeze({ events(t, e) { const n = t.stream.streams.setup(t, e); return Pr([Wr(t.event, n), Zr(() => e.cancel())].concat(t.cancelEvent.map((t) => [Wr(t, () => e.cancel())]).getOr([]))) } }); const Uv = function (t) { const e = Ct(null); return xi({ readState() { return { timer: e.get() !== null ? 'set' : 'unset' } }, setTimer(t) { e.set(t) }, cancel() { const t = e.get(); t !== null && t.cancel() } }) }; const Wv = Object.freeze({ throttle: Uv, init(t) { return t.stream.streams.state(t) } }); const Gv = [tr('stream', Go('mode', { throttle: [Zo('delay'), dr('stopEvent', !0), Ma('streams', { setup(t, e) { const n = t.stream; const o = ah(t.onStream, n.delay); return e.setTimer(o), function (t, e) { o.throttle(t, e), n.stopEvent && e.stop() } }, state: Uv })] })), dr('event', 'input'), ur('cancelEvent'), Ca('onStream')]; const Xv = La({ fields: Gv, name: 'streaming', active: jv, state: Wv }); var Yv = function (t) { let n = P.none(); let e = []; const o = function (t) { r() ? a(t) : e.push(t) }; var r = function () { return n.isSome() }; const i = function (t) { A(t, a) }; var a = function (e) { n.each((t) => { setTimeout(() => { e(t) }, 0) }) }; return t((t) => { n = P.some(t), i(e), e = [] }), { get: o, map(n) { return Yv((e) => { o((t) => { e(n(t)) }) }) }, isReady: r } }; const qv = { nu: Yv, pure(e) { return Yv((t) => { t(e) }) } }; var Kv = function (e) { const t = function (t) { let o; e((o = t, function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; const n = this; setTimeout(() => { o.apply(n, t) }, 0) })) }; const n = function () { return qv.nu(t) }; return { map(o) { return Kv((n) => { t((t) => { const e = o(t); n(e) }) }) }, bind(n) { return Kv((e) => { t((t) => { n(t).get(e) }) }) }, anonBind(n) { return Kv((e) => { t((t) => { n.get(e) }) }) }, toLazy: n, toCached() { let e = null; return Kv((t) => { e === null && (e = n()), e.get(t) }) }, get: t } }; const Jv = { nu: Kv, pure(e) { return Kv((t) => { t(e) }) } }; const $v = U('sink'); const Qv = U(al({ name: $v(), overrides: U({ dom: { tag: 'div' }, behaviours: _a([is.config({ useFixed: !0 })]), events: Pr([Kr(It()), Kr(At()), Kr(jt())]) }) })); (yv = bv || (bv = {}))[yv.HighlightFirst = 0] = 'HighlightFirst', yv[yv.HighlightNone = 1] = 'HighlightNone'; const Zv = function (t, e) { const n = t.getHotspot(e).getOr(e); return t.layouts.fold(() => ({ anchor: 'hotspot', hotspot: n }), (t) => ({ anchor: 'hotspot', hotspot: n, layouts: t })) }; const tp = function (t, e, n, o, r, i, a) { let u; let c; let s; let l; let f; let d; let m; let h; let g; let v; const p = Zv(t, n); return (c = p, l = o, f = r, d = a, m = e, h = s = n, g = (0, (u = t).fetch)(h).map(m), v = rp(s, u), g.map((t) => Gm.sketch(Gn({}, f.menu(), { uid: li(''), data: t, highlightImmediately: d === bv.HighlightFirst, onOpenMenu(t, e) { const n = v().getOrDie(); is.position(n, c, e), ks.decloak(l) }, onOpenSubmenu(t, e, n) { const o = v().getOrDie(); is.position(o, { anchor: 'submenu', item: e }, n), ks.decloak(l) }, onEscape() { return fm.focus(s), ks.close(l), P.some(!0) } })))).map((t) => ks.cloak(o), ks.open(o, t), i(o), o) }; const ep = function (t, e, n, o, r, i, a) { return ks.close(o), Jv.pure(o) }; const np = function (t, e, n, o, r, i) { const a = Pv.getCoupled(n, 'sandbox'); return (ks.isOpen(a) ? ep : tp)(t, e, n, a, o, r, i) }; const op = function (t, e, n) { let o; let r; const i = Ll.getCurrent(e).getOr(e); const a = eu(t.element()); n ? Wi(i.element(), 'min-width', `${a}px`) : (o = i.element(), r = a, tu.set(o, r)) }; var rp = function (e, t) { return e.getSystem().getByUid(`${t.uid}-${$v()}`).map((t) => function () { return ft.value(t) }).getOrThunk(() => t.lazySink.fold(() => function () { return ft.error(new Error('No internal sink is specified, nor could an external sink be found')) }, (t) => function () { return t(e) })) }; const ip = function (o, r, i) { let e; const a = (e = Un('aria-owns'), { id: U(e), link(t) { Cn(t, 'aria-owns', e) }, unlink(t) { Vn(t, 'aria-owns') } }); const t = rp(r, o); return { dom: { tag: 'div', classes: o.sandboxClasses, attributes: { id: a.id() } }, behaviours: Ds(o.sandboxBehaviours, [am.config({ store: { mode: 'memory', initialValue: r } }), ks.config({ onOpen(t, e) { const n = Zv(o, r); a.link(r.element()), o.matchWidth && op(n.hotspot, e, o.useMinWidth), o.onOpen(n, t, e), i !== undefined && i.onOpen !== undefined && i.onOpen(t, e) }, onClose(t, e) { a.unlink(r.element()), i !== undefined && i.onClose !== undefined && i.onClose(t, e) }, isPartOf(t, e, n) { return ga(e, n) || ga(r, n) }, getAttachPoint() { return t().getOrDie() } }), Ll.config({ find(t) { return ks.getState(t).bind((t) => Ll.getCurrent(t)) } }), Hs({ isExtraPart: U(!1) })]) } }; const ap = function (t, e, n) { const o = am.getValue(n); am.setValue(e, o), cp(e) }; const up = function (t, e) { const n = t.element(); const o = Qi(n); const r = n.dom(); Mn(n, 'type') !== 'number' && e(r, o) }; var cp = function (t) { up(t, (t, e) => t.setSelectionRange(e.length, e.length)) }; const sp = function (t, e, o) { if (t.selectsOver) { const n = am.getValue(e); const r = t.getDisplayText(n); const i = am.getValue(o); return t.getDisplayText(i).indexOf(r) === 0 ? P.some(() => { let t, n; ap(0, e, o), t = e, n = r.length, up(t, (t, e) => t.setSelectionRange(n, e.length)) }) : P.none() } return P.none() }; const lp = U([ur('data'), dr('inputAttributes', {}), dr('inputStyles', {}), dr('tag', 'input'), dr('inputClasses', []), Sa('onSetValue'), dr('styles', {}), dr('eventOrder', {}), Es('inputBehaviours', [am, fm]), dr('selectOnFocus', !0)]); const fp = function (t) { return _a([fm.config({ onFocus: !1 === t.selectOnFocus ? N : function (t) { const e = t.element(); const n = Qi(e); e.dom().setSelectionRange(0, n.length) } })]) }; const dp = function (t) { return { tag: t.tag, attributes: Gn({ type: 'input' }, t.inputAttributes), styles: t.inputStyles, classes: t.inputClasses } }; const mp = U('alloy.typeahead.itemexecute'); const hp = function () { return [dr('sandboxClasses', []), Bs('sandboxBehaviours', [Ll, Ua, ks, am])] }; const gp = U([ur('lazySink'), Zo('fetch'), dr('minChars', 5), dr('responseTime', 1e3), Sa('onOpen'), dr('getHotspot', P.some), dr('layouts', P.none()), dr('eventOrder', {}), yr('model', {}, [dr('getDisplayText', (t) => t.meta !== undefined && t.meta.text !== undefined ? t.meta.text : t.value), dr('selectsOver', !0), dr('populateFromBrowse', !0)]), Sa('onSetValue'), ka('onExecute'), Sa('onItemExecute'), dr('inputClasses', []), dr('inputAttributes', {}), dr('inputStyles', {}), dr('matchWidth', !0), dr('useMinWidth', !1), dr('dismissOnBlur', !0), wa(['openClass']), ur('initialData'), Es('typeaheadBehaviours', [fm, am, Xv, jd, km, Pv]), xr('previewing', () => Ct(!0))].concat(lp()).concat(hp())); const vp = U([il({ schema: [xa()], name: 'menu', overrides(o) { return { fakeFocus: !0, onHighlight(e, n) { o.previewing.get() ? e.getSystem().getByUid(o.uid).each((t) => { sp(o.model, t, n).fold(() => Jl.dehighlight(e, n), (t) => t()) }) : e.getSystem().getByUid(o.uid).each((t) => { o.model.populateFromBrowse && ap(o.model, t, n) }), o.previewing.set(!1) }, onExecute(t, e) { return t.getSystem().getByUid(o.uid).toOption().map((t) => Cr(t, mp(), { item: e }), !0) }, onHover(t, e) { o.previewing.set(!1), t.getSystem().getByUid(o.uid).each((t) => { o.model.populateFromBrowse && ap(o.model, t, e) }) } } } })]); const pp = Bl({ name: 'Typeahead', configFields: gp(), partFields: vp(), factory(r, t, e, i) { const n = function (t, e, n) { r.previewing.set(!1); const o = Pv.getCoupled(t, 'sandbox'); ks.isOpen(o) ? Ll.getCurrent(o).each((t) => { Jl.getHighlighted(t).fold(() => { n(t) }, () => { Vr(o, t.element(), 'keydown', e) }) }) : tp(r, a(t), t, o, i, (t) => { Ll.getCurrent(t).each(n) }, bv.HighlightFirst).get(N) }; const o = fp(r); var a = function (o) { return function (t) { const e = rt(t.menus); const n = j(e, (t) => T(t.items, (t) => t.type === 'item')); return am.getState(o).update(E(n, (t) => t.data)), t } }; const u = [fm.config({}), am.config({ onSetValue: r.onSetValue, store: Gn({ mode: 'dataset', getDataKey(t) { return Qi(t.element()) }, getFallbackEntry(t) { return { value: t, meta: {} } }, setValue(t, e) { Zi(t.element(), r.model.getDisplayText(e)) } }, r.initialData.map((t) => wt('initialValue', t)).getOr({})) }), Xv.config({ stream: { mode: 'throttle', delay: r.responseTime, stopEvent: !1 }, onStream(t, e) { const n = Pv.getCoupled(t, 'sandbox'); if (fm.isFocused(t) && Qi(t.element()).length >= r.minChars) { const o = Ll.getCurrent(n).bind((t) => Jl.getHighlighted(t).map(am.getValue)); r.previewing.set(!0), tp(r, a(t), t, n, i, (t) => { Ll.getCurrent(n).each((t) => { o.fold(() => { r.model.selectsOver && Jl.highlightFirst(t) }, (e) => { Jl.highlightBy(t, (t) => am.getValue(t).value === e.value), Jl.getHighlighted(t).orThunk(() => Jl.highlightFirst(t), P.none()) }) }) }, bv.HighlightFirst).get(N) } }, cancelEvent: Ve() }), jd.config({ mode: 'special', onDown(t, e) { return n(t, e, Jl.highlightFirst), P.some(!0) }, onEscape(t) { const e = Pv.getCoupled(t, 'sandbox'); return ks.isOpen(e) ? (ks.close(e), P.some(!0)) : P.none() }, onUp(t, e) { return n(t, e, Jl.highlightLast), P.some(!0) }, onEnter(e) { const t = Pv.getCoupled(e, 'sandbox'); const n = ks.isOpen(t); if (n && !r.previewing.get()) return Ll.getCurrent(t).bind((t) => Jl.getHighlighted(t)).map((t) => Cr(e, mp(), { item: t }), !0); const o = am.getValue(e); return kr(e, Ve()), r.onExecute(t, e, o), n && ks.close(t), P.some(!0) } }), km.config({ toggleClass: r.markers.openClass, aria: { mode: 'pressed', syncWithExpanded: !0 } }), Pv.config({ others: { sandbox(t) { return ip(r, t, { onOpen: d, onClose: d }) } } }), Am('typeaheadevents', [ei((t) => { const e = N; np(r, a(t), t, i, e, bv.HighlightFirst).get(N) }), Wr(mp(), (t, e) => { const n = Pv.getCoupled(t, 'sandbox'); ap(r.model, t, e.event().item()), kr(t, Ve()), r.onItemExecute(t, n, e.event().item(), am.getValue(t)), ks.close(n), cp(t) })].concat(r.dismissOnBlur ? [Wr(we(), (t) => { const e = Pv.getCoupled(t, 'sandbox'); lf(e.element()).isNone() && ks.close(e) })] : []))]; return { uid: r.uid, dom: dp(r), behaviours: Gn({}, o, Ts(r.typeaheadBehaviours, u)), eventOrder: r.eventOrder } } }); const bp = function (t, e, n) { const o = xp(t, e, n); return Iv.sketch(o) }; const yp = function (t, e) { return bp(t, e, []) }; var xp = function (t, e, n) { return { dom: wp(n), components: t.toArray().concat([e]) } }; var wp = function (t) { return { tag: 'div', classes: ['tox-form__group'].concat(t) } }; const zp = function (t, e) { return Iv.parts().label({ dom: { tag: 'label', classes: ['tox-label'], innerHtml: e.translate(t) } }) }; const Sp = function (t) { return t.type === 'separator' }; const kp = { type: 'separator' }; const Cp = function (t, n) { const e = D(t, (t, e) => x(e) ? e === '' ? t : e === '|' ? t.length > 0 && !Sp(t[t.length - 1]) ? t.concat([kp]) : t : it(n, e.toLowerCase()) ? t.concat([n[e.toLowerCase()]]) : (console.error(`No representation for menuItem: ${e}`), t) : t.concat([e]), []); return e.length > 0 && Sp(e[e.length - 1]) && e.pop(), e }; const Op = function (t, e) { return it(t, 'getSubmenuItems') ? (o = e, r = (n = t).getSubmenuItems(), i = Mp(r, o), { item: n, menus: gt(i.menus, wt(n.value, i.items)), expansions: gt(i.expansions, wt(n.value, n.value)) }) : { item: t, menus: {}, expansions: {} }; let n, o, r, i }; var Mp = function (t, r) { const e = Cp(x(t) ? t.split(' ') : t, r); return B(e, (t, e) => { const n = (function (t) { if (Sp(t)) return t; const e = xt(t, 'value').getOrThunk(() => Un('generated-menu-item')); return gt({ value: e }, t) }(e)); const o = Op(n, r); return { menus: gt(t.menus, o.menus), items: [o.item].concat(t.items), expansions: gt(t.expansions, o.expansions) } }, { menus: {}, expansions: {}, items: [] }) }; const Hp = function (t, n, o) { const e = Un('primary-menu'); const r = Mp(t, o.menuItems()); const i = Xg(e, r.items, n, o); const a = et(r.menus, (t, e) => Xg(e, t, n, o)); const u = gt(a, wt(e, i)); return Gm.tieredData(e, u, r.expansions) }; const Vp = Tl({ name: 'Input', configFields: lp(), factory(t, e) { return { uid: t.uid, dom: dp(t), components: [], behaviours: (n = t, Gn({}, fp(n), Ts(n.inputBehaviours, [am.config({ store: { mode: 'manual', initialValue: n.data.getOr(undefined), getValue(t) { return Qi(t.element()) }, setValue(t, e) { Qi(t.element()) !== e && Zi(t.element(), e) } }, onSetValue: n.onSetValue })]))), eventOrder: t.eventOrder }; let n } }); const Ep = be.detect().browser.isFirefox(); const Ap = { position: 'absolute', left: '-9999px' }; const Tp = function (t, e, n) { let o; let r; let i; const a = (function (t, e) { const n = Ne.fromTag('span', t.dom()); Cn(n, 'role', 'presentation'); const o = Ne.fromText(e, t.dom()); return mn(n, o), n }(on(e), n)); Ep && (o = e, r = a, i = Un('ephox-alloy-aria-voice'), Cn(r, 'id', i), Cn(o, 'aria-describedby', i)), On(a, t(n)), Gi(a, Ap), mn(e, a), setTimeout(() => { Vn(a, 'aria-live'), vn(a) }, 1e3) }; const Bp = function (t) { return { 'aria-live': 'assertive', 'aria-atomic': 'true', role: 'alert' } }; const Dp = ['input', 'textarea']; const _p = function (t) { const e = yn(t); return M(Dp, e) }; const Fp = function (t, e) { const n = e.getRoot(t).getOr(t.element()); Li(n, e.invalidClass), e.notify.each((e) => { _p(t.element()) && Vn(n, 'title'), e.getContainer(t).each((t) => { bn(t, e.validHtml) }), e.onValid(t) }) }; const Lp = function (n, t, e, o) { const r = t.getRoot(n).getOr(n.element()); _i(r, t.invalidClass), t.notify.each((t) => { let e; _p(n.element()) && Cn(n.element(), 'title', o), e = _r(), Tp(Bp, e, o), t.getContainer(n).each((t) => { bn(t, o) }), t.onInvalid(n, o) }) }; const Ip = function (e, t, n) { return t.validator.fold(() => Jv.pure(ft.value(!0)), (t) => t.validate(e)) }; const Rp = function (e, n, t) { return n.notify.each((t) => { t.onValidate(e) }), Ip(e, n).map((t) => e.getSystem().isConnected() ? t.fold((t) => Lp(e, n, 0, t), ft.error(t), (t) => Fp(e, n), ft.value(t)) : ft.error('No longer in system')) }; const Np = Object.freeze({ markValid: Fp, markInvalid: Lp, query: Ip, run: Rp, isInvalid(t, e) { const n = e.getRoot(t).getOr(t.element()); return Ii(n, e.invalidClass) } }); const Pp = Object.freeze({ events(e, t) { return e.validator.map((t) => Pr([Wr(t.onEvent, (t) => { Rp(t, e).get(d) })].concat(t.validateOnLoad ? [Qr((t) => { Rp(t, e).get(N) })] : []))).getOr({}) } }); const jp = [Zo('invalidClass'), dr('getRoot', P.none), fr('notify', [dr('aria', 'alert'), dr('getContainer', P.none), dr('validHtml', ''), Sa('onValid'), Sa('onInvalid'), Sa('onValidate')]), fr('validator', [Zo('validate'), dr('onEvent', 'input'), dr('validateOnLoad', !0)])]; const Up = La({ fields: jp, name: 'invalidating', active: Pp, apis: Np, extra: { validation(n) { return function (t) { const e = am.getValue(t); return Jv.pure(n(e)) } } } }); const Wp = Object.freeze({ exhibit(t, e) { return zi({ attributes: zt([{ key: e.tabAttr, value: 'true' }]) }) } }); const Gp = [dr('tabAttr', 'data-alloy-tabstop')]; const Xp = La({ fields: Gp, name: 'tabstopping', active: Wp }); const Yp = function (t) { return { value: U(t) } }; const qp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; const Kp = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; const Jp = function (t) { return qp.test(t) || Kp.test(t) }; const $p = function (t) { let e; const n = (e = t.value().replace(qp, (t, e, n, o) => e + e + n + n + o + o), { value: U(e) }); return Kp.exec(n.value()) }; const Qp = function (t) { const e = t.toString(16); return e.length == 1 ? `0${e}` : e }; const Zp = function (t) { const e = Qp(t.red()) + Qp(t.green()) + Qp(t.blue()); return Yp(e) }; const tb = Math.min; const eb = Math.max; const nb = Math.round; const ob = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/; const rb = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/; const ib = function (t, e, n, o) { return { red: U(t), green: U(e), blue: U(n), alpha: U(o) } }; const ab = function (t) { const e = parseInt(t, 10); return e.toString() === t && e >= 0 && e <= 255 }; const ub = function (t) { let e, n, o, r, i, a, u, c, s, l; if (i = (t.hue() || 0) % 360, a = t.saturation() / 100, u = t.value() / 100, a = eb(0, tb(a, 1)), u = eb(0, tb(u, 1)), a === 0) return c = s = l = nb(255 * u), ib(c, s, l, 1); switch (e = i / 60, o = (n = u * a) * (1 - Math.abs(e % 2 - 1)), r = u - n, Math.floor(e)) { case 0:c = n, s = o, l = 0; break; case 1:c = o, s = n, l = 0; break; case 2:c = 0, s = n, l = o; break; case 3:c = 0, s = o, l = n; break; case 4:c = o, s = 0, l = n; break; case 5:c = n, s = 0, l = o; break; default:c = s = l = 0 } return c = nb(255 * (c + r)), s = nb(255 * (s + r)), l = nb(255 * (l + r)), ib(c, s, l, 1) }; const cb = function (t) { const e = $p(t); const n = parseInt(e[1], 16); const o = parseInt(e[2], 16); const r = parseInt(e[3], 16); return ib(n, o, r, 1) }; const sb = function (t, e, n, o) { const r = parseInt(t, 10); const i = parseInt(e, 10); const a = parseInt(n, 10); const u = parseFloat(o); return ib(r, i, a, u) }; const lb = function (t) { return `rgba(${t.red()},${t.green()},${t.blue()},${t.alpha()})` }; const fb = U(ib(255, 0, 0, 1)); const db = tinymce.util.Tools.resolve('tinymce.util.LocalStorage'); const mb = 'tinymce-custom-colors'; const hb = 'choiceitem'; const gb = [{ type: hb, text: 'Turquoise', value: '#18BC9B' }, { type: hb, text: 'Green', value: '#2FCC71' }, { type: hb, text: 'Blue', value: '#3598DB' }, { type: hb, text: 'Purple', value: '#9B59B6' }, { type: hb, text: 'Navy Blue', value: '#34495E' }, { type: hb, text: 'Dark Turquoise', value: '#18A085' }, { type: hb, text: 'Dark Green', value: '#27AE60' }, { type: hb, text: 'Medium Blue', value: '#2880B9' }, { type: hb, text: 'Medium Purple', value: '#8E44AD' }, { type: hb, text: 'Midnight Blue', value: '#2B3E50' }, { type: hb, text: 'Yellow', value: '#F1C40F' }, { type: hb, text: 'Orange', value: '#E67E23' }, { type: hb, text: 'Red', value: '#E74C3C' }, { type: hb, text: 'Light Gray', value: '#ECF0F1' }, { type: hb, text: 'Gray', value: '#95A5A6' }, { type: hb, text: 'Dark Yellow', value: '#F29D12' }, { type: hb, text: 'Dark Orange', value: '#D35400' }, { type: hb, text: 'Dark Red', value: '#E74C3C' }, { type: hb, text: 'Medium Gray', value: '#BDC3C7' }, { type: hb, text: 'Dark Gray', value: '#7E8C8D' }, { type: hb, text: 'Black', value: '#000000' }, { type: hb, text: 'White', value: '#ffffff' }]; const vb = (function lV(r) { void 0 === r && (r = 10); let t; const e = db.getItem(mb); const n = x(e) ? JSON.parse(e) : []; const i = r - (t = n).length < 0 ? t.slice(0, r) : t; const a = function (t) { i.splice(t, 1) }; return { add(t) { let e, n, o; (e = i, n = t, o = C(e, n), o === -1 ? P.none() : P.some(o)).each(a), i.unshift(t), i.length > r && i.pop(), db.setItem(mb, JSON.stringify(i)) }, state() { return i.slice(0) } } }(10)); const pb = function (t) { let e; const n = []; for (e = 0; e < t.length; e += 2)n.push({ text: t[e + 1], value: `#${t[e]}`, type: 'choiceitem' }); return n }; const bb = function (t) { return t.getParam('color_map') }; const yb = function (t, e) { return t.getParam('color_cols', e, 'number') }; const xb = function (t) { return !1 !== t.getParam('custom_colors') }; const wb = function (t) { const e = bb(t); return e !== undefined ? pb(e) : gb }; const zb = function () { return E(vb.state(), (t) => ({ type: hb, text: t, value: t })) }; const Sb = function (t) { vb.add(t) }; const kb = function (t, n) { let o; return t.dom.getParents(t.selection.getStart(), (t) => { let e; (e = t.style[n === 'forecolor' ? 'color' : 'background-color']) && (o = o || e) }), o }; const Cb = function (t) { return Math.max(5, Math.ceil(Math.sqrt(t))) }; const Ob = function (t) { const e = wb(t); const n = Cb(e.length); return yb(t, n) }; const Mb = function (e, n, t, o) { t === 'custom' ? Eb(e)((t) => { t.each((t) => { Sb(t), e.execCommand('mceApplyTextcolor', n, t), o(t) }) }, '#000000') : t === 'remove' ? (o(''), e.execCommand('mceRemoveTextcolor', n)) : (o(t), e.execCommand('mceApplyTextcolor', n, t)) }; const Hb = function (o, r) { return function (t) { let e, n; t(o.concat(zb().concat((n = { type: e = 'choiceitem', text: 'Remove color', icon: 'color-swatch-remove-color', value: 'remove' }, r ? [n, { type: e, text: 'Custom color', icon: 'color-picker', value: 'custom' }] : [n])))) } }; const Vb = function (e, r, i, t) { let a; e.ui.registry.addSplitButton(r, (a = Ct(null), { type: 'splitbutton', tooltip: t, presets: 'color', icon: r === 'forecolor' ? 'text-color' : 'highlight-bg-color', select(n) { return P.from(kb(e, i)).bind((t) => (function (t) { if (t === 'transparent') return P.some(ib(0, 0, 0, 0)); if (ob.test(t)) { const e = ob.exec(t); return P.some(sb(e[1], e[2], e[3], '1')) } if (rb.test(t)) { const n = ob.exec(t); return P.some(sb(n[1], n[2], n[3], n[4])) } return P.none() }(t)).map((t) => { const e = Zp(t).value(); return fe(n.toLowerCase(), e) })).getOr(!1) }, columns: Ob(e), fetch: Hb(wb(e), xb(e)), onAction(t) { a.get() !== null && Mb(e, i, a.get(), () => {}) }, onItemAction(o, t) { Mb(e, i, t, (t) => { let e, n; a.set(t), e = r === 'forecolor' ? 'tox-icon-text-color__color' : 'tox-icon-highlight-bg-color__color', n = t, o.setIconFill(e, n), o.setIconStroke(e, n) }) } })) }; var Eb = function (i) { return function (t, e) { let n; const o = { colorpicker: e }; const r = (n = t, function (t) { const e = t.getData(); n(P.from(e.colorpicker)), t.close() }); i.windowManager.open({ title: 'Color Picker', size: 'normal', body: { type: 'panel', items: [{ type: 'colorpicker', name: 'colorpicker', label: 'Color' }] }, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: o, onAction(t, e) { e.name === 'hex-valid' && (e.value ? t.enable('ok') : t.disable('ok')) }, onSubmit: r, onClose() {}, onCancel() { t(P.none()) } }) } }; const Ab = { register(t) { let i; (i = t).addCommand('mceApplyTextcolor', (t, e) => { let n, o, r; o = t, r = e, (n = i).undoManager.transact(() => { n.focus(), n.formatter.apply(o, { value: r }), n.nodeChanged() }) }), i.addCommand('mceRemoveTextcolor', (t) => { let e, n; n = t, (e = i).undoManager.transact(() => { e.focus(), e.formatter.remove(n, { value: null }, null, !0), e.nodeChanged() }) }), Vb(t, 'forecolor', 'forecolor', 'Text color'), Vb(t, 'backcolor', 'hilitecolor', 'Background color') }, getFetch: Hb, colorPickerDialog: Eb, getCurrentColor: kb, getColorCols: Ob, calcCols: Cb }; const Tb = U([Zo('dom'), Zo('fetch'), Sa('onOpen'), ka('onExecute'), dr('getHotspot', P.some), dr('layouts', P.none()), Es('dropdownBehaviours', [km, Pv, jd, fm]), Zo('toggleClass'), dr('eventOrder', {}), ur('lazySink'), dr('matchWidth', !1), dr('useMinWidth', !1), ur('role')].concat(hp())); const Bb = U([il({ schema: [xa()], name: 'menu', defaults(t) { return { onExecute: t.onExecute } } }), Qv()]); var Db = Bl({ name: 'Dropdown', configFields: Tb(), partFields: Bb(), factory(e, t, n, o) { let r; const i = function (t) { ks.getState(t).each((t) => { Gm.highlightPrimary(t) }) }; const a = { expand(t) { km.isOn(t) || np(e, (t) => t, t, o, N, bv.HighlightNone).get(N) }, open(t) { km.isOn(t) || np(e, (t) => t, t, o, N, bv.HighlightFirst).get(N) }, isOpen: km.isOn, close(t) { km.isOn(t) && np(e, (t) => t, t, o, N, bv.HighlightFirst).get(N) } }; const u = function (t, e) { return Or(t), P.some(!0) }; const c = e.role.fold(() => ({ 'aria-haspopup': 'true' }), (t) => ({ role: t, 'aria-haspopup': 'true' })); return { uid: e.uid, dom: e.dom, components: t, behaviours: Ts(e.dropdownBehaviours, [km.config({ toggleClass: e.toggleClass, aria: { mode: 'expanded' } }), Pv.config({ others: { sandbox(t) { return ip(e, t, { onOpen() { km.on(t) }, onClose() { km.off(t) } }) } } }), jd.config({ mode: 'special', onSpace: u, onEnter: u, onDown(t, e) { if (Db.isOpen(t)) { const n = Pv.getCoupled(t, 'sandbox'); i(n) } else Db.open(t); return P.some(!0) }, onEscape(t, e) { return Db.isOpen(t) ? (Db.close(t), P.some(!0)) : P.none() } }), fm.config({})]), events: Ym(P.some((t) => { np(e, (t) => t, t, o, i, bv.HighlightFirst).get(N) })), eventOrder: Gn({}, e.eventOrder, (r = {}, r[Se()] = ['disabling', 'toggling', 'alloy.base.behaviour'], r)), apis: a, domModification: { attributes: c } } }, apis: { open(t, e) { return t.open(e) }, expand(t, e) { return t.expand(e) }, close(t, e) { return t.close(e) }, isOpen(t, e) { return t.isOpen(e) } } }); const _b = La({ fields: [], name: 'unselecting', active: Object.freeze({ events(t) { return Pr([jr(Wt(), U(!0))]) }, exhibit(t, e) { return zi({ styles: { '-webkit-user-select': 'none', 'user-select': 'none', '-ms-user-select': 'none', '-moz-user-select': '-moz-none' }, attributes: { unselectable: 'on' } }) } }) }); const Fb = Un('color-input-change'); const Lb = Un('color-swatch-change'); const Ib = Un('color-picker-cancel'); const Rb = function (t, e, o) { let n; let r; const i = Iv.parts().field({ factory: Vp, inputClasses: ['tox-textfield'], onSetValue(t) { return Up.run(t).get(() => {}) }, inputBehaviours: _a([Xp.config({}), Up.config({ invalidClass: 'tox-textbox-field-invalid', getRoot(t) { return an(t.element()) }, notify: { onValid(t) { const e = am.getValue(t); Cr(t, Fb, { color: e }) } }, validator: { validateOnLoad: !1, validate(t) { const e = am.getValue(t); if (e.length === 0) return Jv.pure(ft.value(!0)); const n = Ne.fromTag('span'); Wi(n, 'background-color', e); const o = qi(n, 'background-color').fold(() => ft.error('blah'), (t) => ft.value(e)); return Jv.pure(o) } } })]), selectOnFocus: !1 }); const a = t.label.map((t) => zp(t, e.providers)); const u = function (t, e) { Cr(t, Lb, { value: e }) }; var c = Km((n = { dom: { tag: 'span', attributes: { 'aria-label': e.providers.translate('Color swatch') } }, layouts: P.some({ onRtl() { return [$u] }, onLtr() { return [Qu] } }), components: [], fetch: Ab.getFetch(o.getColors(), o.hasCustomColors()), onItemAction(n) { e.getSink().each((t) => { c.getOpt(t).each((e) => { n === 'custom' ? o.colorPicker((t) => { t.fold(() => kr(e, Ib), (t) => { u(e, t), Sb(t) }) }, '#ffffff') : u(e, n === 'remove' ? '' : n) }) }) } }, r = e, Db.sketch({ dom: n.dom, components: n.components, toggleClass: 'mce-active', dropdownBehaviours: _a([_b.config({}), Xp.config({})]), layouts: n.layouts, sandboxClasses: ['tox-dialog__popups'], lazySink: r.getSink, fetch() { return Jv.nu((t) => n.fetch(t)).map((t) => Yg(gt(Gg(Un('menu-value'), t, (t) => { n.onItemAction(t) }, 5, 'color', dg.CLOSE_ON_EXECUTE, () => !1, r.providers), { movement: _g(5, 'color') }))) }, parts: { menu: Dg(0, 0, 'color') } }))); return Iv.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: a.toArray().concat([{ dom: { tag: 'div', classes: ['tox-color-input'] }, components: [i, c.asSpec()] }]), fieldBehaviours: _a([Am('form-field-events', [Wr(Fb, (t, e) => { c.getOpt(t).each((t) => { Wi(t.element(), 'background-color', e.event().color()) }) }), Wr(Lb, (e, n) => { Iv.getField(e).each((t) => { am.setValue(t, n.event().value()), Ll.getCurrent(e).each(fm.focus) }) }), Wr(Ib, (e, t) => { Iv.getField(e).each((t) => { Ll.getCurrent(e).each(fm.focus) }) })])]) }) }; const Nb = be.detect().deviceType.isTouch(); const Pb = al({ schema: [Zo('dom')], name: 'label' }); const jb = function (t) { return al({ name: `${t}-edge`, overrides(o) { return o.model.manager.edgeActions[t].fold(() => ({}), (n) => { const t = Pr([Gr(Ht(), n, [o])]); const e = Pr([Gr(At(), n, [o]), Gr(Tt(), (t, e) => { e.mouseIsDown.get() && n(t, e) }, [o])]); return { events: Nb ? t : e } }) } }) }; const Ub = jb('top-left'); const Wb = jb('top'); const Gb = jb('top-right'); const Xb = jb('right'); const Yb = jb('bottom-right'); const qb = jb('bottom'); const Kb = jb('bottom-left'); const Jb = [Pb, jb('left'), Xb, Wb, qb, Ub, Gb, Kb, Yb, rl({ name: 'thumb', defaults: U({ dom: { styles: { position: 'absolute' } } }), overrides(t) { return { events: Pr([Yr(Ht(), t, 'spectrum'), Yr(Vt(), t, 'spectrum'), Yr(Et(), t, 'spectrum'), Yr(At(), t, 'spectrum'), Yr(Tt(), t, 'spectrum'), Yr(Dt(), t, 'spectrum')]) } } }), rl({ schema: [xr('mouseIsDown', () => Ct(!1))], name: 'spectrum', overrides(n) { const o = n.model.manager; const r = function (e, t) { return o.getValueFromEvent(t).map((t) => o.setValueFrom(e, n, t)) }; const t = Pr([Wr(Ht(), r), Wr(Vt(), r)]); const e = Pr([Wr(At(), r), Wr(Tt(), (t, e) => { n.mouseIsDown.get() && r(t, e) })]); return { behaviours: _a(Nb ? [] : [jd.config({ mode: 'special', onLeft(t) { return o.onLeft(t, n) }, onRight(t) { return o.onRight(t, n) }, onUp(t) { return o.onUp(t, n) }, onDown(t) { return o.onDown(t, n) } }), fm.config({})]), events: Nb ? t : e } } })]; const $b = be.detect().deviceType.isTouch(); const Qb = U('slider.change.value'); const Zb = function (t) { const e = t.event().raw(); if ($b) { const n = e; return n.touches !== undefined && n.touches.length === 1 ? P.some(n.touches[0]).map((t) => Xa(t.clientX, t.clientY)) : P.none() } const o = e; return o.clientX !== undefined ? P.some(o).map((t) => Xa(t.clientX, t.clientY)) : P.none() }; const ty = function (t, e, n, o) { return t < e ? t : n < t ? n : t === e ? e - 1 : Math.max(e, t - o) }; const ey = function (t, e, n, o) { return n < t ? t : t < e ? e : t === n ? n + 1 : Math.min(n, t + o) }; const ny = function (t, e, n) { return Math.max(e, Math.min(n, t)) }; const oy = function (t) { const e = t.min; const n = t.max; const o = t.range; const r = t.value; const i = t.step; const a = t.snap; const u = t.snapStart; const c = t.rounded; const s = t.hasMinEdge; const l = t.hasMaxEdge; const f = t.minBound; const d = t.maxBound; const m = t.screenRange; const h = s ? e - 1 : e; const g = l ? n + 1 : n; if (r < f) return h; if (d < r) return g; let v; let p; let b; let y; let x; let w; let z; const S = (x = r, w = f, z = d, Math.min(z, Math.max(x, w)) - w); const k = ny(S / m * o + e, h, g); return a && e <= k && k <= n ? (v = k, p = e, b = n, y = i, u.fold(() => { const t = v - p; const e = Math.round(t / y) * y; return ny(p + e, p - 1, b + 1) }, (t) => { const e = (v - t) % y; const n = Math.round(e / y); const o = Math.floor((v - t) / y); const r = Math.floor((b - t) / y); const i = t + Math.min(r, o + n) * y; return Math.max(t, i) })) : c ? Math.round(k) : k }; const ry = function (t) { const e = t.min; const n = t.max; const o = t.range; const r = t.value; const i = t.hasMinEdge; const a = t.hasMaxEdge; const u = t.maxBound; const c = t.maxOffset; const s = t.centerMinEdge; const l = t.centerMaxEdge; return r < e ? i ? 0 : s : n < r ? a ? u : l : (r - e) / o * c }; const iy = function (t) { return t.model.minX }; const ay = function (t) { return t.model.minY }; const uy = function (t) { return t.model.minX - 1 }; const cy = function (t) { return t.model.minY - 1 }; const sy = function (t) { return t.model.maxX }; const ly = function (t) { return t.model.maxY }; const fy = function (t) { return t.model.maxX + 1 }; const dy = function (t) { return t.model.maxY + 1 }; const my = function (t, e, n) { return e(t) - n(t) }; const hy = function (t) { return my(t, sy, iy) }; const gy = function (t) { return my(t, ly, ay) }; const vy = function (t) { return hy(t) / 2 }; const py = function (t) { return gy(t) / 2 }; const by = function (t) { return t.stepSize }; const yy = function (t) { return t.snapToGrid }; const xy = function (t) { return t.snapStart }; const wy = function (t) { return t.rounded }; const zy = function (t, e) { return t[`${e}-edge`] !== undefined }; const Sy = function (t) { return zy(t, 'left') }; const ky = function (t) { return zy(t, 'right') }; const Cy = function (t) { return zy(t, 'top') }; const Oy = function (t) { return zy(t, 'bottom') }; const My = function (t) { return t.model.value.get() }; const Hy = function (t) { return { x: U(t) } }; const Vy = function (t) { return { y: U(t) } }; const Ey = function (t, e) { return { x: U(t), y: U(e) } }; const Ay = function (t, e) { Cr(t, Qb(), { value: e }) }; const Ty = 'left'; const By = function (t) { return t.element().dom().getBoundingClientRect() }; const Dy = function (t, e) { return t[e] }; const _y = function (t) { const e = By(t); return Dy(e, Ty) }; const Fy = function (t) { const e = By(t); return Dy(e, 'right') }; const Ly = function (t) { const e = By(t); return Dy(e, 'top') }; const Iy = function (t) { const e = By(t); return Dy(e, 'bottom') }; const Ry = function (t) { const e = By(t); return Dy(e, 'width') }; const Ny = function (t) { const e = By(t); return Dy(e, 'height') }; const Py = function (t, e, n) { return (t + e) / 2 - n }; const jy = function (t, e) { const n = By(t); const o = By(e); const r = Dy(n, Ty); const i = Dy(n, 'right'); const a = Dy(o, Ty); return Py(r, i, a) }; const Uy = function (t, e) { const n = By(t); const o = By(e); const r = Dy(n, 'top'); const i = Dy(n, 'bottom'); const a = Dy(o, 'top'); return Py(r, i, a) }; const Wy = function (t, e) { Cr(t, Qb(), { value: e }) }; const Gy = function (t) { return { x: U(t) } }; const Xy = function (t, e, n) { const o = { min: iy(e), max: sy(e), range: hy(e), value: n, step: by(e), snap: yy(e), snapStart: xy(e), rounded: wy(e), hasMinEdge: Sy(e), hasMaxEdge: ky(e), minBound: _y(t), maxBound: Fy(t), screenRange: Ry(t) }; return oy(o) }; const Yy = function (a) { return function (t, e) { return (n = a, o = t, r = e, i = (n > 0 ? ey : ty)(My(r).x(), iy(r), sy(r), by(r)), Wy(o, Gy(i)), P.some(i)).map(() => !0); let n, o, r, i } }; const qy = function (t, e, n, o, r, i) { let a; let u; let c; let s; let l; let f; let d; let m; let h; const g = (u = i, c = n, s = o, l = r, f = Ry(a = e), d = s.bind((t) => P.some(jy(t, a))).getOr(0), m = l.bind((t) => P.some(jy(t, a))).getOr(f), h = { min: iy(u), max: sy(u), range: hy(u), value: c, hasMinEdge: Sy(u), hasMaxEdge: ky(u), minBound: _y(a), minOffset: 0, maxBound: Fy(a), maxOffset: f, centerMinEdge: d, centerMaxEdge: m }, ry(h)); return _y(e) - _y(t) + g }; const Ky = Yy(-1); const Jy = Yy(1); const $y = P.none; const Qy = P.none; const Zy = { 'top-left': P.none(), top: P.none(), 'top-right': P.none(), right: P.some((t, e) => { Ay(t, Hy(fy(e))) }), 'bottom-right': P.none(), bottom: P.none(), 'bottom-left': P.none(), left: P.some((t, e) => { Ay(t, Hy(uy(e))) }) }; const tx = Object.freeze({ setValueFrom(t, e, n) { const o = Xy(t, e, n); const r = Gy(o); return Wy(t, r), o }, setToMin(t, e) { const n = iy(e); Wy(t, Gy(n)) }, setToMax(t, e) { const n = sy(e); Wy(t, Gy(n)) }, findValueOfOffset: Xy, getValueFromEvent(t) { return Zb(t).map((t) => t.left()) }, findPositionOfValue: qy, setPositionFromValue(t, e, n, o) { const r = My(n); const i = qy(t, o.getSpectrum(t), r.x(), o.getLeftEdge(t), o.getRightEdge(t), n); const a = eu(e.element()) / 2; Wi(e.element(), 'left', `${i - a}px`) }, onLeft: Ky, onRight: Jy, onUp: $y, onDown: Qy, edgeActions: Zy }); const ex = function (t, e) { Cr(t, Qb(), { value: e }) }; const nx = function (t) { return { y: U(t) } }; const ox = function (t, e, n) { const o = { min: ay(e), max: ly(e), range: gy(e), value: n, step: by(e), snap: yy(e), snapStart: xy(e), rounded: wy(e), hasMinEdge: Cy(e), hasMaxEdge: Oy(e), minBound: Ly(t), maxBound: Iy(t), screenRange: Ny(t) }; return oy(o) }; const rx = function (a) { return function (t, e) { return (n = a, o = t, r = e, i = (n > 0 ? ey : ty)(My(r).y(), ay(r), ly(r), by(r)), ex(o, nx(i)), P.some(i)).map(() => !0); let n, o, r, i } }; const ix = function (t, e, n, o, r, i) { let a; let u; let c; let s; let l; let f; let d; let m; let h; const g = (u = i, c = n, s = o, l = r, f = Ny(a = e), d = s.bind((t) => P.some(Uy(t, a))).getOr(0), m = l.bind((t) => P.some(Uy(t, a))).getOr(f), h = { min: ay(u), max: ly(u), range: gy(u), value: c, hasMinEdge: Cy(u), hasMaxEdge: Oy(u), minBound: Ly(a), minOffset: 0, maxBound: Iy(a), maxOffset: f, centerMinEdge: d, centerMaxEdge: m }, ry(h)); return Ly(e) - Ly(t) + g }; const ax = P.none; const ux = P.none; const cx = rx(-1); const sx = rx(1); const lx = { 'top-left': P.none(), top: P.some((t, e) => { Ay(t, Vy(cy(e))) }), 'top-right': P.none(), right: P.none(), 'bottom-right': P.none(), bottom: P.some((t, e) => { Ay(t, Vy(dy(e))) }), 'bottom-left': P.none(), left: P.none() }; const fx = Object.freeze({ setValueFrom(t, e, n) { const o = ox(t, e, n); const r = nx(o); return ex(t, r), o }, setToMin(t, e) { const n = ay(e); ex(t, nx(n)) }, setToMax(t, e) { const n = ly(e); ex(t, nx(n)) }, findValueOfOffset: ox, getValueFromEvent(t) { return Zb(t).map((t) => t.top()) }, findPositionOfValue: ix, setPositionFromValue(t, e, n, o) { const r = My(n); const i = ix(t, o.getSpectrum(t), r.y(), o.getTopEdge(t), o.getBottomEdge(t), n); const a = ru(e.element()) / 2; Wi(e.element(), 'top', `${i - a}px`) }, onLeft: ax, onRight: ux, onUp: cx, onDown: sx, edgeActions: lx }); const dx = function (t, e) { Cr(t, Qb(), { value: e }) }; const mx = function (t, e) { return { x: U(t), y: U(e) } }; const hx = function (s, l) { return function (t, e) { return (n = s, o = l, r = t, i = e, a = n > 0 ? ey : ty, u = o ? My(i).x() : a(My(i).x(), iy(i), sy(i), by(i)), c = o ? a(My(i).y(), ay(i), ly(i), by(i)) : My(i).y(), dx(r, mx(u, c)), P.some(u)).map(() => !0); let n, o, r, i, a, u, c } }; const gx = hx(-1, !1); const vx = hx(1, !1); const px = hx(-1, !0); const bx = hx(1, !0); const yx = { 'top-left': P.some((t, e) => { Ay(t, Ey(uy(e), cy(e))) }), top: P.some((t, e) => { Ay(t, Ey(vy(e), cy(e))) }), 'top-right': P.some((t, e) => { Ay(t, Ey(fy(e), cy(e))) }), right: P.some((t, e) => { Ay(t, Ey(fy(e), py(e))) }), 'bottom-right': P.some((t, e) => { Ay(t, Ey(fy(e), dy(e))) }), bottom: P.some((t, e) => { Ay(t, Ey(vy(e), dy(e))) }), 'bottom-left': P.some((t, e) => { Ay(t, Ey(uy(e), dy(e))) }), left: P.some((t, e) => { Ay(t, Ey(uy(e), py(e))) }) }; const xx = Object.freeze({ setValueFrom(t, e, n) { const o = Xy(t, e, n.left()); const r = ox(t, e, n.top()); const i = mx(o, r); return dx(t, i), i }, setToMin(t, e) { const n = iy(e); const o = ay(e); dx(t, mx(n, o)) }, setToMax(t, e) { const n = sy(e); const o = ly(e); dx(t, mx(n, o)) }, getValueFromEvent(t) { return Zb(t) }, setPositionFromValue(t, e, n, o) { const r = My(n); const i = qy(t, o.getSpectrum(t), r.x(), o.getLeftEdge(t), o.getRightEdge(t), n); const a = ix(t, o.getSpectrum(t), r.y(), o.getTopEdge(t), o.getBottomEdge(t), n); const u = eu(e.element()) / 2; const c = ru(e.element()) / 2; Wi(e.element(), 'left', `${i - u}px`), Wi(e.element(), 'top', `${a - c}px`) }, onLeft: gx, onRight: vx, onUp: px, onDown: bx, edgeActions: yx }); const wx = be.detect().deviceType.isTouch(); const zx = [dr('stepSize', 1), dr('onChange', N), dr('onChoose', N), dr('onInit', N), dr('onDragStart', N), dr('onDragEnd', N), dr('snapToGrid', !1), dr('rounded', !0), ur('snapStart'), tr('model', Go('mode', { x: [dr('minX', 0), dr('maxX', 100), xr('value', (t) => Ct(t.mode.minX)), Zo('getInitialValue'), Ma('manager', tx)], y: [dr('minY', 0), dr('maxY', 100), xr('value', (t) => Ct(t.mode.minY)), Zo('getInitialValue'), Ma('manager', fx)], xy: [dr('minX', 0), dr('maxX', 100), dr('minY', 0), dr('maxY', 100), xr('value', (t) => Ct({ x: U(t.mode.minX), y: U(t.mode.minY) })), Zo('getInitialValue'), Ma('manager', xx)] })), Es('sliderBehaviours', [jd, am])].concat(wx ? [] : [xr('mouseIsDown', () => Ct(!1))]); const Sx = be.detect().deviceType.isTouch(); const kx = Bl({ name: 'Slider', configFields: zx, partFields: Jb, factory(i, t, e, n) { const a = function (t) { return yl(t, i, 'thumb') }; const u = function (t) { return yl(t, i, 'spectrum') }; const o = function (t) { return bl(t, i, 'left-edge') }; const r = function (t) { return bl(t, i, 'right-edge') }; const c = function (t) { return bl(t, i, 'top-edge') }; const s = function (t) { return bl(t, i, 'bottom-edge') }; const l = i.model; const f = l.manager; const d = function (t, e) { f.setPositionFromValue(t, e, i, { getLeftEdge: o, getRightEdge: r, getTopEdge: c, getBottomEdge: s, getSpectrum: u }) }; const m = function (t, e) { l.value.set(e); const n = a(t); return d(t, n), i.onChange(t, n, e), P.some(!0) }; const h = [Wr(Ht(), (t, e) => { i.onDragStart(t, a(t)) }), Wr(Et(), (t, e) => { i.onDragEnd(t, a(t)) })]; const g = [Wr(At(), (t, e) => { e.stop(), i.onDragStart(t, a(t)), i.mouseIsDown.set(!0) }), Wr(Dt(), (t, e) => { i.onDragEnd(t, a(t)) })]; const v = Sx ? h : g; return { uid: i.uid, dom: i.dom, components: t, behaviours: Ts(i.sliderBehaviours, R([Sx ? [] : [jd.config({ mode: 'special', focusIn(t) { return bl(t, i, 'spectrum').map(jd.focusIn).map(U(!0)) } })], [am.config({ store: { mode: 'manual', getValue(t) { return l.value.get() } } }), Ua.config({ channels: { 'mouse.released': { onReceive(n, t) { const e = i.mouseIsDown.get(); i.mouseIsDown.set(!1), e && bl(n, i, 'thumb').each((t) => { const e = l.value.get(); i.onChoose(n, t, e) }) } } } })]])), events: Pr([Wr(Qb(), (t, e) => { m(t, e.event().value()) }), Qr((t, e) => { const n = l.getInitialValue(); l.value.set(n); const o = a(t); d(t, o); const r = u(t); i.onInit(t, o, r, l.value.get()) })].concat(v)), apis: { resetToMin(t) { f.setToMin(t, i) }, resetToMax(t) { f.setToMax(t, i) }, changeValue: m, refresh: d }, domModification: { styles: { position: 'relative' } } } }, apis: { resetToMin(t, e) { t.resetToMin(e) }, resetToMax(t, e) { t.resetToMax(e) }, refresh(t, e) { t.refresh(e) } } }); const Cx = U(Un('rgb-hex-update')); const Ox = U(Un('slider-update')); const Mx = U(Un('palette-update')); const Hx = function (t, o) { const r = kx.parts().spectrum({ dom: { tag: 'canvas', attributes: { role: 'presentation' }, classes: [o('sv-palette-spectrum')] } }); const i = kx.parts().thumb({ dom: { tag: 'div', attributes: { role: 'presentation' }, classes: [o('sv-palette-thumb')], innerHtml: `<div class=${o('sv-palette-inner-thumb')} role="presentation"></div>` } }); const a = function (t, e) { const n = t.width; const o = t.height; const r = t.getContext('2d'); r.fillStyle = e, r.fillRect(0, 0, n, o); const i = r.createLinearGradient(0, 0, n, 0); i.addColorStop(0, 'rgba(255,255,255,1)'), i.addColorStop(1, 'rgba(255,255,255,0)'), r.fillStyle = i, r.fillRect(0, 0, n, o); const a = r.createLinearGradient(0, 0, 0, o); a.addColorStop(0, 'rgba(0,0,0,0)'), a.addColorStop(1, 'rgba(0,0,0,1)'), r.fillStyle = a, r.fillRect(0, 0, n, o) }; return Tl({ factory(t) { const e = U({ x: U(0), y: U(0) }); const n = _a([Ll.config({ find: P.some }), fm.config({})]); return kx.sketch({ dom: { tag: 'div', attributes: { role: 'presentation' }, classes: [o('sv-palette')] }, model: { mode: 'xy', getInitialValue: e }, rounded: !1, components: [r, i], onChange(t, e, n) { Cr(t, Mx(), { value: n }) }, onInit(t, e, n, o) { a(n.element().dom(), lb(fb())) }, sliderBehaviours: n }) }, name: 'SaturationBrightnessPalette', configFields: [], apis: { setRgba(t, e, n) { let o, r; o = n, r = e.components()[0].element().dom(), a(r, lb(o)) } }, extraApis: {} }) }; const Vx = function (t, e) { const n = kx.parts().spectrum({ dom: { tag: 'div', classes: [e('hue-slider-spectrum')], attributes: { role: 'presentation' } } }); const o = kx.parts().thumb({ dom: { tag: 'div', classes: [e('hue-slider-thumb')], attributes: { role: 'presentation' } } }); return kx.sketch({ dom: { tag: 'div', classes: [e('hue-slider')], attributes: { role: 'presentation' } }, rounded: !1, model: { mode: 'y', getInitialValue: U({ y: U(0) }) }, components: [n, o], sliderBehaviours: _a([fm.config({})]), onChange(t, e, n) { Cr(t, Ox(), { value: n }) } }) }; const Ex = [Es('formBehaviours', [am])]; const Ax = function (t) { return `<alloy.field.${t}>` }; const Tx = function (o, t, e) { return { uid: o.uid, dom: o.dom, components: t, behaviours: Ts(o.formBehaviours, [am.config({ store: { mode: 'manual', getValue(t) { const e = wl(t, o); return et(e, (t, e) => t().bind((t) => { let e; const n = Ll.getCurrent(t); return e = 'missing current', n.fold(() => ft.error(e), ft.value) }).map(am.getValue)) }, setValue(n, t) { tt(t, (e, t) => { bl(n, o, t).each((t) => { Ll.getCurrent(t).each((t) => { am.setValue(t, e) }) }) }) } } })]), apis: { getField(t, e) { return bl(t, o, e).bind(Ll.getCurrent) } } } }; const Bx = { getField: bi((t, e, n) => t.getField(e, n)), sketch(t) { let n; const e = (n = [], { field(t, e) { return n.push(t), ml('form', Ax(t), e) }, record() { return n } }); const o = t(e); const r = e.record(); const i = E(r, (t) => rl({ name: t, pname: Ax(t) })); return Hl('form', Ex, i, Tx, o) } }; const Dx = Un('valid-input'); const _x = Un('invalid-input'); const Fx = Un('validating-input'); const Lx = 'colorcustom.rgb.'; const Ix = function (m, h, g, v) { const p = function (t, e, n, o, r) { let i; let a; const u = m(`${Lx}range`); const c = [Iv.parts().label({ dom: { tag: 'label', innerHtml: n, attributes: { 'aria-label': o } } }), Iv.parts().field({ data: r, factory: Vp, inputAttributes: Gn({ type: 'text' }, e === 'hex' ? { 'aria-live': 'polite' } : {}), inputClasses: [h('textfield')], inputBehaviours: _a([(i = e, a = t, Up.config({ invalidClass: h('invalid'), notify: { onValidate(t) { Cr(t, Fx, { type: i }) }, onValid(t) { Cr(t, Dx, { type: i, value: am.getValue(t) }) }, onInvalid(t) { Cr(t, _x, { type: i, value: am.getValue(t) }) } }, validator: { validate(t) { const e = am.getValue(t); const n = a(e) ? ft.value(!0) : ft.error(m('aria.input.invalid')); return Jv.pure(n) }, validateOnLoad: !1 } })), Xp.config({})]), onSetValue(t) { Up.isInvalid(t) && Up.run(t).get(N) } })]; const s = e !== 'hex' ? [Iv.parts()['aria-descriptor']({ text: u })] : []; return { dom: { tag: 'div', attributes: { role: 'presentation' } }, components: c.concat(s) } }; const b = function (t, e) { const n = e.red(); const o = e.green(); const r = e.blue(); am.setValue(t, { red: n, green: o, blue: r }) }; const y = Km({ dom: { tag: 'div', classes: [h('rgba-preview')], styles: { 'background-color': 'white' }, attributes: { role: 'presentation' } } }); const x = function (t, e) { y.getOpt(t).each((t) => { Wi(t.element(), 'background-color', `#${e.value()}`) }) }; return Tl({ factory(t) { const n = { red: U(Ct(P.some(255))), green: U(Ct(P.some(255))), blue: U(Ct(P.some(255))), hex: U(Ct(P.some('ffffff'))) }; const o = function (t) { return n[t]().get() }; const i = function (t, e) { n[t]().set(e) }; const r = function (t) { const e = t.red(); const n = t.green(); const o = t.blue(); i('red', P.some(e)), i('green', P.some(n)), i('blue', P.some(o)) }; const e = function (t, e) { const n = e.event(); n.type() !== 'hex' ? i(n.type(), P.none()) : v(t) }; const a = function (r, t, e) { const n = parseInt(e, 10); i(t, P.some(n)), o('red').bind((n) => o('green').bind((e) => o('blue').map((t) => ib(n, e, t, 1)))).each((t) => { let e; let n; const o = (e = r, n = Zp(t), Bx.getField(e, 'hex').each((t) => { fm.isFocused(t) || am.setValue(e, { hex: n.value() }) }), n); x(r, o) }) }; const u = function (t, e) { const n = e.event(); n.type() === 'hex' ? (function (t, e) { g(t); const n = Yp(e); i('hex', P.some(e)); const o = cb(n); b(t, o), r(o), Cr(t, Cx(), { hex: n }), x(t, n) }(t, n.value())) : a(t, n.type(), n.value()) }; const c = function (t) { return { label: m(`${Lx + t}.label`), description: m(`${Lx + t}.description`) } }; const s = c('red'); const l = c('green'); const f = c('blue'); const d = c('hex'); return gt(Bx.sketch((t) => ({ dom: { tag: 'form', classes: [h('rgb-form')], attributes: { 'aria-label': m('aria.color.picker') } }, components: [t.field('red', Iv.sketch(p(ab, 'red', s.label, s.description, 255))), t.field('green', Iv.sketch(p(ab, 'green', l.label, l.description, 255))), t.field('blue', Iv.sketch(p(ab, 'blue', f.label, f.description, 255))), t.field('hex', Iv.sketch(p(Jp, 'hex', d.label, d.description, 'ffffff'))), y.asSpec()], formBehaviours: _a([Up.config({ invalidClass: h('form-invalid') }), Am('rgb-form-events', [Wr(Dx, u), Wr(_x, e), Wr(Fx, e)])]) })), { apis: { updateHex(t, e) { let n, o; am.setValue(t, { hex: e.value() }), n = t, o = cb(e), b(n, o), r(o), x(t, e) } } }) }, name: 'RgbForm', configFields: [], apis: { updateHex(t, e, n) { t.updateHex(e, n) } }, extraApis: {} }) }; const Rx = function (t, e, n) { return { hue: U(t), saturation: U(e), value: U(n) } }; const Nx = function (c, s) { return Tl({ name: 'ColourPicker', configFields: [dr('onValidHex', N), dr('onInvalidHex', N), sr('formChangeEvent')], factory(t) { let u; let p; const n = Ix(c, s, t.onValidHex, t.onInvalidHex); const o = Hx(c, s); const b = { paletteRgba: U(Ct(fb())) }; const e = Km(o.sketch({})); const r = Km(n.sketch({})); const i = function (t, n) { e.getOpt(t).each((t) => { const e = cb(n); b.paletteRgba().set(e), o.setRgba(t, e) }) }; const a = function (t, e) { r.getOpt(t).each((t) => { n.updateHex(t, e) }) }; const y = function (e, n, t) { A(t, (t) => { t(e, n) }) }; return { uid: t.uid, dom: t.dom, components: [e.asSpec(), Vx(c, s), r.asSpec()], behaviours: _a([Am('colour-picker-events', [Wr(Mx(), (p = [a], function (t, e) { let n; let o; let r; let i; let a; let u; let c; let s; let l; const f = e.event().value(); const d = b.paletteRgba().get(); const m = (c = a = 0, o = (n = d).red() / 255, r = n.green() / 255, i = n.blue() / 255, (s = Math.min(o, Math.min(r, i))) === (l = Math.max(o, Math.max(r, i))) ? Rx(0, 0, 100 * (c = s)) : (a = 60 * ((a = o === s ? 3 : i === s ? 1 : 5) - (o === s ? r - i : i === s ? o - r : i - o) / (l - s)), u = (l - s) / l, c = l, Rx(Math.round(a), Math.round(100 * u), Math.round(100 * c)))); const h = Rx(m.hue(), f.x(), 100 - f.y()); const g = ub(h); const v = Zp(g); y(t, v, p) })), Wr(Ox(), (u = [i, a], function (t, e) { let n; let o; let r; const i = e.event().value(); const a = (n = i.y(), o = Rx(360 * (100 - n / 100), 100, 100), r = ub(o), Zp(r)); y(t, a, u) }))]), Ll.config({ find(t) { return r.getOpt(t) } }), jd.config({ mode: 'acyclic' })]) } } }) }; const Px = function () { return Ll.config({ find: P.some }) }; const jx = function (t) { return Ll.config({ find: t.getOpt }) }; const Ux = function (t) { return Ll.config({ find(e) { return sn(e.element(), t).bind((t) => e.getSystem().getByDom(t).toOption()) } }) }; const Wx = { 'colorcustom.rgb.red.label': 'R', 'colorcustom.rgb.red.description': 'Red component', 'colorcustom.rgb.green.label': 'G', 'colorcustom.rgb.green.description': 'Green component', 'colorcustom.rgb.blue.label': 'B', 'colorcustom.rgb.blue.description': 'Blue component', 'colorcustom.rgb.hex.label': '#', 'colorcustom.rgb.hex.description': 'Hex color code', 'colorcustom.rgb.range': 'Range 0 to 255', 'colorcustom.sb.saturation': 'Saturation', 'colorcustom.sb.brightness': 'Brightness', 'colorcustom.sb.picker': 'Saturation and Brightness Picker', 'colorcustom.sb.palette': 'Saturation and Brightness Palette', 'colorcustom.sb.instructions': 'Use arrow keys to select saturation and brightness, on x and y axes', 'colorcustom.hue.hue': 'Hue', 'colorcustom.hue.slider': 'Hue Slider', 'colorcustom.hue.palette': 'Hue Palette', 'colorcustom.hue.instructions': 'Use arrow keys to select a hue', 'aria.color.picker': 'Color Picker', 'aria.input.invalid': 'Invalid input' }; const Gx = function (t) { return Wx[t] }; const Xx = Vo([dr('preprocess', d), dr('postprocess', d)]); const Yx = function (t, e, n) { return am.config(gt({ store: { mode: 'manual', getValue: e, setValue: n } }, t.map((t) => ({ store: { initialValue: t } })).getOr({}))) }; const qx = function (t, e, n) { return Yx(t, (t) => e(t.element()), (t, e) => n(t.element(), e)) }; const Kx = function (r, t) { const i = Uo('RepresentingConfigs.memento processors', Xx, t); return am.config({ store: { mode: 'manual', getValue(t) { const e = r.get(t); const n = am.getValue(e); return i.postprocess(n) }, setValue(t, e) { const n = i.preprocess(e); const o = r.get(t); am.setValue(o, n) } } }) }; const Jx = Yx; const $x = function (t) { return qx(t, pn, bn) }; const Qx = function (t) { return am.config({ store: { mode: 'memory', initialValue: t } }) }; const Zx = function (r, e) { const n = function (t, e) { e.stop() }; const o = function (t) { return function (e, n) { A(t, (t) => { t(e, n) }) } }; const i = function (t, e) { if (!og.isDisabled(t)) { const n = e.event().raw(); u(t, n.dataTransfer.files) } }; const a = function (t, e) { const n = e.event().raw().target.files; u(t, n) }; var u = function (t, e) { let n, o; am.setValue(t, (n = e, o = new RegExp(`(${'.jpg,.jpeg,.png,.gif'.split(/\s*,\s*/).join('|')})$`, 'i'), T($(n), (t) => o.test(t.name)))), Cr(t, Mv, { name: r.name }) }; const c = Km({ dom: { tag: 'input', attributes: { type: 'file', multiple: 'multiple' }, styles: { display: 'none' } }, behaviours: _a([Am('input-file-events', [Kr(jt())])]) }); const t = r.label.map((t) => zp(t, e)); const s = Iv.parts().field({ factory: { sketch(t) { return { uid: t.uid, dom: { tag: 'div', classes: ['tox-dropzone-container'] }, behaviours: _a([Qx([]), Px(), og.config({}), km.config({ toggleClass: 'dragenter', toggleOnExecute: !1 }), Am('dropzone-events', [Wr('dragenter', o([n, km.toggle])), Wr('dragleave', o([n, km.toggle])), Wr('dragover', n), Wr('drop', o([n, i])), Wr(Pt(), a)])]), components: [{ dom: { tag: 'div', classes: ['tox-dropzone'], styles: {} }, components: [{ dom: { tag: 'p', innerHtml: e.translate('Drop an image here') } }, qm.sketch({ dom: { tag: 'button', innerHtml: e.translate('Browse for an image'), styles: { position: 'relative' }, classes: ['tox-button', 'tox-button--secondary'] }, components: [c.asSpec()], action(t) { c.get(t).element().dom().click() }, buttonBehaviours: _a([Xp.config({})]) })] }] } } } }); const l = r.flex ? ['tox-form__group--stretched'] : []; return bp(t, s, l) }; const tw = Un('alloy-fake-before-tabstop'); const ew = Un('alloy-fake-after-tabstop'); const nw = function (t) { return { dom: { tag: 'div', styles: { width: '1px', height: '1px', outline: 'none' }, attributes: { tabindex: '0' }, classes: t }, behaviours: _a([fm.config({ ignore: !0 }), Xp.config({})]) } }; const ow = function (t, e) { Cr(t, It(), { raw: { which: 9, shiftKey: e } }) }; const rw = function (t) { return ev(t, [`.${tw}`, `.${ew}`].join(','), U(!1)) }; const iw = function (t, e) { const n = e.element(); Ii(n, tw) ? ow(t, !0) : Ii(n, ew) && ow(t, !1) }; const aw = function (t) { return { dom: { tag: 'div', classes: ['tox-navobj'] }, components: [nw([tw]), t, nw([ew])], behaviours: _a([Ux(1)]) } }; const uw = !(be.detect().browser.isIE() || be.detect().browser.isEdge()); const cw = function (t, e) { let o; let r; const n = uw && t.sandboxed; const i = Gn({}, t.label.map((t) => ({ title: t })).getOr({}), n ? { sandbox: 'allow-scripts' } : {}); const a = (o = n, r = Ct(''), { getValue(t) { return r.get() }, setValue(t, e) { if (o)Cn(t.element(), 'src', `data:text/html;charset=utf-8,${encodeURIComponent(e)}`); else { Cn(t.element(), 'src', "javascript:''"); const n = t.element().dom().contentWindow.document; n.open(), n.write(e), n.close() }r.set(e) } }); const u = t.label.map((t) => zp(t, e)); const c = Iv.parts().field({ factory: { sketch(t) { return aw({ uid: t.uid, dom: { tag: 'iframe', attributes: i }, behaviours: _a([Xp.config({}), fm.config({}), Jx(P.none(), a.getValue, a.setValue)]) }) } } }); const s = t.flex ? ['tox-form__group--stretched'] : []; return bp(u, c, s) }; function sw(t, e) { return fw(document.createElement('canvas'), t, e) } function lw(t) { return t.getContext('2d') } function fw(t, e, n) { return t.width = e, t.height = n, t } const dw = { create: sw, clone: function fV(t) { let e; return lw(e = sw(t.width, t.height)).drawImage(t, 0, 0), e }, resize: fw, get2dContext: lw, get3dContext: function dV(t) { let e = null; try { e = t.getContext('webgl') || t.getContext('experimental-webgl') } catch (n) {} return e || (e = null), e } }; const mw = { getWidth: function mV(t) { return t.naturalWidth || t.width }, getHeight: function hV(t) { return t.naturalHeight || t.height } }; const hw = window.Promise ? window.Promise : (function () { const t = function (t) { if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new'); if (typeof t !== 'function') throw new TypeError('not a function'); this._state = null, this._value = null, this._deferreds = [], s(t, o(r, this), o(a, this)) }; const e = t.immediateFn || typeof window.setImmediate === 'function' && window.setImmediate || function (t) { setTimeout(t, 1) }; function o(t, e) { return function () { t.apply(e, arguments) } } const n = Array.isArray || function (t) { return Object.prototype.toString.call(t) === '[object Array]' }; function i(o) { const r = this; this._state !== null ? e(() => { const t = r._state ? o.onFulfilled : o.onRejected; if (t !== null) { let e; try { e = t(r._value) } catch (n) { return void o.reject(n) }o.resolve(e) } else (r._state ? o.resolve : o.reject)(r._value) }) : this._deferreds.push(o) } function r(t) { try { if (t === this) throw new TypeError('A promise cannot be resolved with itself.'); if (t && (typeof t === 'object' || typeof t === 'function')) { const e = t.then; if (typeof e === 'function') return void s(o(e, t), o(r, this), o(a, this)) } this._state = !0, this._value = t, u.call(this) } catch (n) { a.call(this, n) } } function a(t) { this._state = !1, this._value = t, u.call(this) } function u() { for (let t = 0, e = this._deferreds.length; t < e; t++)i.call(this, this._deferreds[t]); this._deferreds = null } function c(t, e, n, o) { this.onFulfilled = typeof t === 'function' ? t : null, this.onRejected = typeof e === 'function' ? e : null, this.resolve = n, this.reject = o } function s(t, e, n) { let o = !1; try { t((t) => { o || (o = !0, e(t)) }, (t) => { o || (o = !0, n(t)) }) } catch (r) { if (o) return; o = !0, n(r) } } return t.prototype.catch = function (t) { return this.then(null, t) }, t.prototype.then = function (n, o) { const r = this; return new t((t, e) => { i.call(r, new c(n, o, t, e)) }) }, t.all = function () { const c = Array.prototype.slice.call(arguments.length === 1 && n(arguments[0]) ? arguments[0] : arguments); return new t((r, i) => { if (c.length === 0) return r([]); let a = c.length; function u(e, t) { try { if (t && (typeof t === 'object' || typeof t === 'function')) { const n = t.then; if (typeof n === 'function') return void n.call(t, (t) => { u(e, t) }, i) }c[e] = t, --a == 0 && r(c) } catch (o) { i(o) } } for (let t = 0; t < c.length; t++)u(t, c[t]) }) }, t.resolve = function (e) { return e && typeof e === 'object' && e.constructor === t ? e : new t((t) => { t(e) }) }, t.reject = function (n) { return new t((t, e) => { e(n) }) }, t.race = function (r) { return new t((t, e) => { for (let n = 0, o = r.length; n < o; n++)r[n].then(t, e) }) }, t }()); function gw() { return new (Ye.getOrDie('FileReader'))() } const vw = { atob(t) { return Ye.getOrDie('atob')(t) }, requestAnimationFrame(t) { Ye.getOrDie('requestAnimationFrame')(t) } }; function pw(u) { return new hw((t, e) => { const n = URL.createObjectURL(u); const o = new Image(); const r = function () { o.removeEventListener('load', i), o.removeEventListener('error', a) }; function i() { r(), t(o) } function a() { r(), e(`Unable to load data of type ${u.type}: ${n}`) }o.addEventListener('load', i), o.addEventListener('error', a), o.src = n, o.complete && i() }) } function bw(o) { return new hw((t, n) => { const e = new XMLHttpRequest(); e.open('GET', o, !0), e.responseType = 'blob', e.onload = function () { this.status == 200 && t(this.response) }, e.onerror = function () { let t; const e = this; n(this.status === 0 ? ((t = new Error('No access to download image')).code = 18, t.name = 'SecurityError', t) : new Error(`Error ${e.status} downloading image`)) }, e.send() }) } function yw(t) { const e = t.split(','); const n = /data:([^;]+)/.exec(e[0]); if (!n) return P.none(); for (var o, r = n[1], i = e[1], a = vw.atob(i), u = a.length, c = Math.ceil(u / 1024), s = new Array(c), l = 0; l < c; ++l) { for (var f = 1024 * l, d = Math.min(f + 1024, u), m = new Array(d - f), h = f, g = 0; h < d; ++g, ++h)m[g] = a[h].charCodeAt(0); s[l] = (o = m, new (Ye.getOrDie('Uint8Array'))(o)) } return P.some(function v(t, e) { return new (Ye.getOrDie('Blob'))(t, e) }(s, { type: r })) } function xw(n) { return new hw((t, e) => { yw(n).fold(() => { e(`uri is not base64: ${n}`) }, t) }) } function ww(n) { return new hw((t) => { const e = gw(); e.onloadend = function () { t(e.result) }, e.readAsDataURL(n) }) } const zw = { blobToImage: pw, imageToBlob: function gV(t) { const e = t.src; return e.indexOf('data:') === 0 ? xw(e) : bw(e) }, blobToArrayBuffer: function vV(n) { return new hw((t) => { const e = gw(); e.onloadend = function () { t(e.result) }, e.readAsArrayBuffer(n) }) }, blobToDataUri: ww, blobToBase64: function pV(t) { return ww(t).then((t) => t.split(',')[1]) }, dataUriToBlobSync: yw, canvasToBlob: function bV(t, n, o) { return n = n || 'image/png', HTMLCanvasElement.prototype.toBlob ? new hw((e) => { t.toBlob((t) => { e(t) }, n, o) }) : xw(t.toDataURL(n, o)) }, canvasToDataURL: function yV(t, e, n) { return e = e || 'image/png', t.then((t) => t.toDataURL(e, n)) }, blobToCanvas: function xV(t) { return pw(t).then((t) => { let e; return (function n(t) { URL.revokeObjectURL(t.src) }(t)), e = dw.create(mw.getWidth(t), mw.getHeight(t)), dw.get2dContext(e).drawImage(t, 0, 0), e }) }, uriToBlob: function wV(t) { return t.indexOf('blob:') === 0 ? bw(t) : t.indexOf('data:') === 0 ? xw(t) : null } }; function Sw(t, e, n) { const o = e.type; function r(e, n) { return t.then((t) => zw.canvasToDataURL(t, e, n)) } return { getType: U(o), toBlob: function i() { return hw.resolve(e) }, toDataURL: function a() { return n }, toBase64: function u() { return n.split(',')[1] }, toAdjustedBlob: function c(e, n) { return t.then((t) => zw.canvasToBlob(t, e, n)) }, toAdjustedDataURL: r, toAdjustedBase64: function s(t, e) { return r(t, e).then((t) => t.split(',')[1]) }, toCanvas: function l() { return t.then(dw.clone) } } } function kw(e) { return zw.blobToDataUri(e).then((t) => Sw(zw.blobToCanvas(e), e, t)) } const Cw = { fromBlob: kw, fromCanvas: function zV(e, t) { return zw.canvasToBlob(e, t).then((t) => Sw(hw.resolve(e), t, e.toDataURL())) }, fromImage: function SV(t) { return zw.imageToBlob(t).then((t) => kw(t)) }, fromBlobAndUrlSync(t, e) { return Sw(zw.blobToCanvas(t), t, e) } }; const Ow = function (t) { return Cw.fromBlob(t) }; function Mw(t, e, n) { return n < (t = parseFloat(t)) ? t = n : t < e && (t = e), t } const Hw = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.2, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.3, 0.32, 0.34, 0.36, 0.38, 0.4, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.8, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1, 1.06, 1.12, 1.18, 1.24, 1.3, 1.36, 1.42, 1.48, 1.54, 1.6, 1.66, 1.72, 1.78, 1.84, 1.9, 1.96, 2, 2.12, 2.25, 2.37, 2.5, 2.62, 2.75, 2.87, 3, 3.2, 3.4, 3.6, 3.8, 4, 4.3, 4.7, 4.9, 5, 5.5, 6, 6.5, 6.8, 7, 7.3, 7.5, 7.8, 8, 8.4, 8.7, 9, 9.4, 9.6, 9.8, 10]; function Vw(t, e) { let n; let o; let r; let i; const a = []; const u = new Array(10); for (n = 0; n < 5; n++) { for (o = 0; o < 5; o++)a[o] = e[o + 5 * n]; for (o = 0; o < 5; o++) { for (r = i = 0; r < 5; r++)i += t[o + 5 * r] * a[r]; u[o + 5 * n] = i } } return u } function Ew(t, n) { return n = Mw(n, 0, 1), t.map((t, e) => e % 6 == 0 ? t = 1 - (1 - t) * n : t *= n, Mw(t, 0, 1)) } const Aw = { identity: function kV() { return [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1] }, adjust: Ew, multiply: Vw, adjustContrast: function CV(t, e) { let n; return e = Mw(e, -1, 1), Vw(t, [(n = (e *= 100) < 0 ? 127 + e / 100 * 127 : 127 * (n = (n = e % 1) == 0 ? Hw[e] : Hw[Math.floor(e)] * (1 - n) + Hw[Math.floor(e) + 1] * n) + 127) / 127, 0, 0, 0, 0.5 * (127 - n), 0, n / 127, 0, 0, 0.5 * (127 - n), 0, 0, n / 127, 0, 0.5 * (127 - n), 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) }, adjustBrightness: function OV(t, e) { return Vw(t, [1, 0, 0, 0, e = Mw(255 * e, -255, 255), 0, 1, 0, 0, e, 0, 0, 1, 0, e, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) }, adjustSaturation: function MV(t, e) { let n; return Vw(t, [0.3086 * (1 - (n = 1 + ((e = Mw(e, -1, 1)) > 0 ? 3 * e : e))) + n, 0.6094 * (1 - n), 0.082 * (1 - n), 0, 0, 0.3086 * (1 - n), 0.6094 * (1 - n) + n, 0.082 * (1 - n), 0, 0, 0.3086 * (1 - n), 0.6094 * (1 - n), 0.082 * (1 - n) + n, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) }, adjustHue: function HV(t, e) { let n, o; return e = Mw(e, -180, 180) / 180 * Math.PI, Vw(t, [0.213 + 0.787 * (n = Math.cos(e)) + -0.213 * (o = Math.sin(e)), 0.715 + -0.715 * n + -0.715 * o, 0.072 + -0.072 * n + 0.928 * o, 0, 0, 0.213 + -0.213 * n + 0.143 * o, 0.715 + n * (1 - 0.715) + 0.14 * o, 0.072 + -0.072 * n + -0.283 * o, 0, 0, 0.213 + -0.213 * n + -0.787 * o, 0.715 + -0.715 * n + 0.715 * o, 0.072 + 0.928 * n + 0.072 * o, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) }, adjustColors: function VV(t, e, n, o) { return Vw(t, [e = Mw(e, 0, 2), 0, 0, 0, 0, 0, n = Mw(n, 0, 2), 0, 0, 0, 0, 0, o = Mw(o, 0, 2), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]) }, adjustSepia: function EV(t, e) { return Vw(t, Ew([0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], e = Mw(e, 0, 1))) }, adjustGrayscale: function AV(t, e) { return Vw(t, Ew([0.33, 0.34, 0.33, 0, 0, 0.33, 0.34, 0.33, 0, 0, 0.33, 0.34, 0.33, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], e = Mw(e, 0, 1))) } }; function Tw(e, n) { return e.toCanvas().then((t) => (function i(t, e, n) { let o; const r = dw.get2dContext(t); return o = (function H(t, e) { let n; let o; let r; let i; let a; const u = t.data; const c = e[0]; const s = e[1]; const l = e[2]; const f = e[3]; const d = e[4]; const m = e[5]; const h = e[6]; const g = e[7]; const v = e[8]; const p = e[9]; const b = e[10]; const y = e[11]; const x = e[12]; const w = e[13]; const z = e[14]; const S = e[15]; const k = e[16]; const C = e[17]; const O = e[18]; const M = e[19]; for (a = 0; a < u.length; a += 4)n = u[a], o = u[a + 1], r = u[a + 2], i = u[a + 3], u[a] = n * c + o * s + r * l + i * f + d, u[a + 1] = n * m + o * h + r * g + i * v + p, u[a + 2] = n * b + o * y + r * x + i * w + z, u[a + 3] = n * S + o * k + r * C + i * O + M; return t }(r.getImageData(0, 0, t.width, t.height), n)), r.putImageData(o, 0, 0), Cw.fromCanvas(t, e) }(t, e.getType(), n))) } function Bw(e, n) { return e.toCanvas().then((t) => (function a(t, e, n) { let o; let r; const i = dw.get2dContext(t); return o = i.getImageData(0, 0, t.width, t.height), r = i.getImageData(0, 0, t.width, t.height), r = (function w(t, e, n) { let o, r, i, a, u, c, s, l, f, d, m, h, g, v, p, b, y; function x(t, e, n) { return n < t ? t = n : t < e && (t = e), t } for (i = Math.round(Math.sqrt(n.length)), a = Math.floor(i / 2), o = t.data, r = e.data, b = t.width, y = t.height, c = 0; c < y; c++) for (u = 0; u < b; u++) { for (s = l = f = 0, m = 0; m < i; m++) for (d = 0; d < i; d++)h = x(u + d - a, 0, b - 1), g = x(c + m - a, 0, y - 1), v = 4 * (g * b + h), p = n[m * i + d], s += o[v] * p, l += o[v + 1] * p, f += o[v + 2] * p; r[v = 4 * (c * b + u)] = x(s, 0, 255), r[v + 1] = x(l, 0, 255), r[v + 2] = x(f, 0, 255) } return e }(o, r, n)), i.putImageData(r, 0, 0), Cw.fromCanvas(t, e) }(t, e.getType(), n))) } function Dw(c) { return function (e, n) { return e.toCanvas().then((t) => (function (t, e, n) { let o; let r; const i = dw.get2dContext(t); const a = new Array(256); for (r = 0; r < a.length; r++)a[r] = c(r, n); return o = (function u(t, e) { let n; const o = t.data; for (n = 0; n < o.length; n += 4)o[n] = e[o[n]], o[n + 1] = e[o[n + 1]], o[n + 2] = e[o[n + 2]]; return t }(i.getImageData(0, 0, t.width, t.height), a)), i.putImageData(o, 0, 0), Cw.fromCanvas(t, e) }(t, e.getType(), n))) } } function _w(n) { return function (t, e) { return Tw(t, n(Aw.identity(), e)) } } function Fw(e) { return function (t) { return Bw(t, e) } } const Lw = { invert: (function TV(e) { return function (t) { return Tw(t, e) } }([-1, 0, 0, 0, 255, 0, -1, 0, 0, 255, 0, 0, -1, 0, 255, 0, 0, 0, 1, 0])), brightness: _w(Aw.adjustBrightness), hue: _w(Aw.adjustHue), saturate: _w(Aw.adjustSaturation), contrast: _w(Aw.adjustContrast), grayscale: _w(Aw.adjustGrayscale), sepia: _w(Aw.adjustSepia), colorize(t, e, n, o) { return Tw(t, Aw.adjustColors(Aw.identity(), e, n, o)) }, sharpen: Fw([0, -1, 0, -1, 5, -1, 0, -1, 0]), emboss: Fw([-2, -1, 0, -1, 1, 1, 0, 1, 2]), gamma: Dw((t, e) => 255 * Math.pow(t / 255, 1 - e)), exposure: Dw((t, e) => 255 * (1 - Math.exp(-t / 255 * e))), colorFilter: Tw, convoluteFilter: Bw }; const Iw = { scale: function BV(t, e, n) { const o = mw.getWidth(t); const r = mw.getHeight(t); let i = e / o; let a = n / r; let u = !1; (i < 0.5 || i > 2) && (i = i < 0.5 ? 0.5 : 2, u = !0), (a < 0.5 || a > 2) && (a = a < 0.5 ? 0.5 : 2, u = !0); const c = (function l(u, c, s) { return new hw((t) => { const e = mw.getWidth(u); const n = mw.getHeight(u); const o = Math.floor(e * c); const r = Math.floor(n * s); const i = dw.create(o, r); const a = dw.get2dContext(i); a.drawImage(u, 0, 0, e, n, 0, 0, o, r), t(i) }) }(t, i, a)); return u ? c.then((t) => BV(t, e, n)) : c } }; const Rw = { rotate: function DV(e, n) { return e.toCanvas().then((t) => (function u(t, e, n) { const o = dw.create(t.width, t.height); const r = dw.get2dContext(o); let i = 0; let a = 0; return (n = n < 0 ? 360 + n : n) != 90 && n != 270 || dw.resize(o, o.height, o.width), n != 90 && n != 180 || (i = o.width), n != 270 && n != 180 || (a = o.height), r.translate(i, a), r.rotate(n * Math.PI / 180), r.drawImage(t, 0, 0), Cw.fromCanvas(o, e) }(t, e.getType(), n))) }, flip: function _V(e, n) { return e.toCanvas().then((t) => (function i(t, e, n) { const o = dw.create(t.width, t.height); const r = dw.get2dContext(o); return n == 'v' ? (r.scale(1, -1), r.drawImage(t, 0, -o.height)) : (r.scale(-1, 1), r.drawImage(t, -o.width, 0)), Cw.fromCanvas(o, e) }(t, e.getType(), n))) }, crop: function FV(e, n, o, r, i) { return e.toCanvas().then((t) => (function u(t, e, n, o, r, i) { const a = dw.create(r, i); return dw.get2dContext(a).drawImage(t, -n, -o), Cw.fromCanvas(a, e) }(t, e.getType(), n, o, r, i))) }, resize: function LV(e, n, o) { return e.toCanvas().then((t) => Iw.scale(t, n, o).then((t) => Cw.fromCanvas(t, e.getType()))) } }; const Nw = ((function () { function t(t) { this.littleEndian = !1, this._dv = new DataView(t) }t.prototype.readByteAt = function (t) { return this._dv.getUint8(t) }, t.prototype.read = function (t, e) { if (t + e > this.length()) return null; for (var n = this.littleEndian ? 0 : -8 * (e - 1), o = 0, r = 0; o < e; o++)r |= this.readByteAt(t + o) << Math.abs(n + 8 * o); return r }, t.prototype.BYTE = function (t) { return this.read(t, 1) }, t.prototype.SHORT = function (t) { return this.read(t, 2) }, t.prototype.LONG = function (t) { return this.read(t, 4) }, t.prototype.SLONG = function (t) { const e = this.read(t, 4); return e > 2147483647 ? e - 4294967296 : e }, t.prototype.CHAR = function (t) { return String.fromCharCode(this.read(t, 1)) }, t.prototype.STRING = function (t, e) { return this.asArray('CHAR', t, e).join('') }, t.prototype.SEGMENT = function (t, e) { const n = this._dv.buffer; switch (arguments.length) { case 2:return n.slice(t, t + e); case 1:return n.slice(t); default:return n } }, t.prototype.asArray = function (t, e, n) { for (var o = [], r = 0; r < n; r++)o[r] = this[t](e + r); return o }, t.prototype.length = function () { return this._dv ? this._dv.byteLength : 0 } }()), function (t, e) { return Rw.rotate(t, e) }); const Pw = function (t) { return Lw.invert(t) }; const jw = function (t) { return Lw.sharpen(t) }; const Uw = function (t, e) { return Lw.brightness(t, e) }; const Ww = function (t, e) { return Lw.contrast(t, e) }; const Gw = function (t, e, n, o) { return Lw.colorize(t, e, n, o) }; const Xw = function (t, e) { return Lw.gamma(t, e) }; const Yw = function (t, e) { return Rw.flip(t, e) }; const qw = function (t, e, n, o, r) { return Rw.crop(t, e, n, o, r) }; const Kw = function (t, e, n) { return Rw.resize(t, e, n) }; const Jw = Nw; const $w = function (t, e) { return { dom: { tag: 'span', innerHtml: Qm(t, e), classes: ['tox-icon', 'tox-tbtn__icon-wrap'] } } }; const Qw = function (t, e, n) { return { dom: { tag: 'span', innerHtml: n.translate(t), classes: [`${e}__select-label`] }, behaviours: _a([Yd.config({})]) } }; const Zw = function (t, e, n, o, r) { void 0 === n && (n = []); const i = { buttonBehaviours: _a([ig(t.disabled), Xp.config({}), Am('button press', [Ur('click'), Ur('mousedown')])].concat(n)), eventOrder: { click: ['button press', 'alloy.base.behaviour'], mousedown: ['button press', 'alloy.base.behaviour'] }, action: e }; const a = gt(i, { dom: o }); const u = gt(a, { components: r }); return qm.sketch(u) }; const tz = function (t, e, n, o) { void 0 === o && (o = []); const r = { tag: 'button', classes: ['tox-tbtn'], attributes: t.tooltip.map((t) => ({ 'aria-label': n.translate(t), title: n.translate(t) })).getOr({}) }; const i = t.icon.map((t) => $w(t, n.icons)); const a = hg([i]); return Zw(t, e, o, r, a) }; const ez = function (t, e, n, o) { void 0 === o && (o = []); const r = n.translate(t.text); const i = t.icon ? t.icon.map((t) => $w(t, n.icons)) : P.none(); const a = i.isSome() ? hg([i]) : []; const u = i.isSome() ? {} : { innerHtml: r }; const c = (t.primary ? ['tox-button'] : ['tox-button', 'tox-button--secondary']).concat(i.isSome() ? ['tox-button--icon'] : []); const s = Gn({ tag: 'button', classes: c }, u, { attributes: { title: r } }); return Zw(t, e, o, s, a) }; const nz = function (e, n) { return function (t) { n === 'custom' ? Cr(t, Ev, { name: e, value: {} }) : n === 'submit' ? kr(t, Av) : n === 'cancel' ? kr(t, Vv) : console.error('Unknown button type: ', n) } }; const oz = function (t, e, n) { const o = nz(t.name, e); return ez(t, o, n, []) }; const rz = U([dr('field1Name', 'field1'), dr('field2Name', 'field2'), Ca('onLockedChange'), wa(['lockClass']), dr('locked', !1), Bs('coupledFieldBehaviours', [Ll, am])]); const iz = function (t, i) { return rl({ factory: Iv, name: t, overrides(r) { return { fieldBehaviours: _a([Am('coupled-input-behaviour', [Wr(Nt(), (n) => { let t, e, o; (t = n, e = r, o = i, bl(t, e, o).bind(Ll.getCurrent)).each((e) => { bl(n, r, 'lock').each((t) => { km.isOn(t) && r.onLockedChange(n, e, t) }) }) })])]) } } }) }; const az = U([iz('field1', 'field2'), iz('field2', 'field1'), rl({ factory: qm, schema: [Zo('dom')], name: 'lock', overrides(t) { return { buttonBehaviours: _a([km.config({ selected: t.locked, toggleClass: t.markers.lockClass, aria: { mode: 'pressed' } })]) } } })]); const uz = Bl({ name: 'FormCoupledInputs', configFields: rz(), partFields: az(), factory(o, t, e, n) { return { uid: o.uid, dom: o.dom, components: t, behaviours: Ds(o.coupledFieldBehaviours, [Ll.config({ find: P.some }), am.config({ store: { mode: 'manual', getValue(t) { let e; const n = Sl(t, o, ['field1', 'field2']); return (e = {})[o.field1Name] = am.getValue(n.field1()), e[o.field2Name] = am.getValue(n.field2()), e }, setValue(t, e) { const n = Sl(t, o, ['field1', 'field2']); kt(e, o.field1Name) && am.setValue(n.field1(), e[o.field1Name]), kt(e, o.field2Name) && am.setValue(n.field2(), e[o.field2Name]) } } })]), apis: { getField1(t) { return bl(t, o, 'field1') }, getField2(t) { return bl(t, o, 'field2') }, getLock(t) { return bl(t, o, 'lock') } } } }, apis: { getField1(t, e) { return t.getField1(e) }, getField2(t, e) { return t.getField2(e) }, getLock(t, e) { return t.getLock(e) } } }); const cz = function (t) { const e = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t); if (e === null) return ft.error(t); const n = parseFloat(e[1]); const o = e[2]; return ft.value({ value: n, unit: o }) }; const sz = function (t, e) { const n = { '': 96, px: 96, pt: 72, cm: 2.54, pc: 12, mm: 25.4, in: 1 }; const o = function (t) { return Object.prototype.hasOwnProperty.call(n, t) }; return t.unit === e ? P.some(t.value) : o(t.unit) && o(e) ? n[t.unit] === n[e] ? P.some(t.value) : P.some(t.value / n[t.unit] * n[e]) : P.none() }; const lz = function (t) { return P.none() }; const fz = function (t, e) { return (function (t, e) { for (var n = [], o = 0; o < t.length; o++) { const r = t[o]; if (!r.isSome()) return P.none(); n.push(r.getOrDie()) } return P.some(e.apply(null, n)) }([cz(t).toOption(), cz(e).toOption()], (t, o) => sz(t, o.unit).map((t) => o.value / t).map((t) => { return e = t, n = o.unit, function (t) { return sz(t, n).map((t) => ({ value: t * e, unit: n })) }; let e, n }).getOr(lz))).getOr(lz) }; const dz = function (o, e) { let u = lz; const r = Un('ratio-event'); const t = uz.parts().lock({ dom: { tag: 'button', classes: ['tox-lock', 'tox-button', 'tox-button--naked', 'tox-button--icon'], attributes: { title: e.translate(o.label.getOr('Constrain proportions')) } }, components: [{ dom: { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__lock'], innerHtml: Qm('lock', e.icons) } }, { dom: { tag: 'span', classes: ['tox-icon', 'tox-lock-icon__unlock'], innerHtml: Qm('unlock', e.icons) } }], buttonBehaviours: _a([Xp.config({})]) }); const n = function (t) { return { dom: { tag: 'div', classes: ['tox-form__group'] }, components: t } }; const i = function (n) { return Iv.parts().field({ factory: Vp, inputClasses: ['tox-textfield'], inputBehaviours: _a([Xp.config({}), Am('size-input-events', [Wr(Ft(), (t, e) => { Cr(t, r, { isField1: n }) }), Wr(Pt(), (t, e) => { Cr(t, Mv, { name: o.name }) })])]), selectOnFocus: !1 }) }; const a = function (t) { return Iv.parts().label({ dom: { tag: 'label', classes: ['tox-label'], innerHtml: e.translate(t) } }) }; const c = uz.parts().field1(n([a('Width'), i(!0)])); const s = function (t) { return { dom: { tag: 'div', classes: ['tox-form__controls-h-stack'] }, components: t } }; const l = uz.parts().field2(n([a('Height'), s([i(!1), t])])); return uz.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: [s([c, l])], field1Name: 'width', field2Name: 'height', locked: !0, markers: { lockClass: 'tox-locked' }, onLockedChange(t, i, e) { cz(am.getValue(t)).each((t) => { u(t).each((t) => { let e, n, o, r; am.setValue(i, (o = { '': 0, px: 0, pt: 1, mm: 1, pc: 2, ex: 2, em: 2, ch: 2, rem: 2, cm: 3, in: 4, '%': 4 }, (r = (e = t).value.toFixed((n = e.unit) in o ? o[n] : 1)).indexOf('.') !== -1 && (r = r.replace(/\.?0*$/, '')), r + e.unit)) }) }) }, coupledFieldBehaviours: _a([Am('size-input-events2', [Wr(r, (t, e) => { const n = e.event().isField1(); const o = n ? uz.getField1(t) : uz.getField2(t); const r = n ? uz.getField2(t) : uz.getField1(t); const i = o.map(am.getValue).getOr(''); const a = r.map(am.getValue).getOr(''); u = fz(i, a) })])]) }) }; const mz = { undo: U(Un('undo')), redo: U(Un('redo')), zoom: U(Un('zoom')), back: U(Un('back')), apply: U(Un('apply')), swap: U(Un('swap')), transform: U(Un('transform')), tempTransform: U(Un('temp-transform')), transformApply: U(Un('transform-apply')) }; const hz = U('save-state'); const gz = U('disable'); const vz = U('enable'); const pz = { formActionEvent: Ev, saveState: hz, disable: gz, enable: vz }; const bz = function (r, c) { const t = function (t, e, n, o) { return ez({ name: t, text: t, disabled: n, primary: o }, e, c) }; const e = function (t, e, n, o) { return tz({ name: t, icon: P.some(t), tooltip: P.some(e), disabled: o }, n, c) }; const l = { tag: 'div', classes: ['tox-image-tools__toolbar', 'tox-image-tools-edit-panel'] }; const n = P.none(); const o = N; const i = function (t, e, n) { Cr(t, e, n) }; const f = function (t, e) { i(t, mz.transform(), { transform: e }) }; const a = function (t, e) { i(t, mz.tempTransform(), { transform: e }) }; const u = function (t) { return function () { R.getOpt(t).each((t) => { Yd.set(t, [L]) }) } }; const s = function (t, e) { i(t, mz.transformApply(), { transform: e, swap: u(t) }) }; const d = function () { return t('Back', (t) => i(t, mz.back(), { swap: u(t) }), !1, !1) }; const m = function () { return t('Apply', (t) => i(t, mz.apply(), { swap: u(t) }), !0, !0) }; const h = xv.sketch({ dom: l, components: [d(), { dom: { tag: 'div', classes: ['tox-spacer'] } }, t('Apply', (t) => { s(t, (t) => { const e = r.getRect(); return qw(t, e.x, e.y, e.w, e.h) }), r.hideCrop() }, !1, !0)] }); const g = Km(dz({ name: 'size', label: n, colspan: n, type: 'sizeinput', constrain: !0 }, c)); const v = xv.sketch({ dom: l, components: [d(), { dom: { tag: 'div', classes: ['tox-spacer'] } }, g.asSpec(), { dom: { tag: 'div', classes: ['tox-spacer'] } }, t('Apply', (u) => { g.getOpt(u).each((t) => { let e; let n; const o = am.getValue(t); const r = parseInt(o.width, 10); const i = parseInt(o.height, 10); const a = (e = r, n = i, function (t) { return Kw(t, e, n) }); s(u, a) }) }, !1, !0)] }); const p = function (e, n) { return function (t) { return e(t, n) } }; const b = p(Yw, 'h'); const y = p(Yw, 'v'); const x = p(Jw, -90); const w = p(Jw, 90); const z = xv.sketch({ dom: l, components: [d(), { dom: { tag: 'div', classes: ['tox-spacer'] } }, e('flip-horizontally', 'Flip horizontally', (t) => { a(t, b) }, !1), e('flip-vertically', 'Flip vertically', (t) => { a(t, y) }, !1), e('rotate-left', 'Rotate counterclockwise', (t) => { a(t, x) }, !1), e('rotate-right', 'Rotate clockwise', (t) => { a(t, w) }, !1), { dom: { tag: 'div', classes: ['tox-spacer'] } }, m()] }); const S = function (t, e, n, o, r) { const i = kx.parts().label({ dom: { tag: 'label', innerHtml: c.translate(t) } }); const a = kx.parts().spectrum({ dom: { tag: 'div', classes: ['tox-slider__rail'], attributes: { role: 'presentation' } } }); const u = kx.parts().thumb({ dom: { tag: 'div', classes: ['tox-slider__handle'], attributes: { role: 'presentation' } } }); return kx.sketch({ dom: { tag: 'div', classes: ['tox-slider'], attributes: { role: 'presentation' } }, model: { mode: 'x', minX: n, maxX: r, getInitialValue: U({ x: U(o) }) }, components: [i, a, u], sliderBehaviours: _a([fm.config({})]), onChoose: e }) }; const k = function (t, e, n, o, r) { return xv.sketch({ dom: l, components: [d(), (i = t, a = e, u = n, c = o, s = r, S(i, (t, e, n) => { const o = p(a, n.x() / 100); f(t, o) }, u, c, s)), m()] }); let i, a, u, c, s }; const C = xv.sketch({ dom: l, components: [d(), { dom: { tag: 'div', classes: ['tox-spacer'] } }, m()] }); const O = k('Brightness', Uw, -100, 0, 100); const M = k('Contrast', Ww, -100, 0, 100); const H = k('Gamma', Xw, -100, 0, 100); const V = function (t) { return S(t, (l, t, e) => { const n = E.getOpt(l); const o = T.getOpt(l); const r = A.getOpt(l); n.each((s) => { o.each((c) => { r.each((t) => { let e; let n; let o; const r = am.getValue(s).x() / 100; const i = am.getValue(t).x() / 100; const a = am.getValue(c).x() / 100; const u = (e = r, n = i, o = a, function (t) { return Gw(t, e, n, o) }); f(l, u) }) }) }) }, 0, 100, 200) }; var E = Km(V('R')); var A = Km(V('G')); var T = Km(V('B')); const B = xv.sketch({ dom: l, components: [d(), E.asSpec(), A.asSpec(), T.asSpec(), m()] }); const D = function (e, n, o) { return function (t) { i(t, mz.swap(), { transform: n, swap() { R.getOpt(t).each((t) => { Yd.set(t, [e]), o(t) }) } }) } }; const _ = P.some(jw); const F = P.some(Pw); var L = xv.sketch({ dom: l, components: [e('crop', 'Crop', D(h, n, (t) => { r.showCrop() }), !1), e('resize', 'Resize', D(v, n, (t) => { g.getOpt(t).each((t) => { const e = r.getMeasurements(); const n = e.width; const o = e.height; am.setValue(t, { width: n, height: o }) }) }), !1), e('orientation', 'Orientation', D(z, n, o), !1), e('brightness', 'Brightness', D(O, n, o), !1), e('sharpen', 'Sharpen', D(C, _, o), !1), e('contrast', 'Contrast', D(M, n, o), !1), e('color-levels', 'Color levels', D(B, n, o), !1), e('gamma', 'Gamma', D(H, n, o), !1), e('invert', 'Invert', D(C, F, o), !1)] }); const I = xv.sketch({ dom: { tag: 'div' }, components: [L], containerBehaviours: _a([Yd.config({})]) }); var R = Km(I); return { memContainer: R, getApplyButton(t) { return R.getOpt(t).map((t) => { const e = t.components()[0]; return e.components()[e.components().length - 1] }) } } }; const yz = tinymce.util.Tools.resolve('tinymce.dom.DomQuery'); const xz = tinymce.util.Tools.resolve('tinymce.geom.Rect'); const wz = tinymce.util.Tools.resolve('tinymce.util.Observable'); const zz = tinymce.util.Tools.resolve('tinymce.util.Tools'); const Sz = tinymce.util.Tools.resolve('tinymce.util.VK'); function kz(t) { let e, n; if (t.changedTouches) for (e = 'screenX screenY pageX pageY clientX clientY'.split(' '), n = 0; n < e.length; n++)t[e[n]] = t.changedTouches[0][e[n]] } function Cz(t, r) { let i; let a; let e; let u; let c; let l; let f; const d = r.document || document; r = r || {}; const m = d.getElementById(r.handle || t); e = function (t) { let e; let n; const o = (function s(t) { let e; let n; let o; let r; let i; let a; let u; const c = Math.max; return e = t.documentElement, n = t.body, o = c(e.scrollWidth, n.scrollWidth), r = c(e.clientWidth, n.clientWidth), i = c(e.offsetWidth, n.offsetWidth), a = c(e.scrollHeight, n.scrollHeight), u = c(e.clientHeight, n.clientHeight), { width: o < i ? r : o, height: a < c(e.offsetHeight, n.offsetHeight) ? u : a } }(d)); kz(t), t.preventDefault(), a = t.button, e = m, l = t.screenX, f = t.screenY, n = window.getComputedStyle ? window.getComputedStyle(e, null).getPropertyValue('cursor') : e.runtimeStyle.cursor, i = yz('<div></div>').css({ position: 'absolute', top: 0, left: 0, width: o.width, height: o.height, zIndex: 2147483647, opacity: 1e-4, cursor: n }).appendTo(d.body), yz(d).on('mousemove touchmove', c).on('mouseup touchend', u), r.start(t) }, c = function (t) { if (kz(t), t.button !== a) return u(t); t.deltaX = t.screenX - l, t.deltaY = t.screenY - f, t.preventDefault(), r.drag(t) }, u = function (t) { kz(t), yz(d).off('mousemove touchmove', c).off('mouseup touchend', u), i.remove(), r.stop && r.stop(t) }, this.destroy = function () { yz(m).off() }, yz(m).on('mousedown touchstart', e) } let Oz; let Mz; let Hz; let Vz = 0; const Ez = function (e) { const l = Km({ dom: { tag: 'div', classes: ['tox-image-tools__image-bg'], attributes: { role: 'presentation' } } }); const f = Ct(1); const d = Ct(P.none()); const m = Ct({ x: 0, y: 0, w: 1, h: 1 }); const c = Ct({ x: 0, y: 0, w: 1, h: 1 }); const s = function (t, s) { h.getOpt(t).each((t) => { const n = f.get(); const o = eu(t.element()); const r = ru(t.element()); const i = s.dom().naturalWidth * n; const a = s.dom().naturalHeight * n; const u = Math.max(0, o / 2 - i / 2); const c = Math.max(0, r / 2 - a / 2); const e = { left: `${u.toString()}px`, top: `${c.toString()}px`, width: `${i.toString()}px`, height: `${a.toString()}px`, position: 'absolute' }; Gi(s, e), l.getOpt(t).each((t) => { Gi(t.element(), e) }), d.get().each((t) => { const e = m.get(); t.setRect({ x: e.x * n + u, y: e.y * n + c, w: e.w * n, h: e.h * n }), t.setClampRect({ x: u, y: c, w: i, h: a }), t.setViewPortRect({ x: 0, y: 0, w: o, h: r }) }) }) }; const n = function (t, e) { let n; const u = Ne.fromTag('img'); return Cn(u, 'src', e), (n = u.dom(), new lh((t) => { var e = function () { n.removeEventListener('load', e), t(n) }; n.complete ? t(n) : n.addEventListener('load', e) })).then(() => h.getOpt(t).map((t) => { const e = ua({ element: u }); Yd.replaceAt(t, 1, P.some(e)); const n = c.get(); const o = { x: 0, y: 0, w: u.dom().naturalWidth, h: u.dom().naturalHeight }; c.set(o); let r; let a; const i = xz.inflate(o, -20, -20); return m.set(i), n.w === o.w && n.h === o.h || (r = t, a = u, h.getOpt(r).each((t) => { const e = eu(t.element()); const n = ru(t.element()); const o = a.dom().naturalWidth; const r = a.dom().naturalHeight; const i = Math.min(e / o, n / r); i >= 1 ? f.set(1) : f.set(i) })), s(t, u), u })) }; const t = xv.sketch({ dom: { tag: 'div', classes: ['tox-image-tools__image'] }, components: [l.asSpec(), { dom: { tag: 'img', attributes: { src: e } } }, { dom: { tag: 'div' }, behaviours: _a([Am('image-panel-crop-events', [Qr((t) => { h.getOpt(t).each((t) => { const e = (function z(s, n, l, o, r) { let f; let a; let e; let i; const u = 'tox-'; const c = `tox-crid-${Vz++}`; function d(t, e) { return { x: e.x - t.x, y: e.y - t.y, w: e.w, h: e.h } } function m(t, e, n, o) { let r, i, a, u, c; r = e.x, i = e.y, a = e.w, u = e.h, r += n * t.deltaX, i += o * t.deltaY, (a += n * t.deltaW) < 20 && (a = 20), (u += o * t.deltaH) < 20 && (u = 20), c = s = xz.clamp({ x: r, y: i, w: a, h: u }, l, t.name === 'move'), c = d(l, c), f.fire('updateRect', { rect: c }), v(c) } function h(e) { function t(t, e) { e.h < 0 && (e.h = 0), e.w < 0 && (e.w = 0), yz(`#${c}-${t}`, o).css({ left: e.x, top: e.y, width: e.w, height: e.h }) }zz.each(a, (t) => { yz(`#${c}-${t.name}`, o).css({ left: e.w * t.xMul + e.x, top: e.h * t.yMul + e.y }) }), t('top', { x: n.x, y: n.y, w: n.w, h: e.y - n.y }), t('right', { x: e.x + e.w, y: e.y, w: n.w - e.x - e.w + n.x, h: e.h }), t('bottom', { x: n.x, y: e.y + e.h, w: n.w, h: n.h - e.y - e.h + n.y }), t('left', { x: n.x, y: e.y, w: e.x - n.x, h: e.h }), t('move', e) } function g(t) { h(s = t) } function v(t) { g(function n(t, e) { return { x: e.x + t.x, y: e.y + t.y, w: e.w, h: e.h } }(l, t)) } return a = [{ name: 'move', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: 0, deltaH: 0, label: 'Crop Mask' }, { name: 'nw', xMul: 0, yMul: 0, deltaX: 1, deltaY: 1, deltaW: -1, deltaH: -1, label: 'Top Left Crop Handle' }, { name: 'ne', xMul: 1, yMul: 0, deltaX: 0, deltaY: 1, deltaW: 1, deltaH: -1, label: 'Top Right Crop Handle' }, { name: 'sw', xMul: 0, yMul: 1, deltaX: 1, deltaY: 0, deltaW: -1, deltaH: 1, label: 'Bottom Left Crop Handle' }, { name: 'se', xMul: 1, yMul: 1, deltaX: 0, deltaY: 0, deltaW: 1, deltaH: 1, label: 'Bottom Right Crop Handle' }], i = ['top', 'right', 'bottom', 'left'], (function p() { yz(`<div id="${c}" class="${u}croprect-container" role="grid" aria-dropeffect="execute">`).appendTo(o), zz.each(i, (t) => { yz(`#${c}`, o).append(`<div id="${c}-${t}"class="${u}croprect-block" style="display: none" data-mce-bogus="all">`) }), zz.each(a, (t) => { yz(`#${c}`, o).append(`<div id="${c}-${t.name}" class="${u}croprect-handle ${u}croprect-handle-${t.name}"style="display: none" data-mce-bogus="all" role="gridcell" tabindex="-1" aria-label="${t.label}" aria-grabbed="false" title="${t.label}">`) }), e = zz.map(a, (e) => { let n; return new Cz(c, { document: o.ownerDocument, handle: `${c}-${e.name}`, start() { n = s }, drag(t) { m(e, n, t.deltaX, t.deltaY) } }) }), h(s), yz(o).on('focusin focusout', (t) => { yz(t.target).attr('aria-grabbed', t.type === 'focus') }), yz(o).on('keydown', (e) => { let i; function t(t, e, n, o, r) { t.stopPropagation(), t.preventDefault(), m(i, n, o, r) } switch (zz.each(a, (t) => { if (e.target.id === `${c}-${t.name}`) return i = t, !1 }), e.keyCode) { case Sz.LEFT:t(e, 0, s, -10, 0); break; case Sz.RIGHT:t(e, 0, s, 10, 0); break; case Sz.UP:t(e, 0, s, 0, -10); break; case Sz.DOWN:t(e, 0, s, 0, 10); break; case Sz.ENTER:case Sz.SPACEBAR:e.preventDefault(), r() } }) }()), f = zz.extend({ toggleVisibility: function b(t) { let e; e = zz.map(a, (t) => `#${c}-${t.name}`).concat(zz.map(i, (t) => `#${c}-${t}`)).join(','), t ? yz(e, o).show() : yz(e, o).hide() }, setClampRect: function y(t) { l = t, h(s) }, setRect: g, getInnerRect: function t() { return d(l, s) }, setInnerRect: v, setViewPortRect: function x(t) { n = t, h(s) }, destroy: function w() { zz.each(e, (t) => { t.destroy() }), e = [] } }, wz) }({ x: 10, y: 10, w: 100, h: 100 }, { x: 0, y: 0, w: 200, h: 200 }, { x: 0, y: 0, w: 200, h: 200 }, t.element().dom(), () => {})); e.toggleVisibility(!1), e.on('updateRect', (t) => { const e = t.rect; const n = f.get(); const o = { x: Math.round(e.x / n), y: Math.round(e.y / n), w: Math.round(e.w / n), h: Math.round(e.h / n) }; m.set(o) }), d.set(P.some(e)) }) })])]) }], containerBehaviours: _a([Yd.config({}), Am('image-panel-events', [Qr((t) => { n(t, e) })])]) }); var h = Km(t); return { memContainer: h, updateSrc: n, zoom(t, e) { const n = f.get(); const o = e > 0 ? Math.min(2, n + 0.1) : Math.max(0.1, n - 0.1); f.set(o), h.getOpt(t).each((t) => { const e = t.components()[1].element(); s(t, e) }) }, showCrop() { d.get().each((t) => { t.toggleVisibility(!0) }) }, hideCrop() { d.get().each((t) => { t.toggleVisibility(!1) }) }, getRect() { return m.get() }, getMeasurements() { const t = c.get(); return { width: t.w, height: t.h } } } }; const Az = function (t, e, n, o, r) { return tz({ name: t, icon: P.some(e), disabled: n, tooltip: P.some(t) }, o, r) }; const Tz = function (t, e) { e ? og.enable(t) : og.disable(t) }; const Bz = function () { return Ye.getOrDie('URL') }; const Dz = function (t) { return Bz().createObjectURL(t) }; const _z = function (t) { Bz().revokeObjectURL(t) }; const Fz = function (t) { const e = Ct(t); const n = Ct(P.none()); const r = (function s() { const n = []; let o = -1; function t() { return o > 0 } function e() { return o !== -1 && o < n.length - 1 } return { data: n, add: function r(t) { let e; return e = n.splice(++o), n.push(t), { state: t, removed: e } }, undo: function i() { if (t()) return n[--o] }, redo: function a() { if (e()) return n[++o] }, canUndo: t, canRedo: e } }()); r.add(t); const i = function (t) { e.set(t) }; const a = function (t) { return { blob: t, url: Dz(t) } }; const u = function (t) { _z(t.url) }; const o = function () { n.get().each(u), n.set(P.none()) }; const c = function (t) { const e = a(t); i(e); let n; const o = r.add(e).removed; return n = o, zz.each(n, u), e.url }; return { getBlobState() { return e.get() }, setBlobState: i, addBlobState: c, getTempState() { return n.get().fold(() => e.get(), (t) => t) }, updateTempState(t) { const e = a(t); return o(), n.set(P.some(e)), e.url }, addTempState(t) { const e = a(t); return n.set(P.some(e)), e.url }, applyTempState(e) { return n.get().fold(() => {}, (t) => { c(t.blob), e() }) }, destroyTempState: o, undo() { const t = r.undo(); return i(t), t.url }, redo() { const t = r.redo(); return i(t), t.url }, getHistoryStates() { return { undoEnabled: r.canUndo(), redoEnabled: r.canRedo() } } } }; const Lz = function (t, e) { let n; let o; let r; const a = Fz(t.currentState); const i = function (t) { const e = a.getHistoryStates(); g.updateButtonUndoStates(t, e.undoEnabled, e.redoEnabled), Cr(t, pz.formActionEvent, { name: pz.saveState(), value: e.undoEnabled }) }; const u = function (t) { return t.toBlob() }; const c = function (t) { Cr(t, pz.formActionEvent, { name: pz.disable(), value: {} }) }; const s = function (t) { v.getApplyButton(t).each((t) => { og.enable(t) }), Cr(t, pz.formActionEvent, { name: pz.enable(), value: {} }) }; const l = function (t, e) { return c(t), h.updateSrc(t, e) }; const f = function (e, t, n, o, r) { return c(e), Ow(t).then(n).then(u).then(o).then((t) => l(e, t).then((t) => i(e), r(), s(e), t)).catch((t) => { console.log(t), s(e) }) }; const d = function (t, e, n) { const o = a.getBlobState().blob; f(t, o, e, (t) => a.updateTempState(t), n) }; const m = function (t) { const e = a.getBlobState().url; return a.destroyTempState(), i(t), e }; var h = Ez(t.currentState.url); var g = (o = Km(Az('Undo', 'undo', !0, (t) => { Cr(t, mz.undo(), { direction: 1 }) }, n = e)), r = Km(Az('Redo', 'redo', !0, (t) => { Cr(t, mz.redo(), { direction: 1 }) }, n)), { container: xv.sketch({ dom: { tag: 'div', classes: ['tox-image-tools__toolbar', 'tox-image-tools__sidebar'] }, components: [o.asSpec(), r.asSpec(), Az('Zoom in', 'zoom-in', !1, (t) => { Cr(t, mz.zoom(), { direction: 1 }) }, n), Az('Zoom out', 'zoom-out', !1, (t) => { Cr(t, mz.zoom(), { direction: -1 }) }, n)] }), updateButtonUndoStates(t, e, n) { o.getOpt(t).each((t) => { Tz(t, e) }), r.getOpt(t).each((t) => { Tz(t, n) }) } }); var v = bz(h, e); return { dom: { tag: 'div', attributes: { role: 'presentation' } }, components: [v.memContainer.asSpec(), h.memContainer.asSpec(), g.container], behaviours: _a([am.config({ store: { mode: 'manual', getValue() { return a.getBlobState() } } }), Am('image-tools-events', [Wr(mz.undo(), (e, t) => { const n = a.undo(); l(e, n).then((t) => { s(e), i(e) }) }), Wr(mz.redo(), (e, t) => { const n = a.redo(); l(e, n).then((t) => { s(e), i(e) }) }), Wr(mz.zoom(), (t, e) => { const n = e.event().direction(); h.zoom(t, n) }), Wr(mz.back(), (t, e) => { let n, o; o = m(n = t), l(n, o).then((t) => { s(n) }), e.event().swap()(), h.hideCrop() }), Wr(mz.apply(), (t, e) => { a.applyTempState(() => { m(t), e.event().swap()() }) }), Wr(mz.transform(), (t, e) => d(t, e.event().transform(), N)), Wr(mz.tempTransform(), (t, e) => { return n = t, o = e.event().transform(), r = a.getTempState().blob, void f(n, r, o, (t) => a.addTempState(t), N); let n, o, r }), Wr(mz.transformApply(), (t, e) => { return n = t, o = e.event().transform(), r = e.event().swap(), i = a.getBlobState().blob, void f(n, i, o, (t) => { const e = a.addBlobState(t); return m(n), e }, r); let n, o, r, i }), Wr(mz.swap(), (e, t) => { let n; n = e, g.updateButtonUndoStates(n, !1, !1); const o = t.event().transform(); const r = t.event().swap(); o.fold(() => { r() }, (t) => { d(e, t, r) }) })]), Px()]) } }; const Iz = Tl({ name: 'HtmlSelect', configFields: [Zo('options'), Es('selectBehaviours', [fm, am]), dr('selectClasses', []), dr('selectAttributes', {}), ur('data')], factory(n, t) { const e = E(n.options, (t) => ({ dom: { tag: 'option', value: t.value, innerHtml: t.text } })); const o = n.data.map((t) => wt('initialValue', t)).getOr({}); return { uid: n.uid, dom: { tag: 'select', classes: n.selectClasses, attributes: n.selectAttributes }, components: e, behaviours: Ts(n.selectBehaviours, [fm.config({}), am.config({ store: Gn({ mode: 'manual', getValue(t) { return Qi(t.element()) }, setValue(t, e) { _(n.options, (t) => t.value === e).isSome() && Zi(t.element(), e) } }, o) })]) } } }); const Rz = function (n, e) { const t = n.label.map((t) => zp(t, e)); const o = [jd.config({ mode: 'execution', useEnter: !0 !== n.multiline, useControlEnter: !0 === n.multiline, execute(t) { return kr(t, Av), P.some(!0) } }), Am('textfield-change', [Wr(Nt(), (t, e) => { Cr(t, Mv, { name: n.name }) }), Wr(Gt(), (t, e) => { Cr(t, Mv, { name: n.name }) })]), Xp.config({})]; const r = n.validation.map((o) => Up.config({ getRoot(t) { return an(t.element()) }, invalidClass: 'tox-invalid', validator: { validate(t) { const e = am.getValue(t); const n = o.validator(e); return Jv.pure(!0 === n ? ft.value(e) : ft.error(n)) }, validateOnLoad: o.validateOnLoad } })).toArray(); const i = Iv.parts().field({ tag: !0 === n.multiline ? 'textarea' : 'input', inputAttributes: n.placeholder.fold(() => {}, (t) => ({ placeholder: e.translate(t) })), inputClasses: [n.classname], inputBehaviours: _a(R([o, r])), selectOnFocus: !1, factory: Vp }); const a = n.flex ? ['tox-form__group--stretched'] : []; return bp(t, i, a) }; var Nz = function (i) { return Gn({}, i, { toCached() { return Nz(i.toCached()) }, bindFuture(e) { return Nz(i.bind((t) => t.fold((t) => Jv.pure(ft.error(t)), (t) => e(t)))) }, bindResult(e) { return Nz(i.map((t) => t.bind(e))) }, mapResult(e) { return Nz(i.map((t) => t.map(e))) }, mapError(e) { return Nz(i.map((t) => t.mapError(e))) }, foldResult(e, n) { return i.map((t) => t.fold(e, n)) }, withTimeout(t, r) { return Nz(Jv.nu((e) => { let n = !1; const o = window.setTimeout(() => { n = !0, e(ft.error(r())) }, t); i.get((t) => { n || (window.clearTimeout(o), e(t)) }) })) } }) }; const Pz = function (t) { return Nz(Jv.nu(t)) }; const jz = Pz; const Uz = { type: 'separator' }; const Wz = function (t) { return { type: 'menuitem', value: t.url, text: t.title, meta: { attach: t.attach }, onAction() {} } }; const Gz = function (t, e) { return { type: 'menuitem', value: e, text: t, meta: { attach: N }, onAction() {} } }; const Xz = function (t, e) { return o = t, n = T(e, (t) => t.type === o), E(n, Wz); let n, o }; const Yz = function (t, e) { const n = t.toLowerCase(); return T(e, (t) => { const e = t.meta !== undefined && t.meta.text !== undefined ? t.meta.text : t.text; return fe(e.toLowerCase(), n) || fe(t.value.toLowerCase(), n) }) }; const qz = function (c, t, s) { const e = am.getValue(t); const l = e.meta.text !== undefined ? e.meta.text : e.value; return s.getLinkInformation().fold(() => [], (t) => { let e; let n; let o; let r; let i; let a; const u = Yz(l, (e = s.getHistory(c), E(e, (t) => Gz(t, t)))); return c === 'file' ? (n = [u, Yz(l, (a = t, Xz('header', a.targets))), Yz(l, R([(i = t, i.anchorTop.map((t) => Gz('<top>', t)).toArray()), (r = t, Xz('anchor', r.targets)), (o = t, o.anchorBottom.map((t) => Gz('<bottom>', t)).toArray())]))], D(n, (t, e) => t.length === 0 || e.length === 0 ? t.concat(e) : t.concat(Uz, e), [])) : u }) }; const Kz = function (i, a, o) { let t; const r = function (t) { const e = am.getValue(t); o.addToHistory(e.value, i.filetype) }; const e = Iv.parts().field({ factory: pp, dismissOnBlur: !0, inputClasses: ['tox-textfield'], sandboxClasses: ['tox-dialog__popups'], minChars: 0, responseTime: 0, fetch(t) { const e = qz(i.filetype, t, o); const n = Hp(e, dg.BUBBLE_TO_SANDBOX, a.providers); return Jv.pure(n) }, getHotspot(t) { return f.getOpt(t) }, onSetValue(t, e) { t.hasConfigured(Up) && Up.run(t).get(N) }, typeaheadBehaviours: _a(R([o.getValidationHandler().map((o) => Up.config({ getRoot(t) { return an(t.element()) }, invalidClass: 'tox-control-wrap--status-invalid', notify: {}, validator: { validate(e) { const n = am.getValue(e); return jz((t) => { o({ type: i.filetype, url: n.value }, (n) => { f.getOpt(e).each((t) => { const e = function (t, e, n) { (n ? _i : Li)(t.element(), e) }; e(t, 'tox-control-wrap--status-valid', n.status === 'valid'), e(t, 'tox-control-wrap--status-unknown', n.status === 'unknown') }), t((n.status === 'invalid' ? ft.error : ft.value)(n.message)) }) }) }, validateOnLoad: !1 } })).toArray(), [Xp.config({}), Am('urlinput-events', R([i.filetype === 'file' ? [Wr(Nt(), (t) => { Cr(t, Mv, { name: i.name }) })] : [], [Wr(Pt(), (t) => { Cr(t, Mv, { name: i.name }), r(t) }), Wr(Gt(), (t) => { Cr(t, Mv, { name: i.name }), r(t) })]]))]])), eventOrder: (t = {}, t[Nt()] = ['streaming', 'urlinput-events', 'invalidating'], t), model: { getDisplayText(t) { return t.value }, selectsOver: !1, populateFromBrowse: !1 }, markers: { openClass: 'dog' }, lazySink: a.getSink, parts: { menu: Dg(0, 0, 'normal') }, onExecute(t, e, n) { Cr(e, Av, {}) }, onItemExecute(t, e, n, o) { r(t), Cr(t, Mv, { name: i.name }) } }); const n = i.label.map((t) => zp(t, a.providers)); const u = function (t, e, n) { return void 0 === e && (e = t), void 0 === n && (n = t), { dom: { tag: 'div', classes: ['tox-icon', `tox-control-wrap__status-icon-${t}`], innerHtml: Qm(e, a.providers.icons), attributes: { title: a.providers.translate(n) } } } }; const c = Km({ dom: { tag: 'div', classes: ['tox-control-wrap__status-icon-wrap'] }, components: [u('valid', 'checkmark', 'valid'), u('unknown', 'warning'), u('invalid', 'warning')] }); const s = o.getUrlPicker(i.filetype); const l = Un('browser.url.event'); var f = Km({ dom: { tag: 'div', classes: ['tox-control-wrap'] }, components: [e, c.asSpec()] }); return Iv.sketch({ dom: wp([]), components: n.toArray().concat([{ dom: { tag: 'div', classes: ['tox-form__controls-h-stack'] }, components: R([[f.asSpec()], s.map(() => { return t = i.label, e = l, n = 'tox-browse-url', o = 'browse', r = a.providers, qm.sketch({ dom: { tag: 'button', classes: ['tox-tbtn', n], innerHtml: Qm(o, r.icons), attributes: { title: r.translate(t.getOr('')) } }, buttonBehaviours: _a([Xp.config({})]), action(t) { kr(t, e) } }); let t, e, n, o, r }).toArray()]) }]), fieldBehaviours: _a([Am('url-input-events', [Wr(l, (o) => { Ll.getCurrent(o).each((e) => { const n = am.getValue(e); s.each((t) => { t(n).get((t) => { am.setValue(e, t), Cr(o, Mv, { name: i.name }) }) }) }) })])]) }) }; const Jz = function (a, e) { let t; let n; const o = a.label.map((t) => zp(t, e)); const r = function (n) { return function (e, t) { ma(t.event().target(), '[data-collection-item-value]').each((t) => { n(e, t, Mn(t, 'data-collection-item-value')) }) } }; const i = [Wr(_t(), r((t, e) => { cf(e) })), Wr(jt(), r((t, e, n) => { Cr(t, Ev, { name: a.name, value: n }) })), Wr(Ft(), r((t, e, n) => { da(t.element(), `.${Dh}`).each((t) => { Li(t, Dh) }), _i(e, Dh) })), Wr(Lt(), r((t, e, n) => { da(t.element(), `.${Dh}`).each((t) => { Li(t, Dh) }) })), ei(r((t, e, n) => { Cr(t, Ev, { name: a.name, value: n }) }))]; const u = Iv.parts().field({ dom: { tag: 'div', classes: ['tox-collection'].concat(a.columns !== 1 ? ['tox-collection--grid'] : ['tox-collection--list']) }, components: [], factory: { sketch: d }, behaviours: _a([Yd.config({}), am.config({ store: { mode: 'memory', initialValue: [] }, onSetValue(o, t) { let e, n, r, i; e = o, n = E(t, (t) => { let e; const n = a.columns === 1 ? t.text.map((t) => `<span class="tox-collection__item-label">${t}</span>`).getOr('') : ''; const o = t.icon.map((t) => `<span class="tox-collection__item-icon">${t}</span>`).getOr(''); const r = { _: ' ', ' - ': ' ', '-': ' ' }; const i = t.text.getOr('').replace(/\_| \- |\-/g, (t) => r[t]); return `<div class="tox-collection__item" tabindex="-1" data-collection-item-value="${(e = t.value) === '"' ? '&quot;' : e}" title="${i}" aria-label="${i}">${o}${n}</div>` }), r = a.columns > 1 && a.columns !== 'auto' ? V(n, a.columns) : [n], i = E(r, (t) => `<div class="tox-collection__group">${t.join('')}</div>`), bn(e.element(), i.join('')), a.columns === 'auto' && kh(o, 5, 'tox-collection__item').each((t) => { const e = t.numRows; const n = t.numColumns; jd.setGridSize(o, e, n) }), kr(o, _v) } }), Xp.config({}), jd.config((t = a.columns, n = 'normal', t === 1 ? { mode: 'menu', moveOnTab: !1, selector: '.tox-collection__item' } : t === 'auto' ? { mode: 'flatgrid', selector: '.tox-collection__item', initSize: { numColumns: 1, numRows: 1 } } : { mode: 'matrix', selectors: { row: n === 'color' ? '.tox-swatches__row' : '.tox-collection__group', cell: n === 'color' ? `.${Vh}` : `.${Hh}` } })), Am('collection-events', i)]) }); return bp(o, u, ['tox-form__group--collection']) }; const $z = function (r) { return function (e, n, o) { return xt(n, 'name').fold(() => r(n, o), (t) => e.field(t, r(n, o))) } }; const Qz = { bar: $z((t, e) => { return n = t, o = e.shared, { dom: { tag: 'div', classes: ['tox-bar'] }, components: E(n.items, o.interpreter) }; let n, o }), collection: $z((t, e) => Jz(t, e.shared.providers)), alloy: $z(d), alertbanner: $z((t, e) => { return n = t, o = e.shared.providers, xv.sketch({ dom: { tag: 'div', attributes: { role: 'alert' }, classes: ['tox-notification', 'tox-notification--in', `tox-notification--${n.level}`] }, components: [{ dom: { tag: 'div', classes: ['tox-notification__body'], innerHtml: o.translate(n.text) } }, qm.sketch({ dom: { tag: 'button', classes: ['tox-notification__right-icon', 'tox-button', 'tox-button--naked', 'tox-button--icon'], innerHtml: Qm(n.icon, o.icons), attributes: { title: o.translate(n.actionLabel) } }, action(t) { Cr(t, Ev, { name: 'alert-banner', value: n.url }) } })] }); let n, o }), input: $z((t, e) => { return n = t, o = e.shared.providers, Rz({ name: n.name, multiline: !1, label: n.label, placeholder: n.placeholder, flex: !1, classname: 'tox-textfield', validation: P.none() }, o); let n, o }), textarea: $z((t, e) => { return n = t, o = e.shared.providers, Rz({ name: n.name, multiline: !0, label: n.label, placeholder: n.placeholder, flex: n.flex, classname: 'tox-textarea', validation: P.none() }, o); let n, o }), listbox: $z((t, e) => { return n = t, o = e.shared.providers, r = zp(n.label, o), i = Iv.parts().field({ factory: Iz, dom: { classes: ['mce-select-field'] }, selectBehaviours: _a([Xp.config({})]), options: n.values, data: n.initialValue.getOr(undefined) }), yp(P.some(r), i); let n, o, r, i }), label: $z((t, e) => { return n = t, o = e.shared, r = { dom: { tag: 'label', innerHtml: o.providers.translate(n.label), classes: ['tox-label'] } }, i = E(n.items, o.interpreter), { dom: { tag: 'div', classes: ['tox-form__group'] }, components: [r].concat(i), behaviours: _a([Px(), Yd.config({}), $x(P.none()), jd.config({ mode: 'acyclic' })]) }; let n, o, r, i }), iframe: (Oz = function (t, e) { return cw(t, e.shared.providers) }, function (t, e, n) { const o = gt(e, { source: 'dynamic' }); return $z(Oz)(t, o, n) }), autocomplete: $z((t, e) => { return r = t, i = e.shared, n = zp(r.label.getOr('?'), i.providers), o = Iv.parts().field({ factory: pp, dismissOnBlur: !1, inputClasses: ['tox-textfield'], minChars: 1, fetch(t) { const e = am.getValue(t); const n = r.getItems(e); const o = Hp(n, dg.BUBBLE_TO_SANDBOX, i.providers); return Jv.pure(o) }, markers: { openClass: 'dog' }, lazySink: i.getSink, parts: { menu: Dg(0, 0, 'normal') } }), yp(P.some(n), o); let r, i, n, o }), button: $z((t, e) => { return n = t, o = e.shared.providers, r = nz(n.name, 'custom'), ez(n, r, o, [Qx(''), Px()]); let n, o, r }), checkbox: $z((t, e) => { return n = t, o = e.shared.providers, r = am.config({ store: { mode: 'manual', getValue(t) { const e = t.element().dom(); return e.indeterminate ? 'indeterminate' : e.checked ? 'checked' : 'unchecked' }, setValue(t, e) { const n = t.element().dom(); switch (e) { case 'indeterminate':n.indeterminate = !0; break; case 'checked':n.checked = !0, n.indeterminate = !1; break; default:n.checked = !1, n.indeterminate = !1 } } } }), i = function (t) { return t.element().dom().click(), P.some(!0) }, a = Iv.parts().field({ factory: { sketch: d }, dom: { tag: 'input', classes: ['tox-checkbox__input'], attributes: { type: 'checkbox' } }, behaviours: _a([Px(), Xp.config({}), fm.config({}), r, jd.config({ mode: 'special', onEnter: i, onSpace: i }), Am('checkbox-events', [Wr(Pt(), (t, e) => { Cr(t, Mv, { name: n.name }) })])]) }), u = Iv.parts().label({ dom: { tag: 'span', classes: ['tox-checkbox__label'], innerHtml: o.translate(n.label) }, behaviours: _a([_b.config({})]) }), s = Km({ dom: { tag: 'div', classes: ['tox-checkbox__icons'] }, components: [(c = function (t) { return { dom: { tag: 'span', classes: ['tox-icon', `tox-checkbox-icon__${t}`], innerHtml: Qm(t === 'checked' ? 'selected' : t === 'unchecked' ? 'unselected' : 'indeterminate', o.icons) } } })('checked'), c('unchecked'), c('indeterminate')] }), Iv.sketch({ dom: { tag: 'label', classes: ['tox-checkbox'] }, components: [a, s.asSpec(), u] }); let n, o, r, i, a, u, c, s }), colorinput: $z((t, e) => Rb(t, e.shared, e.colorinput)), colorpicker: $z((t) => { const e = function (t) { return `tox-${t}` }; const n = Nx(Gx, e); const r = Km(n.sketch({ dom: { tag: 'div', classes: [e('color-picker-container')], attributes: { role: 'presentation' } }, onValidHex(t) { Cr(t, Ev, { name: 'hex-valid', value: !0 }) }, onInvalidHex(t) { Cr(t, Ev, { name: 'hex-valid', value: !1 }) } })); return { dom: { tag: 'div' }, components: [r.asSpec()], behaviours: _a([am.config({ store: { mode: 'manual', getValue(t) { const e = r.get(t); return Ll.getCurrent(e).bind((t) => am.getValue(t).hex).map((t) => `#${t}`).getOr('') }, setValue(t, e) { const n = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(e); const o = r.get(t); Ll.getCurrent(o).fold(() => { console.log('Can not find form') }, (t) => { am.setValue(t, { hex: P.from(n[1]).getOr('') }), Bx.getField(t, 'hex').each((t) => { kr(t, Nt()) }) }) } } }), Px()]) } }), dropzone: $z((t, e) => Zx(t, e.shared.providers)), grid: $z((t, e) => { return n = t, o = e.shared, { dom: { tag: 'div', classes: ['tox-form__grid', `tox-form__grid--${n.columns}col`] }, components: E(n.items, o.interpreter) }; let n, o }), selectbox: $z((t, e) => { return n = t, o = e.shared.providers, r = n.label.map((t) => zp(t, o)), i = Iv.parts().field({ dom: {}, selectAttributes: { size: n.size }, options: n.items, factory: Iz, selectBehaviours: _a([Xp.config({}), Am('selectbox-change', [Wr(Pt(), (t, e) => { Cr(t, Mv, { name: n.name }) })])]) }), a = n.size > 1 ? P.none() : P.some({ dom: { tag: 'div', classes: ['tox-selectfield__icon-js'], innerHtml: Qm('chevron-down', o.icons) } }), u = { dom: { tag: 'div', classes: ['tox-selectfield'] }, components: R([[i], a.toArray()]) }, Iv.sketch({ dom: { tag: 'div', classes: ['tox-form__group'] }, components: R([r.toArray(), [u]]) }); let n, o, r, i, a, u }), sizeinput: $z((t, e) => dz(t, e.shared.providers)), urlinput: $z((t, e) => Kz(t, e.shared, e.urlinput)), customeditor: $z((e) => { const n = Ct(P.none()); const o = Km({ dom: { tag: e.tag } }); const r = Ct(P.none()); return { dom: { tag: 'div', classes: ['tox-custom-editor'] }, behaviours: _a([Am('editor-foo-events', [Qr((t) => { o.getOpt(t).each((t) => { e.init(t.element().dom()).then((e) => { r.get().each((t) => { e.setValue(t) }), r.set(P.none()), n.set(P.some(e)) }) }) })]), am.config({ store: { mode: 'manual', getValue() { return n.get().fold(() => r.get().getOr(''), (t) => t.getValue()) }, setValue(t, e) { n.get().fold(() => { r.set(P.some(e)) }, (t) => t.setValue(e)) } } }), Px()]), components: [o.asSpec()] } }), htmlpanel: $z((t) => xv.sketch({ dom: { tag: 'div', innerHtml: t.html }, containerBehaviours: _a([Xp.config({}), fm.config({})]) })), imagetools: $z((t, e) => Lz(t, e.shared.providers)), table: $z((t, e) => { return n = t, o = e.shared.providers, a = function (t) { return { dom: { tag: 'th', innerHtml: o.translate(t) } } }, u = function (t) { return { dom: { tag: 'td', innerHtml: o.translate(t) } } }, c = function (t) { return { dom: { tag: 'tr' }, components: E(t, u) } }, { dom: { tag: 'table', classes: ['tox-dialog__table'] }, components: [(i = n.header, { dom: { tag: 'thead' }, components: [{ dom: { tag: 'tr' }, components: E(i, a) }] }), (r = n.cells, { dom: { tag: 'tbody' }, components: E(r, c) })], behaviours: _a([Xp.config({}), fm.config({})]) }; let n, o, r, i, a, u, c }) }; const Zz = { field(t, e) { return e } }; const tS = function (e, t, n) { var o = gt(n, { shared: { interpreter(t) { return eS(e, t, o) } } }); return eS(e, t, o) }; var eS = function (e, n, o) { return xt(Qz, n.type).fold(() => console.error(`Unknown factory type "${n.type}", defaulting to container: `, n), n, (t) => t(e, n, o)) }; const nS = function (t) { return { colorPicker: (o = t, function (t, e) { Ab.colorPickerDialog(o)(t, e) }), hasCustomColors: (n = t, function () { return xb(n) }), getColors: (e = t, function () { return wb(e) }) }; let e, n, o }; const oS = [{ title: 'Headings', items: [{ title: 'Heading 1', format: 'h1' }, { title: 'Heading 2', format: 'h2' }, { title: 'Heading 3', format: 'h3' }, { title: 'Heading 4', format: 'h4' }, { title: 'Heading 5', format: 'h5' }, { title: 'Heading 6', format: 'h6' }] }, { title: 'Inline', items: [{ title: 'Bold', icon: 'bold', format: 'bold' }, { title: 'Italic', icon: 'italic', format: 'italic' }, { title: 'Underline', icon: 'underline', format: 'underline' }, { title: 'Strikethrough', icon: 'strike-through', format: 'strikethrough' }, { title: 'Superscript', icon: 'superscript', format: 'superscript' }, { title: 'Subscript', icon: 'subscript', format: 'subscript' }, { title: 'Code', icon: 'code', format: 'code' }] }, { title: 'Blocks', items: [{ title: 'Paragraph', format: 'p' }, { title: 'Blockquote', format: 'blockquote' }, { title: 'Div', format: 'div' }, { title: 'Pre', format: 'pre' }] }, { title: 'Alignment', items: [{ title: 'Left', icon: 'align-left', format: 'alignleft' }, { title: 'Center', icon: 'align-center', format: 'aligncenter' }, { title: 'Right', icon: 'align-right', format: 'alignright' }, { title: 'Justify', icon: 'align-justify', format: 'alignjustify' }] }]; var rS = function (t) { return D(t, (t, e) => { if (it(e, 'items')) { const n = rS(e.items); return { customFormats: t.customFormats.concat(n.customFormats), formats: t.formats.concat([{ title: e.title, items: n.formats }]) } } if (it(e, 'inline') || it(e, 'block') || it(e, 'selector')) { const o = `custom-${e.title.toLowerCase()}`; return { customFormats: t.customFormats.concat([{ name: o, format: e }]), formats: t.formats.concat([{ title: e.title, format: o, icon: e.icon }]) } } return Gn({}, t, { formats: t.formats.concat(e) }) }, { customFormats: [], formats: [] }) }; const iS = function (i) { return (t = i, P.from(t.getParam('style_formats')).filter(O)).map((t) => { let e; let n; let o; const r = (e = i, n = rS(t), o = function (t) { A(t, (t) => { e.formatter.has(t.name) || e.formatter.register(t.name, t.format) }) }, e.formatter ? o(n.customFormats) : e.on('init', () => { o(n.customFormats) }), n.formats); return i.getParam('style_formats_merge', !1, 'boolean') ? oS.concat(r) : r }).getOr(oS); let t }; const aS = function (t, e, n) { const o = { type: 'formatter', isSelected: e(t.format), getStylePreview: n(t.format) }; return gt(t, o) }; const uS = function (s, t, l, f) { var d = function (t) { return E(t, (t) => { let e; let n; let o; let r; let i; let a; const u = Q(t); if (kt(t, 'items')) { const c = d(t.items); return gt((i = t, a = { type: 'submenu', isSelected: U(!1), getStylePreview() { return P.none() } }, gt(i, a)), { getStyleItems() { return c } }) } return kt(t, 'format') ? aS(t, l, f) : u.length === 1 && M(u, 'title') ? gt(t, { type: 'separator' }) : (n = Un((e = t).title), o = { type: 'formatter', format: n, isSelected: l(n), getStylePreview: f(n) }, r = gt(e, o), s.formatter.register(n, r), r) }) }; return d(t) }; const cS = zz.trim; const sS = function (e) { return function (t) { if (t && t.nodeType === 1) { if (t.contentEditable === e) return !0; if (t.getAttribute('data-mce-contenteditable') === e) return !0 } return !1 } }; const lS = sS('true'); const fS = sS('false'); const dS = function (t, e, n, o, r) { return { type: t, title: e, url: n, level: o, attach: r } }; const mS = function (t) { return t.innerText || t.textContent }; const hS = function (t) { return (e = t) && e.nodeName === 'A' && (e.id || e.name) !== undefined && vS(t); let e }; const gS = function (t) { return t && /^(H[1-6])$/.test(t.nodeName) }; var vS = function (t) { return (function (t) { for (;t = t.parentNode;) { const e = t.contentEditable; if (e && e !== 'inherit') return lS(t) } return !1 }(t)) && !fS(t) }; const pS = function (t) { return gS(t) && vS(t) }; const bS = function (t) { let e; let n; const o = (e = t).id ? e.id : Un('h'); return dS('header', mS(t), `#${o}`, gS(n = t) ? parseInt(n.nodeName.substr(1), 10) : 0, () => { t.id = o }) }; const yS = function (t) { const e = t.id || t.name; const n = mS(t); return dS('anchor', n || `#${e}`, `#${e}`, 0, N) }; const xS = function (t) { let e, n; return e = 'h1,h2,h3,h4,h5,h6,a:not([href])', n = t, E(Oc(Ne.fromDom(n), e), (t) => t.dom()) }; const wS = function (t) { return cS(t.title).length > 0 }; const zS = function (t) { let e; const n = xS(t); return T((e = n, E(T(e, pS), bS)).concat(E(T(n, hS), yS)), wS) }; const SS = 'tinymce-url-history'; const kS = function (t) { return x(t) && /^https?/.test(t) }; const CS = function (t) { return w(t) && (function (t, e) { for (let n = Q(t), o = 0, r = n.length; o < r; o++) { const i = n[o]; const a = t[i]; if (e(a, i, t)) return P.some(a) } return P.none() }(t, (t) => { return !(O(e = t) && e.length <= 5 && W(e, kS)); let e })).isNone() }; const OS = function () { let t; const e = localStorage.getItem(SS); if (e === null) return {}; try { t = JSON.parse(e) } catch (n) { if (n instanceof SyntaxError) return console.log(`Local storage ${SS} was not valid JSON`, n), {}; throw n } return CS(t) ? t : (console.log(`Local storage ${SS} was not valid format`, t), {}) }; const MS = function (t) { const e = OS(); return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : [] }; const HS = function (e, t) { if (kS(e)) { const n = OS(); const o = Object.prototype.hasOwnProperty.call(n, t) ? n[t] : []; const r = T(o, (t) => t !== e); n[t] = [e].concat(r).slice(0, 5), (function (t) { if (!CS(t)) throw new Error(`Bad format for history:\n${JSON.stringify(t)}`); localStorage.setItem(SS, JSON.stringify(t)) }(n)) } }; const VS = Object.prototype.hasOwnProperty; const ES = function (t) { return !!t }; const AS = function (t) { return et(zz.makeMap(t, /[, ]/), ES) }; const TS = function (t, e) { return VS.call(t, e) ? P.some(t[e]) : P.none() }; const BS = function (t, e, n) { const o = TS(t, e).getOr(n); return x(o) ? P.some(o) : P.none() }; const DS = function (u) { return function (r) { return (t = u.settings, e = r, n = P.some(t.file_picker_types).filter(ES), o = P.some(t.file_browser_callback_types).filter(ES), i = n.or(o).map(AS).fold(() => !0, (t) => TS(t, e).getOr(!1)), a = P.some(t.file_picker_callback).filter(S), i ? a : P.none()).map((o) => function (e) { return Jv.nu((n) => { const t = zz.extend({ filetype: r }, P.from(e.meta).getOr({})); o.call(u, (t, e) => { if (!x(t)) throw new Error('Expected value to be string'); if (e !== undefined && !w(e)) throw new Error('Expected meta to be a object'); n({ value: t, meta: e }) }, e.value, t) }) }); let t, e, n, o, i, a } }; const _S = function (t) { return { getHistory: MS, addToHistory: HS, getLinkInformation: (n = t, function () { return !1 === n.settings.typeahead_urls ? P.none() : P.some({ targets: zS(n.getBody()), anchorTop: BS(n.settings, 'anchor_top', '#top'), anchorBottom: BS(n.settings, 'anchor_bottom', '#bottom') }) }), getValidationHandler: (e = t, function () { const t = e.settings.filepicker_validator_handler; return S(t) ? P.some(t) : P.none() }), getUrlPicker: DS(t) }; let e, n }; const FS = { valignCentre: [], alignCentre: [], alignLeft: [], alignRight: [], right: [], left: [], bottom: [], top: [] }; const LS = function (t, e, n) { let o; let r; let i; let a; let u; let c; let s; let l; let f; var d = { shared: { providers: { icons() { return e.ui.registry.getAll().icons }, menuItems() { return e.ui.registry.getAll().menuItems }, translate: Lh.translate }, interpreter(t) { return eS(Zz, t, d) }, anchors: { toolbar() { return { anchor: 'hotspot', hotspot: n(), bubble: ju(-12, 12, FS), layouts: { onRtl() { return [$u] }, onLtr() { return [Qu] } } } }, banner() { return { anchor: 'hotspot', hotspot: n(), layouts: { onRtl() { return [nc] }, onLtr() { return [nc] } } } }, cursor() { return { anchor: 'selection', root: Ne.fromDom(e.getBody()), getSelection() { const t = e.selection.getRng(); return P.some(gc(Ne.fromDom(t.startContainer), t.startOffset, Ne.fromDom(t.endContainer), t.endOffset)) } } }, node(t) { return { anchor: 'node', root: Ne.fromDom(e.getBody()), node: t } } }, getSink() { return ft.value(t) } }, urlinput: _S(e), styleselect: (o = e, r = function (t) { return function () { return o.formatter.match(t) } }, i = function (e) { return function () { const t = o.formatter.get(e); return t !== undefined ? P.some({ tag: t.length > 0 && (t[0].inline || t[0].block) || 'div', styleAttr: o.formatter.getCssText(e) }) : P.none() } }, a = function (t) { const e = t.items; return e !== undefined && e.length > 0 ? j(e, a) : [t.format] }, u = Ct([]), c = Ct([]), s = Ct([]), l = Ct([]), f = Ct(!1), o.on('init', () => { const t = iS(o); const e = uS(o, t, r, i); u.set(e), c.set(j(e, a)) }), o.on('addStyleModifications', (t) => { const e = uS(o, t.items, r, i); s.set(e), f.set(t.replace), l.set(j(e, a)) }), { getData() { const t = f.get() ? [] : u.get(); const e = s.get(); return t.concat(e) }, getFlattenedKeys() { const t = f.get() ? [] : c.get(); const e = l.get(); return t.concat(e) } }), colorinput: nS(e) }; return d }; const IS = tinymce.util.Tools.resolve('tinymce.util.Delay'); const RS = U([dr('shell', !0), Es('toolbarBehaviours', [Yd])]); const NS = U([al({ name: 'groups', overrides(t) { return { behaviours: _a([Yd.config({})]) } } })]); const PS = Bl({ name: 'Toolbar', configFields: RS(), partFields: NS(), factory(e, t, n, o) { const r = function (t) { return e.shell ? P.some(t) : bl(t, e, 'groups') }; const i = e.shell ? { behaviours: [Yd.config({})], components: [] } : { behaviours: [], components: t }; return { uid: e.uid, dom: e.dom, components: i.components, behaviours: Ts(e.toolbarBehaviours, i.behaviours), apis: { setGroups(t, e) { r(t).fold(() => { throw console.error('Toolbar was defined to not be a shell, but no groups container was specified in components'), new Error('Toolbar was defined to not be a shell, but no groups container was specified in components') }, (t) => { Yd.set(t, e) }) } }, domModification: { attributes: { role: 'group' } } } }, apis: { setGroups(t, e, n) { t.setGroups(e, n) } } }); const jS = U([Zo('items'), wa(['itemSelector']), Es('tgroupBehaviours', [jd])]); const US = U([ul({ name: 'items', unit: 'item' })]); const WS = Bl({ name: 'ToolbarGroup', configFields: jS(), partFields: US(), factory(t, e, n, o) { return { uid: t.uid, dom: t.dom, components: e, behaviours: Ts(t.tgroupBehaviours, [jd.config({ mode: 'flow', selector: t.markers.itemSelector })]), domModification: { attributes: { role: 'toolbar' } } } } }); const GS = function (t) { const e = t.title.fold(() => ({}), (t) => ({ attributes: { title: t } })); return WS.sketch({ dom: Gn({ tag: 'div', classes: ['tox-toolbar__group'] }, e), components: [WS.parts().items({})], items: t.items, markers: { itemSelector: '*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled])' }, tgroupBehaviours: _a([Xp.config({}), fm.config({})]) }) }; const XS = function (n) { const t = n.cyclicKeying ? 'cyclic' : 'acyclic'; return PS.sketch({ uid: n.uid, dom: { tag: 'div', classes: ['tox-toolbar'] }, components: [PS.parts().groups({})], toolbarBehaviours: _a([jd.config({ mode: t, onEscape: n.onEscape, selector: '.tox-toolbar__group' }), Am('toolbar-events', [Qr((t) => { const e = E(n.initGroups, GS); PS.setGroups(t, e) })])]) }) }; const YS = [pr('disabled', !1), sr('tooltip'), sr('icon'), sr('text'), br('onSetup', () => N)]; const qS = Vo([er('type'), or('onAction')].concat(YS)); const KS = function (t) { return Po('toolbarbutton', qS, t) }; const JS = Vo([er('type'), sr('tooltip'), sr('icon'), sr('text'), or('fetch'), br('onSetup', () => N)]); const $S = Vo([er('type'), sr('tooltip'), sr('icon'), sr('text'), lr('select'), or('fetch'), br('onSetup', () => N), vr('presets', 'normal', ['normal', 'color', 'toolbar']), dr('columns', 1), or('onAction'), or('onItemAction')]); const QS = [pr('active', !1)].concat(YS); const ZS = Vo(QS.concat([er('type'), or('onAction')])); const tk = function (t) { return Po('ToggleButton', ZS, t) }; const ek = [br('predicate', () => !1), vr('scope', 'node', ['node', 'editor']), vr('position', 'selection', ['node', 'selection', 'line'])]; const nk = YS.concat([dr('type', 'contextformbutton'), dr('primary', !1), or('onAction'), xr('original', d)]); const ok = QS.concat([dr('type', 'contextformbutton'), dr('primary', !1), or('onAction'), xr('original', d)]); const rk = YS.concat([dr('type', 'contextformbutton')]); const ik = QS.concat([dr('type', 'contextformtogglebutton')]); const ak = Go('type', { contextformbutton: nk, contextformtogglebutton: ok }); const uk = Vo([dr('type', 'contextform'), br('initValue', () => ''), sr('label'), ar('commands', ak), cr('launch', Go('type', { contextformbutton: rk, contextformtogglebutton: ik }))].concat(ek)); const ck = Vo([dr('type', 'contexttoolbar'), er('items')].concat(ek)); const sk = Un('toolbar.button.execute'); const lk = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'toolbar-button-events'] }; const fk = Object.freeze({ getState(t, e, n) { return n } }); const dk = Object.freeze({ events(r, i) { const o = function (n, o) { r.updateState.each((t) => { const e = t(n, o); i.set(e) }), r.renderComponents.each((t) => { const e = t(o, i.get()); ds(n), A(e, (t) => { cs(n, n.getSystem().build(t)) }) }) }; return Pr([Wr(ze(), (t, e) => { const n = r.channel; M(e.channels(), n) && o(t, e.data()) }), Qr((e, t) => { r.initialData.each((t) => { o(e, t) }) })]) } }); const mk = Object.freeze({ init(t) { const e = Ct(P.none()); return { readState() { return e.get().getOr('none') }, get() { return e.get() }, set(t) { return e.set(t) }, clear() { return e.set(P.none()) } } } }); const hk = [Zo('channel'), ur('renderComponents'), ur('updateState'), ur('initialData')]; const gk = La({ fields: hk, name: 'reflecting', active: dk, apis: fk, state: mk }); const vk = U([Zo('toggleClass'), Zo('fetch'), Ca('onExecute'), dr('getHotspot', P.some), dr('layouts', P.none()), Ca('onItemExecute'), ur('lazySink'), Zo('dom'), Sa('onOpen'), Es('splitDropdownBehaviours', [Pv, jd, fm]), dr('matchWidth', !1), dr('useMinWidth', !1), dr('eventOrder', {}), ur('role')].concat(hp())); const pk = rl({ factory: qm, schema: [Zo('dom')], name: 'arrow', defaults(t) { return { buttonBehaviours: _a([fm.revoke()]) } }, overrides(e) { return { dom: { tag: 'span', attributes: { role: 'presentation' } }, action(t) { t.getSystem().getByUid(e.uid).each(Or) }, buttonBehaviours: _a([km.config({ toggleOnExecute: !1, toggleClass: e.toggleClass })]) } } }); const bk = rl({ factory: qm, schema: [Zo('dom')], name: 'button', defaults(t) { return { buttonBehaviours: _a([fm.revoke()]) } }, overrides(n) { return { dom: { tag: 'span', attributes: { role: 'presentation' } }, action(e) { e.getSystem().getByUid(n.uid).each((t) => { n.onExecute(t, e) }) } } } }); const yk = U([pk, bk, al({ factory: { sketch(t) { return { uid: t.uid, dom: { tag: 'span', styles: { display: 'none' }, attributes: { 'aria-hidden': 'true' }, innerHtml: t.text } } } }, schema: [Zo('text')], name: 'aria-descriptor' }), il({ schema: [xa()], name: 'menu', defaults(o) { return { onExecute(e, n) { e.getSystem().getByUid(o.uid).each((t) => { o.onItemExecute(t, e, n) }) } } } }), Qv()]); const xk = Bl({ name: 'SplitDropdown', configFields: vk(), partFields: yk(), factory(o, t, e, n) { const r = function (t) { Ll.getCurrent(t).each((t) => { Jl.highlightFirst(t), jd.focusIn(t) }) }; const i = function (t) { np(o, (t) => t, t, n, r, bv.HighlightFirst).get(N) }; const a = function (t) { const e = yl(t, o, 'button'); return Or(e), P.some(!0) }; const u = vt(Pr([Qr((n, t) => { bl(n, o, 'aria-descriptor').each((t) => { const e = Un('aria'); Cn(t.element(), 'id', e), Cn(n.element(), 'aria-describedby', e) }) })]), Ym(P.some(i))); return { uid: o.uid, dom: o.dom, components: t, eventOrder: Gn({}, o.eventOrder, { 'alloy.execute': ['disabling', 'toggling', 'alloy.base.behaviour'] }), events: u, behaviours: Ts(o.splitDropdownBehaviours, [Pv.config({ others: { sandbox(t) { const e = yl(t, o, 'arrow'); return ip(o, t, { onOpen() { km.on(e), km.on(t) }, onClose() { km.off(e), km.off(t) } }) } } }), jd.config({ mode: 'special', onSpace: a, onEnter: a, onDown(t) { return i(t), P.some(!0) } }), fm.config({}), km.config({ toggleOnExecute: !1, aria: { mode: 'expanded' } })]), domModification: { attributes: { role: o.role.getOr('button'), 'aria-haspopup': !0 } } } } }); const wk = function (e) { return { isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }; const zk = function (e) { return { setActive(t) { km.set(e, t) }, isActive() { return km.isOn(e) }, isDisabled() { return og.isDisabled(e) }, setDisabled(t) { return t ? og.disable(e) : og.enable(e) } } }; const Sk = function (t, e) { return t.map((t) => ({ 'aria-label': e.translate(t), title: e.translate(t) })).getOr({}) }; const kk = Un('focus-button'); const Ck = function (e, n, t, o, r, i) { let a; return { dom: { tag: 'button', classes: ['tox-tbtn'].concat(n.isSome() ? ['tox-tbtn--select'] : []), attributes: Sk(t, i) }, components: hg([e.map((t) => $w(t, i.icons)), n.map((t) => Qw(t, 'tox-tbtn', i))]), eventOrder: (a = {}, a[At()] = ['focusing', 'alloy.base.behaviour', 'common-button-display-events'], a), buttonBehaviours: _a([Am('common-button-display-events', [Wr(At(), (t, e) => { e.event().prevent(), kr(t, kk) })])].concat(o.map((t) => gk.config({ channel: t, initialData: { icon: e, text: n }, renderComponents(t, e) { return hg([t.icon.map((t) => $w(t, i.icons)), t.text.map((t) => Qw(t, 'tox-tbtn', i))]) } })).toArray()).concat(r.getOr([]))) } }; const Ok = function (t, e, n) { let o; const r = Ct(N); const i = Ck(t.icon, t.text, t.tooltip, P.none(), P.none(), n); return qm.sketch({ dom: i.dom, components: i.components, eventOrder: lk, buttonBehaviours: _a([Am('toolbar-button-events', [(o = { onAction: t.onAction, getApi: e.getApi }, ei((e, t) => { ug(o, e)((t) => { Cr(e, sk, { buttonApi: t }), o.onAction(t) }) })), cg(e, r), sg(e, r)]), ig(t.disabled)].concat(e.toolbarButtonBehaviours)) }) }; const Mk = function (t, e, n) { return Ok(t, { toolbarButtonBehaviours: [].concat(n.length > 0 ? [Am('toolbarButtonWith', n)] : []), getApi: wk, onSetup: t.onSetup }, e) }; const Hk = function (t, e, n) { return gt(Ok(t, { toolbarButtonBehaviours: [Yd.config({}), km.config({ toggleClass: 'tox-tbtn--enabled', aria: { mode: 'pressed' }, toggleOnExecute: !1 })].concat(n.length > 0 ? [Am('toolbarToggleButtonWith', n)] : []), getApi: zk, onSetup: t.onSetup }, e)) }; const Vk = function (e, t) { let n; let o; let r; let i; const a = Un('channel-update-split-dropdown-display'); const u = function (n) { return { isDisabled() { return !0 }, setDisabled() {}, setIconFill(t, e) { da(n.element(), `svg path[id="${t}"], rect[id="${t}"]`).each((t) => { Cn(t, 'fill', e) }) }, setIconStroke(t, e) { da(n.element(), `svg path[id="${t}"], rect[id="${t}"]`).each((t) => { Cn(t, 'stroke', e) }) }, setActive(e) { Cn(n.element(), 'aria-pressed', e), da(n.element(), 'span').each((t) => { n.getSystem().getByDom(t).each((t) => km.set(t, e)) }) }, isActive() { return da(n.element(), 'span').exists((t) => n.getSystem().getByDom(t).exists(km.isOn)) } } }; const c = Ct(N); const s = { getApi: u, onSetup: e.onSetup }; return xk.sketch({ dom: { tag: 'div', classes: ['tox-split-button'], attributes: vt({ 'aria-pressed': !1 }, Sk(e.tooltip, t.providers)) }, onExecute(t) { e.onAction(u(t)) }, onItemExecute(t, e, n) {}, splitDropdownBehaviours: _a([ag(!1), Am('split-dropdown-events', [Wr(kk, fm.focus), cg(s, c), sg(s, c)])]), eventOrder: (n = {}, n[Te()] = ['alloy.base.behaviour', 'split-dropdown-events'], n), toggleClass: 'tox-tbtn--enabled', lazySink: t.getSink, fetch: (o = u, r = e, i = t.providers, function (e) { return Jv.nu((t) => r.fetch(t)).map((t) => Yg(gt(Gg(Un('menu-value'), t, (t) => { r.onItemAction(o(e), t) }, r.columns, r.presets, dg.CLOSE_ON_EXECUTE, r.select.getOr(() => !1), i), { movement: _g(r.columns, r.presets), menuBehaviours: Oh(r.columns !== 'auto' ? [] : [Qr((o, t) => { kh(o, 4, _h(r.presets)).each((t) => { const e = t.numRows; const n = t.numColumns; jd.setGridSize(o, e, n) }) })]) }))) }), parts: { menu: Dg(0, e.columns, e.presets) }, components: [xk.parts().button(Ck(e.icon, e.text, P.none(), P.some(a), P.some([km.config({ toggleClass: 'tox-tbtn--enabled', toggleOnExecute: !1 })]), t.providers)), xk.parts().arrow({ dom: { tag: 'button', classes: ['tox-tbtn', 'tox-split-button__chevron'], innerHtml: Qm('chevron-down', t.providers.icons) } }), xk.parts()['aria-descriptor']({ text: t.providers.translate('To open the popup, press Shift+Enter') })] }) }; const Ek = function (i, a) { return Wr(sk, (t, e) => { let n; const o = i.get(t); const r = (n = o, { hide() { return kr(n, He()) }, getValue() { return am.getValue(n) } }); a.onAction(r, e.event().buttonApi()) }) }; const Ak = function (t, e, n) { let o; let r; let i; let a; let u; let c; let s; let l; let f; let d; let m; let h; const g = { backstage: { shared: { providers: n } } }; return e.type === 'contextformtogglebutton' ? (s = t, f = g, (d = (l = e).original).primary, m = Xn(d, ['primary']), h = jo(tk(Gn({}, m, { type: 'togglebutton', onAction() {} }))), Hk(h, f.backstage.shared.providers, [Ek(s, l)])) : (o = t, i = g, (a = (r = e).original).primary, u = Xn(a, ['primary']), c = jo(KS(Gn({}, u, { type: 'button', onAction() {} }))), Mk(c, i.backstage.shared.providers, [Ek(o, r)])) }; const Tk = function (t, e) { let n; let o; let r; let i; const a = t.label.fold(() => ({}), (t) => ({ 'aria-label': t })); const u = Km(Vp.sketch({ inputClasses: ['tox-toolbar-textfield', 'tox-toolbar-nav-js'], data: t.initValue(), inputAttributes: a, selectOnFocus: !0, inputBehaviours: _a([jd.config({ mode: 'special', onEnter(t) { return c.findPrimary(t).map((t) => Or(t), !0) }, onLeft(t, e) { return e.cut(), P.none() }, onRight(t, e) { return e.cut(), P.none() } })]) })); var c = (n = u, o = t.commands, r = e, i = E(o, (t) => Km(Ak(n, t, r))), { asSpecs() { return E(i, (t) => t.asSpec()) }, findPrimary(n) { return Mt(o, (t, e) => t.primary ? P.from(i[e]).bind((t) => t.getOpt(n)).filter(m(og.isDisabled)) : P.none()) } }); return XS({ uid: Un('context-toolbar'), initGroups: [{ title: P.none(), items: [u.asSpec()] }, { title: P.none(), items: c.asSpecs() }], onEscape: P.none, cyclicKeying: !0 }) }; const Bk = Un('forward-slide'); const Dk = Un('backward-slide'); const _k = Un('change-slide-event'); const Fk = 'tox-pop--resizing'; const Lk = function (e, t) { return Mt(t, (t) => t.predicate(e.dom()) ? P.some({ toolbarApi: t, elem: e }) : P.none()) }; const Ik = function (e, n) { const t = function (t) { return t.dom() === n.getBody() }; const o = Ne.fromDom(n.selection.getNode()); return Lk(o, e.inNodeScope).orThunk(() => Lk(o, e.inEditorScope).orThunk(() => (function (t, e, n) { for (let o = t.dom(), r = S(n) ? n : U(!1); o.parentNode;) { o = o.parentNode; const i = Ne.fromDom(o); const a = e(i); if (a.isSome()) return a; if (r(i)) break } return P.none() }(o, (t) => Lk(t, e.inNodeScope), t)))) }; const Rk = function (n, r) { const t = {}; const i = []; const a = []; const u = {}; const c = {}; const o = function (e, n) { const o = jo(Po('ContextForm', uk, n)); (t[e] = o).launch.map((t) => { u[`form:${e}`] = Gn({}, n.launch, { type: t.type === 'contextformtogglebutton' ? 'togglebutton' : 'button', onAction() { r(o) } }) }), o.scope === 'editor' ? a.push(o) : i.push(o), c[e] = o }; const s = function (e, n) { let t; (t = n, Po('ContextToolbar', ck, t)).each((t) => { n.scope === 'editor' ? a.push(t) : i.push(t), c[e] = t }) }; const e = Q(n); return A(e, (t) => { const e = n[t]; e.type === 'contextform' ? o(t, e) : e.type === 'contexttoolbar' && s(t, e) }), { forms: t, inNodeScope: i, inEditorScope: a, lookupTable: c, formNavigators: u } }; const Nk = Un('update-menu-text'); const Pk = function (t, e, o) { const r = t.text.map((t) => Km(Qw(t, e, o.providers))); const n = function (t, e) { const n = am.getValue(t); return fm.focus(n), Cr(n, 'keydown', { raw: e.event().raw() }), Db.close(n), P.some(!0) }; const i = t.role.fold(() => ({}), (t) => ({ role: t })); return Km(Db.sketch(Gn({}, i, { dom: { tag: 'button', classes: [e, `${e}--select`].concat(E(t.classes, (t) => `${e}--${t}`)), attributes: t.tooltip.fold(() => ({}), (t) => { const e = o.providers.translate(t); return { title: e, 'aria-label': e } }) }, components: hg([t.icon.map((t) => $w(t, o.providers.icons)), r.map((t) => t.asSpec()), P.some({ dom: { tag: 'div', classes: [`${e}__select-chevron`], innerHtml: Qm('chevron-down', o.providers.icons) } })]), matchWidth: !0, useMinWidth: !0, dropdownBehaviours: _a([ig(t.disabled), _b.config({}), Yd.config({}), Am('menubutton-update-display-text', [Qr(t.onAttach), Zr(t.onDetach), Wr(Nk, (e, n) => { r.bind((t) => t.getOpt(e)).each((t) => { Yd.set(t, [aa(o.providers.translate(n.event().text()))]) }) })])]), eventOrder: gt(lk, { mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events', 'normal-dropdown-events'] }), sandboxBehaviours: _a([jd.config({ mode: 'special', onLeft: n, onRight: n })]), lazySink: o.getSink, toggleClass: `${e}--active`, parts: { menu: Dg(0, t.columns, t.presets) }, fetch() { return Jv.nu(t.fetch) } }))).asSpec() }; const jk = function (t, e, n, o) { let i; let a; let r; let u; let c; const s = n.type === 'basic' ? function () { return E(n.data, (t) => aS(t, o.isSelectedFor, o.getPreviewFor)) } : n.getData; return { items: (i = e, a = o, r = function (e, n, o) { const r = i.shared.providers.translate(e.title); return e.type === 'separator' ? { type: 'separator', text: r } : e.type === 'submenu' ? { type: 'nestedmenuitem', text: r, disabled: o, getSubmenuItems() { return j(e.getStyleItems(), (t) => u(t, n)) } } : e.getStylePreview().fold(() => ({ type: 'togglemenuitem', text: r, active: e.isSelected(), disabled: o, onAction: a.onAction(e) }), (t) => ({ type: 'styleitem', item: { type: 'togglemenuitem', text: r, disabled: o, active: e.isSelected(), onAction: a.onAction(e), meta: t } })) }, u = function (t, e) { const n = t.type === 'formatter' && a.isInvalid(t); return e === 0 ? n ? [] : [r(t, e, !1)] : [r(t, e, n)] }, c = function (t) { const e = a.shouldHide ? 0 : 1; return j(t, (t) => u(t, e)) }, { validateItems: c, getFetch(o, r) { return function (t) { const e = r(); const n = c(e); t(Hp(n, dg.CLOSE_ON_EXECUTE, o.shared.providers)) } } }), getStyleItems: s } }; const Uk = function (n, t, e, o) { const r = jk(0, t, e, o); const i = r.items; const a = r.getStyleItems; return Pk({ text: P.some(''), icon: P.none(), tooltip: P.from(o.tooltip), role: P.none(), fetch: i.getFetch(t, a), onAttach: o.nodeChangeHandler.map((e) => function (t) { return n.on('nodeChange', e(t)) }).getOr(() => {}), onDetach: o.nodeChangeHandler.map((e) => function (t) { return n.off('nodeChange', e(t)) }).getOr(() => {}), columns: 1, presets: 'normal', classes: ['bespoke'] }, 'tox-tbtn', t.shared) }; (Hz = Mz || (Mz = {}))[Hz.SemiColon = 0] = 'SemiColon', Hz[Hz.Space = 1] = 'Space'; let Wk; let Gk; const Xk = function (t, e, n, o) { let r; let i; const a = xt(t.settings, e).getOr(n); return { type: 'basic', data: (i = a, r = o === Mz.SemiColon ? i.replace(/;$/, '').split(';') : i.split(' '), E(r, (t) => { let e = t; let n = t; const o = t.split('='); return o.length > 1 && (e = o[0], n = o[1]), { title: e, format: n } })) } }; const Yk = [{ title: 'Left', icon: 'align-left', format: 'alignleft' }, { title: 'Center', icon: 'align-center', format: 'aligncenter' }, { title: 'Right', icon: 'align-right', format: 'alignright' }, { title: 'Justify', icon: 'align-justify', format: 'alignjustify' }]; const qk = function (n, o) { const t = P.some((e) => function () { const t = _(Yk, (t) => n.formatter.match(t.format)).fold(() => 'Align', (t) => t.title); Cr(e, Nk, { text: o.shared.providers.translate(t) }) }); const e = { type: 'basic', data: Yk }; return Uk(n, o, e, { tooltip: 'Align', isSelectedFor(t) { return function () { return n.formatter.match(t) } }, getPreviewFor(t) { return function () { return P.none() } }, onAction(t) { return function () { n.undoManager.transact(() => { n.focus(), n.formatter.match(t.format) ? n.formatter.remove(t.format) : n.formatter.apply(t.format) }) } }, nodeChangeHandler: t, shouldHide: !1, isInvalid(t) { return !n.formatter.canApply(t.format) } }) }; const Kk = ['-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'sans-serif']; const Jk = function (r) { const o = function () { const n = function (t) { return t ? t.split(',')[0] : '' }; const t = r.queryCommandValue('FontName'); const e = i.data; const o = t ? t.toLowerCase() : ''; return _(e, (t) => { const e = t.format; return e.toLowerCase() === o || n(e).toLowerCase() === n(o).toLowerCase() }).orThunk(() => { return (t = o).indexOf('-apple-system') === 0 && (e = t.toLowerCase().split(/['"]?\s*,\s*['"]?/), W(Kk, (t) => e.indexOf(t.toLowerCase()) > -1)) ? P.from({ title: 'System Font', format: o }) : P.none(); let t, e }) }; const t = P.some((n) => function () { const t = r.queryCommandValue('FontName'); const e = o().fold(() => t, (t) => t.title); Cr(n, Nk, { text: e }) }); var i = Xk(r, 'font_formats', 'Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats', Mz.SemiColon); return { tooltip: 'Fonts', isSelectedFor(e) { return function () { return o().exists((t) => t.format === e) } }, getPreviewFor(t) { return function () { return P.some({ tag: 'div', styleAttr: t.indexOf('dings') === -1 ? `font-family:${t}` : '' }) } }, onAction(t) { return function () { r.undoManager.transact(() => { r.focus(), r.execCommand('FontName', !1, t.format) }) } }, nodeChangeHandler: t, dataset: i, shouldHide: !1, isInvalid() { return !1 } } }; const $k = function (t, e) { return /[0-9.]+px$/.test(t) ? (n = 72 * parseInt(t, 10) / 96, o = e || 0, r = Math.pow(10, o), `${Math.round(n * r) / r}pt`) : t; let n, o, r }; const Qk = function (i) { const a = function () { let n = P.none(); const o = u.data; const r = i.queryCommandValue('FontSize'); if (r) for (let t = function (t) { const e = $k(r, t); n = _(o, (t) => t.format === r || t.format === e) }, e = 3; n.isNone() && e >= 0; e--)t(e); return { matchOpt: n, px: r } }; const t = P.some((r) => function () { const t = a(); const e = t.matchOpt; const n = t.px; const o = e.fold(() => n, (t) => t.title); Cr(r, Nk, { text: o }) }); var u = Xk(i, 'fontsize_formats', '8pt 10pt 12pt 14pt 18pt 24pt 36pt', Mz.Space); return { tooltip: 'Font Sizes', isSelectedFor(e) { return function () { return a().matchOpt.exists((t) => t.format === e) } }, getPreviewFor() { return function () { return P.none() } }, onAction(t) { return function () { i.undoManager.transact(() => { i.focus(), i.execCommand('FontSize', !1, t.format) }) } }, nodeChangeHandler: t, dataset: u, shouldHide: !1, isInvalid() { return !1 } } }; const Zk = function (n, t, e) { const o = e.parents; const r = t(); return Mt(o, (e) => _(r, (t) => n.formatter.matchNode(e, t.format))).orThunk(() => n.formatter.match('p') ? P.some({ title: 'Paragraph', format: 'p' }) : P.none()) }; const tC = function (o) { const t = P.some((n) => function (t) { const e = Zk(o, () => r.data, t).fold(() => 'Paragraph', (t) => t.title); Cr(n, Nk, { text: e }) }); var r = Xk(o, 'block_formats', 'Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre', Mz.SemiColon); return { tooltip: 'Blocks', isSelectedFor(t) { return function () { return o.formatter.match(t) } }, getPreviewFor(e) { return function () { const t = o.formatter.get(e); return P.some({ tag: t.length > 0 && (t[0].inline || t[0].block) || 'div', styleAttr: o.formatter.getCssText(e) }) } }, onAction(t) { return function () { o.undoManager.transact(() => { o.focus(), o.formatter.match(t.format) ? o.formatter.remove(t.format) : o.formatter.apply(t.format) }) } }, nodeChangeHandler: t, dataset: r, shouldHide: !1, isInvalid(t) { return !o.formatter.canApply(t.format) } } }; const eC = function (i) { return { tooltip: 'Formats', isSelectedFor(t) { return function () { return i.formatter.match(t) } }, getPreviewFor(e) { return function () { const t = i.formatter.get(e); return t !== undefined ? P.some({ tag: t.length > 0 && (t[0].inline || t[0].block) || 'div', styleAttr: i.formatter.getCssText(e) }) : P.none() } }, onAction(t) { return function () { i.undoManager.transact(() => { i.focus(), i.formatter.match(t.format) ? i.formatter.remove(t.format) : i.formatter.apply(t.format) }) } }, nodeChangeHandler: P.some((n) => { var o = function (t) { const e = t.items; return e !== undefined && e.length > 0 ? j(e, o) : [{ title: t.title, format: t.format }] }; const r = j(iS(i), o); return function (t) { const e = Zk(i, () => r, t).fold(() => 'Paragraph', (t) => t.title); Cr(n, Nk, { text: e }) } }), shouldHide: i.getParam('style_formats_autohide', !1, 'boolean'), isInvalid(t) { return !i.formatter.canApply(t.format) } } }; const nC = { file: { title: 'File', items: 'newdocument restoredraft | preview | print | deleteallconversations' }, edit: { title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall | searchreplace' }, view: { title: 'View', items: 'code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments' }, insert: { title: 'Insert', items: 'image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime' }, format: { title: 'Format', items: 'bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align | removeformat' }, tools: { title: 'Tools', items: 'spellchecker spellcheckerlanguage | a11ycheck code wordcount' }, table: { title: 'Table', items: 'inserttable tableprops deletetable row column cell' }, help: { title: 'Help', items: 'help' } }; const oC = function (t, e, n, o) { return Pk({ text: t.text, icon: t.icon, tooltip: t.tooltip, role: o, fetch(e) { t.fetch((t) => { e(Hp(t, dg.CLOSE_ON_EXECUTE, n.providers)) }) }, onAttach() {}, onDetach() {}, columns: 1, presets: 'normal', classes: [] }, e, n) }; const rC = { formats(t, e) { const n = e.styleselect; const o = jk(0, e, n, eC(t)); return { type: 'nestedmenuitem', text: 'Formats', getSubmenuItems() { return o.items.validateItems(o.getStyleItems()) } } }, blockformats(t, e) { const n = tC(t); const o = jk(0, e, n.dataset, n); return { type: 'nestedmenuitem', text: 'Blocks', getSubmenuItems() { return o.items.validateItems(o.getStyleItems()) } } }, fontformats(t, e) { const n = Jk(t); const o = jk(0, e, n.dataset, n); return { type: 'nestedmenuitem', text: e.shared.providers.translate('Fonts'), getSubmenuItems() { return o.items.validateItems(o.getStyleItems()) } } }, fontsizes(t, e) { const n = Qk(t); const o = jk(0, e, n.dataset, n); return { type: 'nestedmenuitem', text: 'Font Sizes', getSubmenuItems() { return o.items.validateItems(o.getStyleItems()) } } } }; const iC = function (t) { return typeof t === 'string' ? t.split(' ') : t }; const aC = function (c, s, l) { const f = vt(nC, s.menus); const e = Q(s.menus).length > 0; const t = s.menubar === undefined || !0 === s.menubar ? iC('file edit view insert format tools table help') : iC(!1 === s.menubar ? '' : s.menubar); const n = T(t, (t) => e && s.menus.hasOwnProperty(t) && s.menus[t].hasOwnProperty('items') || nC.hasOwnProperty(t)); const o = E(n, (t) => { let e; let n; let o; let r; let i; let a; const u = f[t]; return e = { title: u.title, items: iC(u.items) }, n = s, r = l, a = (i = o = c, i.getParam('removed_menuitems', '')).split(/[ ,]/), { text: e.title, getItems() { return j(e.items, (e) => e.trim().length === 0 ? [] : H(a, (t) => t === e) ? [] : e === 'separator' || e === '|' ? [{ type: 'separator' }] : n.menuItems[e] ? [n.menuItems[e]] : rC[e] ? [rC[e](o, r)] : []) } } }); return T(o, (t) => t.getItems().length > 0) }; const uC = [{ name: 'history', items: ['undo', 'redo'] }, { name: 'styles', items: ['styleselect'] }, { name: 'formatting', items: ['bold', 'italic'] }, { name: 'alignment', items: ['alignleft', 'aligncenter', 'alignright', 'alignjustify'] }, { name: 'indentation', items: ['outdent', 'indent'] }, { name: 'permanent pen', items: ['permanentpen'] }, { name: 'comments', items: ['addcomment'] }]; const cC = function (o, r) { return function (t, e) { const n = o(t).fold(g(ft.error, Wo), ft.value).getOrDie(); return r(n, e) } }; const sC = { button: cC(KS, (t, e) => { return n = t, o = e.backstage.shared.providers, Mk(n, o, []); let n, o }), togglebutton: cC(tk, (t, e) => { return n = t, o = e.backstage.shared.providers, Hk(n, o, []); let n, o }), menubutton: cC((t) => Po('menubutton', JS, t), (t, e) => oC(t, 'tox-tbtn', e.backstage.shared, P.none())), splitbutton: cC((t) => Po('SplitButton', $S, t), (t, e) => Vk(t, e.backstage.shared)), styleSelectButton(t, e) { return n = t, o = e.backstage, r = o.styleselect, Uk(n, o, r, eC(n)); let n, o, r }, fontsizeSelectButton(t, e) { return n = t, o = e.backstage, r = Qk(n), Uk(n, o, r.dataset, r); let n, o, r }, fontSelectButton(t, e) { return n = t, o = e.backstage, r = Jk(n), Uk(n, o, r.dataset, r); let n, o, r }, formatButton(t, e) { return n = t, o = e.backstage, r = tC(n), Uk(n, o, r.dataset, r); let n, o, r }, alignMenuButton(t, e) { return qk(t, e.backstage) } }; const lC = { styleselect: sC.styleSelectButton, fontsizeselect: sC.fontsizeSelectButton, fontselect: sC.fontSelectButton, formatselect: sC.formatButton, align: sC.alignMenuButton }; const fC = function (t) { const e = t.split('|'); return E(e, (t) => ({ items: t.trim().split(' ') })) }; const dC = function (t) { return !1 === t.toolbar ? [] : t.toolbar === undefined || !0 === t.toolbar ? (n = t.buttons, e = E(uC, (t) => { const e = T(t.items, (t) => it(n, t) || it(lC, t)); return { name: t.name, items: e } }), T(e, (t) => t.items.length > 0)) : x(t.toolbar) ? fC(t.toolbar) : O(t.toolbar) && x(t.toolbar[0]) ? fC(t.toolbar.join(' | ')) : t.toolbar; let n, e }; const mC = function (n, o, r) { const t = dC(o); const e = E(t, (t) => { const e = j(t.items, (t) => t.trim().length === 0 ? [] : xt(o.buttons, t.toLowerCase()).fold(() => xt(lC, t.toLowerCase()).map((t) => t(n, r)).orThunk(() => console.error(`No representation for toolbarItem: ${t}`), P.none()), (t) => { return n = r, xt(sC, (e = t).type).fold(() => console.error('skipping button defined by', e), P.none(), (t) => P.some(t(e, n))); let e, n }).toArray()); return { title: P.from(n.translate(t.name)), items: e } }); return T(e, (t) => t.items.length > 0) }; const hC = function (i, t, a, c) { let n; let o; const s = sa((n = { sink: a, onEscape() { return i.focus(), P.some(!0) } }, o = Ct([]), Xm.sketch({ dom: { tag: 'div', classes: ['tox-pop'] }, fireDismissalEventInstead: { event: 'doNotDismissYet' }, onShow(t) { o.set([]), Xm.getContent(t).each((t) => { Ji(t.element(), 'visibility') }), Li(t.element(), Fk), Ji(t.element(), 'width') }, inlineBehaviours: _a([Am('context-toolbar-events', [$r(Ut(), (t, e) => { Xm.getContent(t).each((t) => {}), Li(t.element(), Fk), Ji(t.element(), 'width') }), Wr(_k, (e, n) => { Ji(e.element(), 'width'); const t = eu(e.element()); Xm.setContent(e, n.event().contents()), _i(e.element(), Fk); const o = eu(e.element()); Wi(e.element(), 'width', `${t}px`), Xm.getContent(e).each((t) => { n.event().focus().bind((t) => cf(t), lf(e.element())).orThunk(() => jd.focusIn(t), sf()) }), setTimeout(() => { Wi(e.element(), 'width', `${o}px`) }, 0) }), Wr(Bk, (t, e) => { Xm.getContent(t).each((t) => { o.set(o.get().concat([{ bar: t, focus: sf() }])) }), Cr(t, _k, { contents: e.event().forwardContents(), focus: P.none() }) }), Wr(Dk, (e, t) => { J(o.get()).each((t) => { o.set(o.get().slice(0, o.get().length - 1)), Cr(e, _k, { contents: la(t.bar), focus: t.focus }) }) })]), jd.config({ mode: 'special', onEscape(e) { return J(o.get()).fold(() => n.onEscape(), (t) => kr(e, Dk), P.some(!0)) } })]), lazySink() { return ft.value(n.sink) } }))); const l = function () { return P.some(Ne.fromDom(i.contentAreaContainer)) }; i.on('init', () => { const t = i.getBody().ownerDocument.defaultView; const e = Zg(Ne.fromDom(t), 'scroll', () => { f.get().each((t) => { const e = d.get().getOr(i.selection.getNode()).getBoundingClientRect(); const n = i.contentAreaContainer.getBoundingClientRect(); const o = e.bottom < 0; const r = e.top > n.height; o || r ? Wi(s.element(), 'display', 'none') : (Ji(s.element(), 'display'), is.positionWithin(a, t, s, l())) }) }); i.on('remove', () => { e.unbind() }) }); var f = Ct(P.none()); var d = Ct(P.none()); const e = Ct(null); const m = function (t) { return { dom: { tag: 'div', classes: ['tox-pop__dialog'] }, components: [t], behaviours: _a([jd.config({ mode: 'acyclic' }), Am('pop-dialog-wrap-events', [Qr((t) => { i.shortcuts.add('ctrl+F9', 'focus statusbar', () => jd.focusIn(t)) }), Zr((t) => { i.shortcuts.remove('ctrl+F9') })])]) } }; const u = Xt(() => Rk(t, (t) => { const e = h(t); Cr(s, Bk, { forwardContents: m(e) }) })); var h = function (t) { let e; let n; const o = i.ui.registry.getAll().buttons; const r = u(); return t.type === 'contexttoolbar' ? (e = vt(o, r.formNavigators), n = mC(i, { buttons: e, toolbar: t.items }, c), XS({ uid: Un('context-toolbar'), initGroups: n, onEscape: P.none, cyclicKeying: !0 })) : Tk(t, c.backstage.shared.providers) }; i.on('contexttoolbar-show', (e) => { const t = u(); xt(t.lookupTable, e.toolbarKey).each((t) => { b(t, e.target === i ? P.none() : P.some(e)), Xm.getContent(s).each(jd.focusIn) }) }); const r = { valignCentre: [], alignCentre: [], alignLeft: ['tox-pop--align-left'], alignRight: ['tox-pop--align-right'], right: ['tox-pop--right'], left: ['tox-pop--left'], bottom: ['tox-pop--bottom'], top: ['tox-pop--top'] }; const g = { maxHeightFunction: Lu() }; const v = { bubble: ju(12, 0, r), layouts: { onLtr() { return [oc] }, onRtl() { return [rc] } }, overrides: g }; const p = { bubble: ju(0, 12, r), layouts: { onLtr() { return [ec, nc, Zu, $u, tc, Qu] }, onRtl() { return [ec, nc, tc, Qu, Zu, $u] } }, overrides: g }; var b = function (t, e) { x(); let n; let o; let r; const i = h(t); const a = e.map(Ne.fromDom); const u = (n = t.position, o = a, r = n === 'node' ? c.backstage.shared.anchors.node(o) : c.backstage.shared.anchors.cursor(), gt(r, n === 'line' ? v : p)); f.set(P.some(u)), d.set(e), Xm.showWithin(s, u, m(i), l()), Ji(s.element(), 'display') }; const y = function () { const t = u(); Ik(t, i).fold(() => { f.set(P.none()), Xm.hide(s) }, (t) => { b(t.toolbarApi, P.some(t.elem.dom())) }) }; var x = function () { const t = e.get(); t !== null && (clearTimeout(t), e.set(null)) }; const w = function (t) { x(), e.set(t) }; i.on('click keyup setContent ObjectResized ResizeEditor', (t) => { w(IS.setEditorTimeout(i, y, 0)) }), i.on('nodeChange', (t) => { lf(s.element()).fold(() => { w(IS.setEditorTimeout(i, y, 0)) }, (t) => {}) }) }; const gC = function (t, n, o) { const e = Zg(Ne.fromDom(document), 'mousedown', (e) => { A([n, o], (t) => { t.broadcastOn([Cs()], { target: e.target() }) }) }); const r = Zg(Ne.fromDom(document), 'touchstart', (e) => { A([n, o], (t) => { t.broadcastOn([Cs()], { target: e.target() }) }) }); const i = Zg(Ne.fromDom(document), 'mouseup', (e) => { e.raw().button === 0 && A([n, o], (t) => { t.broadcastOn([Os()], { target: e.target() }) }) }); const a = function (e) { A([n, o], (t) => { t.broadcastOn([Cs()], { target: Ne.fromDom(e.target) }) }) }; t.on('mousedown', a), t.on('touchstart', a); const u = function (e) { e.button === 0 && A([n, o], (t) => { t.broadcastOn([Os()], { target: Ne.fromDom(e.target) }) }) }; t.on('mouseup', u); const c = Zg(Ne.fromDom(window), 'scroll', (e) => { A([n, o], (t) => { t.broadcastEvent(Ae(), e) }) }); t.on('remove', () => { t.off('mousedown', a), t.off('touchstart', a), t.off('mouseup', u), e.unbind(), r.unbind(), i.unbind(), c.unbind() }), t.on('detach', () => { gs(n), gs(o), n.destroy(), o.destroy() }) }; const vC = Ol; const pC = sl; const bC = Tl({ factory(o, t) { const e = { focus: jd.focusIn, setMenus(t, e) { const n = E(e, (e) => { const t = { text: P.some(e.text), icon: P.none(), tooltip: P.none(), fetch(t) { t(e.getItems()) } }; return oC(t, 'tox-mbtn', { getSink: o.getSink, providers: o.providers }, P.some('menuitem')) }); Yd.set(t, n) } }; return { uid: o.uid, dom: o.dom, components: [], behaviours: _a([Yd.config({}), Am('menubar-events', [Qr((t) => { o.onSetup(t) }), Wr(_t(), (n, t) => { da(n.element(), '.tox-mbtn--active').each((e) => { ma(t.event().target(), '.tox-mbtn').each((t) => { nn(e, t) || n.getSystem().getByDom(e).each((e) => { n.getSystem().getByDom(t).each((t) => { Db.expand(t), Db.close(e), fm.focus(t) }) }) }) }) }), Wr(_e(), (n, t) => { t.event().prevFocus().bind((t) => n.getSystem().getByDom(t).toOption()).each((e) => { t.event().newFocus().bind((t) => n.getSystem().getByDom(t).toOption()).each((t) => { Db.isOpen(e) && (Db.expand(t), Db.close(e)) }) }) })]), jd.config({ mode: 'flow', selector: '.tox-mbtn', onEscape(t) { return o.onEscape(t), P.some(!0) } }), Xp.config({})]), apis: e, domModification: { attributes: { role: 'menubar' } } } }, name: 'silver.Menubar', configFields: [Zo('dom'), Zo('uid'), Zo('onEscape'), Zo('getSink'), Zo('providers'), dr('onSetup', N)], apis: { focus(t, e) { t.focus(e) }, setMenus(t, e, n) { t.setMenus(e, n) } } }); const yC = function (e, t) { return t.getAnimationRoot.fold(() => e.element(), (t) => t(e)) }; const xC = function (t) { return t.dimension.property }; const wC = function (t, e) { return t.dimension.getDimension(e) }; const zC = function (t, e) { const n = yC(t, e); Ni(n, [e.shrinkingClass, e.growingClass]) }; const SC = function (t, e) { Li(t.element(), e.openClass), _i(t.element(), e.closedClass), Wi(t.element(), xC(e), '0px'), $i(t.element()) }; const kC = function (t, e) { Li(t.element(), e.closedClass), _i(t.element(), e.openClass), Ji(t.element(), xC(e)) }; const CC = function (t, e, n, o) { n.setCollapsed(), Wi(t.element(), xC(e), wC(e, t.element())), $i(t.element()), zC(t, e), SC(t, e), e.onStartShrink(t), e.onShrunk(t) }; const OC = function (t, e, n, o) { const r = o.getOrThunk(() => wC(e, t.element())); n.setCollapsed(), Wi(t.element(), xC(e), r), $i(t.element()); const i = yC(t, e); Li(i, e.growingClass), _i(i, e.shrinkingClass), SC(t, e), e.onStartShrink(t) }; const MC = function (t, e, n) { const o = wC(e, t.element()); (o === '0px' ? CC : OC)(t, e, n, P.some(o)) }; const HC = function (t, e, n) { const o = yC(t, e); const r = Ii(o, e.shrinkingClass); const i = wC(e, t.element()); kC(t, e); const a = wC(e, t.element()); (r ? function () { Wi(t.element(), xC(e), i), $i(t.element()) } : function () { SC(t, e) })(), Li(o, e.shrinkingClass), _i(o, e.growingClass), kC(t, e), Wi(t.element(), xC(e), a), n.setExpanded(), e.onStartGrow(t) }; const VC = function (t, e, n) { const o = yC(t, e); return !0 === Ii(o, e.growingClass) }; const EC = function (t, e, n) { const o = yC(t, e); return !0 === Ii(o, e.shrinkingClass) }; const AC = Object.freeze({ grow(t, e, n) { n.isExpanded() || HC(t, e, n) }, shrink(t, e, n) { n.isExpanded() && MC(t, e, n) }, immediateShrink(t, e, n) { n.isExpanded() && CC(t, e, n, P.none()) }, hasGrown(t, e, n) { return n.isExpanded() }, hasShrunk(t, e, n) { return n.isCollapsed() }, isGrowing: VC, isShrinking: EC, isTransitioning(t, e, n) { return !0 === VC(t, e) || !0 === EC(t, e) }, toggleGrow(t, e, n) { (n.isExpanded() ? MC : HC)(t, e, n) }, disableTransitions: zC }); const TC = Object.freeze({ exhibit(t, e) { const n = e.expanded; return zi(n ? { classes: [e.openClass], styles: {} } : { classes: [e.closedClass], styles: wt(e.dimension.property, '0px') }) }, events(n, o) { return Pr([$r(Ut(), (t, e) => { e.event().raw().propertyName === n.dimension.property && (zC(t, n), o.isExpanded() && Ji(t.element(), n.dimension.property), (o.isExpanded() ? n.onGrown : n.onShrunk)(t)) })]) } }); const BC = [Zo('closedClass'), Zo('openClass'), Zo('shrinkingClass'), Zo('growingClass'), ur('getAnimationRoot'), Sa('onShrunk'), Sa('onStartShrink'), Sa('onGrown'), Sa('onStartGrow'), dr('expanded', !1), tr('dimension', Go('property', { width: [Ma('property', 'width'), Ma('getDimension', (t) => `${eu(t)}px`)], height: [Ma('property', 'height'), Ma('getDimension', (t) => `${ru(t)}px`)] }))]; const DC = La({ fields: BC, name: 'sliding', active: TC, apis: AC, state: Object.freeze({ init(t) { const e = Ct(t.expanded); return xi({ isExpanded() { return !0 === e.get() }, isCollapsed() { return !1 === e.get() }, setCollapsed: f(e.set, !1), setExpanded: f(e.set, !0), readState() { return `expanded: ${e.get()}` } }) } }) }); const _C = 'container'; const FC = [Es('slotBehaviours', [])]; const LC = function (t) { return `<alloy.field.${t}>` }; const IC = function (r, t, e) { let n; const o = function (t) { return zl(r) }; const i = function (n, o) { return void 0 === o && (o = undefined), function (t, e) { return bl(t, r, e).map((t) => n(t, e)).getOr(o) } }; const a = function (t, e) { return Mn(t.element(), 'aria-hidden') !== 'true' }; const u = i(a, !1); const c = i((t, e) => { if (a(t)) { const n = t.element(); Wi(n, 'display', 'none'), Cn(n, 'aria-hidden', 'true'), Cr(t, Fe(), { name: e, visible: !1 }) } }); const s = (n = c, function (e, t) { A(t, (t) => n(e, t)) }); const l = i((t, e) => { if (!a(t)) { const n = t.element(); Ji(n, 'display'), Vn(n, 'aria-hidden'), Cr(t, Fe(), { name: e, visible: !0 }) } }); const f = { getSlotNames: o, getSlot(t, e) { return bl(t, r, e) }, isShowing: u, hideSlot: c, hideAllSlots(t) { return s(t, o()) }, showSlot: l }; return { uid: r.uid, dom: r.dom, components: t, behaviours: As(r.slotBehaviours), apis: f } }; const RC = et({ getSlotNames(t, e) { return t.getSlotNames(e) }, getSlot(t, e, n) { return t.getSlot(e, n) }, isShowing(t, e, n) { return t.isShowing(e, n) }, hideSlot(t, e, n) { return t.hideSlot(e, n) }, hideAllSlots(t, e) { return t.hideAllSlots(e) }, showSlot(t, e, n) { return t.showSlot(e, n) } }, bi); const NC = Gn({}, RC, { sketch(t) { let n; const e = (n = [], { slot(t, e) { return n.push(t), ml(_C, LC(t), e) }, record() { return n } }); const o = t(e); const r = e.record(); const i = E(r, (t) => rl({ name: t, pname: LC(t) })); return Hl(_C, FC, i, IC, o) } }); const PC = function (t) { return { element() { return t.element().dom() } } }; const jC = function (e) { return NC.sketch((t) => { return { dom: { tag: 'div', classes: ['tox-sidebar__pane-container'] }, components: (o = t, i = e, E(i, (t) => { const e = t.name; const n = t.settings; return o.slot(e, { dom: { tag: 'div', classes: ['tox-sidebar__pane'] }, behaviours: Oh([Qr((t) => { n.onrender && n.onrender(PC(t)) }), Wr(Fe(), (o, t) => { const r = t.event(); _(i, (t) => t.name === r.name()).each((t) => { const e = t.settings; const n = r.visible() ? e.onshow : e.onhide; n && n(PC(o)) }) })]) }) })), slotBehaviours: Oh([Qr((t) => NC.hideAllSlots(t))]) }; let o, i }) }; const UC = Un('FixSizeEvent'); const WC = Un('AutoSizeEvent'); const GC = { setSidebar(t, e) { Ll.getCurrent(t).each((t) => Yd.set(t, [jC(e)])) }, toggleSidebar(t, n) { Ll.getCurrent(t).each((e) => { Ll.getCurrent(e).each((t) => { DC.hasGrown(e) ? NC.isShowing(t, n) ? DC.shrink(e) : (NC.hideAllSlots(t), NC.showSlot(t, n)) : (NC.hideAllSlots(t), NC.showSlot(t, n), DC.grow(e)) }) }) }, whichSidebar(t) { return Ll.getCurrent(t).bind((t) => DC.isGrowing(t) || DC.hasGrown(t) ? Ll.getCurrent(t).bind((e) => _(NC.getSlotNames(e), (t) => NC.isShowing(e, t))) : P.none()) }, renderSidebar(t) { return { uid: t.uid, dom: { tag: 'div', classes: ['tox-sidebar'] }, components: [{ dom: { tag: 'div', classes: ['tox-sidebar__slider'] }, components: [], behaviours: _a([Xp.config({}), fm.config({}), DC.config({ dimension: { property: 'width' }, closedClass: 'tox-sidebar--sliding-closed', openClass: 'tox-sidebar--sliding-open', shrinkingClass: 'tox-sidebar--sliding-shrinking', growingClass: 'tox-sidebar--sliding-growing', onShrunk(t) { Ll.getCurrent(t).each(NC.hideAllSlots), kr(t, WC) }, onGrown(t) { kr(t, WC) }, onStartGrow(t) { Cr(t, UC, { width: qi(t.element(), 'width').getOr('') }) }, onStartShrink(t) { Cr(t, UC, { width: `${eu(t.element())}px` }) } }), Yd.config({}), Ll.config({ find(t) { const e = Yd.contents(t); return K(e) } })]) }], behaviours: _a([Ux(0), Am('sidebar-sliding-events', [Wr(UC, (t, e) => { Wi(t.element(), 'width', e.event().width()) }), Wr(WC, (t, e) => { Ji(t.element(), 'width') })])]) } } }; const XC = pC.optional({ factory: bC, name: 'menubar', schema: [Zo('dom'), Zo('getSink')] }); const YC = pC.optional({ factory: { sketch(t) { return XS({ uid: t.uid, onEscape() { return t.onEscape(), P.some(!0) }, cyclicKeying: !1, initGroups: [] }) } }, name: 'toolbar', schema: [Zo('dom'), Zo('onEscape')] }); const qC = pC.optional({ name: 'socket', schema: [Zo('dom')] }); const KC = pC.optional({ factory: { sketch: GC.renderSidebar }, name: 'sidebar', schema: [Zo('dom')] }); const JC = Bl({ name: 'OuterContainer', factory(n, t, e) { const o = { getSocket(t) { return vC.getPart(t, n, 'socket') }, setSidebar(t, e) { vC.getPart(t, n, 'sidebar').each((t) => GC.setSidebar(t, e)) }, toggleSidebar(t, e) { vC.getPart(t, n, 'sidebar').each((t) => GC.toggleSidebar(t, e)) }, whichSidebar(t) { return vC.getPart(t, n, 'sidebar').bind(GC.whichSidebar).getOrNull() }, getToolbar(t) { return vC.getPart(t, n, 'toolbar') }, setToolbar(t, e) { vC.getPart(t, n, 'toolbar').each((t) => { PS.setGroups(t, e) }) }, focusToolbar(t) { vC.getPart(t, n, 'toolbar').each((t) => { jd.focusIn(t) }) }, setMenubar(t, e) { vC.getPart(t, n, 'menubar').each((t) => { bC.setMenus(t, e) }) }, focusMenubar(t) { vC.getPart(t, n, 'menubar').each((t) => { bC.focus(t) }) } }; return { uid: n.uid, dom: n.dom, components: t, apis: o, behaviours: n.behaviours } }, configFields: [Zo('dom'), Zo('behaviours')], partFields: [XC, YC, qC, KC], apis: { getSocket(t, e) { return t.getSocket(e) }, setSidebar(t, e, n) { t.setSidebar(e, n) }, toggleSidebar(t, e, n) { t.toggleSidebar(e, n) }, whichSidebar(t, e) { return t.whichSidebar(e) }, getToolbar(t, e) { return t.getToolbar(e) }, setToolbar(t, e, n) { const o = E(n, (t) => GS(t)); t.setToolbar(e, o) }, setMenubar(t, e, n) { t.setMenubar(e, n) }, focusMenubar(t, e) { t.focusMenubar(e) }, focusToolbar(t, e) { t.focusToolbar(e) } } }); const $C = function (t) { return t.fire('SkinLoaded') }; const QC = function (t) { return t.fire('ResizeEditor') }; const ZC = function (t) { const e = function () { t._skinLoaded = !0, $C(t) }; return function () { t.initialized ? e() : t.on('init', e) } }; const tO = function (t, e) { let n; const o = (function (t) { const e = t.settings; const n = e.skin; let o = e.skin_url; if (!1 !== n) { const r = n || 'oxide'; o = o ? t.documentBaseURI.toAbsolute(o) : `${Sv.baseURL}/skins/ui/${r}` } return o }(e)); o && (n = `${o}/skin.min.css`, e.contentCSS.push(`${o + (t ? '/content.inline' : '/content')}.min.css`)), (!1 === e.getParam('skin')) == 0 && n ? zv.DOM.styleSheetLoader.load(n, ZC(e)) : ZC(e)() }; const eO = f(tO, !1); const nO = f(tO, !0); const oO = function (t) { return function (e) { const n = t.outerContainer; en('*', n.element()).forEach((t) => { n.getSystem().getByDom(t).each((t) => { t.hasConfigured(og) && (e.mode === 'readonly' ? og.disable(t) : og.enable(t)) }) }) } }; const rO = { render(n, o, t, e, r) { let i, a; eO(n), i = Ne.fromDom(r.targetNode), a = o.mothership, hs(i, a, fn), ms(_r(), o.uiMothership), n.on('init', () => { JC.setToolbar(o.outerContainer, mC(n, t, { backstage: e })), JC.setMenubar(o.outerContainer, aC(n, t, e)), JC.setSidebar(o.outerContainer, n.sidebars || []), n.readonly && oO(o)({ mode: 'readonly' }) }); const u = JC.getSocket(o.outerContainer).getOrDie('Could not find expected socket element'); return n.on('SwitchMode', oO(o)), n.getParam('readonly', !1, 'boolean') && n.setMode('readonly'), n.addCommand('ToggleSidebar', (t, e) => { JC.toggleSidebar(o.outerContainer, e), n.fire('ToggleSidebar') }), n.addQueryValueHandler('ToggleSidebar', () => JC.whichSidebar(o.outerContainer)), { iframeContainer: u.element().dom(), editorContainer: o.outerContainer.element().dom() } }, getBehaviours(t) { return [] } }; const iO = function (n, e) { return un(n).orThunk(() => { const t = Ne.fromTag('span'); ln(n, t); const e = un(t); return vn(t), e }).map((t) => qa(t).translate(-e.left(), -e.top())).getOrThunk(() => Xa(0, 0)) }; const aO = dt([{ offset: ['x', 'y'] }, { absolute: ['x', 'y'] }, { fixed: ['x', 'y'] }]); const uO = function (e) { return function (t) { return t.translate(-e.left(), -e.top()) } }; const cO = function (e) { return function (t) { return t.translate(e.left(), e.top()) } }; const sO = function (n) { return function (t, e) { return D(n, (t, e) => e(t), Xa(t, e)) } }; const lO = function (t, e, n) { return t.fold(sO([cO(n), uO(e)]), sO([uO(e)]), sO([])) }; const fO = function (t, e, n) { return t.fold(sO([cO(n)]), sO([]), sO([cO(e)])) }; const dO = function (t, e, n) { return t.fold(sO([]), sO([uO(n)]), sO([cO(e), uO(n)])) }; const mO = function (t, e, n) { return t.fold((t, e) => ({ position: 'absolute', left: `${t}px`, top: `${e}px` }), (t, e) => ({ position: 'absolute', left: `${t - n.left()}px`, top: `${e - n.top()}px` }), (t, e) => ({ position: 'fixed', left: `${t}px`, top: `${e}px` })) }; const hO = aO.offset; const gO = aO.absolute; const vO = aO.fixed; const pO = function (t, e) { _i(t.element(), e.transitionClass), Li(t.element(), e.fadeOutClass), _i(t.element(), e.fadeInClass) }; const bO = function (t, e) { _i(t.element(), e.transitionClass), Li(t.element(), e.fadeInClass), _i(t.element(), e.fadeOutClass) }; const yO = function (t, e) { return t.y() >= e.y() && t.bottom() <= e.bottom() }; const xO = function (t, e) { return Hn(t, e) ? P.some(parseInt(Mn(t, e), 10)) : P.none() }; const wO = function (o, r, i) { return (a = o, t = r, e = a.element(), xO(e, t.leftAttr).bind((o) => xO(e, t.topAttr).map((t) => { const e = eu(a.element()); const n = ru(a.element()); return yu(o, t, e, n) }))).bind((t) => { return yO(t, i) ? (e = r, n = o.element(), Vn(n, e.leftAttr), Vn(n, e.topAttr), P.some(gO(t.x(), t.y()))) : P.none(); let e, n }); let a, t, e }; const zO = function (t, e, n, o, r) { const i = qa(t.element()); const a = yu(i.left(), i.top(), eu(t.element()), ru(t.element())); if (yO(a, n)) return P.none(); u = t, c = e, s = i.left(), l = i.top(), f = u.element(), Cn(f, c.leftAttr, s), Cn(f, c.topAttr, l); let u; let c; let s; let l; let f; const d = gO(i.left(), i.top()); const m = lO(d, o, r); const h = gO(n.x(), n.y()); const g = lO(h, o, r); const v = a.y() <= n.y() ? g.top() : g.top() + n.height() - a.height(); return P.some(vO(m.left(), v)) }; const SO = function (i, t, e) { const a = t.lazyViewport(i); t.contextual.each((r) => { r.lazyContext(i).each((t) => { let e; let n; const o = xu(t); n = a, ((e = o).y() < n.bottom() && e.bottom() > n.y() ? pO : bO)(i, r) }) }); let n; let o; let r; let u; let c; const s = on(i.element()); const l = Ja(s); const f = iO(i.element(), l); (n = i, o = t, r = a, u = l, c = f, qi(n.element(), 'position').is('fixed') ? wO(n, o, r) : zO(n, o, r, u, c)).each((t) => { const e = mO(t, 0, f); Gi(i.element(), e) }) }; const kO = Object.freeze({ refresh: SO }); const CO = Object.freeze({ events(o, t) { return Pr([Wr(Ut(), (e, n) => { o.contextual.each((t) => { nn(e.element(), n.event().target()) && (Li(e.element(), t.transitionClass), n.stop()) }) }), Wr(Ae(), (t, e) => { SO(t, o) })]) } }); const OO = [fr('contextual', [Zo('fadeInClass'), Zo('fadeOutClass'), Zo('transitionClass'), Zo('lazyContext')]), dr('lazyViewport', (t) => { const e = Ja(); return yu(e.left(), e.top(), window.innerWidth, window.innerHeight) }), Zo('leftAttr'), Zo('topAttr')]; const MO = La({ fields: OO, name: 'docking', active: CO, apis: kO }); const HO = { render(t, e, n, o, r) { let i; const a = zv.DOM; nO(t); const u = function () { qi(i.element(), 'position').is('fixed') || Gi(i.element(), { top: `${qa(Ne.fromDom(t.getBody())).top() - ru(i.element())}px`, left: `${qa(Ne.fromDom(t.getBody())).left()}px` }), MO.refresh(i) }; const c = function () { Wi(e.outerContainer.element(), 'display', 'flex'), a.addClass(t.getBody(), 'mce-edit-focus'), u(), MO.refresh(i) }; const s = function () { e.outerContainer && (Wi(e.outerContainer.element(), 'display', 'none'), a.removeClass(t.getBody(), 'mce-edit-focus')) }; return t.on('focus', () => { i ? c() : (i = e.outerContainer, ms(_r(), e.mothership), ms(_r(), e.uiMothership), JC.setToolbar(e.outerContainer, mC(t, n, { backstage: o })), JC.setMenubar(e.outerContainer, aC(t, n, o)), Gi(i.element(), { position: 'absolute', top: `${qa(Ne.fromDom(t.getBody())).top() - ru(i.element())}px`, left: `${qa(Ne.fromDom(t.getBody())).left()}px` }), u(), c(), t.on('nodeChange ResizeWindow', u), t.on('activate', c), t.on('deactivate', s), t.nodeChanged()) }), t.on('blur hide', s), { editorContainer: e.outerContainer.element().dom() } }, getBehaviours(e) { return [MO.config({ leftAttr: 'data-dock-left', topAttr: 'data-dock-top', contextual: { lazyContext(t) { return P.from(e).map((t) => Ne.fromDom(t.getBody())) }, fadeInClass: 'tox-toolbar-dock-fadein', fadeOutClass: 'tox-toolbar-dock-fadeout', transitionClass: 'tox-toolbar-dock-transition' } }), fm.config({})] } }; const VO = function (t, e) { return { anchor: 'makeshift', x: t, y: e } }; const EO = function (t, e) { let n; let o; let r; const i = zv.DOM.getPos(t); return n = e, o = i.x, r = i.y, VO(n.x + o, n.y + r) }; const AO = function (t, e) { return e.type === 'contextmenu' ? t.inline ? VO((o = e).pageX, o.pageY) : EO(t.getContentAreaContainer(), VO((n = e).clientX, n.clientY)) : TO(t); let n, o }; var TO = function (t) { return { anchor: 'selection', root: Ne.fromDom(t.selection.getNode()) } }; const BO = function (t) { return typeof t === 'string' ? t.split(/[ ,]/) : t }; const DO = function (t, e, n) { let o; let r; const i = t.ui.registry.getAll().contextMenus; return (o = t.settings, r = e, it(o, r) ? P.some(o[r]) : P.none()).map(BO).getOrThunk(() => T(BO(n), (t) => it(i, t))) }; const _O = function (t) { return t.settings.contextmenu_never_use_native || !1 }; const FO = function (t) { return DO(t, 'contextmenu', 'link image imagetools table spellchecker configurepermanentpen') }; const LO = function (t) { return x(t) ? t === '|' : t.type === 'separator' }; const IO = { type: 'separator' }; var RO = function (e) { if (x(e)) return e; switch (e.type) { case 'separator':return IO; case 'submenu':return { type: 'nestedmenuitem', text: e.text, icon: e.icon, getSubmenuItems() { const t = e.getSubmenuItems(); return x(t) ? t : E(t, RO) } }; default:return { type: 'menuitem', text: e.text, icon: e.icon, onAction: (n = e.onAction, function () { for (let t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return n() }) } } let n }; const NO = function (t, e) { if (e.length === 0) return t; const n = J(t).filter((t) => !LO(t)).fold(() => [], (t) => [IO]); return t.concat(n).concat(e).concat([IO]) }; const PO = function (d, t, m) { const h = sa(Xm.sketch({ dom: { tag: 'div' }, lazySink: t, onEscape() { return d.focus() } })); d.on('contextmenu', (t) => { if (e = d, !t.ctrlKey || _O(e)) { var e; let n; let r; let i; let o; const a = t.button !== 2 || t.target === d.getBody(); const u = a ? (n = d, { anchor: 'node', node: P.some(Ne.fromDom(n.selection.getNode())), root: Ne.fromDom(n.getBody()) }) : AO(d, t); const c = d.ui.registry.getAll(); const s = FO(d); const l = a ? d.selection.getStart(!0) : t.target; const f = (r = c.contextMenus, i = l, (o = D(s, (t, e) => { if (it(r, e)) { const n = r[e].update(i); if (x(n)) return NO(t, n.split(' ')); if (n.length > 0) { const o = E(n, RO); return NO(t, o) } return t } return t.concat([e]) }, [])).length > 0 && LO(o[o.length - 1]) && o.pop(), o); f.length > 0 && (t.preventDefault(), Xm.showMenuAt(h, u, { menu: { markers: Tg('normal') }, data: Hp(f, dg.CLOSE_ON_EXECUTE, m.providers) })) } }) }; const jO = function (t) { return /^[0-9\.]+(|px)$/i.test(`${t}`) ? P.some(parseInt(t, 10)) : P.none() }; const UO = function (t) { return k(t) ? `${t}px` : t }; const WO = 'data-initial-z-index'; const GO = function (t, e) { let n; t.getSystem().addToGui(e), an((n = e).element()).each((e) => { qi(e, 'z-index').each((t) => { Cn(e, WO, t) }), Wi(e, 'z-index', Xi(n.element(), 'z-index')) }) }; const XO = function (t) { an(t.element()).each((t) => { const e = Mn(t, WO); Hn(t, WO) ? Wi(t, 'z-index', e) : Ji(t, 'z-index'), Vn(t, WO) }), t.getSystem().removeFromGui(t) }; const YO = function (t, e, n, o) { return (r = t, i = e, a = r.element(), u = parseInt(Mn(a, i.leftAttr), 10), c = parseInt(Mn(a, i.topAttr), 10), isNaN(u) || isNaN(c) ? P.none() : P.some(Xa(u, c))).fold(() => n, (t) => vO(t.left() + o.left(), t.top() + o.top())); let r, i, a, u, c }; const qO = function (t, e, n, o, r, i) { let a; let u; let c; const s = YO(t, e, n, o); const l = JO(t, e, s, r, i); const f = lO(s, r, i); return a = e, u = f, c = t.element(), Cn(c, a.leftAttr, `${u.left()}px`), Cn(c, a.topAttr, `${u.top()}px`), l.fold(() => ({ coord: vO(f.left(), f.top()), extra: P.none() }), (t) => ({ coord: t.output(), extra: t.extra() })) }; const KO = function (t, e) { let n, o; n = e, o = t.element(), Vn(o, n.leftAttr), Vn(o, n.topAttr) }; var JO = function (t, e, g, v, p) { const n = e.getSnapPoints(t); return Mt(n, (t) => { let e; let n; let o; let r; let i; let a; let u; let c; let s; let l; let f; let d; let m; const h = t.sensor(); return e = g, n = h, o = t.range().left(), r = t.range().top(), u = fO(e, i = v, a = p), c = fO(n, i, a), Math.abs(u.left() - c.left()) <= o && Math.abs(u.top() - c.top()) <= r ? P.some({ output: U((s = t.output(), l = g, f = v, d = p, m = function (o, r) { return function (t, e) { const n = o(l, f, d); return r(t.getOr(n.left()), e.getOr(n.top())) } }, s.fold(m(dO, aO.offset), m(fO, aO.absolute), m(lO, aO.fixed)))), extra: t.extra }) : P.none() }) }; const $O = function (n, t, i, a, u, c) { return t.fold(() => { let t; let n; let o; const e = (t = i, n = c.left(), o = c.top(), t.fold((t, e) => aO.offset(t + n, e + o), (t, e) => aO.absolute(t + n, e + o), (t, e) => aO.fixed(t + n, e + o))); const r = lO(e, a, u); return vO(r.left(), r.top()) }, (e) => { const t = qO(n, e, i, c, a, u); return t.extra.each((t) => { e.onSensor(n, t) }), t.coord }) }; const QO = function (t, e, n) { let o; const r = e.getTarget(t.element()); if (e.repositionTarget) { const i = on(t.element()); const a = Ja(i); const u = iO(r, a); const c = qi(o = r, 'left').bind((n) => qi(o, 'top').bind((e) => qi(o, 'position').map((t) => (t === 'fixed' ? vO : hO)(parseInt(n, 10), parseInt(e, 10))))).getOrThunk(() => { const t = qa(o); return gO(t.left(), t.top()) }); const s = $O(t, e.snaps, c, a, u, n); const l = mO(s, 0, u); Gi(r, l) }e.onDrag(t, r, n) }; const ZO = fr('snaps', [Zo('getSnapPoints'), Sa('onSensor'), Zo('leftAttr'), Zo('topAttr'), dr('lazyViewport', () => { const t = Ja(); return { x: t.left, y: t.top, width: U(window.innerWidth), height: U(window.innerHeight), bottom: U(t.top() + window.innerHeight), right: U(t.left() + window.innerWidth) } })]); const tM = Object.freeze({ getData(t) { return P.from(Xa(t.x(), t.y())) }, getDelta(t, e) { return Xa(e.left() - t.left(), e.top() - t.top()) } }); const eM = [dr('useFixed', !1), Zo('blockerClass'), dr('getTarget', d), dr('onDrag', N), dr('repositionTarget', !0), Sa('onDrop'), ZO, Ma('dragger', { handlers(u, c) { return Pr([Wr(At(), (e, t) => { if (t.event().raw().button === 0) { t.stop(); let n; const o = { drop() { i() }, delayDrop() { a.schedule() }, forceDrop() { i() }, move(t) { a.cancel(), c.update(tM, t).each((t) => { QO(e, u, t) }) } }; const r = e.getSystem().build(xv.sketch({ dom: { styles: { left: '0px', top: '0px', width: '100%', height: '100%', position: 'fixed', 'z-index': '1000000000000000' }, classes: [u.blockerClass] }, events: (n = o, Pr([Wr(At(), n.forceDrop), Wr(Dt(), n.drop), Wr(Tt(), (t, e) => { n.move(e.event()) }), Wr(Bt(), n.delayDrop)])) })); var i = function () { XO(r), u.snaps.each((t) => { KO(e, t) }); const t = u.getTarget(e.element()); u.onDrop(e, t) }; var a = nv(i, 200); c.reset(), GO(e, r) } })]) } })]; const nM = Object.freeze({ getData(t) { let e; const n = t.raw().touches; return n.length === 1 ? (e = n[0], P.some(Xa(e.clientX, e.clientY))) : P.none() }, getDelta(t, e) { return Xa(e.left() - t.left(), e.top() - t.top()) } }); const oM = eM; const rM = [dr('useFixed', !1), dr('getTarget', d), dr('onDrag', N), dr('repositionTarget', !0), dr('onDrop', N), ZO, Ma('dragger', { handlers(o, r) { return Pr([Jr(Ht()), Wr(Vt(), (e, t) => { t.stop(), r.update(nM, t.event()).each((t) => { QO(e, o, t) }) }), Wr(Et(), (e, t) => { o.snaps.each((t) => { KO(e, t) }); const n = o.getTarget(e.element()); r.reset(), o.onDrop(e, n) })]) } })]; const iM = Object.freeze({ mouse: oM, touch: rM }); const aM = Object.freeze({ init() { let i = P.none(); const t = U({}); return xi({ readState: t, reset() { i = P.none() }, update(r, t) { return r.getData(t).bind((t) => { return e = r, n = t, o = i.map((t) => e.getDelta(t, n)), i = P.some(n), o; let e, n, o }) } }) } }); const uM = Ra({ branchKey: 'mode', branches: iM, name: 'dragging', active: { events(t, e) { return t.dragger.handlers(t, e) } }, extra: { snap: We(['sensor', 'range', 'output'], ['extra']) }, state: aM }); (Gk = Wk || (Wk = {}))[Gk.None = 0] = 'None', Gk[Gk.Both = 1] = 'Both', Gk[Gk.Vertical = 2] = 'Vertical'; let cM; let sM; let lM; let fM; let dM; const mM = function (t, e, n, o) { const r = t + e; const i = n.filter((t) => r < t); const a = o.filter((t) => t < r); return i.or(a).getOr(r) }; const hM = function (t, e, n, o, r) { let i; let a; const u = {}; return u.height = mM(o, e.top(), Cv(t), (i = t, P.from(i.getParam('max_height')).filter(k))), n === Wk.Both && (u.width = mM(r, e.left(), kv(t), (a = t, P.from(a.getParam('max_width')).filter(k)))), u }; const gM = function (t) { if (t.nodeType === 1) { if (t.nodeName === 'BR' || t.getAttribute('data-mce-bogus')) return !0; if (t.getAttribute('data-mce-type') === 'bookmark') return !0 } return !1 }; const vM = function (i, a) { return a.delimiter || (a.delimiter = '\xbb'), { dom: { tag: 'div', classes: ['tox-statusbar__path'] }, behaviours: _a([jd.config({ mode: 'flow', selector: 'div[role=button]' }), Xp.config({}), Yd.config({}), Am('elementPathEvents', [Qr((r, t) => { i.shortcuts.add('alt+F11', 'focus statusbar elementpath', () => jd.focusIn(r)), i.on('nodeChange', (t) => { let e; let o; const n = (function (t) { for (var e = [], n = t.length; n-- > 0;) { const o = t[n]; if (o.nodeType === 1 && !gM(o)) { const r = i.fire('ResolveName', { name: o.nodeName.toLowerCase(), target: o }); if (r.isDefaultPrevented() || e.push({ name: r.name, element: o }), r.isPropagationStopped()) break } } return e }(t.parents)); n.length > 0 && Yd.set(r, (e = E(n || [], (e, t) => qm.sketch({ dom: { tag: 'div', classes: ['tox-statusbar__path-item'], attributes: { role: 'button', 'data-index': t, 'tab-index': -1, 'aria-level': t + 1 }, innerHtml: e.name }, action(t) { i.focus(), i.selection.select(e.element), i.nodeChanged() } })), o = { dom: { tag: 'div', classes: ['tox-statusbar__path-divider'], attributes: { 'aria-hidden': !0 }, innerHtml: ` ${a.delimiter} ` } }, D(e.slice(1), (t, e) => { const n = t; return n.push(o), n.push(e), n }, [e[0]]))) }) })])]), components: [] } }; const pM = function (s, t) { let e; let n; let o; let r; let i; let a; let u; let c; let l; const f = function (c) { return { dom: { tag: 'div', classes: ['tox-statusbar__resize-handle'], attributes: { title: t.translate('Resize') }, innerHtml: Qm('resize-handle', t.icons) }, behaviours: _a([uM.config({ mode: 'mouse', repositionTarget: !1, onDrag(t, e, n) { let o, r, i, a, u; o = s, r = n, i = c, a = Ne.fromDom(o.getContainer()), u = hM(o, r, i, o.getContainer().scrollHeight, eu(a)), tt(u, (t, e) => Wi(a, e, `${t}px`)), QC(o) }, blockerClass: 'tox-blocker' })]) } }; return { dom: { tag: 'div', classes: ['tox-statusbar'] }, components: (l = [], s.getParam('elementpath', !0, 'boolean') && l.push(vM(s, {})), fe(s.settings.plugins, 'wordcount') && l.push((a = s, u = t, c = function (t, e, n) { return Yd.set(t, [aa(u.translate([`{0} ${n}`, e[n]]))]) }, { dom: { tag: 'span', classes: ['tox-statusbar__wordcount'] }, components: [], behaviours: _a([Yd.config({}), am.config({ store: { mode: 'memory', initialValue: { mode: 'words', count: { words: 0, characters: 0 } } } }), Am('wordcount-events', [Wr(jt(), (t) => { const e = am.getValue(t); const n = e.mode === 'words' ? 'characters' : 'words'; am.setValue(t, { mode: n, count: e.count }), c(t, e.count, n) }), Qr((n) => { a.on('wordCountUpdate', (t) => { const e = am.getValue(n).mode; am.setValue(n, { mode: e, count: t.wordCount }), c(n, t.wordCount, e) }) })])]) })), s.getParam('branding', !0, 'boolean') && l.push({ dom: { tag: 'span', classes: ['tox-statusbar__branding'], innerHtml: Lh.translate(['Powered by {0}', '<a href="https://www.tiny.cloud/?utm_campaign=editor_referral&amp;utm_medium=poweredby&amp;utm_source=tinymce&amp;utm_content=v5" rel="noopener" target="_blank" tabindex="-1">Tiny</a>']) } }), r = l.length > 0 ? [{ dom: { tag: 'div', classes: ['tox-statusbar__text-container'] }, components: l }] : [], n = !fe((e = s).settings.plugins, 'autoresize'), i = !1 === (o = e.getParam('resize', n)) ? Wk.None : o === 'both' ? Wk.Both : Wk.Vertical, i !== Wk.None && r.push(f(i)), r) } }; const bM = function (f) { let t; let e; const n = f.getParam('inline', !1, 'boolean'); const s = n ? HO : rO; let o = P.none(); const r = Lh.isRtl() ? { attributes: { dir: 'rtl' } } : {}; const l = sa({ dom: Gn({ tag: 'div', classes: ['tox', 'tox-silver-sink', 'tox-tinymce-aux'] }, r), behaviours: _a([is.config({ useFixed: !1 })]) }); const i = Km({ dom: { tag: 'div', classes: ['tox-anchorbar'] } }); const d = LS(l, f, () => o.bind((t) => i.getOpt(t)).getOrDie('Could not find a toolbar element')); const m = function () { return ft.value(l) }; const a = JC.parts().menubar({ dom: { tag: 'div', classes: ['tox-menubar'] }, getSink: m, providers: d.shared.providers, onEscape() { f.focus() } }); const u = JC.parts().toolbar({ dom: { tag: 'div', classes: ['tox-toolbar'] }, onEscape() { f.focus() } }); const c = JC.parts().socket({ dom: { tag: 'div', classes: ['tox-edit-area'] } }); const h = JC.parts().sidebar({ dom: { tag: 'div', classes: ['tox-sidebar'] } }); const g = f.getParam('statusbar', !0, 'boolean') && !n ? P.some(pM(f, d.shared.providers)) : P.none(); const v = { dom: { tag: 'div', classes: ['tox-sidebar-wrap'] }, components: [c, h] }; const p = (e = (t = f).getParam('toolbar'), (O(e) ? e.length > 0 : !1 !== t.getParam('toolbar', !0, 'boolean')) || Ov(f).isSome()); const b = !1 !== f.getParam('menubar', !0, 'boolean'); const y = R([b ? [a] : [], p ? [u] : [], [i.asSpec()], n ? [] : [v]]); const x = R([[{ dom: { tag: 'div', classes: ['tox-editor-container'] }, components: y }], n ? [] : g.toArray()]); const w = Gn({ role: 'application' }, Lh.isRtl() ? { dir: 'rtl' } : {}); const z = sa(JC.sketch({ dom: { tag: 'div', classes: ['tox', 'tox-tinymce'].concat(n ? ['tox-tinymce-inline'] : []), styles: { visibility: 'hidden' }, attributes: w }, components: x, behaviours: _a(s.getBehaviours(f).concat([jd.config({ mode: 'cyclic', selector: '.tox-menubar, .tox-toolbar, .tox-sidebar--sliding-open, .tox-statusbar__path' })])) })); o = P.some(z), f.shortcuts.add('alt+F9', 'focus menubar', () => { JC.focusMenubar(z) }), f.shortcuts.add('alt+F10', 'focus toolbar', () => { JC.focusToolbar(z) }); const S = wv(z); const k = wv(l); gC(f, S, k); const C = function (t) { let e; const n = zv.DOM; const o = f.getParam('width', n.getStyle(t, 'width')); const r = (e = f).getParam('height', Math.max(e.getElement().offsetHeight, 200)); const i = kv(f); const a = Cv(f); const u = jO(o).bind((e) => UO(i.map((t) => Math.max(e, t)))).getOr(UO(o)); const c = jO(r).bind((e) => a.map((t) => Math.max(e, t))).getOr(r); const s = UO(u); if (Ki('div', 'width', s) && Wi(z.element(), 'width', s), !f.inline) { const l = UO(c); Ki('div', 'height', l) ? Wi(z.element(), 'height', l) : Wi(z.element(), 'height', '200px') } return c }; return { mothership: S, uiMothership: k, backstage: d, renderUI() { PO(f, m, d.shared); const t = f.ui.registry.getAll(); const e = t.buttons; const n = t.menuItems; const o = t.contextToolbars; const r = { menuItems: n, buttons: e, menus: f.settings.menu ? et(f.settings.menu, (t) => vt(t, { items: t.items })) : {}, menubar: f.settings.menubar, toolbar: Ov(f).getOr(f.getParam('toolbar', !0)), sidebar: f.sidebars ? f.sidebars : [] }; hC(f, o, l, { backstage: d }); const i = f.getElement(); const a = C(i); const u = { mothership: S, uiMothership: k, outerContainer: z }; const c = { targetNode: i, height: a }; return s.render(f, u, r, d, c) }, getUi() { return { channels: { broadcastAll: k.broadcast, broadcastOn: k.broadcastOn, register() {} } } } } }; const yM = function (t, e) { return function () { t.execCommand('mceToggleFormat', !1, e) } }; const xM = function (n) { const t = [{ type: 'menuitem', text: 'Left', icon: 'align-left', onAction: yM(n, 'alignleft') }, { type: 'menuitem', text: 'Center', icon: 'align-center', onAction: yM(n, 'aligncenter') }, { type: 'menuitem', text: 'Right', icon: 'align-right', onAction: yM(n, 'alignright') }, { type: 'menuitem', text: 'Justify', icon: 'align-justify', onAction: yM(n, 'alignjustify') }]; n.ui.registry.addNestedMenuItem('align', { text: 'Align', icon: 'align-left', getSubmenuItems() { return t } }); const e = function (e) { return function (t) { return n.formatter ? n.formatter.formatChanged(e.name, t.setActive) : n.on('init', () => { n.formatter.formatChanged(e.name, t.setActive) }), function () {} } }; zz.each([{ name: 'alignleft', text: 'Align left', cmd: 'JustifyLeft', icon: 'align-left' }, { name: 'aligncenter', text: 'Align center', cmd: 'JustifyCenter', icon: 'align-center' }, { name: 'alignright', text: 'Align right', cmd: 'JustifyRight', icon: 'align-right' }, { name: 'alignjustify', text: 'Justify', cmd: 'JustifyFull', icon: 'align-justify' }], (t) => { n.ui.registry.addToggleButton(t.name, { tooltip: t.text, onAction() { return n.execCommand(t.cmd) }, icon: t.icon, onSetup: e(t) }) }); const o = { name: 'alignnone', text: 'No alignment', cmd: 'JustifyNone', icon: 'align-justify' }; n.ui.registry.addButton(o.name, { tooltip: o.text, onAction() { return n.execCommand(o.cmd) }, icon: o.icon, onSetup: e(o) }) }; const wM = function (t, e) { return function () { t.execCommand('mceToggleFormat', !1, e) } }; const zM = function (i, a) { return function (e) { let t, n, o, r; return n = a, o = function (t) { e.setActive(t) }, r = function (t) { o(t, n) }, (t = i).formatter ? t.formatter.formatChanged(n, r) : t.on('init', () => { t.formatter.formatChanged(n, r) }), function () {} } }; const SM = function (t) { let e, n, o; e = t, zz.each([{ name: 'bold', text: 'Bold', icon: 'bold' }, { name: 'italic', text: 'Italic', icon: 'italic' }, { name: 'underline', text: 'Underline', icon: 'underline' }, { name: 'strikethrough', text: 'Strikethrough', icon: 'strike-through' }, { name: 'subscript', text: 'Subscript', icon: 'subscript' }, { name: 'superscript', text: 'Superscript', icon: 'superscript' }], (t) => { e.ui.registry.addToggleButton(t.name, { tooltip: t.text, icon: t.icon, onSetup: zM(e, t.name), onAction: wM(e, t.name) }) }), n = t, zz.each([{ name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut' }, { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy' }, { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste' }, { name: 'help', text: 'Help', action: 'mceHelp', icon: 'help' }, { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all' }, { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document' }, { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting' }, { name: 'remove', text: 'Remove', action: 'Delete', icon: 'remove' }], (t) => { n.ui.registry.addButton(t.name, { tooltip: t.text, icon: t.icon, onAction() { return n.execCommand(t.action) } }) }), o = t, zz.each([{ name: 'blockquote', text: 'Blockquote', action: 'mceBlockQuote', icon: 'quote' }], (t) => { o.ui.registry.addToggleButton(t.name, { tooltip: t.text, icon: t.icon, onAction() { return o.execCommand(t.action) }, onSetup: zM(o, t.name) }) }) }; const kM = function (t) { let e; SM(t), e = t, zz.each([{ name: 'bold', text: 'Bold', action: 'Bold', icon: 'bold', shortcut: 'Meta+B' }, { name: 'italic', text: 'Italic', action: 'Italic', icon: 'italic', shortcut: 'Meta+I' }, { name: 'underline', text: 'Underline', action: 'Underline', icon: 'underline', shortcut: 'Meta+U' }, { name: 'strikethrough', text: 'Strikethrough', action: 'Strikethrough', icon: 'strike-through', shortcut: '' }, { name: 'subscript', text: 'Subscript', action: 'Subscript', icon: 'subscript', shortcut: '' }, { name: 'superscript', text: 'Superscript', action: 'Superscript', icon: 'superscript', shortcut: '' }, { name: 'removeformat', text: 'Clear formatting', action: 'RemoveFormat', icon: 'remove-formatting', shortcut: '' }, { name: 'newdocument', text: 'New document', action: 'mceNewDocument', icon: 'new-document', shortcut: '' }, { name: 'cut', text: 'Cut', action: 'Cut', icon: 'cut', shortcut: 'Meta+X' }, { name: 'copy', text: 'Copy', action: 'Copy', icon: 'copy', shortcut: 'Meta+C' }, { name: 'paste', text: 'Paste', action: 'Paste', icon: 'paste', shortcut: 'Meta+V' }, { name: 'selectall', text: 'Select all', action: 'SelectAll', icon: 'select-all', shortcut: 'Meta+A' }], (t) => { e.ui.registry.addMenuItem(t.name, { text: t.text, icon: t.icon, shortcut: t.shortcut, onAction() { return e.execCommand(t.action) } }) }), e.ui.registry.addMenuItem('codeformat', { text: 'Code', icon: 'sourcecode', onAction: wM(e, 'code') }) }; const CM = function (t, e, n) { const o = function () { return !!e.undoManager && e.undoManager[n]() }; const r = function () { t.setDisabled(e.readonly || !o()) }; return t.setDisabled(!o()), e.on('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', r), function () { return e.off('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', r) } }; const OM = function (t) { let e, n; (e = t).ui.registry.addMenuItem('undo', { text: 'Undo', icon: 'undo', shortcut: 'Meta+Z', onSetup(t) { return CM(t, e, 'hasUndo') }, onAction() { return e.execCommand('undo') } }), e.ui.registry.addMenuItem('redo', { text: 'Redo', icon: 'redo', shortcut: 'Meta+Y', onSetup(t) { return CM(t, e, 'hasRedo') }, onAction() { return e.execCommand('redo') } }), (n = t).ui.registry.addButton('undo', { tooltip: 'Undo', icon: 'undo', onSetup(t) { return CM(t, n, 'hasUndo') }, onAction() { return n.execCommand('undo') } }), n.ui.registry.addButton('redo', { tooltip: 'Redo', icon: 'redo', onSetup(t) { return CM(t, n, 'hasRedo') }, onAction() { return n.execCommand('redo') } }) }; const MM = function (t) { let e, n; (e = t).ui.registry.addButton('visualaid', { tooltip: 'Visual aids', text: 'Visual aids', onAction() { return e.execCommand('mceToggleVisualAid') } }), (n = t).ui.registry.addToggleMenuItem('visualaid', { text: 'Visual aids', onSetup(t) { return (function (e, t) { e.setActive(t.hasVisual); const n = function (t) { e.setActive(t.hasVisual) }; return t.on('VisualAid', n), function () { return t.off('VisualAid', n) } }(t, n)) }, onAction() { n.execCommand('mceToggleVisualAid') } }) }; const HM = function (t) { let r; (r = t).ui.registry.addButton('outdent', { tooltip: 'Decrease indent', icon: 'outdent', onSetup(t) { return e = t, o = function () { e.setDisabled(!n.queryCommandState('outdent')) }, (n = r).on('NodeChange', o), function () { return n.off('NodeChange', o) }; let e, n, o }, onAction() { return r.execCommand('outdent') } }), r.ui.registry.addButton('indent', { tooltip: 'Increase indent', icon: 'indent', onAction() { return r.execCommand('indent') } }) }; const VM = function (t) { xM(t), kM(t), OM(t), Ab.register(t), MM(t), HM(t) }; const EM = function (t, e) { const n = P.from(Mn(t, 'id')).fold(() => { const t = Un('dialog-label'); return Cn(e, 'id', t), t }, d); Cn(t, 'aria-labelledby', n) }; const AM = U([Zo('lazySink'), ur('dragBlockClass'), dr('useTabstopAt', U(!0)), dr('eventOrder', {}), Es('modalBehaviours', [jd]), ka('onExecute'), Oa('onEscape')]); const TM = { sketch: d }; const BM = U([al({ name: 'draghandle', overrides(t, e) { return { behaviours: _a([uM.config({ mode: 'mouse', getTarget(t) { return fa(t, '[role="dialog"]').getOr(t) }, blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: \n${xo(e, null, 2)}`).message) })]) } } }), rl({ schema: [Zo('dom')], name: 'title' }), rl({ factory: TM, schema: [Zo('dom')], name: 'close' }), rl({ factory: TM, schema: [Zo('dom')], name: 'body' }), rl({ factory: TM, schema: [Zo('dom')], name: 'footer' }), il({ factory: { sketch(t, e) { return Gn({}, t, { dom: e.dom, components: e.components }) } }, schema: [dr('dom', { tag: 'div', styles: { position: 'fixed', left: '0px', top: '0px', right: '0px', bottom: '0px' } }), dr('components', [])], name: 'blocker' })]); const DM = Bl({ name: 'ModalDialog', configFields: AM(), partFields: BM(), factory(o, t, e, r) { const u = Un('alloy.dialog.busy'); const c = Un('alloy.dialog.idle'); const s = _a([jd.config({ mode: 'special', onTab() { return P.some(!0) }, onShiftTab() { return P.some(!0) } }), fm.config({})]); const n = Un('modal-events'); const i = Gn({}, o.eventOrder, { 'alloy.system.attached': [n].concat(o.eventOrder['alloy.system.attached'] || []) }); return { uid: o.uid, dom: o.dom, components: t, apis: { show(i) { const t = o.lazySink(i).getOrDie(); const a = Ct(P.none()); const e = r.blocker(); const n = t.getSystem().build(Gn({}, e, { components: e.components.concat([la(i)]), behaviours: _a([Am('dialog-blocker-events', [Wr(c, (t, e) => { Hn(i.element(), 'aria-busy') && (Vn(i.element(), 'aria-busy'), a.get().each((t) => Yd.remove(i, t))) }), Wr(u, (t, e) => { Cn(i.element(), 'aria-busy', 'true'); const n = e.event().getBusySpec(); a.get().each((t) => { Yd.remove(i, t) }); const o = n(i, s); const r = t.getSystem().build(o); a.set(P.some(r)), Yd.append(i, la(r)), r.hasConfigured(jd) && jd.focusIn(r) })])]) })); cs(t, n), jd.focusIn(i) }, hide(e) { an(e.element()).each((t) => { e.getSystem().getByDom(t).each((t) => { fs(t) }) }) }, getBody(t) { return yl(t, o, 'body') }, getFooter(t) { return yl(t, o, 'footer') }, setIdle(t) { kr(t, c) }, setBusy(t, e) { Cr(t, u, { getBusySpec: e }) } }, eventOrder: i, domModification: { attributes: { role: 'dialog', 'aria-modal': 'true' } }, behaviours: Ts(o.modalBehaviours, [Yd.config({}), jd.config({ mode: 'cyclic', onEnter: o.onExecute, onEscape: o.onEscape, useTabstopAt: o.useTabstopAt }), Am(n, [Qr((t) => { EM(t.element(), yl(t, o, 'title').element()) })])]) } }, apis: { show(t, e) { t.show(e) }, hide(t, e) { t.hide(e) }, getBody(t, e) { return t.getBody(e) }, getFooter(t, e) { return t.getFooter(e) }, setBusy(t, e, n) { t.setBusy(e, n) }, setIdle(t, e) { t.setIdle(e) } } }); const _M = [er('type'), er('text'), nr('level', ['info', 'warn', 'error', 'success']), er('icon'), dr('url', '')]; const FM = [er('type'), er('text'), pr('primary', !1), _o('name', 'name', Zn(() => Un('button-name')), Ko), sr('icon')]; const LM = [er('type'), er('name'), er('label')]; const IM = ['checked', 'unchecked', 'indeterminate']; const RM = Ro((t) => M(IM, t) ? ft.value(t) : ft.error(`Checkbox data: can only be a string of either "${IM.join('" | "')}" `)); const NM = [er('type'), er('name'), sr('label')]; const PM = NM; const jM = Ko; const UM = NM; const WM = Ko; const GM = NM.concat([dr('flex', !1)]); const XM = Eo(Io); const YM = NM.concat([pr('sandboxed', !0), pr('flex', !1)]); const qM = Ko; const KM = NM.concat([sr('placeholder')]); const JM = Ko; const $M = NM.concat([ir('items', [er('text'), er('value')]), hr('size', 1)]); const QM = Ko; const ZM = NM.concat([pr('constrain', !0)]); const tH = Vo([er('width'), er('height')]); const eH = NM.concat([dr('flex', !1), sr('placeholder')]); const nH = Ko; const oH = NM.concat([vr('filetype', 'file', ['image', 'media', 'file'])]); const rH = Vo([er('value'), dr('meta', {})]); const iH = NM.concat([er('type'), gr('tag', 'textarea'), or('init')]); const aH = Ko; const uH = [er('type'), er('html')]; const cH = NM.concat([tr('currentState', Vo([Zo('blob'), er('url')]))]); const sH = NM.concat([dr('columns', 1)]); const lH = (cM = [er('value'), sr('text'), sr('icon')], Bo(cM)); const fH = [er('type'), ar('header', Ko), ar('cells', Eo(Ko))]; const dH = function (e) { return _o('items', 'items', $n(), Eo(Ro((t) => Po(`Checking item of ${e}`, mH, t).fold((t) => ft.error(Wo(t)), (t) => ft.value(t))))) }; var mH = Go('type', { alertbanner: _M, bar: (dM = dH('bar'), [er('type'), dM]), button: FM, checkbox: LM, colorinput: PM, colorpicker: UM, dropzone: GM, grid: (lM = dH('grid'), [er('type'), (fM = 'columns', tr(fM, qo)), lM]), iframe: YM, input: KM, selectbox: $M, sizeinput: ZM, textarea: eH, urlinput: oH, customeditor: iH, htmlpanel: uH, imagetools: cH, collection: sH, label: (sM = dH('label'), [er('type'), er('label'), sM]), table: fH }); const hH = [er('type'), ar('items', mH)]; const gH = [er('title'), ar('items', mH)]; const vH = [er('type'), ir('tabs', gH)]; const pH = Vo([nr('type', ['submit', 'cancel', 'custom']), _o('name', 'name', Zn(() => Un('button-name')), Ko), er('text'), sr('icon'), vr('align', 'end', ['start', 'end']), pr('primary', !1), pr('disabled', !1)]); const bH = Vo([er('title'), tr('body', Go('type', { panel: hH, tabpanel: vH })), gr('size', 'normal'), ar('buttons', pH), dr('initialData', {}), br('onAction', N), br('onChange', N), br('onSubmit', N), br('onClose', N), br('onCancel', N), dr('onTabChange', N), ur('readyWhen')]); var yH = function (t) { return w(t) ? [t].concat(j(rt(t), yH)) : O(t) ? j(t, yH) : [] }; const xH = function (t) { return x(t.type) && x(t.name) }; const wH = { checkbox: RM, colorinput: jM, colorpicker: WM, dropzone: XM, input: JM, iframe: qM, sizeinput: tH, selectbox: QM, size: tH, textarea: nH, urlinput: rH, customeditor: aH, collection: lH }; const zH = function (t) { const e = j(T(yH(t), xH), (e) => { return (t = e, P.from(wH[t.type])).fold(() => [], (t) => [tr(e.name, t)]); let t }); return Vo(e) }; const SH = function (t) { return { internalDialog: jo(Po('dialog', bH, t)), dataValidator: zH(t), initialData: t.initialData } }; const kH = { open(t, e) { const n = SH(e); return t(n.internalDialog, n.initialData, n.dataValidator) }, redial(t) { return SH(t) } }; const CH = Un('update-dialog'); const OH = Un('update-title'); const MH = Un('update-body'); const HH = Un('update-footer'); const VH = function (t) { const n = []; const o = {}; return tt(t, (t, e) => { t.fold(() => { n.push(e) }, (t) => { o[e] = t }) }), n.length > 0 ? ft.error(n) : ft.value(o) }; const EH = Tl({ name: 'TabButton', configFields: [dr('uid', undefined), Zo('value'), _o('dom', 'dom', to((t) => ({ attributes: { role: 'tab', id: Un('aria'), 'aria-selected': 'false' } })), Xo()), ur('action'), dr('domModification', {}), Es('tabButtonBehaviours', [fm, jd, am]), Zo('view')], factory(t, e) { return { uid: t.uid, dom: t.dom, components: t.components, events: Ym(t.action), behaviours: Ts(t.tabButtonBehaviours, [fm.config({}), jd.config({ mode: 'execution', useSpace: !0, useEnter: !0 }), am.config({ store: { mode: 'memory', initialValue: t.value } })]), domModification: t.domModification } } }); const AH = U([Zo('tabs'), Zo('dom'), dr('clickToDismiss', !1), Es('tabbarBehaviours', [Jl, jd]), wa(['tabClass', 'selectedClass'])]); const TH = ul({ factory: EH, name: 'tabs', unit: 'tab', overrides(o, t) { const r = function (t, e) { Jl.dehighlight(t, e), Cr(t, Ie(), { tabbar: t, button: e }) }; const i = function (t, e) { Jl.highlight(t, e), Cr(t, Le(), { tabbar: t, button: e }) }; return { action(t) { const e = t.getSystem().getByUid(o.uid).getOrDie(); const n = Jl.isHighlighted(e, t); (n && o.clickToDismiss ? r : n ? N : i)(e, t) }, domModification: { classes: [o.markers.tabClass] } } } }); const BH = U([TH]); const DH = Bl({ name: 'Tabbar', configFields: AH(), partFields: BH(), factory(t, e, n, o) { return { uid: t.uid, dom: t.dom, components: e, 'debug.sketcher': 'Tabbar', domModification: { attributes: { role: 'tablist' } }, behaviours: Ts(t.tabbarBehaviours, [Jl.config({ highlightClass: t.markers.selectedClass, itemClass: t.markers.tabClass, onHighlight(t, e) { Cn(e.element(), 'aria-selected', 'true') }, onDehighlight(t, e) { Cn(e.element(), 'aria-selected', 'false') } }), jd.config({ mode: 'flow', getInitial(t) { return Jl.getHighlighted(t).map((t) => t.element()) }, selector: `.${t.markers.tabClass}`, executeOnMove: !0 })]) } } }); const _H = Tl({ name: 'Tabview', configFields: [Es('tabviewBehaviours', [Yd])], factory(t, e) { return { uid: t.uid, dom: t.dom, behaviours: Ts(t.tabviewBehaviours, [Yd.config({})]), domModification: { attributes: { role: 'tabpanel' } } } } }); const FH = U([dr('selectFirst', !0), Sa('onChangeTab'), Sa('onDismissTab'), dr('tabs', []), Es('tabSectionBehaviours', [])]); const LH = rl({ factory: DH, schema: [Zo('dom'), rr('markers', [Zo('tabClass'), Zo('selectedClass')])], name: 'tabbar', defaults(t) { return { tabs: t.tabs } } }); const IH = rl({ factory: _H, name: 'tabview' }); const RH = U([LH, IH]); const NH = Bl({ name: 'TabSection', configFields: FH(), partFields: RH(), factory(i, t, e, n) { const o = function (t, e) { bl(t, i, 'tabbar').each((t) => { e(t).each(Or) }) }; return { uid: i.uid, dom: i.dom, components: t, behaviours: As(i.tabSectionBehaviours), events: Pr(R([i.selectFirst ? [Qr((t, e) => { o(t, Jl.getFirst) })] : [], [Wr(Le(), (t, e) => { let o; let r; const n = e.event().button(); o = n, r = am.getValue(o), bl(o, i, 'tabview').each((n) => { _(i.tabs, (t) => t.value === r).each((t) => { const e = t.view(); Cn(n.element(), 'aria-labelledby', Mn(o.element(), 'id')), Yd.set(n, e), i.onChangeTab(n, o, e) }) }) }), Wr(Ie(), (t, e) => { const n = e.event().button(); i.onDismissTab(t, n) })]])), apis: { getViewItems(t) { return bl(t, i, 'tabview').map((t) => Yd.contents(t)).getOr([]) }, showTab(t, n) { o(t, (e) => { const t = Jl.getCandidates(e); return _(t, (t) => am.getValue(t) === n).filter((t) => !Jl.isHighlighted(e, t)) }) } } } }, apis: { getViewItems(t, e) { return t.getViewItems(e) }, showTab(t, e, n) { t.showTab(e, n) } } }); const PH = function (t) { return K((e = t, n = function (t, e) { return e < t ? -1 : t < e ? 1 : 0 }, (o = G.call(e, 0)).sort(n), o)); let e, n, o }; const jH = function (a) { return { smartTabHeight: { extraEvents: [Qr((t) => { da(t.element(), '[role="tabpanel"]').each((n) => { let e; Wi(n, 'visibility', 'hidden'), t.getSystem().getByDom(n).toOption().bind((t) => { let o; let r; let i; const e = (r = n, i = t, E(o = a, (t, e) => { Yd.set(i, o[e].view()); const n = r.dom().getBoundingClientRect(); return Yd.set(i, []), n.height })); return PH(e) }).each((t) => { Wi(n, 'height', `${t}px`) }), Ji(n, 'visibility'), e = t, K(a).each((t) => NH.showTab(e, t.value)) }) }), Wr(_v, (t, e) => { da(t.element(), '[role="tabpanel"]').each((e) => { const t = sf(); Wi(e, 'visibility', 'hidden'); const n = qi(e, 'height').map((t) => parseInt(t, 10)); Ji(e, 'height'); const o = e.dom().getBoundingClientRect().height; n.forall((t) => t < o) ? Wi(e, 'height', `${o}px`) : n.each((t) => { Wi(e, 'height', `${t}px`) }), Ji(e, 'visibility'), t.each(cf) }) })], selectFirst: !1 }, naiveTabHeight: { extraEvents: [], selectFirst: !0 } } }; const UH = 'send-data-to-section'; const WH = 'send-data-to-view'; const GH = function (t, d) { return { dom: { tag: 'div', classes: ['tox-dialog__content-js'] }, components: [], behaviours: _a([Ux(0), gk.config({ channel: MH, updateState(t, e) { return P.some({ isTabPanel() { return e.body.type === 'tabpanel' } }) }, renderComponents(t) { switch (t.body.type) { case 'tabpanel':return [(r = { tabs: t.body.tabs }, i = d, a = Ct({}), u = function (t) { const e = am.getValue(t); const n = VH(e).getOr({}); const o = a.get(); const r = gt(o, n); a.set(r) }, c = function (t) { const e = a.get(); am.setValue(t, e) }, s = Ct(null), l = E(r.tabs, (t) => ({ value: t.title, dom: { tag: 'div', classes: ['tox-dialog__body-nav-item'], innerHtml: i.shared.providers.translate(t.title) }, view() { return [Bx.sketch((e) => ({ dom: { tag: 'div', classes: ['tox-form'] }, components: E(t.items, (t) => tS(e, t, i)), formBehaviours: _a([jd.config({ mode: 'acyclic', useTabstopAt: m(rw) }), Am('TabView.form.events', [Qr(c), Zr(u)]), Ua.config({ channels: zt([{ key: UH, value: { onReceive: u } }, { key: WH, value: { onReceive: c } }]) })]) }))] } })), f = jH(l).smartTabHeight, NH.sketch({ dom: { tag: 'div', classes: ['tox-dialog__body'] }, onChangeTab(t, e, n) { const o = am.getValue(e); Cr(t, Dv, { title: o, oldTitle: s.get() }), s.set(o) }, tabs: l, components: [NH.parts().tabbar({ dom: { tag: 'div', classes: ['tox-dialog__body-nav'] }, components: [DH.parts().tabs({})], markers: { tabClass: 'tox-tab', selectedClass: 'tox-dialog__body-nav-item--active' }, tabbarBehaviours: _a([Xp.config({})]) }), NH.parts().tabview({ dom: { tag: 'div', classes: ['tox-dialog__body-content'] } })], selectFirst: f.selectFirst, tabSectionBehaviours: _a([Am('tabpanel', f.extraEvents), jd.config({ mode: 'acyclic' }), Ll.config({ find(t) { return K(NH.getViewItems(t)) } }), am.config({ store: { mode: 'manual', getValue(t) { return t.getSystem().broadcastOn([UH], {}), a.get() }, setValue(t, e) { a.set(e), t.getSystem().broadcastOn([WH], {}) } } })]) }))]; default:return [(n = { items: t.body.items }, o = d, e = Km(Bx.sketch((e) => ({ dom: { tag: 'div', classes: ['tox-dialog__body-content'] }, components: E(n.items, (t) => tS(e, t, o)) }))), { dom: { tag: 'div', classes: ['tox-dialog__body'] }, components: [e.asSpec()], behaviours: _a([jd.config({ mode: 'acyclic', useTabstopAt: m(rw) }), jx(e), Kx(e, { postprocess(t) { return VH(t).fold((t) => console.error(t), {}, (t) => t) } })]) })] } let n, o, e, r, i, a, u, c, s, l, f }, initialData: t })]) } }; const XH = function (o, n) { const t = function (t, r) { return Wr(t, (n, o) => { e(n, (t, e) => { r(t, o.event(), n) }) }) }; var e = function (e, n) { gk.getState(e).get().each((t) => { n(t.internalDialog, e) }) }; return [qr(Ft(), iw), t(Av, (t) => t.onSubmit(o())), t(Mv, (t, e) => { t.onChange(o(), { name: e.name() }) }), t(Ev, (t, e) => { t.onAction(o(), { name: e.name(), value: e.value() }) }), t(Dv, (t, e) => { t.onTabChange(o(), e.title()) }), t(Hv, (t) => { n.onClose(), t.onClose() }), t(Vv, (t, e, n) => { t.onCancel(o()), kr(n, Hv) }), Zr((t) => { const e = o(); am.setValue(t, e.getData()) }), Wr(Bv, (t, e) => n.onUnblock()), Wr(Tv, (t, e) => n.onBlock(e.event()))] }; const YH = function (t, e) { const n = (function (t, e) { for (var n = [], o = [], r = 0, i = t.length; r < i; r++) { const a = t[r]; (e(a, r, t) ? n : o).push(a) } return { pass: n, fail: o } }(e.map((t) => t.footerButtons).getOr([]), (t) => t.align === 'start')); const o = function (t, e) { return xv.sketch({ dom: { tag: 'div', classes: [`tox-dialog__footer-${t}`] }, components: E(e, (t) => t.memento.asSpec()) }) }; return [o('start', n.pass), o('end', n.fail)] }; const qH = function (t, i) { return { dom: Fh('<div class="tox-dialog__footer"></div>'), components: [], behaviours: _a([gk.config({ channel: HH, initialData: t, updateState(t, e) { const r = E(e.buttons, (t) => { let e; let n; const o = Km((n = i, oz(e = t, e.type, n))); return { name: t.name, align: t.align, memento: o } }); return P.some({ lookupByName(t, e) { return n = t, o = e, _(r, (t) => t.name === o).bind((t) => t.memento.getOpt(n)); let n, o }, footerButtons: r }) }, renderComponents: YH })]) } }; const KH = function (t) { return qm.sketch({ dom: { tag: 'button', classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'], attributes: { type: 'button', 'aria-label': t.translate('Close'), title: t.translate('Close') } }, components: [{ dom: { tag: 'div', classes: ['tox-icon'], innerHtml: '<svg width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M17.953 7.453L13.422 12l4.531 4.547-1.406 1.406L12 13.422l-4.547 4.531-1.406-1.406L10.578 12 6.047 7.453l1.406-1.406L12 10.578l4.547-4.531z" fill-rule="evenodd"></path></svg>' } }], action(t) { kr(t, Vv) } }) }; const JH = function (t, e, n) { const o = function (t) { return [aa(n.translate(t.title))] }; return { dom: { tag: 'div', classes: ['tox-dialog__title'], attributes: Gn({}, e.map((t) => ({ id: t })).getOr({})) }, components: o(t), behaviours: _a([gk.config({ channel: OH, renderComponents: o })]) } }; const $H = function (e, n) { if (e.getRoot().getSystem().isConnected()) { const o = Ll.getCurrent(e.getFormWrapper()).getOr(e.getFormWrapper()); return Bx.getField(o, n).fold(() => { const t = e.getFooter(); return gk.getState(t).get().bind((t) => t.lookupByName(o, n)) }, (t) => P.some(t)) } return P.none() }; const QH = function (c, o) { const t = function (t) { const e = c.getRoot(); e.getSystem().isConnected() && t(e) }; var s = { getData() { const t = c.getRoot(); const e = t.getSystem().isConnected() ? c.getFormWrapper() : t; return am.getValue(e) }, setData(u) { t((t) => { let e; let n; const o = s.getData(); const r = vt(o, u); const i = (e = r, n = c.getRoot(), gk.getState(n).get().map((t) => jo(Po('data', t.dataValidator, e))).getOr(e)); const a = c.getFormWrapper(); am.setValue(a, i) }) }, disable(t) { $H(c, t).each(og.disable) }, enable(t) { $H(c, t).each(og.enable) }, focus(t) { $H(c, t).each(fm.focus) }, block(e) { t((t) => { Cr(t, Tv, { message: e }) }) }, unblock() { t((t) => { kr(t, Bv) }) }, showTab(n) { t((t) => { const e = c.getBody(); gk.getState(e).get().exists((t) => t.isTabPanel()) && Ll.getCurrent(e).each((t) => { NH.showTab(t, n) }) }) }, redial(n) { t((t) => { const e = o(n); t.getSystem().broadcastOn([CH], e), t.getSystem().broadcastOn([OH], e.internalDialog), t.getSystem().broadcastOn([MH], e.internalDialog), t.getSystem().broadcastOn([HH], e.internalDialog), s.setData(e.initialData) }) }, close() { t((t) => { kr(t, Hv) }) } }; return s }; const ZH = function (t, e, n) { let o; let r; let i; let a; let u; let c; let s; let l; let f; let d; let m; const h = (r = { title: n.shared.providers.translate(t.internalDialog.title), draggable: !0 }, i = n.shared.providers, a = DM.parts().title(JH(r, P.none(), i)), u = DM.parts().draghandle({ dom: Fh('<div class="tox-dialog__draghandle"></div>') }), c = DM.parts().close(KH(i)), s = [a].concat(r.draggable ? [u] : []).concat([c]), xv.sketch({ dom: Fh('<div class="tox-dialog__header"></div>'), components: s })); const g = (l = { body: t.internalDialog.body }, f = n, DM.parts().body(GH(l, f))); const v = (d = { buttons: t.internalDialog.buttons }, m = n.shared.providers, DM.parts().footer(qH(d, m))); const p = XH(() => x, { onClose() { return e.closeWindow() }, onBlock(n) { DM.setBusy(y, (t, e) => ({ dom: { tag: 'div', classes: ['tox-dialog__busy-spinner'], attributes: { 'aria-label': n.message() }, styles: { left: '0px', right: '0px', bottom: '0px', top: '0px', position: 'absolute' } }, behaviours: e, components: [{ dom: Fh('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] })) }, onUnblock() { DM.setIdle(y) } }); const b = t.internalDialog.size !== 'normal' ? t.internalDialog.size === 'large' ? 'tox-dialog--width-lg' : 'tox-dialog--width-md' : []; var y = sa(DM.sketch({ lazySink: n.shared.getSink, onEscape(t) { return kr(t, Vv), P.some(!0) }, useTabstopAt(t) { return !rw(t) && (yn(t) !== 'button' || Mn(t, 'disabled') !== 'disabled') }, modalBehaviours: _a([gk.config({ channel: CH, updateState(t, e) { return P.some(e) }, initialData: t }), fm.config({}), Am('execute-on-form', p.concat([$r(Ft(), (t, e) => { jd.focusIn(t) })])), Qx({})]), eventOrder: (o = {}, o[Se()] = ['execute-on-form'], o[Te()] = ['reflecting', 'execute-on-form'], o), dom: { tag: 'div', classes: ['tox-dialog'].concat(b), styles: { position: 'relative' } }, components: [h, g, v], dragBlockClass: 'tox-dialog-wrap', parts: { blocker: { dom: Fh('<div class="tox-dialog-wrap"></div>'), components: [{ dom: { tag: 'div', classes: ['tox-dialog-wrap__backdrop'] } }] } } })); var x = QH({ getRoot() { return y }, getBody() { return DM.getBody(y) }, getFooter() { return DM.getFooter(y) }, getFormWrapper() { const t = DM.getBody(y); return Ll.getCurrent(t).getOr(t) } }, e.redial); return { dialog: y, instanceApi: x } }; const tV = function (t, e, n) { let o; let r; let i; let a; let u; let c; let s; let l; const f = Un('dialog-label'); const d = Km((i = { title: t.internalDialog.title, draggable: !0 }, a = f, u = n.shared.providers, xv.sketch({ dom: Fh('<div class="tox-dialog__header"></div>'), components: [JH(i, P.some(a), u), KH(u)], containerBehaviours: _a([uM.config({ mode: 'mouse', blockerClass: 'blocker', getTarget(t) { return ma(t, '[role="dialog"]').getOrDie() }, snaps: { getSnapPoints() { return [] }, leftAttr: 'data-drag-left', topAttr: 'data-drag-top' } })]) }))); const m = Km((c = { body: t.internalDialog.body }, GH(c, n))); const h = Km((s = { buttons: t.internalDialog.buttons }, l = n.shared.providers, qH(s, l))); const g = XH(() => p, { onBlock() {}, onUnblock() {}, onClose() { return e.closeWindow() } }); const v = sa({ dom: { tag: 'div', classes: ['tox-dialog'], attributes: (o = { role: 'dialog' }, o['aria-labelledby'] = f, o) }, eventOrder: (r = {}, r[ze()] = [gk.name(), Ua.name()], r[Se()] = ['execute-on-form'], r[Te()] = ['reflecting', 'execute-on-form'], r), behaviours: _a([jd.config({ mode: 'cyclic', onEscape(t) { return kr(t, Hv), P.some(!0) }, useTabstopAt(t) { return !rw(t) && (yn(t) !== 'button' || Mn(t, 'disabled') !== 'disabled') } }), gk.config({ channel: CH, updateState(t, e) { return P.some(e) }, initialData: t }), Am('execute-on-form', g), Qx({})]), components: [d.asSpec(), m.asSpec(), h.asSpec()] }); var p = QH({ getRoot() { return v }, getFooter() { return h.get(v) }, getBody() { return m.get(v) }, getFormWrapper() { const t = m.get(v); return Ll.getCurrent(t).getOr(t) } }, e.redial); return { dialog: v, instanceApi: p } }; const eV = function (t, e) { return DM.parts().close(qm.sketch({ dom: { tag: 'button', classes: ['tox-button', 'tox-button--icon', 'tox-button--naked'], attributes: { type: 'button', 'aria-label': e.translate('Close') } }, action: t, buttonBehaviours: _a([Xp.config({})]) })) }; const nV = function () { return DM.parts().title({ dom: { tag: 'div', classes: ['tox-dialog__title'], innerHtml: '', styles: { display: 'none' } } }) }; const oV = function (t, e) { return DM.parts().body({ dom: { tag: 'div', classes: ['tox-dialog__body', 'todo-tox-fit'] }, components: [{ dom: Fh(`<p>${e.translate(t)}</p>`) }] }) }; const rV = function (t) { return DM.parts().footer({ dom: { tag: 'div', classes: ['tox-dialog__footer'] }, components: t }) }; const iV = function (t, e) { return [xv.sketch({ dom: { tag: 'div', classes: ['tox-dialog__footer-start'] }, components: t }), xv.sketch({ dom: { tag: 'div', classes: ['tox-dialog__footer-end'] }, components: e })] }; const aV = function (n) { return DM.sketch({ lazySink: n.lazySink, onEscape() { return n.onCancel(), P.some(!0) }, dom: { tag: 'div', classes: ['tox-dialog'].concat(n.extraClasses) }, components: [{ dom: { tag: 'div', classes: ['tox-dialog__header'] }, components: [n.partSpecs.title, n.partSpecs.close] }, n.partSpecs.body, n.partSpecs.footer], parts: { blocker: { dom: Fh('<div class="tox-dialog-wrap"></div>'), components: [{ dom: { tag: 'div', classes: ['tox-dialog-wrap__backdrop'] } }] } }, modalBehaviours: _a([Am('basic-dialog-events', [Wr(Vv, (t, e) => { n.onCancel() }), Wr(Av, (t, e) => { n.onSubmit() })])]) }) }; const uV = function (c) { let a; let u; const n = (a = c.backstage.shared, { open(t, e) { const n = function () { DM.hide(r), e() }; const o = Km(oz({ name: 'close-alert', text: 'OK', primary: !0, icon: P.none() }, 'cancel', a.providers)); var r = sa(aV({ lazySink() { return a.getSink() }, partSpecs: { title: nV(), close: eV(() => { n() }, a.providers), body: oV(t, a.providers), footer: rV(iV([], [o.asSpec()])) }, onCancel() { return n() }, onSubmit: N, extraClasses: ['tox-alert-dialog'] })); DM.show(r); const i = o.get(r); fm.focus(i) } }); const o = (u = c.backstage.shared, { open(t, e) { const n = function (t) { DM.hide(i), e(t) }; const o = Km(oz({ name: 'yes', text: 'Yes', primary: !0, icon: P.none() }, 'submit', u.providers)); const r = oz({ name: 'no', text: 'No', primary: !0, icon: P.none() }, 'cancel', u.providers); var i = sa(aV({ lazySink() { return u.getSink() }, partSpecs: { title: nV(), close: eV(() => { n(!1) }, u.providers), body: oV(t, u.providers), footer: rV(iV([], [r, o.asSpec()])) }, onCancel() { return n(!1) }, onSubmit() { return n(!0) }, extraClasses: ['tox-confirm-dialog'] })); DM.show(i); const a = o.get(i); fm.focus(a) } }); const r = function (t, i) { return kH.open((t, e, n) => { const o = e; var r = ZH({ dataValidator: n, initialData: o, internalDialog: t }, { redial: kH.redial, closeWindow() { DM.hide(r.dialog), i(r.instanceApi) } }, c.backstage); return DM.show(r.dialog), r.instanceApi.setData(o), r.instanceApi }, t) }; const i = function (t, a, u) { return kH.open((t, e, n) => { const o = jo(Po('data', n, e)); var r = tV({ dataValidator: n, initialData: o, internalDialog: t }, { redial: kH.redial, closeWindow() { Xm.hide(i), u(r.instanceApi) } }, c.backstage); var i = sa(Xm.sketch({ lazySink: c.backstage.shared.getSink, dom: { tag: 'div', classes: [] }, fireDismissalEventInstead: {}, inlineBehaviours: _a([Am('window-manager-inline-events', [Wr(De(), (t, e) => { kr(r.dialog, Vv) })])]) })); return Xm.showAt(i, a, la(r.dialog)), r.instanceApi.setData(o), jd.focusIn(r.dialog), r.instanceApi }, t) }; return { open(t, e, n) { return e !== undefined && e.inline === 'toolbar' ? i(t, c.backstage.shared.anchors.toolbar(), n) : e !== undefined && e.inline === 'cursor' ? i(t, c.backstage.shared.anchors.cursor(), n) : r(t, n) }, alert(t, e) { n.open(t, () => { e() }) }, close(t) { t.close() }, confirm(t, e) { o.open(t, (t) => { e(t) }) } } }; Wn.add('silver', (t) => { const e = bM(t); const n = e.mothership; const o = e.uiMothership; const r = e.backstage; const i = e.renderUI; const a = e.getUi; VM(t), Nn(Un('silver-demo'), n), Nn(Un('silver-ui-demo'), o), qg(t, r.shared); const u = uV({ backstage: r }); return { renderUI: i, getWindowManagerImpl: U(u), getNotificationManagerImpl() { return oh(t, { backstage: r }, o) }, ui: a() } }), function IV() {}
}())
