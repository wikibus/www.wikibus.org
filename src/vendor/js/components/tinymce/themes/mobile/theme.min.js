!(function (n) {
  var y = function () { return (y = Object.assign || function (n) { for (var e, t = 1, r = arguments.length; t < r; t++) for (const o in e = arguments[t])Object.prototype.hasOwnProperty.call(e, o) && (n[o] = e[o]); return n }).apply(this, arguments) }; function c(n, e) { const t = {}; for (var r in n)Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]); if (n != null && typeof Object.getOwnPropertySymbols === 'function') { let o = 0; for (r = Object.getOwnPropertySymbols(n); o < r.length; o++)e.indexOf(r[o]) < 0 && (t[r[o]] = n[r[o]]) } return t } const x = function () { for (let n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e] }; const p = function (t, r) { return function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; return t(r.apply(null, n)) } }; const h = function (n) { return function () { return n } }; const b = function (n) { return n }; function l(r) { for (var o = [], n = 1; n < arguments.length; n++)o[n - 1] = arguments[n]; return function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; const t = o.concat(n); return r.apply(null, t) } } let e; let t; let r; let o; let i; let u; let a; const S = function (t) { return function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; return !t.apply(null, n) } }; const f = function (n) { return function () { throw new Error(n) } }; const s = function (n) { return n() }; const d = h(!1); const m = h(!0); const g = d; const v = m; const w = function () { return O }; var O = (o = { fold(n, e) { return n() }, is: g, isSome: g, isNone: v, getOr: r = function (n) { return n }, getOrThunk: t = function (n) { return n() }, getOrDie(n) { throw new Error(n || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: r, orThunk: t, map: w, ap: w, each() {}, bind: w, flatten: w, exists: g, forall: v, filter: w, equals: e = function (n) { return n.isNone() }, equals_: e, toArray() { return [] }, toString: h('none()') }, Object.freeze && Object.freeze(o), o); var T = function (t) { const n = function () { return t }; const e = function () { return o }; const r = function (n) { return n(t) }; var o = { fold(n, e) { return e(t) }, is(n) { return t === n }, isSome: v, isNone: g, getOr: n, getOrThunk: n, getOrDie: n, getOrNull: n, getOrUndefined: n, or: e, orThunk: e, map(n) { return T(n(t)) }, ap(n) { return n.fold(w, (n) => T(n(t))) }, each(n) { n(t) }, bind: r, flatten: n, exists: r, forall: r, filter(n) { return n(t) ? o : O }, equals(n) { return n.is(t) }, equals_(n, e) { return n.fold(g, (n) => e(t, n)) }, toArray() { return [t] }, toString() { return `some(${t})` } }; return o }; const k = { some: T, none: w, from(n) { return n === null || n === undefined ? O : T(n) } }; const E = Object.keys; const C = Object.hasOwnProperty; const D = function (n, e) { for (let t = E(n), r = 0, o = t.length; r < o; r++) { const i = t[r]; e(n[i], i, n) } }; const M = function (n, r) { return A(n, (n, e, t) => ({ k: e, v: r(n, e, t) })) }; var A = function (r, o) { const i = {}; return D(r, (n, e) => { const t = o(n, e, r); i[t.k] = t.v }), i }; const I = function (n, t) { const r = []; return D(n, (n, e) => { r.push(t(n, e)) }), r }; const B = function (n, e) { return C.call(n, e) }; const R = h('touchstart'); const F = h('touchmove'); const V = h('touchend'); const N = h('mousedown'); const H = h('mousemove'); const j = h('mouseup'); const z = h('mouseover'); const L = h('keydown'); const P = h('keyup'); const U = h('input'); const G = h('change'); const $ = h('click'); const W = h('transitionend'); const _ = h('selectstart'); const q = function (t) { let r; let o = !1; return function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; return o || (o = !0, r = t.apply(null, n)), r } }; const X = function (n, e) { const t = (function (n, e) { for (let t = 0; t < n.length; t++) { const r = n[t]; if (r.test(e)) return r } return undefined }(n, e)); if (!t) return { major: 0, minor: 0 }; const r = function (n) { return Number(e.replace(t, `$${n}`)) }; return K(r(1), r(2)) }; const Y = function () { return K(0, 0) }; var K = function (n, e) { return { major: n, minor: e } }; const J = { nu: K, detect(n, e) { const t = String(e).toLowerCase(); return n.length === 0 ? Y() : X(n, t) }, unknown: Y }; const Q = 'Edge'; const Z = 'Chrome'; const nn = 'Opera'; const en = 'Firefox'; const tn = function (n, e) { return function () { return e === n } }; const rn = function (n) { const e = n.current; return { current: e, version: n.version, isEdge: tn(Q, e), isChrome: tn(Z, e), isIE: tn('IE', e), isOpera: tn(nn, e), isFirefox: tn(en, e), isSafari: tn('Safari', e) } }; const on = { unknown() { return rn({ current: undefined, version: J.unknown() }) }, nu: rn, edge: h(Q), chrome: h(Z), ie: h('IE'), opera: h(nn), firefox: h(en), safari: h('Safari') }; const un = 'Windows'; const an = 'Android'; const cn = 'Solaris'; const fn = 'FreeBSD'; const sn = function (n, e) { return function () { return e === n } }; const ln = function (n) { const e = n.current; return { current: e, version: n.version, isWindows: sn(un, e), isiOS: sn('iOS', e), isAndroid: sn(an, e), isOSX: sn('OSX', e), isLinux: sn('Linux', e), isSolaris: sn(cn, e), isFreeBSD: sn(fn, e) } }; const dn = { unknown() { return ln({ current: undefined, version: J.unknown() }) }, nu: ln, windows: h(un), ios: h('iOS'), android: h(an), linux: h('Linux'), osx: h('OSX'), solaris: h(cn), freebsd: h(fn) }; const mn = function (e) { return function (n) { return (function (n) { if (n === null) return 'null'; const e = typeof n; return e === 'object' && Array.prototype.isPrototypeOf(n) ? 'array' : e === 'object' && String.prototype.isPrototypeOf(n) ? 'string' : e }(n)) === e } }; const gn = mn('string'); const pn = mn('object'); const vn = mn('array'); const hn = mn('boolean'); const bn = mn('function'); const yn = mn('number'); const xn = (i = Array.prototype.indexOf) === undefined ? function (n, e) { return Mn(n, e) } : function (n, e) { return i.call(n, e) }; const wn = function (n, e) { return xn(n, e) > -1 }; const Sn = function (n, e) { for (var t = n.length, r = new Array(t), o = 0; o < t; o++) { const i = n[o]; r[o] = e(i, o, n) } return r }; const On = function (n, e) { for (let t = 0, r = n.length; t < r; t++)e(n[t], t, n) }; const Tn = function (n, e) { for (var t = [], r = 0, o = n.length; r < o; r++) { const i = n[r]; e(i, r, n) && t.push(i) } return t }; const kn = function (n, e, t) { return (function (n, e) { for (let t = n.length - 1; t >= 0; t--)e(n[t], t, n) }(n, (n) => { t = e(t, n) })), t }; const En = function (n, e, t) { return On(n, (n) => { t = e(t, n) }), t }; const Cn = function (n, e) { for (let t = 0, r = n.length; t < r; t++) { const o = n[t]; if (e(o, t, n)) return k.some(o) } return k.none() }; const Dn = function (n, e) { for (let t = 0, r = n.length; t < r; t++) if (e(n[t], t, n)) return k.some(t); return k.none() }; var Mn = function (n, e) { for (let t = 0, r = n.length; t < r; ++t) if (n[t] === e) return t; return -1 }; const An = Array.prototype.push; const In = function (n) { for (var e = [], t = 0, r = n.length; t < r; ++t) { if (!Array.prototype.isPrototypeOf(n[t])) throw new Error(`Arr.flatten item ${t} was not an array, input: ${n}`); An.apply(e, n[t]) } return e }; const Bn = function (n, e) { const t = Sn(n, e); return In(t) }; const Rn = function (n, e) { for (let t = 0, r = n.length; t < r; ++t) if (!0 !== e(n[t], t, n)) return !1; return !0 }; const Fn = Array.prototype.slice; const Vn = function (n) { const e = Fn.call(n, 0); return e.reverse(), e }; const Nn = function (n) { return [n] }; const Hn = (bn(Array.from) && Array.from, function (n, e) { const t = String(e).toLowerCase(); return Cn(n, (n) => n.search(t)) }); const jn = function (n, t) { return Hn(n, t).map((n) => { const e = J.detect(n.versionRegexes, t); return { current: n.name, version: e } }) }; const zn = function (n, t) { return Hn(n, t).map((n) => { const e = J.detect(n.versionRegexes, t); return { current: n.name, version: e } }) }; const Ln = function (n, e) { return n.indexOf(e) !== -1 }; const Pn = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const Un = function (e) { return function (n) { return Ln(n, e) } }; const Gn = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search(n) { return Ln(n, 'edge/') && Ln(n, 'chrome') && Ln(n, 'safari') && Ln(n, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Pn], search(n) { return Ln(n, 'chrome') && !Ln(n, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search(n) { return Ln(n, 'msie') || Ln(n, 'trident') } }, { name: 'Opera', versionRegexes: [Pn, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Un('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Un('firefox') }, { name: 'Safari', versionRegexes: [Pn, /.*?cpu os ([0-9]+)_([0-9]+).*/], search(n) { return (Ln(n, 'safari') || Ln(n, 'mobile/')) && Ln(n, 'applewebkit') } }]; const $n = [{ name: 'Windows', search: Un('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search(n) { return Ln(n, 'iphone') || Ln(n, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: Un('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: Un('os x'), versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: Un('linux'), versionRegexes: [] }, { name: 'Solaris', search: Un('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: Un('freebsd'), versionRegexes: [] }]; const Wn = { browsers: h(Gn), oses: h($n) }; const _n = function (n) { let e; let t; let r; let o; let i; let u; let a; let c; let f; let s; let l; const d = Wn.browsers(); const m = Wn.oses(); const g = jn(d, n).fold(on.unknown, on.nu); const p = zn(m, n).fold(dn.unknown, dn.nu); return { browser: g, os: p, deviceType: (t = g, r = n, o = (e = p).isiOS() && !0 === /ipad/i.test(r), i = e.isiOS() && !o, u = e.isAndroid() && e.version.major === 3, a = e.isAndroid() && e.version.major === 4, c = o || u || a && !0 === /mobile/i.test(r), f = e.isiOS() || e.isAndroid(), s = f && !c, l = t.isSafari() && e.isiOS() && !1 === /safari/i.test(r), { isiPad: h(o), isiPhone: h(i), isTablet: h(c), isPhone: h(s), isTouch: h(f), isAndroid: e.isAndroid, isiOS: e.isiOS, isWebView: h(l) }) } }; const qn = { detect: q(() => { const n = navigator.userAgent; return _n(n) }) }; const Xn = { tap: h('alloy.tap') }; const Yn = h('alloy.focus'); const Kn = h('alloy.blur.post'); const Jn = h('alloy.receive'); const Qn = h('alloy.execute'); const Zn = h('alloy.focus.item'); const ne = Xn.tap; const ee = qn.detect().deviceType.isTouch() ? Xn.tap : $; const te = h('alloy.longpress'); const re = h('alloy.system.init'); const oe = h('alloy.system.attached'); const ie = h('alloy.system.detached'); const ue = h('alloy.focusmanager.shifted'); const ae = function (n, e) { le(n, n.element(), e, {}) }; const ce = function (n, e, t) { le(n, n.element(), e, t) }; const fe = function (n) { ae(n, Qn()) }; const se = function (n, e, t) { le(n, e, t, {}) }; var le = function (n, e, t, r) { const o = y({ target: e }, r); n.getSystem().triggerEvent(t, e, M(o, h)) }; const de = function (n) { if (n === null || n === undefined) throw new Error('Node cannot be null or undefined'); return { dom: h(n) } }; const me = { fromHtml(n, e) { const t = (e || document).createElement('div'); if (t.innerHTML = n, !t.hasChildNodes() || t.childNodes.length > 1) throw console.error('HTML does not have a single root node', n), new Error('HTML must have a single root node'); return de(t.childNodes[0]) }, fromTag(n, e) { const t = (e || document).createElement(n); return de(t) }, fromText(n, e) { const t = (e || document).createTextNode(n); return de(t) }, fromDom: de, fromPoint(n, e, t) { const r = n.dom(); return k.from(r.elementFromPoint(e, t)).map(de) } }; const ge = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE); const pe = (Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE); const ve = Node.TEXT_NODE; const he = (Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, function (n) { return n.dom().nodeName.toLowerCase() }); const be = function (e) { return function (n) { return n.dom().nodeType === e } }; const ye = be(pe); const xe = be(ve); const we = function (n) { const e = xe(n) ? n.dom().parentNode : n.dom(); return e !== undefined && e !== null && e.ownerDocument.body.contains(e) }; const Se = q(() => Oe(me.fromDom(document))); var Oe = function (n) { const e = n.dom().body; if (e === null || e === undefined) throw new Error('Body is not available yet'); return me.fromDom(e) }; const Te = function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; return function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; if (e.length !== t.length) throw new Error(`Wrong number of arguments to struct. Expected "[${e.length}]", got ${t.length} arguments`); const r = {}; return On(e, (n, e) => { r[n] = h(t[e]) }), r } }; const ke = function (n) { return n.slice(0).sort() }; const Ee = function (e, n) { if (!vn(n)) throw new Error(`The ${e} fields must be an array. Was: ${n}.`); On(n, (n) => { if (!gn(n)) throw new Error(`The value ${n} in the ${e} fields was not a string.`) }) }; const Ce = function (o, i) { let t; const u = o.concat(i); if (u.length === 0) throw new Error('You must specify at least one required or optional field.'); return Ee('required', o), Ee('optional', i), t = ke(u), Cn(t, (n, e) => e < t.length - 1 && n === t[e + 1]).each((n) => { throw new Error(`The field: ${n} occurs more than once in the combined fields: [${t.join(', ')}].`) }), function (e) { const t = E(e); Rn(o, (n) => wn(t, n)) || (function (n, e) { throw new Error(`All required keys (${ke(n).join(', ')}) were not specified. Specified keys were: ${ke(e).join(', ')}.`) }(o, t)); const n = Tn(t, (n) => !wn(u, n)); n.length > 0 && (function (n) { throw new Error(`Unsupported keys for object: ${ke(n).join(', ')}`) }(n)); const r = {}; return On(o, (n) => { r[n] = h(e[n]) }), On(i, (n) => { r[n] = h(Object.prototype.hasOwnProperty.call(e, n) ? k.some(e[n]) : k.none()) }), r } }; const De = typeof window !== 'undefined' ? window : Function('return this;')(); const Me = function (n, e) { return (function (n, e) { for (var t = e !== undefined && e !== null ? e : De, r = 0; r < n.length && t !== undefined && t !== null; ++r)t = t[n[r]]; return t }(n.split('.'), e)) }; const Ae = { getOrDie(n, e) { const t = Me(n, e); if (t === undefined || t === null) throw `${n} not available on this browser`; return t } }; const Ie = pe; const Be = ge; const Re = function (n, e) { const t = n.dom(); if (t.nodeType !== Ie) return !1; if (t.matches !== undefined) return t.matches(e); if (t.msMatchesSelector !== undefined) return t.msMatchesSelector(e); if (t.webkitMatchesSelector !== undefined) return t.webkitMatchesSelector(e); if (t.mozMatchesSelector !== undefined) return t.mozMatchesSelector(e); throw new Error('Browser lacks native selectors') }; const Fe = function (n) { return n.nodeType !== Ie && n.nodeType !== Be || n.childElementCount === 0 }; const Ve = function (n, e) { const t = e === undefined ? document : e.dom(); return Fe(t) ? [] : Sn(t.querySelectorAll(n), me.fromDom) }; const Ne = function (n, e) { const t = e === undefined ? document : e.dom(); return Fe(t) ? k.none() : k.from(t.querySelector(n)).map(me.fromDom) }; const He = function (n, e) { return n.dom() === e.dom() }; const je = (qn.detect().browser.isIE(), function (n) { return me.fromDom(n.dom().ownerDocument) }); const ze = function (n) { const e = n.dom(); return k.from(e.parentNode).map(me.fromDom) }; const Le = function (n) { const e = n.dom(); return Sn(e.childNodes, me.fromDom) }; const Pe = function (n, e) { const t = n.dom().childNodes; return k.from(t[e]).map(me.fromDom) }; const Ue = (Te('element', 'offset'), function (e, t) { ze(e).each((n) => { n.dom().insertBefore(t.dom(), e.dom()) }) }); const Ge = function (n, e) { let t; (t = n.dom(), k.from(t.nextSibling).map(me.fromDom)).fold(() => { ze(n).each((n) => { We(n, e) }) }, (n) => { Ue(n, e) }) }; const $e = function (e, t) { Pe(e, 0).fold(() => { We(e, t) }, (n) => { e.dom().insertBefore(t.dom(), n.dom()) }) }; var We = function (n, e) { n.dom().appendChild(e.dom()) }; const _e = function (e, n) { On(n, (n) => { We(e, n) }) }; const qe = function (n) { n.dom().textContent = '', On(Le(n), (n) => { Xe(n) }) }; var Xe = function (n) { const e = n.dom(); e.parentNode !== null && e.parentNode.removeChild(e) }; var Ye = function (n) { ae(n, ie()); const e = n.components(); On(e, Ye) }; var Ke = function (n) { const e = n.components(); On(e, Ke), ae(n, oe()) }; const Je = function (n, e) { Qe(n, e, We) }; var Qe = function (n, e, t) { n.getSystem().addToWorld(e), t(n.element(), e.element()), we(n.element()) && Ke(e), n.syncComponents() }; const Ze = function (n) { Ye(n), Xe(n.element()), n.getSystem().removeFromWorld(n) }; const nt = function (e) { const n = ze(e.element()).bind((n) => e.getSystem().getByDom(n).fold(k.none, k.some)); Ze(e), n.each((n) => { n.syncComponents() }) }; const et = function (n, e, t) { t(n, e.element()); const r = Le(e.element()); On(r, (n) => { e.getByDom(n).each(Ke) }) }; var tt = function (t) { return { is(n) { return t === n }, isValue: m, isError: d, getOr: h(t), getOrThunk: h(t), getOrDie: h(t), or(n) { return tt(t) }, orThunk(n) { return tt(t) }, fold(n, e) { return e(t) }, map(n) { return tt(n(t)) }, mapError(n) { return tt(t) }, each(n) { n(t) }, bind(n) { return n(t) }, exists(n) { return n(t) }, forall(n) { return n(t) }, toOption() { return k.some(t) } } }; var rt = function (t) { return { is: d, isValue: d, isError: m, getOr: b, getOrThunk(n) { return n() }, getOrDie() { return f(String(t))() }, or(n) { return n }, orThunk(n) { return n() }, fold(n, e) { return n(t) }, map(n) { return rt(t) }, mapError(n) { return rt(n(t)) }, each: x, bind(n) { return rt(t) }, exists: d, forall: m, toOption: k.none } }; const ot = { value: tt, error: rt }; const it = function (u) { if (!vn(u)) throw new Error('cases must be an array'); if (u.length === 0) throw new Error('there must be at least one case'); const a = []; const t = {}; return On(u, (n, r) => { const e = E(n); if (e.length !== 1) throw new Error('one and only one name per case'); const o = e[0]; const i = n[o]; if (t[o] !== undefined) throw new Error(`duplicate key detected:${o}`); if (o === 'cata') throw new Error('cannot have a case named cata (sorry)'); if (!vn(i)) throw new Error('case arguments must be an array'); a.push(o), t[o] = function () { const n = arguments.length; if (n !== i.length) throw new Error(`Wrong number of arguments to case ${o}. Expected ${i.length} (${i}), got ${n}`); for (var t = new Array(n), e = 0; e < t.length; e++)t[e] = arguments[e]; return { fold() { if (arguments.length !== u.length) throw new Error(`Wrong number of arguments to fold. Expected ${u.length}, got ${arguments.length}`); return arguments[r].apply(null, t) }, match(n) { const e = E(n); if (a.length !== e.length) throw new Error(`Wrong number of arguments to match. Expected: ${a.join(',')}\nActual: ${e.join(',')}`); if (!Rn(a, (n) => wn(e, n))) throw new Error(`Not all branches were specified when using match. Specified: ${e.join(', ')}\nRequired: ${a.join(', ')}`); return n[o].apply(null, t) }, log(n) { console.log(n, { constructors: a, constructor: o, params: t }) } } } }), t }; const ut = Object.prototype.hasOwnProperty; const at = function (u) { return function () { for (var n = new Array(arguments.length), e = 0; e < n.length; e++)n[e] = arguments[e]; if (n.length === 0) throw new Error("Can't merge zero objects"); for (var t = {}, r = 0; r < n.length; r++) { const o = n[r]; for (const i in o)ut.call(o, i) && (t[i] = u(t[i], o[i])) } return t } }; var ct = at((n, e) => pn(n) && pn(e) ? ct(n, e) : e); const ft = at((n, e) => e); const st = it([{ strict: [] }, { defaultedThunk: ['fallbackThunk'] }, { asOption: [] }, { asDefaultedOptionThunk: ['fallbackThunk'] }, { mergeWithThunk: ['baseThunk'] }]); const lt = function (n) { return st.defaultedThunk(h(n)) }; const dt = st.strict; const mt = st.asOption; const gt = st.defaultedThunk; const pt = (st.asDefaultedOptionThunk, st.mergeWithThunk); const vt = function (e) { return function (n) { return B(n, e) ? k.from(n[e]) : k.none() } }; const ht = function (n, e) { return vt(e)(n) }; const bt = function (n, e) { const t = {}; return t[n] = e, t }; const yt = (it([{ bothErrors: ['error1', 'error2'] }, { firstError: ['error1', 'value2'] }, { secondError: ['value1', 'error2'] }, { bothValues: ['value1', 'value2'] }]), function (n) { return vt(n) }); const xt = function (n, e) { return t = n, r = e, function (n) { return B(n, t) ? n[t] : r }; let t, r }; const wt = function (n, e) { return ht(n, e) }; const St = function (n, e) { return bt(n, e) }; const Ot = function (n) { return e = {}, On(n, (n) => { e[n.key] = n.value }), e; let e }; const Tt = function (n, e) { let t; let r; let o; let i; let u; const a = (t = [], r = [], On(n, (n) => { n.fold((n) => { t.push(n) }, (n) => { r.push(n) }) }), { errors: t, values: r }); return a.errors.length > 0 ? (u = a.errors, p(ot.error, In)(u)) : (i = e, (o = a.values).length === 0 ? ot.value(i) : ot.value(ct(i, ft.apply(undefined, o)))) }; const kt = function (n, e) { return B(t = n, r = e) && t[r] !== undefined && t[r] !== null; let t, r }; (a = u || (u = {}))[a.Error = 0] = 'Error', a[a.Value = 1] = 'Value'; let Et; let Ct; const Dt = function (n, e, t) { return n.stype === u.Error ? e(n.serror) : t(n.svalue) }; const Mt = function (n) { return { stype: u.Value, svalue: n } }; const At = function (n) { return { stype: u.Error, serror: n } }; const It = function (n) { return n.fold(At, Mt) }; const Bt = function (n) { return Dt(n, ot.error, ot.value) }; const Rt = Mt; const Ft = function (n) { const e = []; const t = []; return On(n, (n) => { Dt(n, (n) => t.push(n), (n) => e.push(n)) }), { values: e, errors: t } }; const Vt = At; const Nt = function (n, e) { return n.stype === u.Value ? e(n.svalue) : n }; const Ht = function (n, e) { return n.stype === u.Error ? e(n.serror) : n }; const jt = function (n, e) { return n.stype === u.Value ? { stype: u.Value, svalue: e(n.svalue) } : n }; const zt = function (n, e) { return n.stype === u.Error ? { stype: u.Error, serror: e(n.serror) } : n }; const Lt = function (n) { return p(Vt, In)(n) }; const Pt = function (n, e) { let t; let r; const o = Ft(n); return o.errors.length > 0 ? Lt(o.errors) : (t = o.values, r = e, t.length > 0 ? Rt(ct(r, ft.apply(undefined, t))) : Rt(r)) }; const Ut = function (n) { const e = Ft(n); return e.errors.length > 0 ? Lt(e.errors) : Rt(e.values) }; const Gt = it([{ setOf: ['validator', 'valueType'] }, { arrOf: ['valueType'] }, { objOf: ['fields'] }, { itemOf: ['validator'] }, { choiceOf: ['key', 'branches'] }, { thunk: ['description'] }, { func: ['args', 'outputSchema'] }]); const $t = it([{ field: ['name', 'presence', 'type'] }, { state: ['name'] }]); const Wt = function () { return Ae.getOrDie('JSON') }; const _t = function (n, e, t) { return Wt().stringify(n, e, t) }; const qt = function (n) { return pn(n) && E(n).length > 100 ? ' removed due to size' : _t(n, null, 2) }; const Xt = function (n, e) { return Vt([{ path: n, getErrorInfo: e }]) }; const Yt = it([{ field: ['key', 'okey', 'presence', 'prop'] }, { state: ['okey', 'instantiator'] }]); const Kt = function (t, r, o) { return ht(r, o).fold(() => { return n = o, e = r, Xt(t, () => `Could not find valid *strict* value for "${n}" in ${qt(e)}`); let n, e }, Rt) }; const Jt = function (n, e, t) { const r = ht(n, e).fold(() => t(n), b); return Rt(r) }; const Qt = function (a, c, n, f) { return n.fold((o, t, n, r) => { const i = function (n) { const e = r.extract(a.concat([o]), f, n); return jt(e, (n) => bt(t, f(n))) }; const u = function (n) { return n.fold(() => { const n = bt(t, f(k.none())); return Rt(n) }, (n) => { const e = r.extract(a.concat([o]), f, n); return jt(e, (n) => bt(t, f(k.some(n)))) }) }; return n.fold(() => Nt(Kt(a, c, o), i), (n) => Nt(Jt(c, o, n), i), () => Nt(Rt(ht(c, o)), u), (n) => { return Nt((t = n, r = ht(e = c, o).map((n) => !0 === n ? t(e) : n), Rt(r)), u); let e, t, r }, (n) => { const e = n(c); const t = jt(Jt(c, o, h({})), (n) => ct(e, n)); return Nt(t, i) }) }, (n, e) => { const t = e(c); return Rt(bt(n, f(t))) }) }; const Zt = function (r) { return { extract(t, n, e) { return Ht(r(e, n), (n) => { return e = n, Xt(t, () => e); let e }) }, toString() { return 'val' }, toDsl() { return Gt.itemOf(r) } } }; const nr = function (n) { const c = er(n); const f = kn(n, (e, n) => n.fold((n) => ct(e, St(n, !0)), h(e)), {}); return { extract(n, e, t) { let r; let o; let i; const u = hn(t) ? [] : (o = E(r = t), Tn(o, (n) => kt(r, n))); const a = Tn(u, (n) => !kt(f, n)); return a.length === 0 ? c.extract(n, e, t) : (i = a, Xt(n, () => `There are unsupported fields: [${i.join(', ')}] specified`)) }, toString: c.toString, toDsl: c.toDsl } }; var er = function (a) { return { extract(n, e, t) { return r = n, o = t, i = e, u = Sn(a, (n) => Qt(r, o, n, i)), Pt(u, {}); let r, o, i, u }, toString() { return `obj{\n${Sn(a, (n) => n.fold((n, e, t, r) => `${n} -> ${r.toString()}`, (n, e) => `state(${n})`)).join('\n')}}` }, toDsl() { return Gt.objOf(Sn(a, (n) => n.fold((n, e, t, r) => $t.field(n, t, r), (n, e) => $t.state(n)))) } } }; const tr = function (t, i) { const u = function (n, e) { return (o = Zt(t), { extract(t, r, n) { const e = Sn(n, (n, e) => o.extract(t.concat([`[${e}]`]), r, n)); return Ut(e) }, toString() { return `array(${o.toString()})` }, toDsl() { return Gt.arrOf(o) } }).extract(n, b, e); let o }; return { extract(t, r, o) { const n = E(o); const e = u(t, n); return Nt(e, (n) => { const e = Sn(n, (n) => Yt.field(n, n, dt(), i)); return er(e).extract(t, r, o) }) }, toString() { return `setOf(${i.toString()})` }, toDsl() { return Gt.setOf(t, i) } } }; const rr = h(Zt(Rt)); const or = Yt.state; const ir = Yt.field; const ur = function (t, e, r, o, i) { return wt(o, i).fold(() => { return n = o, e = i, Xt(t, () => `The chosen schema: "${e}" did not exist in branches: ${qt(n)}`); let n, e }, (n) => er(n).extract(t.concat([`branch: ${i}`]), e, r)) }; const ar = function (o, i) { return { extract(e, t, r) { return wt(r, o).fold(() => { return n = o, Xt(e, () => `Choice schema did not contain choice key: "${n}"`); let n }, (n) => ur(e, t, r, i, n)) }, toString() { return `chooseOn(${o}). Possible values: ${E(i)}` }, toDsl() { return Gt.choiceOf(o, i) } } }; const cr = Zt(Rt); const fr = function (e) { return Zt((n) => e(n).fold(Vt, Rt)) }; const sr = function (e, n) { return tr((n) => It(e(n)), n) }; const lr = function (n, e, t) { return Bt((r = n, o = b, i = t, u = e.extract([r], o, i), zt(u, (n) => ({ input: i, errors: n })))); let r, o, i, u }; const dr = function (n) { return n.fold((n) => { throw new Error(gr(n)) }, b) }; const mr = function (n, e, t) { return dr(lr(n, e, t)) }; var gr = function (n) { return `Errors: \n${e = n.errors, t = e.length > 10 ? e.slice(0, 10).concat([{ path: [], getErrorInfo() { return '... (only showing first ten failures)' } }]) : e, Sn(t, (n) => `Failed path: (${n.path.join(' > ')})\n${n.getErrorInfo()}`)}\n\nInput object: ${qt(n.input)}`; let e, t }; const pr = function (n, e) { return ar(n, e) }; const vr = h(cr); const hr = (Et = bn, Ct = 'function', Zt((n) => { const e = typeof n; return Et(n) ? Rt(n) : Vt(`Expected type: ${Ct} but got: ${e}`) })); const br = function (n) { return ir(n, n, dt(), rr()) }; const yr = function (n, e) { return ir(n, n, dt(), e) }; const xr = function (n, e) { return ir(n, n, dt(), er(e)) }; const wr = function (n) { return ir(n, n, mt(), rr()) }; const Sr = function (n, e) { return ir(n, n, mt(), er(e)) }; const Or = function (n, e) { return ir(n, n, mt(), nr(e)) }; const Tr = function (n, e) { return ir(n, n, lt(e), rr()) }; const kr = function (n, e, t) { return ir(n, n, lt(e), t) }; const Er = function (n, e) { return or(n, e) }; const Cr = function (n, e) { return He(n.element(), e.event().target()) }; const Dr = function (n) { if (!kt(n, 'can') && !kt(n, 'abort') && !kt(n, 'run')) throw new Error(`EventHandler defined by: ${_t(n, null, 2)} does not have can, abort, or run!`); return mr('Extracting event.handler', nr([Tr('can', h(!0)), Tr('abort', h(!1)), Tr('run', x)]), n) }; const Mr = function (t) { let e; let r; let o; let i; const n = (e = t, r = function (n) { return n.can }, function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return En(e, (n, e) => n && r(e).apply(undefined, t), !0) }); const u = (o = t, i = function (n) { return n.abort }, function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return En(o, (n, e) => n || i(e).apply(undefined, t), !1) }); return Dr({ can: n, abort: u, run() { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; On(t, (n) => { n.run.apply(undefined, e) }) } }) }; function Ar(n, e, t, r, o) { return n(t, r) ? k.some(t) : bn(o) && o(t) ? k.none() : e(t, r, o) } let Ir; let Br; let Rr; const Fr = function (n, e, t) { for (let r = n.dom(), o = bn(t) ? t : h(!1); r.parentNode;) { r = r.parentNode; const i = me.fromDom(r); if (e(i)) return k.some(i); if (o(i)) break } return k.none() }; const Vr = function (n, e, t) { return Ar((n) => e(n), Fr, n, e, t) }; const Nr = function (n, r) { var o = function (n) { for (let e = 0; e < n.childNodes.length; e++) { if (r(me.fromDom(n.childNodes[e]))) return k.some(me.fromDom(n.childNodes[e])); const t = o(n.childNodes[e]); if (t.isSome()) return t } return k.none() }; return o(n.dom()) }; const Hr = function (n, e, t) { return Vr(n, (n) => e(n).isSome(), t).bind(e) }; const jr = function (n) { return Ot(n) }; const zr = function (n, e) { return { key: n, value: Dr({ abort: e }) } }; const Lr = function (n, e) { return { key: n, value: Dr({ run: e }) } }; const Pr = function (n, e, t) { return { key: n, value: Dr({ run(n) { e.apply(undefined, [n].concat(t)) } }) } }; const Ur = function (n) { return function (t) { return { key: n, value: Dr({ run(n, e) { Cr(n, e) && t(n, e) } }) } } }; const Gr = function (n, e, t) { let u; let r; const o = e.partUids[t]; return r = o, Lr(u = n, (n, i) => { n.getSystem().getByUid(r).each((n) => { let e, t, r, o; t = (e = n).element(), r = u, o = i, e.getSystem().triggerEvent(r, t, o.event()) }) }) }; const $r = function (n) { return Lr(n, (n, e) => { e.cut() }) }; const Wr = Ur(oe()); const _r = Ur(ie()); const qr = Ur(re()); const Xr = (Ir = Qn(), function (n) { return Lr(Ir, n) }); const Yr = function (n) { return Sn(n, (n) => { return r = e = '/*', o = (t = n).length - e.length, r !== '' && (t.length < r.length || t.substr(o, o + r.length) !== r) ? n : n.substring(0, n.length - '/*'.length); let e, t, r, o }) }; const Kr = function (n, e) { const t = n.toString(); const r = t.indexOf(')') + 1; const o = t.indexOf('('); const i = t.substring(o + 1, r - 1).split(/,\s*/); return n.toFunctionAnnotation = function () { return { name: e, parameters: Yr(i) } }, n }; const Jr = function (n) { return { classes: n.classes !== undefined ? n.classes : [], attributes: n.attributes !== undefined ? n.attributes : {}, styles: n.styles !== undefined ? n.styles : {} } }; const Qr = function (t, r, o) { return qr((n, e) => { o(n, t, r) }) }; const Zr = function (n, e, t, r, o, i) { let u; let a; const c = n; const f = Sr(e, [(u = 'config', a = n, ir(u, u, mt(), a))]); return to(c, f, e, t, r, o, i) }; const no = function (o, i, u) { let n, e, t, r, a, c; return n = function (t) { for (var n = [], e = 1; e < arguments.length; e++)n[e - 1] = arguments[e]; const r = [t].concat(n); return t.config({ name: h(o) }).fold(() => { throw new Error(`We could not find any behaviour configuration for: ${o}. Using API: ${u}`) }, (n) => { const e = Array.prototype.slice.call(r, 1); return i.apply(undefined, [t, n.config, n.state].concat(e)) }) }, e = u, t = i.toString(), r = t.indexOf(')') + 1, a = t.indexOf('('), c = t.substring(a + 1, r - 1).split(/,\s*/), n.toFunctionAnnotation = function () { return { name: e, parameters: Yr(c.slice(0, 1).concat(c.slice(3))) } }, n }; const eo = function (n) { return { key: n, value: undefined } }; var to = function (t, n, r, o, e, i, u) { const a = function (n) { return kt(n, r) ? n[r]() : k.none() }; const c = M(e, (n, e) => no(r, n, e)); const f = M(i, (n, e) => Kr(n, e)); var s = y({}, f, c, { revoke: l(eo, r), config(n) { const e = mr(`${r}-config`, t, n); return { key: r, value: { config: e, me: s, configAsRaw: q(() => mr(`${r}-config`, t, n)), initialConfig: n, state: u } } }, schema() { return n }, exhibit(n, t) { return a(n).bind((e) => wt(o, 'exhibit').map((n) => n(t, e.config, e.state))).getOr(Jr({})) }, name() { return r }, handlers(n) { return a(n).map((n) => xt('events', (n, e) => ({}))(o)(n.config, n.state)).getOr({}) } }); return s }; const ro = { init() { return oo({ readState() { return 'No State required' } }) } }; var oo = function (n) { return n }; const io = function (n) { return Ot(n) }; const uo = nr([br('fields'), br('name'), Tr('active', {}), Tr('apis', {}), Tr('state', ro), Tr('extra', {})]); const ao = function (n) { let e; let t; let r; let o; let i; let u; let a; let c; const f = mr(`Creating behaviour: ${n.name}`, uo, n); return e = f.fields, t = f.name, r = f.active, o = f.apis, i = f.extra, u = f.state, a = nr(e), c = Sr(t, [Or('config', e)]), to(a, c, t, r, o, i, u) }; const co = nr([br('branchKey'), br('branches'), br('name'), Tr('active', {}), Tr('apis', {}), Tr('state', ro), Tr('extra', {})]); const fo = h(undefined); const so = function (n, e, t) { if (!(gn(t) || hn(t) || yn(t))) throw console.error('Invalid call to Attr.set. Key ', e, ':: Value ', t, ':: Element ', n), new Error('Attribute value was not simple'); n.setAttribute(e, `${t}`) }; const lo = function (n, e, t) { so(n.dom(), e, t) }; const mo = function (n, e) { const t = n.dom(); D(e, (n, e) => { so(t, e, n) }) }; const go = function (n, e) { const t = n.dom().getAttribute(e); return t === null ? undefined : t }; const po = function (n, e) { const t = n.dom(); return !(!t || !t.hasAttribute) && t.hasAttribute(e) }; const vo = function (n, e) { n.dom().removeAttribute(e) }; const ho = function (n, e) { const t = go(n, e); return t === undefined || t === '' ? [] : t.split(' ') }; const bo = function (n) { return n.dom().classList !== undefined }; const yo = function (n, e) { return o = e, i = ho(t = n, r = 'class').concat([o]), lo(t, r, i.join(' ')), !0; let t, r, o, i }; const xo = function (n, e) { return o = e, (i = Tn(ho(t = n, r = 'class'), (n) => n !== o)).length > 0 ? lo(t, r, i.join(' ')) : vo(t, r), !1; let t, r, o, i }; const wo = function (n, e) { bo(n) ? n.dom().classList.add(e) : yo(n, e) }; const So = function (n) { (bo(n) ? n.dom().classList : ho(n, 'class')).length === 0 && vo(n, 'class') }; const Oo = function (n, e) { bo(n) ? n.dom().classList.remove(e) : xo(n, e), So(n) }; const To = function (n, e) { return bo(n) && n.dom().classList.contains(e) }; const ko = function (n, e, t) { Oo(n, t), wo(n, e) }; const Eo = Object.freeze({ toAlpha(n, e, t) { ko(n.element(), e.alpha, e.omega) }, toOmega(n, e, t) { ko(n.element(), e.omega, e.alpha) }, isAlpha(n, e, t) { return To(n.element(), e.alpha) }, isOmega(n, e, t) { return To(n.element(), e.omega) }, clear(n, e, t) { Oo(n.element(), e.alpha), Oo(n.element(), e.omega) } }); const Co = [br('alpha'), br('omega')]; const Do = ao({ fields: Co, name: 'swapping', apis: Eo }); var Mo = function (n) { let e = n; const t = function () { return e }; return { get: t, set(n) { e = n }, clone() { return Mo(t()) } } }; const Ao = function (n) { n.dom().focus() }; const Io = function (n) { n.dom().blur() }; const Bo = function (n) { const e = n !== undefined ? n.dom() : document; return k.from(e.activeElement).map(me.fromDom) }; const Ro = function (e) { return Bo(je(e)).filter((n) => e.dom().contains(n.dom())) }; const Fo = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const Vo = tinymce.util.Tools.resolve('tinymce.ThemeManager'); const No = function (n) { const e = document.createElement('a'); e.target = '_blank', e.href = n.href, e.rel = 'noreferrer noopener'; const t = document.createEvent('MouseEvents'); t.initMouseEvent('click', !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), document.body.appendChild(e), e.dispatchEvent(t), document.body.removeChild(e) }; const Ho = { formatChanged: h('formatChanged'), orientationChanged: h('orientationChanged'), dropupDismissed: h('dropupDismissed') }; const jo = function (n) { return n.dom().innerHTML }; const zo = function (n, e) { let t; let r; const o = je(n).dom(); const i = me.fromDom(o.createDocumentFragment()); const u = (t = e, (r = (o || document).createElement('div')).innerHTML = t, Le(me.fromDom(r))); _e(i, u), qe(n), We(n, i) }; const Lo = function (n) { return e = n, t = !1, me.fromDom(e.dom().cloneNode(t)); let e, t }; const Po = function (n) { let e; let t; let r; const o = Lo(n); return e = o, t = me.fromTag('div'), r = me.fromDom(e.dom().cloneNode(!0)), We(t, r), jo(t) }; const Uo = function (n) { return Po(n) }; const Go = Object.freeze({ events(a) { return jr([Lr(Jn(), (o, i) => { let n; let e; const u = a.channels; const t = E(u); const r = (n = t, (e = i).universal() ? n : Tn(n, (n) => wn(e.channels(), n))); On(r, (n) => { const e = u[n]; const t = e.schema; const r = mr(`channel[${n}] data\nReceiver: ${Uo(o.element())}`, t, i.data()); e.onReceive(o, r) }) })]) } }); const $o = function (n) { for (var e = [], t = function (n) { e.push(n) }, r = 0; r < n.length; r++)n[r].each(t); return e }; const Wo = function (n, e) { for (let t = 0; t < n.length; t++) { const r = e(n[t], t); if (r.isSome()) return r } return k.none() }; const _o = 'unknown'; (Rr = Br || (Br = {}))[Rr.STOP = 0] = 'STOP', Rr[Rr.NORMAL = 1] = 'NORMAL', Rr[Rr.LOGGING = 2] = 'LOGGING'; const qo = Mo({}); const Xo = function (e, n, t) { let r, o, i, u; switch (wt(qo.get(), e).orThunk(() => { const n = E(qo.get()); return Wo(n, (n) => e.indexOf(n) > -1 ? k.some(qo.get()[n]) : k.none()) }).getOr(Br.NORMAL)) { case Br.NORMAL:return t(Qo()); case Br.LOGGING:var a = (r = e, o = n, i = [], u = (new Date()).getTime(), { logEventCut(n, e, t) { i.push({ outcome: 'cut', target: e, purpose: t }) }, logEventStopped(n, e, t) { i.push({ outcome: 'stopped', target: e, purpose: t }) }, logNoParent(n, e, t) { i.push({ outcome: 'no-parent', target: e, purpose: t }) }, logEventNoHandlers(n, e) { i.push({ outcome: 'no-handlers-left', target: e }) }, logEventResponse(n, e, t) { i.push({ outcome: 'response', purpose: t, target: e }) }, write() { const n = (new Date()).getTime(); wn(['mousemove', 'mouseover', 'mouseout', re()], r) || console.log(r, { event: r, time: n - u, target: o.dom(), sequence: Sn(i, (n) => wn(['cut', 'stopped', 'response'], n.outcome) ? `{${n.purpose}} ${n.outcome} at (${Uo(n.target)})` : n.outcome) }) } }); var c = t(a); return a.write(), c; case Br.STOP:return !0 } }; const Yo = ['alloy/data/Fields', 'alloy/debugging/Debugging']; const Ko = function () { const n = new Error(); if (n.stack === undefined) return _o; const e = n.stack.split('\n'); return Cn(e, (e) => e.indexOf('alloy') > 0 && !Dn(Yo, (n) => e.indexOf(n) > -1).isSome()).getOr(_o) }; const Jo = function (n, e, t) { return Xo(n, e, t) }; var Qo = h({ logEventCut: x, logEventStopped: x, logNoParent: x, logEventNoHandlers: x, logEventResponse: x, write: x }); const Zo = h([br('menu'), br('selectedMenu')]); const ni = h([br('item'), br('selectedItem')]); const ei = (h(er(ni().concat(Zo()))), h(er(ni()))); const ti = xr('initSize', [br('numColumns'), br('numRows')]); const ri = function (n, e, t) { return Ko(), ir(e, e, t, fr((t) => ot.value(function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; return t.apply(undefined, n) }))) }; const oi = function (n) { return ri(0, n, lt(x)) }; const ii = function (n) { return ri(0, n, lt(k.none)) }; const ui = function (n) { return ri(0, n, dt()) }; const ai = function (n) { return ri(0, n, dt()) }; const ci = function (n, e) { return Er(n, h(e)) }; const fi = function (n) { return Er(n, b) }; const si = h(ti); const li = [yr('channels', sr(ot.value, nr([ui('onReceive'), Tr('schema', vr())])))]; const di = ao({ fields: li, name: 'receiving', active: Go }); const mi = function (n, e, t) { const r = e.aria; r.update(n, r, t.get()) }; const gi = function (e, n, t) { n.toggleClass.each((n) => { t.get() ? wo(e.element(), n) : Oo(e.element(), n) }) }; const pi = function (n, e, t) { bi(n, e, t, !t.get()) }; const vi = function (n, e, t) { t.set(!0), gi(n, e, t), mi(n, e, t) }; const hi = function (n, e, t) { t.set(!1), gi(n, e, t), mi(n, e, t) }; var bi = function (n, e, t, r) { (r ? vi : hi)(n, e, t) }; const yi = function (n, e, t) { bi(n, e, t, e.selected) }; const xi = Object.freeze({ onLoad: yi, toggle: pi, isOn(n, e, t) { return t.get() }, on: vi, off: hi, set: bi }); const wi = Object.freeze({ exhibit(n, e, t) { return Jr({}) }, events(n, e) { let t; let r; let o; const i = (t = n, r = e, o = pi, Xr((n) => { o(n, t, r) })); const u = Qr(n, e, yi); return jr(In([n.toggleOnExecute ? [i] : [], [u]])) } }); const Si = Object.freeze({ init(n) { const e = Mo(!1); return { readState() { return e.get() }, get() { return e.get() }, set(n) { return e.set(n) }, clear() { return e.set(!1) } } } }); const Oi = function (n, e, t) { lo(n.element(), 'aria-expanded', t) }; const Ti = [Tr('selected', !1), wr('toggleClass'), Tr('toggleOnExecute', !0), kr('aria', { mode: 'none' }, pr('mode', { pressed: [Tr('syncWithExpanded', !1), ci('update', (n, e, t) => { lo(n.element(), 'aria-pressed', t), e.syncWithExpanded && Oi(n, e, t) })], checked: [ci('update', (n, e, t) => { lo(n.element(), 'aria-checked', t) })], expanded: [ci('update', Oi)], selected: [ci('update', (n, e, t) => { lo(n.element(), 'aria-selected', t) })], none: [ci('update', x)] }))]; const ki = ao({ fields: Ti, name: 'toggling', active: wi, apis: xi, state: Si }); const Ei = function (t, r) { return di.config({ channels: St(Ho.formatChanged(), { onReceive(n, e) { e.command === t && r(n, e.state) } }) }) }; const Ci = function (n) { return di.config({ channels: St(Ho.orientationChanged(), { onReceive: n }) }) }; const Di = function (n, e) { return { key: n, value: { onReceive: e } } }; const Mi = 'tinymce-mobile'; const Ai = { resolve(n) { return `${Mi}-${n}` }, prefix: h(Mi) }; const Ii = function (n, e) { e.ignore || (Ao(n.element()), e.onFocus(n)) }; const Bi = Object.freeze({ focus: Ii, blur(n, e) { e.ignore || Io(n.element()) }, isFocused(n) { return e = n.element(), t = je(e).dom(), e.dom() === t.activeElement; let e, t } }); const Ri = Object.freeze({ exhibit(n, e) { const t = e.ignore ? {} : { attributes: { tabindex: '-1' } }; return Jr(t) }, events(t) { return jr([Lr(Yn(), (n, e) => { Ii(n, t), e.stop() })].concat(t.stopMousedown ? [Lr(N(), (n, e) => { e.event().prevent() })] : [])) } }); const Fi = [oi('onFocus'), Tr('stopMousedown', !1), Tr('ignore', !1)]; const Vi = ao({ fields: Fi, name: 'focusing', active: Ri, apis: Bi }); const Ni = function (n) { return n.style !== undefined }; const Hi = function (n, e, t) { if (!gn(t)) throw console.error('Invalid call to CSS.set. Property ', e, ':: Value ', t, ':: Element ', n), new Error(`CSS value must be a string: ${t}`); Ni(n) && n.style.setProperty(e, t) }; const ji = function (n, e, t) { const r = n.dom(); Hi(r, e, t) }; const zi = function (n, e) { const t = n.dom(); D(e, (n, e) => { Hi(t, e, n) }) }; const Li = function (n, e) { const t = n.dom(); const r = window.getComputedStyle(t).getPropertyValue(e); const o = r !== '' || we(n) ? r : Pi(t, e); return o === null ? undefined : o }; var Pi = function (n, e) { return Ni(n) ? n.style.getPropertyValue(e) : '' }; const Ui = function (n, e) { const t = n.dom(); const r = Pi(t, e); return k.from(r).filter((n) => n.length > 0) }; const Gi = function (n, e) { let t; let r; const o = n.dom(); r = e, Ni(t = o) && t.style.removeProperty(r), po(n, 'style') && go(n, 'style').replace(/^\s+|\s+$/g, '') === '' && vo(n, 'style') }; const $i = function (n) { return n.dom().offsetWidth }; function Wi(r, o) { const n = function (n) { const e = o(n); if (e <= 0 || e === null) { const t = Li(n, r); return parseFloat(t) || 0 } return e }; const i = function (o, n) { return En(n, (n, e) => { const t = Li(o, e); const r = t === undefined ? 0 : parseInt(t, 10); return isNaN(r) ? n : n + r }, 0) }; return { set(n, e) { if (!yn(e) && !e.match(/^[0-9]+$/)) throw new Error(`${r}.set accepts only positive integer values. Value was ${e}`); const t = n.dom(); Ni(t) && (t.style[r] = `${e}px`) }, get: n, getOuter: n, aggregate: i, max(n, e, t) { const r = i(n, t); return r < e ? e - r : 0 } } } let _i; let qi; const Xi = Wi('height', (n) => { const e = n.dom(); return we(n) ? e.getBoundingClientRect().height : e.offsetHeight }); const Yi = function (n) { return Xi.get(n) }; const Ki = function (n, e, t) { return Tn((function (n, e) { for (var t = bn(e) ? e : h(!1), r = n.dom(), o = []; r.parentNode !== null && r.parentNode !== undefined;) { const i = r.parentNode; const u = me.fromDom(i); if (o.push(u), !0 === t(u)) break; r = i } return o }(n, t)), e) }; const Ji = function (n, e) { return Tn(ze(t = n).map(Le).map((n) => Tn(n, (n) => !He(t, n))).getOr([]), e); let t }; const Qi = function (n, e) { return Ve(e, n) }; const Zi = function (n) { return Ne(n) }; const nu = function (n, e, t) { return Fr(n, (n) => Re(n, e), t) }; const eu = function (n, e) { return Ne(e, n) }; const tu = function (n, e, t) { return Ar(Re, nu, n, e, t) }; const ru = function (n, e, t) { const r = Vn(n.slice(0, e)); const o = Vn(n.slice(e + 1)); return Cn(r.concat(o), t) }; const ou = function (n, e, t) { const r = Vn(n.slice(0, e)); return Cn(r, t) }; const iu = function (n, e, t) { const r = n.slice(0, e); const o = n.slice(e + 1); return Cn(o.concat(r), t) }; const uu = function (n, e, t) { const r = n.slice(e + 1); return Cn(r, t) }; const au = function (t) { return function (n) { const e = n.raw(); return wn(t, e.which) } }; const cu = function (n) { return function (e) { return Rn(n, (n) => n(e)) } }; const fu = function (n) { return !0 === n.raw().shiftKey }; const su = function (n) { return !0 === n.raw().ctrlKey }; const lu = S(fu); const du = function (n, e) { return { matches: n, classification: e } }; const mu = function (n, e, t, r) { const o = n + e; return r < o ? t : o < t ? r : o }; const gu = function (n, e, t) { return n <= e ? e : t <= n ? t : n }; const pu = function (e, t, n) { const r = Qi(e.element(), `.${t.highlightClass}`); On(r, (n) => { Oo(n, t.highlightClass), e.getSystem().getByDom(n).each((n) => { t.onDehighlight(e, n) }) }) }; const vu = function (n, e, t, r) { const o = hu(n, e, t, r); pu(n, e), wo(r.element(), e.highlightClass), o || e.onHighlight(n, r) }; var hu = function (n, e, t, r) { return To(r.element(), e.highlightClass) }; const bu = function (n, e, t, r) { const o = Qi(n.element(), `.${e.itemClass}`); return k.from(o[r]).fold(() => ot.error(`No element found with index ${r}`), n.getSystem().getByDom) }; const yu = function (e, n, t) { return eu(e.element(), `.${n.itemClass}`).bind((n) => e.getSystem().getByDom(n).toOption()) }; const xu = function (e, n, t) { const r = Qi(e.element(), `.${n.itemClass}`); return (r.length > 0 ? k.some(r[r.length - 1]) : k.none()).bind((n) => e.getSystem().getByDom(n).toOption()) }; const wu = function (t, e, n, r) { const o = Qi(t.element(), `.${e.itemClass}`); return Dn(o, (n) => To(n, e.highlightClass)).bind((n) => { const e = mu(n, r, 0, o.length - 1); return t.getSystem().getByDom(o[e]).toOption() }) }; const Su = function (e, n, t) { const r = Qi(e.element(), `.${n.itemClass}`); return $o(Sn(r, (n) => e.getSystem().getByDom(n).toOption())) }; const Ou = Object.freeze({ dehighlightAll: pu, dehighlight(n, e, t, r) { const o = hu(n, e, t, r); Oo(r.element(), e.highlightClass), o && e.onDehighlight(n, r) }, highlight: vu, highlightFirst(e, t, r) { yu(e, t, r).each((n) => { vu(e, t, r, n) }) }, highlightLast(e, t, r) { xu(e, t, r).each((n) => { vu(e, t, r, n) }) }, highlightAt(e, t, r, n) { bu(e, t, r, n).fold((n) => { throw new Error(n) }, (n) => { vu(e, t, r, n) }) }, highlightBy(e, t, r, n) { const o = Su(e, t, r); Cn(o, n).each((n) => { vu(e, t, r, n) }) }, isHighlighted: hu, getHighlighted(e, n, t) { return eu(e.element(), `.${n.highlightClass}`).bind((n) => e.getSystem().getByDom(n).toOption()) }, getFirst: yu, getLast: xu, getPrevious(n, e, t) { return wu(n, e, 0, -1) }, getNext(n, e, t) { return wu(n, e, 0, 1) }, getCandidates: Su }); const Tu = [br('highlightClass'), br('itemClass'), oi('onHighlight'), oi('onDehighlight')]; const ku = ao({ fields: Tu, name: 'highlighting', apis: Ou }); const Eu = function (n, e, t) { e.exists((e) => t.exists((n) => He(n, e))) || ce(n, ue(), { prevFocus: e, newFocus: t }) }; const Cu = function () { const o = function (n) { return Ro(n.element()) }; return { get: o, set(n, e) { const t = o(n); n.getSystem().triggerFocus(e, n.element()); const r = o(n); Eu(n, t, r) } } }; (qi = _i || (_i = {})).OnFocusMode = 'onFocus', qi.OnEnterOrSpaceMode = 'onEnterOrSpace', qi.OnApiMode = 'onApi'; let Du; let Mu; const Au = function (n, e, t, r, a) { const c = function (e, t, n, r, o) { let i; let u; const a = n(e, t, r, o); return (i = a, u = t.event(), Cn(i, (n) => n.matches(u)).map((n) => n.classification)).bind((n) => n(e, t, r, o)) }; var o = { schema() { return n.concat([Tr('focusManager', Cu()), kr('focusInside', 'onFocus', fr((n) => wn(['onFocus', 'onEnterOrSpace', 'onApi'], n) ? ot.value(n) : ot.error('Invalid value for focusInside'))), ci('handler', o), ci('state', e), ci('sendFocusIn', a)]) }, processKey: c, toEvents(i, u) { const n = i.focusInside !== _i.OnFocusMode ? k.none() : a(i).map((t) => Lr(Yn(), (n, e) => { t(n, i, u), e.stop() })); return jr(n.toArray().concat([Lr(L(), (r, o) => { c(r, o, t, i, u).fold(() => { let e, t, n; e = r, t = o, n = au([32].concat([13]))(t.event()), i.focusInside === _i.OnEnterOrSpaceMode && n && Cr(e, t) && a(i).each((n) => { n(e, i, u), t.stop() }) }, (n) => { o.stop() }) }), Lr(P(), (n, e) => { c(n, e, r, i, u).each((n) => { e.stop() }) })])) } }; return o }; const Iu = function (n) { const e = [wr('onEscape'), wr('onEnter'), Tr('selector', '[data-alloy-tabstop="true"]'), Tr('firstTabstop', 0), Tr('useTabstopAt', h(!0)), wr('visibilitySelector')].concat([n]); const u = function (n, e) { const t = n.visibilitySelector.bind((n) => tu(e, n)).getOr(e); return Yi(t) > 0 }; const t = function (e, t) { let n, r, o, i; (n = e, r = t, o = Qi(n.element(), r.selector), i = Tn(o, (n) => u(r, n)), k.from(i[r.firstTabstop])).each((n) => { t.focusManager.set(e, n) }) }; const a = function (e, n, t, r, o) { return o(n, t, (n) => { return u(e = r, t = n) && e.useTabstopAt(t); let e, t }).fold(() => r.cyclic ? k.some(!0) : k.none(), (n) => r.focusManager.set(e, n), k.some(!0)) }; const i = function (e, n, t, r) { let o; let i; const u = Qi(e.element(), t.selector); return (o = e, i = t, i.focusManager.get(o).bind((n) => tu(n, i.selector))).bind((n) => Dn(u, l(He, n)).bind((n) => a(e, u, n, t, r))) }; const r = h([du(cu([fu, au([9])]), (n, e, t, r) => { const o = t.cyclic ? ru : ou; return i(n, 0, t, o) }), du(au([9]), (n, e, t, r) => { const o = t.cyclic ? iu : uu; return i(n, 0, t, o) }), du(au([27]), (e, t, n, r) => n.onEscape.bind((n) => n(e, t))), du(cu([lu, au([13])]), (e, t, n, r) => n.onEnter.bind((n) => n(e, t)))]); const o = h([]); return Au(e, ro.init, r, o, () => k.some(t)) }; const Bu = Iu(Er('cyclic', h(!1))); const Ru = Iu(Er('cyclic', h(!0))); const Fu = function (n) { return he(n) === 'input' && go(n, 'type') !== 'radio' || he(n) === 'textarea' }; const Vu = function (n, e, t) { return Fu(t) && au([32])(e.event()) ? k.none() : (se(n, t, Qn()), k.some(!0)) }; const Nu = function (n, e) { return k.some(!0) }; const Hu = [Tr('execute', Vu), Tr('useSpace', !1), Tr('useEnter', !0), Tr('useControlEnter', !1), Tr('useDown', !1)]; const ju = function (n, e, t) { return t.execute(n, e, n.element()) }; const zu = Au(Hu, ro.init, (n, e, t, r) => { const o = t.useSpace && !Fu(n.element()) ? [32] : []; const i = t.useEnter ? [13] : []; const u = t.useDown ? [40] : []; const a = o.concat(i).concat(u); return [du(au(a), ju)].concat(t.useControlEnter ? [du(cu([su, au([13])]), ju)] : []) }, (n, e, t, r) => t.useSpace && !Fu(n.element()) ? [du(au([32]), Nu)] : [], () => k.none()); const Lu = function (n) { const t = Mo(k.none()); return oo({ readState() { return t.get().map((n) => ({ numRows: n.numRows(), numColumns: n.numColumns() })).getOr({ numRows: '?', numColumns: '?' }) }, setGridSize(n, e) { t.set(k.some({ numRows: h(n), numColumns: h(e) })) }, getNumRows() { return t.get().map((n) => n.numRows()) }, getNumColumns() { return t.get().map((n) => n.numColumns()) } }) }; const Pu = Object.freeze({ flatgrid: Lu, init(n) { return n.state(n) } }); const Uu = function (e, t) { return function (n) { return Gu(n) === 'rtl' ? t : e } }; var Gu = function (n) { return Li(n, 'direction') === 'rtl' ? 'rtl' : 'ltr' }; const $u = function (i) { return function (n, e, t, r) { const o = i(n.element()); return Xu(o, n, e, t, r) } }; const Wu = function (n, e) { const t = Uu(n, e); return $u(t) }; const _u = function (n, e) { const t = Uu(e, n); return $u(t) }; const qu = function (o) { return function (n, e, t, r) { return Xu(o, n, e, t, r) } }; var Xu = function (e, t, n, r, o) { return r.focusManager.get(t).bind((n) => e(t.element(), n, r, o)).map((n) => r.focusManager.set(t, n), !0) }; const Yu = qu; const Ku = qu; const Ju = qu; const Qu = function (n) { let e; const t = n.dom(); return !((e = t).offsetWidth <= 0 && e.offsetHeight <= 0) }; const Zu = Ce(['index', 'candidates'], []); const na = function (n, e, t) { return ea(n, e, t, Qu) }; var ea = function (n, e, t, r) { let o; const i = l(He, e); const u = Qi(n, t); const a = Tn(u, Qu); return Dn(o = a, i).map((n) => Zu({ index: n, candidates: o })) }; const ta = function (n, e) { return Dn(n, (n) => He(e, n)) }; const ra = function (t, n, r, e) { return e(Math.floor(n / r), n % r).bind((n) => { const e = n.row() * r + n.column(); return e >= 0 && e < t.length ? k.some(t[e]) : k.none() }) }; const oa = function (o, n, i, u, a) { return ra(o, n, u, (n, e) => { const t = n === i - 1 ? o.length - n * u : u; const r = mu(e, a, 0, t - 1); return k.some({ row: h(n), column: h(r) }) }) }; const ia = function (i, n, u, a, c) { return ra(i, n, a, (n, e) => { const t = mu(n, c, 0, u - 1); const r = t === u - 1 ? i.length - t * a : a; const o = gu(e, 0, r - 1); return k.some({ row: h(t), column: h(o) }) }) }; const ua = [br('selector'), Tr('execute', Vu), ii('onEscape'), Tr('captureTab', !1), si()]; const aa = function (e, t, n) { eu(e.element(), t.selector).each((n) => { t.focusManager.set(e, n) }) }; const ca = function (o) { return function (n, e, t, r) { return na(n, e, t.selector).bind((n) => o(n.candidates(), n.index(), r.getNumRows().getOr(t.initSize.numRows), r.getNumColumns().getOr(t.initSize.numColumns))) } }; const fa = function (n, e, t, r) { return t.captureTab ? k.some(!0) : k.none() }; const sa = ca((n, e, t, r) => oa(n, e, t, r, -1)); const la = ca((n, e, t, r) => oa(n, e, t, r, 1)); const da = ca((n, e, t, r) => ia(n, e, t, r, -1)); const ma = ca((n, e, t, r) => ia(n, e, t, r, 1)); const ga = h([du(au([37]), Wu(sa, la)), du(au([39]), _u(sa, la)), du(au([38]), Yu(da)), du(au([40]), Ku(ma)), du(cu([fu, au([9])]), fa), du(cu([lu, au([9])]), fa), du(au([27]), (n, e, t, r) => t.onEscape(n, e)), du(au([32].concat([13])), (e, t, r, n) => { return (o = e, i = r, i.focusManager.get(o).bind((n) => tu(n, i.selector))).bind((n) => r.execute(e, t, n)); let o, i })]); const pa = h([du(au([32]), Nu)]); const va = Au(ua, Lu, ga, pa, () => k.some(aa)); const ha = function (n, e, t, i) { var u = function (n, e, t) { let r; const o = mu(e, i, 0, t.length - 1); return o === n ? k.none() : (r = t[o], he(r) === 'button' && go(r, 'disabled') === 'disabled' ? u(n, o, t) : k.from(t[o])) }; return na(n, t, e).bind((n) => { const e = n.index(); const t = n.candidates(); return u(e, e, t) }) }; const ba = [br('selector'), Tr('getInitial', k.none), Tr('execute', Vu), ii('onEscape'), Tr('executeOnMove', !1), Tr('allowVertical', !0)]; const ya = function (e, t, r) { return (n = e, o = r, o.focusManager.get(n).bind((n) => tu(n, o.selector))).bind((n) => r.execute(e, t, n)); let n, o }; const xa = function (e, t) { t.getInitial(e).orThunk(() => eu(e.element(), t.selector)).each((n) => { t.focusManager.set(e, n) }) }; const wa = function (n, e, t) { return ha(n, t.selector, e, -1) }; const Sa = function (n, e, t) { return ha(n, t.selector, e, 1) }; const Oa = function (r) { return function (n, e, t) { return r(n, e, t).bind(() => t.executeOnMove ? ya(n, e, t) : k.some(!0)) } }; const Ta = function (n, e, t, r) { return t.onEscape(n, e) }; const ka = h([du(au([32]), Nu)]); const Ea = Au(ba, ro.init, (n, e, t, r) => { const o = [37].concat(t.allowVertical ? [38] : []); const i = [39].concat(t.allowVertical ? [40] : []); return [du(au(o), Oa(Wu(wa, Sa))), du(au(i), Oa(_u(wa, Sa))), du(au([13]), ya), du(au([32]), ya), du(au([27]), Ta)] }, ka, () => k.some(xa)); const Ca = Ce(['rowIndex', 'columnIndex', 'cell'], []); const Da = function (n, e, t) { return k.from(n[e]).bind((n) => k.from(n[t]).map((n) => Ca({ rowIndex: e, columnIndex: t, cell: n }))) }; const Ma = function (n, e, t, r) { const o = n[e].length; const i = mu(t, r, 0, o - 1); return Da(n, e, i) }; const Aa = function (n, e, t, r) { const o = mu(t, r, 0, n.length - 1); const i = n[o].length; const u = gu(e, 0, i - 1); return Da(n, o, u) }; const Ia = function (n, e, t, r) { const o = n[e].length; const i = gu(t + r, 0, o - 1); return Da(n, e, i) }; const Ba = function (n, e, t, r) { const o = gu(t + r, 0, n.length - 1); const i = n[o].length; const u = gu(e, 0, i - 1); return Da(n, o, u) }; const Ra = [xr('selectors', [br('row'), br('cell')]), Tr('cycles', !0), Tr('previousSelector', k.none), Tr('execute', Vu)]; const Fa = function (e, t) { t.previousSelector(e).orThunk(() => { const n = t.selectors; return eu(e.element(), n.cell) }).each((n) => { t.focusManager.set(e, n) }) }; const Va = function (n, e) { return function (t, r, i) { const u = i.cycles ? n : e; return tu(r, i.selectors.row).bind((n) => { const e = Qi(n, i.selectors.cell); return ta(e, r).bind((r) => { const o = Qi(t, i.selectors.row); return ta(o, n).bind((n) => { let e; const t = (e = i, Sn(o, (n) => Qi(n, e.selectors.cell))); return u(t, n, r).map((n) => n.cell()) }) }) }) } }; const Na = Va((n, e, t) => Ma(n, e, t, -1), (n, e, t) => Ia(n, e, t, -1)); const Ha = Va((n, e, t) => Ma(n, e, t, 1), (n, e, t) => Ia(n, e, t, 1)); const ja = Va((n, e, t) => Aa(n, t, e, -1), (n, e, t) => Ba(n, t, e, -1)); const za = Va((n, e, t) => Aa(n, t, e, 1), (n, e, t) => Ba(n, t, e, 1)); const La = h([du(au([37]), Wu(Na, Ha)), du(au([39]), _u(Na, Ha)), du(au([38]), Yu(ja)), du(au([40]), Ku(za)), du(au([32].concat([13])), (e, t, r) => Ro(e.element()).bind((n) => r.execute(e, t, n)))]); const Pa = h([du(au([32]), Nu)]); const Ua = Au(Ra, ro.init, La, Pa, () => k.some(Fa)); const Ga = [br('selector'), Tr('execute', Vu), Tr('moveOnTab', !1)]; const $a = function (e, t, r) { return r.focusManager.get(e).bind((n) => r.execute(e, t, n)) }; const Wa = function (e, t) { eu(e.element(), t.selector).each((n) => { t.focusManager.set(e, n) }) }; const _a = function (n, e, t) { return ha(n, t.selector, e, -1) }; const qa = function (n, e, t) { return ha(n, t.selector, e, 1) }; const Xa = h([du(au([38]), Ju(_a)), du(au([40]), Ju(qa)), du(cu([fu, au([9])]), (n, e, t) => t.moveOnTab ? Ju(_a)(n, e, t) : k.none()), du(cu([lu, au([9])]), (n, e, t) => t.moveOnTab ? Ju(qa)(n, e, t) : k.none()), du(au([13]), $a), du(au([32]), $a)]); const Ya = h([du(au([32]), Nu)]); const Ka = Au(Ga, ro.init, Xa, Ya, () => k.some(Wa)); const Ja = [ii('onSpace'), ii('onEnter'), ii('onShiftEnter'), ii('onLeft'), ii('onRight'), ii('onTab'), ii('onShiftTab'), ii('onUp'), ii('onDown'), ii('onEscape'), Tr('stopSpaceKeyup', !1), wr('focusIn')]; const Qa = Au(Ja, ro.init, (n, e, t) => [du(au([32]), t.onSpace), du(cu([lu, au([13])]), t.onEnter), du(cu([fu, au([13])]), t.onShiftEnter), du(cu([fu, au([9])]), t.onShiftTab), du(cu([lu, au([9])]), t.onTab), du(au([38]), t.onUp), du(au([40]), t.onDown), du(au([37]), t.onLeft), du(au([39]), t.onRight), du(au([32]), t.onSpace), du(au([27]), t.onEscape)], (n, e, t) => t.stopSpaceKeyup ? [du(au([32]), Nu)] : [], (n) => n.focusIn); const Za = Bu.schema(); const nc = Ru.schema(); const ec = Ea.schema(); const tc = va.schema(); const rc = Ua.schema(); const oc = zu.schema(); const ic = Ka.schema(); const uc = Qa.schema(); const ac = (Mu = mr(`Creating behaviour: ${(Du = { branchKey: 'mode', branches: Object.freeze({ acyclic: Za, cyclic: nc, flow: ec, flatgrid: tc, matrix: rc, execution: oc, menu: ic, special: uc }), name: 'keying', active: { events(n, e) { return n.handler.toEvents(n, e) } }, apis: { focusIn(e, t, r) { t.sendFocusIn(t).fold(() => { e.getSystem().triggerFocus(e.element(), e.element()) }, (n) => { n(e, t, r) }) }, setGridSize(n, e, t, r, o) { kt(t, 'setGridSize') ? t.setGridSize(r, o) : console.error('Layout does not support setGridSize') } }, state: Pu }).name}`, co, Du), Zr(pr(Mu.branchKey, Mu.branches), Mu.name, Mu.active, Mu.apis, Mu.extra, Mu.state)); const cc = function (r, n) { return e = r, t = {}, o = Sn(n, (n) => { return e = n.name(), t = `Cannot configure ${n.name()} for ${r}`, ir(e, e, mt(), Zt((n) => Vt(`The field: ${e} is forbidden. ${t}`))); let e, t }).concat([Er('dump', b)]), ir(e, e, lt(t), er(o)); let e, t, o }; const fc = function (n) { return n.dump }; const sc = function (n, e) { return y({}, n.dump, io(e)) }; const lc = cc; const dc = sc; const mc = 'placeholder'; const gc = it([{ single: ['required', 'valueThunk'] }, { multiple: ['required', 'valueThunks'] }]); const pc = function (n, e, t, r) { return t.uiType === mc ? (i = t, u = r, (o = n).exists((n) => n !== i.owner) ? gc.single(!0, h(i)) : wt(u, i.name).fold(() => { throw new Error(`Unknown placeholder component: ${i.name}\nKnown: [${E(u)}]\nNamespace: ${o.getOr('none')}\nSpec: ${_t(i, null, 2)}`) }, (n) => n.replace())) : gc.single(!1, h(t)); let o, i, u }; var vc = function (i, u, a, c) { return pc(i, 0, a, c).fold((n, e) => { const t = e(u, a.config, a.validated); const r = wt(t, 'components').getOr([]); const o = Bn(r, (n) => vc(i, u, n, c)); return [y({}, t, { components: o })] }, (n, e) => { const t = e(u, a.config, a.validated); return a.validated.preprocess.getOr(b)(t) }) }; const hc = function (e, t, n, r) { let o; let i; let u; const a = M(r, (n, e) => { return r = n, o = !1, { name: h(t = e), required() { return r.fold((n, e) => n, (n, e) => n) }, used() { return o }, replace() { if (!0 === o) throw new Error(`Trying to use the same placeholder more than once: ${t}`); return o = !0, r } }; let t, r, o }); const c = (o = e, i = t, u = a, Bn(n, (n) => vc(o, i, n, u))); return D(a, (n) => { if (!1 === n.used() && n.required()) throw new Error(`Placeholder: ${n.name()} was not found in components list\nNamespace: ${e.getOr('none')}\nComponents: ${_t(t.components, null, 2)}`) }), c }; const bc = gc.single; const yc = gc.multiple; const xc = h(mc); let wc = 0; const Sc = function (n) { const e = (new Date()).getTime(); return `${n}_${Math.floor(1e9 * Math.random())}${++wc}${String(e)}` }; const Oc = it([{ required: ['data'] }, { external: ['data'] }, { optional: ['data'] }, { group: ['data'] }]); const Tc = Tr('factory', { sketch: b }); const kc = Tr('schema', []); const Ec = br('name'); const Cc = ir('pname', 'pname', gt((n) => `<alloy.${Sc(n.name)}>`), vr()); const Dc = Er('schema', () => [wr('preprocess')]); const Mc = Tr('defaults', h({})); const Ac = Tr('overrides', h({})); const Ic = er([Tc, kc, Ec, Cc, Mc, Ac]); const Bc = er([Tc, kc, Ec, Cc, Mc, Ac]); const Rc = er([Tc, Dc, Ec, br('unit'), Cc, Mc, Ac]); const Fc = function (n) { const e = function (n) { return n.name }; return n.fold(e, e, e, e) }; const Vc = function (t, r) { return function (n) { const e = mr('Converting part type', r, n); return t(e) } }; const Nc = Vc(Oc.required, Ic); const Hc = Vc(Oc.optional, Bc); const jc = Vc(Oc.group, Rc); const zc = h('entirety'); const Lc = function (n, e, t, r) { return ct(e.defaults(n, t, r), t, { uid: n.partUids[e.name] }, e.overrides(n, t, r)) }; const Pc = function (o, n) { const i = {}; return On(n, (n) => { let e; (e = n, e.fold(k.some, k.none, k.some, k.some)).each((t) => { const r = Uc(o, t.pname); i[t.name] = function (n) { const e = mr(`Part: ${t.name} in ${o}`, er(t.schema), n); return y({}, r, { config: n, validated: e }) } }) }), i }; var Uc = function (n, e) { return { uiType: xc(), owner: n, name: e } }; const Gc = function (n, e, t) { return r = e, i = {}, o = {}, On(t, (n) => { n.fold((r) => { i[r.pname] = bc(!0, (n, e, t) => r.factory.sketch(Lc(n, r, e, t))) }, (n) => { const e = r.parts[n.name]; o[n.name] = h(n.factory.sketch(Lc(r, n, e[zc()]), e)) }, (r) => { i[r.pname] = bc(!1, (n, e, t) => r.factory.sketch(Lc(n, r, e, t))) }, (o) => { i[o.pname] = yc(!0, (e, n, t) => { const r = e[o.name]; return Sn(r, (n) => o.factory.sketch(ct(o.defaults(e, n, t), n, o.overrides(e, n)))) }) }) }), { internals: h(i), externals: h(o) }; let r, i, o }; const $c = function (n, e, t) { return hc(k.some(n), e, e.components, t) }; const Wc = function (n, e, t) { const r = e.partUids[t]; return n.getSystem().getByUid(r).toOption() }; const _c = function (n, e, t) { return Wc(n, e, t).getOrDie(`Could not find part: ${t}`) }; const qc = function (e, n) { const t = Sn(n, Fc); return Ot(Sn(t, (n) => ({ key: n, value: `${e}-${n}` }))) }; const Xc = function (e) { return ir('partUids', 'partUids', pt((n) => qc(n.uid, e)), vr()) }; const Yc = Sc('alloy-premade'); const Kc = function (n) { return St(Yc, n) }; const Jc = function (r) { return n = function (n) { for (var e = [], t = 1; t < arguments.length; t++)e[t - 1] = arguments[t]; return r.apply(undefined, [n.getApis()].concat([n].concat(e))) }, e = r.toString(), t = e.indexOf(')') + 1, o = e.indexOf('('), i = e.substring(o + 1, t - 1).split(/,\s*/), n.toFunctionAnnotation = function () { return { name: 'OVERRIDE', parameters: Yr(i.slice(1)) } }, n; let n, e, t, o, i }; const Qc = h('alloy-id-'); const Zc = h('data-alloy-id'); const nf = Qc(); const ef = Zc(); const tf = function (n, e) { Object.defineProperty(n.dom(), ef, { value: e, writable: !0 }) }; const rf = function (n) { const e = ye(n) ? n.dom()[ef] : null; return k.from(e) }; const of = function (n) { return Sc(n) }; const uf = function (n, e, t, r, o) { let i; let u; const a = (u = o, ((i = r).length > 0 ? [xr('parts', i)] : []).concat([br('uid'), Tr('dom', {}), Tr('components', []), fi('originalSpec'), Tr('debug.sketcher', {})]).concat(u)); return mr(`${n} [SpecSchema]`, nr(a.concat(e)), t) }; const af = function (n, e, t, r, o) { const i = cf(o); const u = Bn(t, (n) => n.fold(k.none, k.some, k.none, k.none).map((n) => xr(n.name, n.schema.concat([fi(zc())]))).toArray()); const a = Xc(t); const c = uf(n, e, i, u, [a]); const f = Gc(0, c, t); return r(c, $c(n, c, f.internals()), i, f.externals()) }; var cf = function (n) { return n.hasOwnProperty('uid') ? n : y({}, n, { uid: of('uid') }) }; const ff = nr([br('name'), br('factory'), br('configFields'), Tr('apis', {}), Tr('extraApis', {})]); const sf = nr([br('name'), br('factory'), br('configFields'), br('partFields'), Tr('apis', {}), Tr('extraApis', {})]); const lf = function (n) { const i = mr(`Sketcher for ${n.name}`, ff, n); const e = M(i.apis, Jc); const t = M(i.extraApis, (n, e) => Kr(n, e)); return y({ name: h(i.name), partFields: h([]), configFields: h(i.configFields), sketch(n) { return e = i.name, t = i.configFields, r = i.factory, o = cf(n), r(uf(e, t, o, [], []), o); let e, t, r, o } }, e, t) }; const df = function (n) { const e = mr(`Sketcher for ${n.name}`, sf, n); const t = Pc(e.name, e.partFields); const r = M(e.apis, Jc); const o = M(e.extraApis, (n, e) => Kr(n, e)); return y({ name: h(e.name), partFields: h(e.partFields), configFields: h(e.configFields), sketch(n) { return af(e.name, e.configFields, e.partFields, e.factory, n) }, parts: h(t) }, r, o) }; const mf = lf({ name: 'Button', factory(n) { let e; let t; let r; const o = (e = n.action, t = function (n, e) { e.stop(), fe(n) }, r = qn.detect().deviceType.isTouch() ? [Lr(ne(), t)] : [Lr($(), t), Lr(N(), (n, e) => { e.cut() })], jr(In([e.map((t) => Lr(Qn(), (n, e) => { t(n), e.stop() })).toArray(), r]))); const i = n.dom.tag; const u = function (e) { return wt(n.dom, 'attributes').bind((n) => wt(n, e)) }; return { uid: n.uid, dom: n.dom, components: n.components, events: o, behaviours: dc(n.buttonBehaviours, [Vi.config({}), ac.config({ mode: 'execution', useSpace: !0, useEnter: !0 })]), domModification: { attributes: (function () { if (i !== 'button') return { role: u('role').getOr('button') }; const n = u('type').getOr('button'); const e = u('role').map((n) => ({ role: n })).getOr({}); return y({ type: n }, e) }()) }, eventOrder: n.eventOrder } }, configFields: [Tr('uid', undefined), br('dom'), Tr('components', []), lc('buttonBehaviours', [Vi, ac]), wr('action'), wr('role'), Tr('eventOrder', {})] }); const gf = ao({ fields: [], name: 'unselecting', active: Object.freeze({ events(n) { return jr([zr(_(), h(!0))]) }, exhibit(n, e) { return Jr({ styles: { '-webkit-user-select': 'none', 'user-select': 'none', '-ms-user-select': 'none', '-moz-user-select': '-moz-none' }, attributes: { unselectable: 'on' } }) } }) }); const pf = function (n) { let e; let t; let r; const o = me.fromHtml(n); const i = Le(o); const u = (t = (e = o).dom().attributes !== undefined ? e.dom().attributes : [], En(t, (n, e) => { let t; return e.name === 'class' ? n : y({}, n, ((t = {})[e.name] = e.value, t)) }, {})); const a = (r = o, Array.prototype.slice.call(r.dom().classList, 0)); const c = i.length === 0 ? {} : { innerHtml: jo(o) }; return y({ tag: he(o), classes: a, attributes: u }, c) }; const vf = function (n) { let e; let o; const t = (e = n, o = { prefix: Ai.prefix() }, e.replace(/\$\{([^{}]*)\}/g, (n, e) => { let t; const r = o[e]; return (t = typeof r) == 'string' || t === 'number' ? r.toString() : n })); return pf(t) }; const hf = function (n) { return { dom: vf(n) } }; const bf = function (n) { return io([ki.config({ toggleClass: Ai.resolve('toolbar-button-selected'), toggleOnExecute: !1, aria: { mode: 'pressed' } }), Ei(n, (n, e) => { (e ? ki.on : ki.off)(n) })]) }; const yf = function (n, e, t) { return mf.sketch({ dom: vf(`<span class="\${prefix}-toolbar-button \${prefix}-toolbar-group-item \${prefix}-icon-${n} \${prefix}-icon"></span>`), action: e, buttonBehaviours: ct(io([gf.config({})]), t) }) }; const xf = { forToolbar: yf, forToolbarCommand(n, e) { return yf(e, () => { n.execCommand(e) }, {}) }, forToolbarStateAction(n, e, t, r) { const o = bf(t); return yf(e, r, o) }, forToolbarStateCommand(n, e) { const t = bf(e); return yf(e, () => { n.execCommand(e) }, t) } }; const wf = qn.detect().deviceType.isTouch(); const Sf = Hc({ schema: [br('dom')], name: 'label' }); const Of = function (n) { return Hc({ name: `${n}-edge`, overrides(r) { return r.model.manager.edgeActions[n].fold(() => ({}), (t) => { const n = jr([Pr(R(), t, [r])]); const e = jr([Pr(N(), t, [r]), Pr(H(), (n, e) => { e.mouseIsDown.get() && t(n, e) }, [r])]); return { events: wf ? n : e } }) } }) }; const Tf = Of('top-left'); const kf = Of('top'); const Ef = Of('top-right'); const Cf = Of('right'); const Df = Of('bottom-right'); const Mf = Of('bottom'); const Af = Of('bottom-left'); const If = [Sf, Of('left'), Cf, kf, Mf, Tf, Ef, Af, Df, Nc({ name: 'thumb', defaults: h({ dom: { styles: { position: 'absolute' } } }), overrides(n) { return { events: jr([Gr(R(), n, 'spectrum'), Gr(F(), n, 'spectrum'), Gr(V(), n, 'spectrum'), Gr(N(), n, 'spectrum'), Gr(H(), n, 'spectrum'), Gr(j(), n, 'spectrum')]) } } }), Nc({ schema: [Er('mouseIsDown', () => Mo(!1))], name: 'spectrum', overrides(t) { const r = t.model.manager; const o = function (e, n) { return r.getValueFromEvent(n).map((n) => r.setValueFrom(e, t, n)) }; const n = jr([Lr(R(), o), Lr(F(), o)]); const e = jr([Lr(N(), o), Lr(H(), (n, e) => { t.mouseIsDown.get() && o(n, e) })]); return { behaviours: io(wf ? [] : [ac.config({ mode: 'special', onLeft(n) { return r.onLeft(n, t) }, onRight(n) { return r.onRight(n, t) }, onUp(n) { return r.onUp(n, t) }, onDown(n) { return r.onDown(n, t) } }), Vi.config({})]), events: wf ? n : e } } })]; const Bf = function (n, e, t) { e.store.manager.onLoad(n, e, t) }; const Rf = function (n, e, t) { e.store.manager.onUnload(n, e, t) }; const Ff = Object.freeze({ onLoad: Bf, onUnload: Rf, setValue(n, e, t, r) { e.store.manager.setValue(n, e, t, r) }, getValue(n, e, t) { return e.store.manager.getValue(n, e, t) }, getState(n, e, t) { return t } }); const Vf = Object.freeze({ events(t, r) { const n = t.resetOnDom ? [Wr((n, e) => { Bf(n, t, r) }), _r((n, e) => { Rf(n, t, r) })] : [Qr(t, r, Bf)]; return jr(n) } }); const Nf = function () { const n = Mo(null); return oo({ set: n.set, get: n.get, isNotSet() { return n.get() === null }, clear() { n.set(null) }, readState() { return { mode: 'memory', value: n.get() } } }) }; const Hf = function () { const i = Mo({}); const u = Mo({}); return oo({ readState() { return { mode: 'dataset', dataByValue: i.get(), dataByText: u.get() } }, lookup(n) { return wt(i.get(), n).orThunk(() => wt(u.get(), n)) }, update(n) { const e = i.get(); const t = u.get(); const r = {}; const o = {}; On(n, (e) => { r[e.value] = e, wt(e, 'meta').each((n) => { wt(n, 'text').each((n) => { o[n] = e }) }) }), i.set(y({}, e, r)), u.set(y({}, t, o)) }, clear() { i.set({}), u.set({}) } }) }; const jf = Object.freeze({ memory: Nf, dataset: Hf, manual() { return oo({ readState() {} }) }, init(n) { return n.store.manager.state(n) } }); const zf = function (n, e, t, r) { const o = e.store; t.update([r]), o.setValue(n, r), e.onSetValue(n, r) }; const Lf = [wr('initialValue'), br('getFallbackEntry'), br('getDataKey'), br('setValue'), ci('manager', { setValue: zf, getValue(n, e, t) { const r = e.store; const o = r.getDataKey(n); return t.lookup(o).fold(() => r.getFallbackEntry(o), (n) => n) }, onLoad(e, t, r) { t.store.initialValue.each((n) => { zf(e, t, r, n) }) }, onUnload(n, e, t) { t.clear() }, state: Hf })]; const Pf = [br('getValue'), Tr('setValue', x), wr('initialValue'), ci('manager', { setValue(n, e, t, r) { e.store.setValue(n, r), e.onSetValue(n, r) }, getValue(n, e, t) { return e.store.getValue(n) }, onLoad(e, t, n) { t.store.initialValue.each((n) => { t.store.setValue(e, n) }) }, onUnload: x, state: ro.init })]; const Uf = [wr('initialValue'), ci('manager', { setValue(n, e, t, r) { t.set(r), e.onSetValue(n, r) }, getValue(n, e, t) { return t.get() }, onLoad(n, e, t) { e.store.initialValue.each((n) => { t.isNotSet() && t.set(n) }) }, onUnload(n, e, t) { t.clear() }, state: Nf })]; const Gf = [kr('store', { mode: 'memory' }, pr('mode', { memory: Uf, manual: Pf, dataset: Lf })), oi('onSetValue'), Tr('resetOnDom', !1)]; var $f = ao({ fields: Gf, name: 'representing', active: Vf, apis: Ff, extra: { setValueFrom(n, e) { const t = $f.getValue(e); $f.setValue(n, t) } }, state: jf }); var Wf = function (t, r) { return { left: h(t), top: h(r), translate(n, e) { return Wf(t + n, r + e) } } }; const _f = Wf; const qf = qn.detect().deviceType.isTouch(); const Xf = h('slider.change.value'); const Yf = function (n) { const e = n.event().raw(); if (qf) { const t = e; return t.touches !== undefined && t.touches.length === 1 ? k.some(t.touches[0]).map((n) => _f(n.clientX, n.clientY)) : k.none() } const r = e; return r.clientX !== undefined ? k.some(r).map((n) => _f(n.clientX, n.clientY)) : k.none() }; const Kf = function (n, e, t, r) { return n < e ? n : t < n ? t : n === e ? e - 1 : Math.max(e, n - r) }; const Jf = function (n, e, t, r) { return t < n ? n : n < e ? e : n === t ? t + 1 : Math.min(t, n + r) }; const Qf = function (n, e, t) { return Math.max(e, Math.min(t, n)) }; const Zf = function (n) { const e = n.min; const t = n.max; const r = n.range; const o = n.value; const i = n.step; const u = n.snap; const a = n.snapStart; const c = n.rounded; const f = n.hasMinEdge; const s = n.hasMaxEdge; const l = n.minBound; const d = n.maxBound; const m = n.screenRange; const g = f ? e - 1 : e; const p = s ? t + 1 : t; if (o < l) return g; if (d < o) return p; let v; let h; let b; let y; let x; let w; let S; const O = (x = o, w = l, S = d, Math.min(S, Math.max(x, w)) - w); const T = Qf(O / m * r + e, g, p); return u && e <= T && T <= t ? (v = T, h = e, b = t, y = i, a.fold(() => { const n = v - h; const e = Math.round(n / y) * y; return Qf(h + e, h - 1, b + 1) }, (n) => { const e = (v - n) % y; const t = Math.round(e / y); const r = Math.floor((v - n) / y); const o = Math.floor((b - n) / y); const i = n + Math.min(o, r + t) * y; return Math.max(n, i) })) : c ? Math.round(T) : T }; const ns = function (n) { const e = n.min; const t = n.max; const r = n.range; const o = n.value; const i = n.hasMinEdge; const u = n.hasMaxEdge; const a = n.maxBound; const c = n.maxOffset; const f = n.centerMinEdge; const s = n.centerMaxEdge; return o < e ? i ? 0 : f : t < o ? u ? a : s : (o - e) / r * c }; const es = Wi('width', (n) => n.dom().offsetWidth); const ts = function (n, e) { es.set(n, e) }; const rs = function (n) { return es.get(n) }; const os = function (n) { return n.model.minX }; const is = function (n) { return n.model.minY }; const us = function (n) { return n.model.minX - 1 }; const as = function (n) { return n.model.minY - 1 }; const cs = function (n) { return n.model.maxX }; const fs = function (n) { return n.model.maxY }; const ss = function (n) { return n.model.maxX + 1 }; const ls = function (n) { return n.model.maxY + 1 }; const ds = function (n, e, t) { return e(n) - t(n) }; const ms = function (n) { return ds(n, cs, os) }; const gs = function (n) { return ds(n, fs, is) }; const ps = function (n) { return ms(n) / 2 }; const vs = function (n) { return gs(n) / 2 }; const hs = function (n) { return n.stepSize }; const bs = function (n) { return n.snapToGrid }; const ys = function (n) { return n.snapStart }; const xs = function (n) { return n.rounded }; const ws = function (n, e) { return n[`${e}-edge`] !== undefined }; const Ss = function (n) { return ws(n, 'left') }; const Os = function (n) { return ws(n, 'right') }; const Ts = function (n) { return ws(n, 'top') }; const ks = function (n) { return ws(n, 'bottom') }; const Es = function (n) { return n.model.value.get() }; const Cs = function (n) { return { x: h(n) } }; const Ds = function (n) { return { y: h(n) } }; const Ms = function (n, e) { return { x: h(n), y: h(e) } }; const As = function (n, e) { ce(n, Xf(), { value: e }) }; const Is = 'left'; const Bs = function (n) { return n.element().dom().getBoundingClientRect() }; const Rs = function (n, e) { return n[e] }; const Fs = function (n) { const e = Bs(n); return Rs(e, Is) }; const Vs = function (n) { const e = Bs(n); return Rs(e, 'right') }; const Ns = function (n) { const e = Bs(n); return Rs(e, 'top') }; const Hs = function (n) { const e = Bs(n); return Rs(e, 'bottom') }; const js = function (n) { const e = Bs(n); return Rs(e, 'width') }; const zs = function (n) { const e = Bs(n); return Rs(e, 'height') }; const Ls = function (n, e, t) { return (n + e) / 2 - t }; const Ps = function (n, e) { const t = Bs(n); const r = Bs(e); const o = Rs(t, Is); const i = Rs(t, 'right'); const u = Rs(r, Is); return Ls(o, i, u) }; const Us = function (n, e) { const t = Bs(n); const r = Bs(e); const o = Rs(t, 'top'); const i = Rs(t, 'bottom'); const u = Rs(r, 'top'); return Ls(o, i, u) }; const Gs = function (n, e) { ce(n, Xf(), { value: e }) }; const $s = function (n) { return { x: h(n) } }; const Ws = function (n, e, t) { const r = { min: os(e), max: cs(e), range: ms(e), value: t, step: hs(e), snap: bs(e), snapStart: ys(e), rounded: xs(e), hasMinEdge: Ss(e), hasMaxEdge: Os(e), minBound: Fs(n), maxBound: Vs(n), screenRange: js(n) }; return Zf(r) }; const _s = function (u) { return function (n, e) { return (t = u, r = n, o = e, i = (t > 0 ? Jf : Kf)(Es(o).x(), os(o), cs(o), hs(o)), Gs(r, $s(i)), k.some(i)).map(() => !0); let t, r, o, i } }; const qs = function (n, e, t, r, o, i) { let u; let a; let c; let f; let s; let l; let d; let m; let g; const p = (a = i, c = t, f = r, s = o, l = js(u = e), d = f.bind((n) => k.some(Ps(n, u))).getOr(0), m = s.bind((n) => k.some(Ps(n, u))).getOr(l), g = { min: os(a), max: cs(a), range: ms(a), value: c, hasMinEdge: Ss(a), hasMaxEdge: Os(a), minBound: Fs(u), minOffset: 0, maxBound: Vs(u), maxOffset: l, centerMinEdge: d, centerMaxEdge: m }, ns(g)); return Fs(e) - Fs(n) + p }; const Xs = _s(-1); const Ys = _s(1); const Ks = k.none; const Js = k.none; const Qs = { 'top-left': k.none(), top: k.none(), 'top-right': k.none(), right: k.some((n, e) => { As(n, Cs(ss(e))) }), 'bottom-right': k.none(), bottom: k.none(), 'bottom-left': k.none(), left: k.some((n, e) => { As(n, Cs(us(e))) }) }; const Zs = Object.freeze({ setValueFrom(n, e, t) { const r = Ws(n, e, t); const o = $s(r); return Gs(n, o), r }, setToMin(n, e) { const t = os(e); Gs(n, $s(t)) }, setToMax(n, e) { const t = cs(e); Gs(n, $s(t)) }, findValueOfOffset: Ws, getValueFromEvent(n) { return Yf(n).map((n) => n.left()) }, findPositionOfValue: qs, setPositionFromValue(n, e, t, r) { const o = Es(t); const i = qs(n, r.getSpectrum(n), o.x(), r.getLeftEdge(n), r.getRightEdge(n), t); const u = rs(e.element()) / 2; ji(e.element(), 'left', `${i - u}px`) }, onLeft: Xs, onRight: Ys, onUp: Ks, onDown: Js, edgeActions: Qs }); const nl = function (n, e) { ce(n, Xf(), { value: e }) }; const el = function (n) { return { y: h(n) } }; const tl = function (n, e, t) { const r = { min: is(e), max: fs(e), range: gs(e), value: t, step: hs(e), snap: bs(e), snapStart: ys(e), rounded: xs(e), hasMinEdge: Ts(e), hasMaxEdge: ks(e), minBound: Ns(n), maxBound: Hs(n), screenRange: zs(n) }; return Zf(r) }; const rl = function (u) { return function (n, e) { return (t = u, r = n, o = e, i = (t > 0 ? Jf : Kf)(Es(o).y(), is(o), fs(o), hs(o)), nl(r, el(i)), k.some(i)).map(() => !0); let t, r, o, i } }; const ol = function (n, e, t, r, o, i) { let u; let a; let c; let f; let s; let l; let d; let m; let g; const p = (a = i, c = t, f = r, s = o, l = zs(u = e), d = f.bind((n) => k.some(Us(n, u))).getOr(0), m = s.bind((n) => k.some(Us(n, u))).getOr(l), g = { min: is(a), max: fs(a), range: gs(a), value: c, hasMinEdge: Ts(a), hasMaxEdge: ks(a), minBound: Ns(u), minOffset: 0, maxBound: Hs(u), maxOffset: l, centerMinEdge: d, centerMaxEdge: m }, ns(g)); return Ns(e) - Ns(n) + p }; const il = k.none; const ul = k.none; const al = rl(-1); const cl = rl(1); const fl = { 'top-left': k.none(), top: k.some((n, e) => { As(n, Ds(as(e))) }), 'top-right': k.none(), right: k.none(), 'bottom-right': k.none(), bottom: k.some((n, e) => { As(n, Ds(ls(e))) }), 'bottom-left': k.none(), left: k.none() }; const sl = Object.freeze({ setValueFrom(n, e, t) { const r = tl(n, e, t); const o = el(r); return nl(n, o), r }, setToMin(n, e) { const t = is(e); nl(n, el(t)) }, setToMax(n, e) { const t = fs(e); nl(n, el(t)) }, findValueOfOffset: tl, getValueFromEvent(n) { return Yf(n).map((n) => n.top()) }, findPositionOfValue: ol, setPositionFromValue(n, e, t, r) { const o = Es(t); const i = ol(n, r.getSpectrum(n), o.y(), r.getTopEdge(n), r.getBottomEdge(n), t); const u = Yi(e.element()) / 2; ji(e.element(), 'top', `${i - u}px`) }, onLeft: il, onRight: ul, onUp: al, onDown: cl, edgeActions: fl }); const ll = function (n, e) { ce(n, Xf(), { value: e }) }; const dl = function (n, e) { return { x: h(n), y: h(e) } }; const ml = function (f, s) { return function (n, e) { return (t = f, r = s, o = n, i = e, u = t > 0 ? Jf : Kf, a = r ? Es(i).x() : u(Es(i).x(), os(i), cs(i), hs(i)), c = r ? u(Es(i).y(), is(i), fs(i), hs(i)) : Es(i).y(), ll(o, dl(a, c)), k.some(a)).map(() => !0); let t, r, o, i, u, a, c } }; const gl = ml(-1, !1); const pl = ml(1, !1); const vl = ml(-1, !0); const hl = ml(1, !0); const bl = { 'top-left': k.some((n, e) => { As(n, Ms(us(e), as(e))) }), top: k.some((n, e) => { As(n, Ms(ps(e), as(e))) }), 'top-right': k.some((n, e) => { As(n, Ms(ss(e), as(e))) }), right: k.some((n, e) => { As(n, Ms(ss(e), vs(e))) }), 'bottom-right': k.some((n, e) => { As(n, Ms(ss(e), ls(e))) }), bottom: k.some((n, e) => { As(n, Ms(ps(e), ls(e))) }), 'bottom-left': k.some((n, e) => { As(n, Ms(us(e), ls(e))) }), left: k.some((n, e) => { As(n, Ms(us(e), vs(e))) }) }; const yl = Object.freeze({ setValueFrom(n, e, t) { const r = Ws(n, e, t.left()); const o = tl(n, e, t.top()); const i = dl(r, o); return ll(n, i), i }, setToMin(n, e) { const t = os(e); const r = is(e); ll(n, dl(t, r)) }, setToMax(n, e) { const t = cs(e); const r = fs(e); ll(n, dl(t, r)) }, getValueFromEvent(n) { return Yf(n) }, setPositionFromValue(n, e, t, r) { const o = Es(t); const i = qs(n, r.getSpectrum(n), o.x(), r.getLeftEdge(n), r.getRightEdge(n), t); const u = ol(n, r.getSpectrum(n), o.y(), r.getTopEdge(n), r.getBottomEdge(n), t); const a = rs(e.element()) / 2; const c = Yi(e.element()) / 2; ji(e.element(), 'left', `${i - a}px`), ji(e.element(), 'top', `${u - c}px`) }, onLeft: gl, onRight: pl, onUp: vl, onDown: hl, edgeActions: bl }); const xl = qn.detect().deviceType.isTouch(); const wl = [Tr('stepSize', 1), Tr('onChange', x), Tr('onChoose', x), Tr('onInit', x), Tr('onDragStart', x), Tr('onDragEnd', x), Tr('snapToGrid', !1), Tr('rounded', !0), wr('snapStart'), yr('model', pr('mode', { x: [Tr('minX', 0), Tr('maxX', 100), Er('value', (n) => Mo(n.mode.minX)), br('getInitialValue'), ci('manager', Zs)], y: [Tr('minY', 0), Tr('maxY', 100), Er('value', (n) => Mo(n.mode.minY)), br('getInitialValue'), ci('manager', sl)], xy: [Tr('minX', 0), Tr('maxX', 100), Tr('minY', 0), Tr('maxY', 100), Er('value', (n) => Mo({ x: h(n.mode.minX), y: h(n.mode.minY) })), br('getInitialValue'), ci('manager', yl)] })), cc('sliderBehaviours', [ac, $f])].concat(xl ? [] : [Er('mouseIsDown', () => Mo(!1))]); const Sl = qn.detect().deviceType.isTouch(); const Ol = df({ name: 'Slider', configFields: wl, partFields: If, factory(i, n, e, t) { const u = function (n) { return _c(n, i, 'thumb') }; const a = function (n) { return _c(n, i, 'spectrum') }; const r = function (n) { return Wc(n, i, 'left-edge') }; const o = function (n) { return Wc(n, i, 'right-edge') }; const c = function (n) { return Wc(n, i, 'top-edge') }; const f = function (n) { return Wc(n, i, 'bottom-edge') }; const s = i.model; const l = s.manager; const d = function (n, e) { l.setPositionFromValue(n, e, i, { getLeftEdge: r, getRightEdge: o, getTopEdge: c, getBottomEdge: f, getSpectrum: a }) }; const m = function (n, e) { s.value.set(e); const t = u(n); return d(n, t), i.onChange(n, t, e), k.some(!0) }; const g = [Lr(R(), (n, e) => { i.onDragStart(n, u(n)) }), Lr(V(), (n, e) => { i.onDragEnd(n, u(n)) })]; const p = [Lr(N(), (n, e) => { e.stop(), i.onDragStart(n, u(n)), i.mouseIsDown.set(!0) }), Lr(j(), (n, e) => { i.onDragEnd(n, u(n)) })]; const v = Sl ? g : p; return { uid: i.uid, dom: i.dom, components: n, behaviours: sc(i.sliderBehaviours, In([Sl ? [] : [ac.config({ mode: 'special', focusIn(n) { return Wc(n, i, 'spectrum').map(ac.focusIn).map(h(!0)) } })], [$f.config({ store: { mode: 'manual', getValue(n) { return s.value.get() } } }), di.config({ channels: { 'mouse.released': { onReceive(t, n) { const e = i.mouseIsDown.get(); i.mouseIsDown.set(!1), e && Wc(t, i, 'thumb').each((n) => { const e = s.value.get(); i.onChoose(t, n, e) }) } } } })]])), events: jr([Lr(Xf(), (n, e) => { m(n, e.event().value()) }), Wr((n, e) => { const t = s.getInitialValue(); s.value.set(t); const r = u(n); d(n, r); const o = a(n); i.onInit(n, r, o, s.value.get()) })].concat(v)), apis: { resetToMin(n) { l.setToMin(n, i) }, resetToMax(n) { l.setToMax(n, i) }, changeValue: m, refresh: d }, domModification: { styles: { position: 'relative' } } } }, apis: { resetToMin(n, e) { n.resetToMin(e) }, resetToMax(n, e) { n.resetToMax(e) }, refresh(n, e) { n.refresh(e) } } }); const Tl = function (e, t, r) { return xf.forToolbar(t, () => { const n = r(); e.setContextToolbar([{ label: `${t} group`, items: n }]) }, {}) }; const kl = function (n) { return [(o = n, i = function (n) { return n < 0 ? 'black' : n > 360 ? 'white' : `hsl(${n}, 100%, 50%)` }, Ol.sketch({ dom: vf('<div class="${prefix}-slider ${prefix}-hue-slider-container"></div>'), components: [Ol.parts()['left-edge'](hf('<div class="${prefix}-hue-slider-black"></div>')), Ol.parts().spectrum({ dom: vf('<div class="${prefix}-slider-gradient-container"></div>'), components: [hf('<div class="${prefix}-slider-gradient"></div>')], behaviours: io([ki.config({ toggleClass: Ai.resolve('thumb-active') })]) }), Ol.parts()['right-edge'](hf('<div class="${prefix}-hue-slider-white"></div>')), Ol.parts().thumb({ dom: vf('<div class="${prefix}-slider-thumb"></div>'), behaviours: io([ki.config({ toggleClass: Ai.resolve('thumb-active') })]) })], onChange(n, e, t) { const r = i(t.x()); ji(e.element(), 'background-color', r), o.onChange(n, e, r) }, onDragStart(n, e) { ki.on(e) }, onDragEnd(n, e) { ki.off(e) }, onInit(n, e, t, r) { const o = i(r.x()); ji(e.element(), 'background-color', o) }, stepSize: 10, model: { mode: 'x', minX: 0, maxX: 360, getInitialValue() { return { x() { return o.getInitialValue() } } } }, sliderBehaviours: io([Ci(Ol.refresh)]) }))]; let o, i }; const El = function (n, r) { const e = { onChange(n, e, t) { r.undoManager.transact(() => { r.formatter.apply('forecolor', { value: t }), r.nodeChanged() }) }, getInitialValue() { return -1 } }; return Tl(n, 'color', () => kl(e)) }; const Cl = nr([br('getInitialValue'), br('onChange'), br('category'), br('sizes')]); const Dl = function (n) { const i = mr('SizeSlider', Cl, n); return Ol.sketch({ dom: { tag: 'div', classes: [Ai.resolve(`slider-${i.category}-size-container`), Ai.resolve('slider'), Ai.resolve('slider-size-container')] }, onChange(n, e, t) { let r; const o = t.x(); (r = o) >= 0 && r < i.sizes.length && i.onChange(o) }, onDragStart(n, e) { ki.on(e) }, onDragEnd(n, e) { ki.off(e) }, model: { mode: 'x', minX: 0, maxX: i.sizes.length - 1, getInitialValue() { return { x() { return i.getInitialValue() } } } }, stepSize: 1, snapToGrid: !0, sliderBehaviours: io([Ci(Ol.refresh)]), components: [Ol.parts().spectrum({ dom: vf('<div class="${prefix}-slider-size-container"></div>'), components: [hf('<div class="${prefix}-slider-size-line"></div>')] }), Ol.parts().thumb({ dom: vf('<div class="${prefix}-slider-thumb"></div>'), behaviours: io([ki.config({ toggleClass: Ai.resolve('thumb-active') })]) })] }) }; const Ml = ['9px', '10px', '11px', '12px', '14px', '16px', '18px', '20px', '24px', '32px', '36px']; const Al = function (n) { let e; let t; const r = n.selection.getStart(); const o = me.fromDom(r); const i = me.fromDom(n.getBody()); const u = (e = function (n) { return He(i, n) }, (ye(t = o) ? k.some(t) : ze(t)).map((n) => Vr(n, (n) => Ui(n, 'font-size').isSome(), e).bind((n) => Ui(n, 'font-size')).getOrThunk(() => Li(n, 'font-size'))).getOr('')); return Cn(Ml, (n) => u === n).getOr('medium') }; const Il = { candidates: h(Ml), get(n) { let e; const t = Al(n); return (e = t, Dn(Ml, (n) => n === e)).getOr(2) }, apply(r, n) { let e; (e = n, k.from(Ml[e])).each((n) => { let e, t; t = n, Al(e = r) !== t && e.execCommand('fontSize', !1, t) }) } }; const Bl = Il.candidates(); const Rl = function (n) { return [hf('<span class="${prefix}-toolbar-button ${prefix}-icon-small-font ${prefix}-icon"></span>'), (e = n, Dl({ onChange: e.onChange, sizes: Bl, category: 'font', getInitialValue: e.getInitialValue })), hf('<span class="${prefix}-toolbar-button ${prefix}-icon-large-font ${prefix}-icon"></span>')]; let e }; const Fl = function (n) { const e = (function t(n) { return n.uid !== undefined }(n)) && kt(n, 'uid') ? n.uid : of('memento'); return { get(n) { return n.getSystem().getByUid(e).getOrDie() }, getOpt(n) { return n.getSystem().getByUid(e).fold(k.none, k.some) }, asSpec() { return y({}, n, { uid: e }) } } }; function Vl(n, e) { return Hl(document.createElement('canvas'), n, e) } function Nl(n) { return n.getContext('2d') } function Hl(n, e, t) { return n.width = e, n.height = t, n } const jl = { create: Vl, clone: function Ah(n) { let e; return Nl(e = Vl(n.width, n.height)).drawImage(n, 0, 0), e }, resize: Hl, get2dContext: Nl, get3dContext: function Ih(n) { let e = null; try { e = n.getContext('webgl') || n.getContext('experimental-webgl') } catch (t) {} return e || (e = null), e } }; const zl = { getWidth: function Bh(n) { return n.naturalWidth || n.width }, getHeight: function Rh(n) { return n.naturalHeight || n.height } }; const Ll = window.Promise ? window.Promise : (function () { const n = function (n) { if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new'); if (typeof n !== 'function') throw new TypeError('not a function'); this._state = null, this._value = null, this._deferreds = [], f(n, r(o, this), r(u, this)) }; const e = n.immediateFn || typeof window.setImmediate === 'function' && window.setImmediate || function (n) { setTimeout(n, 1) }; function r(n, e) { return function () { n.apply(e, arguments) } } const t = Array.isArray || function (n) { return Object.prototype.toString.call(n) === '[object Array]' }; function i(r) { const o = this; this._state !== null ? e(() => { const n = o._state ? r.onFulfilled : r.onRejected; if (n !== null) { let e; try { e = n(o._value) } catch (t) { return void r.reject(t) }r.resolve(e) } else (o._state ? r.resolve : r.reject)(o._value) }) : this._deferreds.push(r) } function o(n) { try { if (n === this) throw new TypeError('A promise cannot be resolved with itself.'); if (n && (typeof n === 'object' || typeof n === 'function')) { const e = n.then; if (typeof e === 'function') return void f(r(e, n), r(o, this), r(u, this)) } this._state = !0, this._value = n, a.call(this) } catch (t) { u.call(this, t) } } function u(n) { this._state = !1, this._value = n, a.call(this) } function a() { for (let n = 0, e = this._deferreds.length; n < e; n++)i.call(this, this._deferreds[n]); this._deferreds = null } function c(n, e, t, r) { this.onFulfilled = typeof n === 'function' ? n : null, this.onRejected = typeof e === 'function' ? e : null, this.resolve = t, this.reject = r } function f(n, e, t) { let r = !1; try { n((n) => { r || (r = !0, e(n)) }, (n) => { r || (r = !0, t(n)) }) } catch (o) { if (r) return; r = !0, t(o) } } return n.prototype.catch = function (n) { return this.then(null, n) }, n.prototype.then = function (t, r) { const o = this; return new n((n, e) => { i.call(o, new c(t, r, n, e)) }) }, n.all = function () { const c = Array.prototype.slice.call(arguments.length === 1 && t(arguments[0]) ? arguments[0] : arguments); return new n((o, i) => { if (c.length === 0) return o([]); let u = c.length; function a(e, n) { try { if (n && (typeof n === 'object' || typeof n === 'function')) { const t = n.then; if (typeof t === 'function') return void t.call(n, (n) => { a(e, n) }, i) }c[e] = n, --u == 0 && o(c) } catch (r) { i(r) } } for (let n = 0; n < c.length; n++)a(n, c[n]) }) }, n.resolve = function (e) { return e && typeof e === 'object' && e.constructor === n ? e : new n((n) => { n(e) }) }, n.reject = function (t) { return new n((n, e) => { e(t) }) }, n.race = function (o) { return new n((n, e) => { for (let t = 0, r = o.length; t < r; t++)o[t].then(n, e) }) }, n }()); function Pl() { return new (Ae.getOrDie('FileReader'))() } const Ul = { atob(n) { return Ae.getOrDie('atob')(n) }, requestAnimationFrame(n) { Ae.getOrDie('requestAnimationFrame')(n) } }; function Gl(a) { return new Ll((n, e) => { const t = URL.createObjectURL(a); const r = new Image(); const o = function () { r.removeEventListener('load', i), r.removeEventListener('error', u) }; function i() { o(), n(r) } function u() { o(), e(`Unable to load data of type ${a.type}: ${t}`) }r.addEventListener('load', i), r.addEventListener('error', u), r.src = t, r.complete && i() }) } function $l(r) { return new Ll((n, t) => { const e = new XMLHttpRequest(); e.open('GET', r, !0), e.responseType = 'blob', e.onload = function () { this.status == 200 && n(this.response) }, e.onerror = function () { let n; const e = this; t(this.status === 0 ? ((n = new Error('No access to download image')).code = 18, n.name = 'SecurityError', n) : new Error(`Error ${e.status} downloading image`)) }, e.send() }) } function Wl(n) { const e = n.split(','); const t = /data:([^;]+)/.exec(e[0]); if (!t) return k.none(); for (var r, o = t[1], i = e[1], u = Ul.atob(i), a = u.length, c = Math.ceil(a / 1024), f = new Array(c), s = 0; s < c; ++s) { for (var l = 1024 * s, d = Math.min(l + 1024, a), m = new Array(d - l), g = l, p = 0; g < d; ++p, ++g)m[p] = u[g].charCodeAt(0); f[s] = (r = m, new (Ae.getOrDie('Uint8Array'))(r)) } return k.some(function v(n, e) { return new (Ae.getOrDie('Blob'))(n, e) }(f, { type: o })) } function _l(t) { return new Ll((n, e) => { Wl(t).fold(() => { e(`uri is not base64: ${t}`) }, n) }) } function ql(t) { return new Ll((n) => { const e = Pl(); e.onloadend = function () { n(e.result) }, e.readAsDataURL(t) }) } let Xl; let Yl; let Kl; const Jl = { blobToImage: Gl, imageToBlob: function Fh(n) { const e = n.src; return e.indexOf('data:') === 0 ? _l(e) : $l(e) }, blobToArrayBuffer: function Vh(t) { return new Ll((n) => { const e = Pl(); e.onloadend = function () { n(e.result) }, e.readAsArrayBuffer(t) }) }, blobToDataUri: ql, blobToBase64: function Nh(n) { return ql(n).then((n) => n.split(',')[1]) }, dataUriToBlobSync: Wl, canvasToBlob: function Hh(n, t, r) { return t = t || 'image/png', HTMLCanvasElement.prototype.toBlob ? new Ll((e) => { n.toBlob((n) => { e(n) }, t, r) }) : _l(n.toDataURL(t, r)) }, canvasToDataURL: function jh(n, e, t) { return e = e || 'image/png', n.then((n) => n.toDataURL(e, t)) }, blobToCanvas: function zh(n) { return Gl(n).then((n) => { let e; return (function t(n) { URL.revokeObjectURL(n.src) }(n)), e = jl.create(zl.getWidth(n), zl.getHeight(n)), jl.get2dContext(e).drawImage(n, 0, 0), e }) }, uriToBlob: function Lh(n) { return n.indexOf('blob:') === 0 ? $l(n) : n.indexOf('data:') === 0 ? _l(n) : null } }; const Ql = function (n) { return Jl.blobToBase64(n) }; const Zl = function (u) { const e = Fl({ dom: { tag: 'input', attributes: { accept: 'image/*', type: 'file', title: '' }, styles: { visibility: 'hidden', position: 'absolute' } }, events: jr([$r($()), Lr(G(), (n, e) => { let t, r, o; (t = e, r = t.event(), o = r.raw().target.files || r.raw().dataTransfer.files, k.from(o[0])).each((n) => { let o, i; o = u, Ql(i = n).then((r) => { o.undoManager.transact(() => { const n = o.editorUpload.blobCache; const e = n.create(Sc('mceu'), i, r); n.add(e); const t = o.dom.createHTML('img', { src: e.blobUri() }); o.insertContent(t) }) }) }) })]) }); return mf.sketch({ dom: vf('<span class="${prefix}-toolbar-button ${prefix}-icon-image ${prefix}-icon"></span>'), components: [e.asSpec()], action(n) { e.get(n).element().dom().click() } }) }; const nd = function (n) { return n.dom().textContent }; const ed = function (n) { return n.length > 0 }; const td = function (n) { return n === undefined || n === null ? '' : n }; const rd = function (e, t, n) { return n.text.toOption().filter(ed).fold(() => { return go(n = e, 'href') === nd(n) ? k.some(t) : k.none(); let n }, k.some) }; const od = function (n) { const e = me.fromDom(n.selection.getStart()); return tu(e, 'a') }; const id = { getInfo(n) { return od(n).fold(() => ({ url: '', text: n.selection.getContent({ format: 'text' }), title: '', target: '', link: k.none() }), (n) => { return t = nd(e = n), r = go(e, 'href'), o = go(e, 'title'), i = go(e, 'target'), { url: td(r), text: t !== r ? td(t) : '', title: td(o), target: td(i), link: k.some(e) }; let e, t, r, o, i }) }, applyInfo(o, i) { i.url.toOption().filter(ed).fold(() => { let e; e = o, i.link.bind(b).each((n) => { e.execCommand('unlink') }) }, (e) => { let n; let t; const r = (n = i, (t = {}).href = e, n.title.toOption().filter(ed).each((n) => { t.title = n }), n.target.toOption().filter(ed).each((n) => { t.target = n }), t); i.link.bind(b).fold(() => { const n = i.text.toOption().filter(ed).getOr(e); o.insertContent(o.dom.createHTML('a', r, o.dom.encode(n))) }, (t) => { const n = rd(t, e, i); mo(t, r), n.each((n) => { let e; e = n, t.dom().textContent = e }) }) }) }, query: od }; const ud = qn.detect(); const ad = function (n, e) { const t = e.selection.getRng(); n(), e.selection.setRng(t) }; const cd = function (n, e) { (ud.os.isAndroid() ? ad : s)(e, n) }; const fd = function (n, e) { let t, r; return { key: n, value: { config: {}, me: (t = n, r = jr(e), ao({ fields: [br('enabled')], name: t, active: { events: h(r) } })), configAsRaw: h({}), initialConfig: {}, state: ro } } }; const sd = Object.freeze({ getCurrent(n, e, t) { return e.find(n) } }); const ld = [br('find')]; const dd = ao({ fields: ld, name: 'composing', apis: sd }); const md = lf({ name: 'Container', factory(n) { const e = n.dom; const t = e.attributes; const r = c(e, ['attributes']); return { uid: n.uid, dom: y({ tag: 'div', attributes: y({ role: 'presentation' }, t) }, r), components: n.components, behaviours: fc(n.containerBehaviours), events: n.events, domModification: n.domModification, eventOrder: n.eventOrder } }, configFields: [Tr('components', []), cc('containerBehaviours', []), Tr('events', {}), Tr('domModification', {}), Tr('eventOrder', {})] }); const gd = lf({ name: 'DataField', factory(t) { return { uid: t.uid, dom: t.dom, behaviours: dc(t.dataBehaviours, [$f.config({ store: { mode: 'memory', initialValue: t.getInitialValue() } }), dd.config({ find: k.some })]), events: jr([Wr((n, e) => { $f.setValue(n, t.getInitialValue()) })]) } }, configFields: [br('uid'), br('dom'), br('getInitialValue'), lc('dataBehaviours', [$f, dd])] }); const pd = function (n) { return n.dom().value }; const vd = function (n, e) { if (e === undefined) throw new Error('Value.set was undefined'); n.dom().value = e }; const hd = h([wr('data'), Tr('inputAttributes', {}), Tr('inputStyles', {}), Tr('tag', 'input'), Tr('inputClasses', []), oi('onSetValue'), Tr('styles', {}), Tr('eventOrder', {}), cc('inputBehaviours', [$f, Vi]), Tr('selectOnFocus', !0)]); const bd = function (n) { return y({}, (e = n, io([Vi.config({ onFocus: !1 === e.selectOnFocus ? x : function (n) { const e = n.element(); const t = pd(e); e.dom().setSelectionRange(0, t.length) } })])), sc(n.inputBehaviours, [$f.config({ store: { mode: 'manual', initialValue: n.data.getOr(undefined), getValue(n) { return pd(n.element()) }, setValue(n, e) { pd(n.element()) !== e && vd(n.element(), e) } }, onSetValue: n.onSetValue })])); let e }; const yd = lf({ name: 'Input', configFields: hd(), factory(n, e) { return { uid: n.uid, dom: (t = n, { tag: t.tag, attributes: y({ type: 'input' }, t.inputAttributes), styles: t.inputStyles, classes: t.inputClasses }), components: [], behaviours: bd(n), eventOrder: n.eventOrder }; let t } }); const xd = Object.freeze({ exhibit(n, e) { return Jr({ attributes: Ot([{ key: e.tabAttr, value: 'true' }]) }) } }); const wd = [Tr('tabAttr', 'data-alloy-tabstop')]; const Sd = ao({ fields: wd, name: 'tabstopping', active: xd }); const Od = function (n, e) { const t = Fl(yd.sketch({ inputAttributes: { placeholder: e }, onSetValue(n, e) { ae(n, U()) }, inputBehaviours: io([dd.config({ find: k.some }), Sd.config({}), ac.config({ mode: 'execution' })]), selectOnFocus: !1 })); const r = Fl(mf.sketch({ dom: vf('<button class="${prefix}-input-container-x ${prefix}-icon-cancel-circle ${prefix}-icon"></button>'), action(n) { const e = t.get(n); $f.setValue(e, '') } })); return { name: n, spec: md.sketch({ dom: vf('<div class="${prefix}-input-container"></div>'), components: [t.asSpec(), r.asSpec()], containerBehaviours: io([ki.config({ toggleClass: Ai.resolve('input-container-empty') }), dd.config({ find(n) { return k.some(t.get(n)) } }), fd('input-clearing', [Lr(U(), (n) => { const e = t.get(n); ($f.getValue(e).length > 0 ? ki.off : ki.on)(n) })])]) }) } }; const Td = ['input', 'button', 'textarea']; const kd = function (n, e, t) { e.disabled && Id(n, e, t) }; const Ed = function (n) { return wn(Td, he(n.element())) }; const Cd = function (n) { lo(n.element(), 'disabled', 'disabled') }; const Dd = function (n) { vo(n.element(), 'disabled') }; const Md = function (n) { lo(n.element(), 'aria-disabled', 'true') }; const Ad = function (n) { lo(n.element(), 'aria-disabled', 'false') }; var Id = function (e, n, t) { n.disableClass.each((n) => { wo(e.element(), n) }), (Ed(e) ? Cd : Md)(e) }; const Bd = function (n) { return Ed(n) ? po(n.element(), 'disabled') : go(n.element(), 'aria-disabled') === 'true' }; const Rd = Object.freeze({ enable(e, n, t) { n.disableClass.each((n) => { Oo(e.element(), n) }), (Ed(e) ? Dd : Ad)(e) }, disable: Id, isDisabled: Bd, onLoad: kd }); const Fd = Object.freeze({ exhibit(n, e, t) { return Jr({ classes: e.disabled ? e.disableClass.map(Nn).getOr([]) : [] }) }, events(n, e) { return jr([zr(Qn(), (n, e) => Bd(n)), Qr(n, e, kd)]) } }); const Vd = [Tr('disabled', !1), wr('disableClass')]; const Nd = ao({ fields: Vd, name: 'disabling', active: Fd, apis: Rd }); const Hd = [cc('formBehaviours', [$f])]; const jd = function (n) { return `<alloy.field.${n}>` }; const zd = function (o, n, e) { return { uid: o.uid, dom: o.dom, components: n, behaviours: sc(o.formBehaviours, [$f.config({ store: { mode: 'manual', getValue(n) { let e; let t; const r = (e = o, t = n.getSystem(), M(e.partUids, (n, e) => h(t.getByUid(n)))); return M(r, (n, e) => n().bind((n) => { let e; const t = dd.getCurrent(n); return e = 'missing current', t.fold(() => ot.error(e), ot.value) }).map($f.getValue)) }, setValue(t, n) { D(n, (e, n) => { Wc(t, o, n).each((n) => { dd.getCurrent(n).each((n) => { $f.setValue(n, e) }) }) }) } } })]), apis: { getField(n, e) { return Wc(n, o, e).bind(dd.getCurrent) } } } }; const Ld = (Jc((n, e, t) => n.getField(e, t)), function (n) { let i; const e = (i = [], { field(n, e) { return i.push(n), t = 'form', r = jd(n), o = e, { uiType: xc(), owner: t, name: r, config: o, validated: {} }; let t, r, o }, record() { return i } }); const t = n(e); const r = e.record(); const o = Sn(r, (n) => Nc({ name: n, pname: jd(n) })); return af('form', Hd, o, zd, t) }); const Pd = function () { const e = Mo(k.none()); const t = function () { e.get().each((n) => { n.destroy() }) }; return { clear() { t(), e.set(k.none()) }, isSet() { return e.get().isSome() }, set(n) { t(), e.set(k.some(n)) }, run(n) { e.get().each(n) } } }; const Ud = function () { const e = Mo(k.none()); return { clear() { e.set(k.none()) }, set(n) { e.set(k.some(n)) }, isSet() { return e.get().isSome() }, on(n) { e.get().each(n) } } }; const Gd = function (n) { return { xValue: n, points: [] } }; const $d = function (n, e) { if (e === n.xValue) return n; const t = e - n.xValue > 0 ? 1 : -1; const r = { direction: t, xValue: e }; return { xValue: e, points: (n.points.length === 0 ? [] : n.points[n.points.length - 1].direction === t ? n.points.slice(0, n.points.length - 1) : n.points).concat([r]) } }; const Wd = function (n) { if (n.points.length === 0) return 0; const e = n.points[0].direction; const t = n.points[n.points.length - 1].direction; return e === -1 && t === -1 ? -1 : e === 1 && t === 1 ? 1 : 0 }; const _d = function (n) { const r = 'navigateEvent'; const e = er([br('fields'), Tr('maxFieldIndex', n.fields.length - 1), br('onExecute'), br('getInitialValue'), Er('state', () => ({ dialogSwipeState: Ud(), currentScreen: Mo(0) }))]); const u = mr('SerialisedDialog', e, n); const o = function (e, n, t) { return mf.sketch({ dom: vf(`<span class="\${prefix}-icon-${n} \${prefix}-icon"></span>`), action(n) { ce(n, r, { direction: e }) }, buttonBehaviours: io([Nd.config({ disableClass: Ai.resolve('toolbar-navigation-disabled'), disabled: !t })]) }) }; const i = function (n, o) { const i = Qi(n.element(), `.${Ai.resolve('serialised-dialog-screen')}`); eu(n.element(), `.${Ai.resolve('serialised-dialog-chain')}`).each((r) => { u.state.currentScreen.get() + o >= 0 && u.state.currentScreen.get() + o < i.length && (Ui(r, 'left').each((n) => { const e = parseInt(n, 10); const t = rs(i[0]); ji(r, 'left', `${e - o * t}px`) }), u.state.currentScreen.set(u.state.currentScreen.get() + o)) }) }; const a = function (r) { const n = Qi(r.element(), 'input'); k.from(n[u.state.currentScreen.get()]).each((n) => { r.getSystem().getByDom(n).each((n) => { let e, t; e = r, t = n.element(), e.getSystem().triggerFocus(t, e.element()) }) }); const e = f.get(r); ku.highlightAt(e, u.state.currentScreen.get()) }; const c = Fl(Ld((t) => ({ dom: vf('<div class="${prefix}-serialised-dialog"></div>'), components: [md.sketch({ dom: vf('<div class="${prefix}-serialised-dialog-chain" style="left: 0px; position: absolute;"></div>'), components: Sn(u.fields, (n, e) => e <= u.maxFieldIndex ? md.sketch({ dom: vf('<div class="${prefix}-serialised-dialog-screen"></div>'), components: [o(-1, 'previous', e > 0), t.field(n.name, n.spec), o(1, 'next', e < u.maxFieldIndex)] }) : t.field(n.name, n.spec)) })], formBehaviours: io([Ci((n, e) => { let t; t = e, eu(n.element(), `.${Ai.resolve('serialised-dialog-chain')}`).each((n) => { ji(n, 'left', `${-u.state.currentScreen.get() * t.width}px`) }) }), ac.config({ mode: 'special', focusIn(n) { a(n) }, onTab(n) { return i(n, 1), k.some(!0) }, onShiftTab(n) { return i(n, -1), k.some(!0) } }), fd('form-events', [Wr((e, n) => { u.state.currentScreen.set(0), u.state.dialogSwipeState.clear(); const t = f.get(e); ku.highlightFirst(t), u.getInitialValue(e).each((n) => { $f.setValue(e, n) }) }), Xr(u.onExecute), Lr(W(), (n, e) => { e.event().raw().propertyName === 'left' && a(n) }), Lr(r, (n, e) => { const t = e.event().direction(); i(n, t) })])]) }))); var f = Fl({ dom: vf('<div class="${prefix}-dot-container"></div>'), behaviours: io([ku.config({ highlightClass: Ai.resolve('dot-active'), itemClass: Ai.resolve('dot-item') })]), components: Bn(u.fields, (n, e) => e <= u.maxFieldIndex ? [hf('<div class="${prefix}-dot-item ${prefix}-icon-full-dot ${prefix}-icon"></div>')] : []) }); return { dom: vf('<div class="${prefix}-serializer-wrapper"></div>'), components: [c.asSpec(), f.asSpec()], behaviours: io([ac.config({ mode: 'special', focusIn(n) { const e = c.get(n); ac.focusIn(e) } }), fd('serializer-wrapper-events', [Lr(R(), (n, e) => { const t = e.event(); u.state.dialogSwipeState.set(Gd(t.raw().touches[0].clientX)) }), Lr(F(), (n, e) => { const t = e.event(); u.state.dialogSwipeState.on((n) => { e.event().prevent(), u.state.dialogSwipeState.set($d(n, t.raw().touches[0].clientX)) }) }), Lr(V(), (r) => { u.state.dialogSwipeState.on((n) => { const e = c.get(r); const t = -1 * Wd(n); i(e, t) }) })])]) } }; const qd = q((t, r) => { return [{ label: 'the link group', items: [_d({ fields: [Od('url', 'Type or paste URL'), Od('text', 'Link text'), Od('title', 'Link title'), Od('target', 'Link target'), (n = 'link', { name: n, spec: gd.sketch({ dom: { tag: 'span', styles: { display: 'none' } }, getInitialValue() { return k.none() } }) })], maxFieldIndex: ['url', 'text', 'title', 'target'].length - 1, getInitialValue() { return k.some(id.getInfo(r)) }, onExecute(n) { const e = $f.getValue(n); id.applyInfo(r, e), t.restoreToolbar(), r.focus() } })] }]; let n }); const Xd = [{ title: 'Headings', items: [{ title: 'Heading 1', format: 'h1' }, { title: 'Heading 2', format: 'h2' }, { title: 'Heading 3', format: 'h3' }, { title: 'Heading 4', format: 'h4' }, { title: 'Heading 5', format: 'h5' }, { title: 'Heading 6', format: 'h6' }] }, { title: 'Inline', items: [{ title: 'Bold', icon: 'bold', format: 'bold' }, { title: 'Italic', icon: 'italic', format: 'italic' }, { title: 'Underline', icon: 'underline', format: 'underline' }, { title: 'Strikethrough', icon: 'strikethrough', format: 'strikethrough' }, { title: 'Superscript', icon: 'superscript', format: 'superscript' }, { title: 'Subscript', icon: 'subscript', format: 'subscript' }, { title: 'Code', icon: 'code', format: 'code' }] }, { title: 'Blocks', items: [{ title: 'Paragraph', format: 'p' }, { title: 'Blockquote', format: 'blockquote' }, { title: 'Div', format: 'div' }, { title: 'Pre', format: 'pre' }] }, { title: 'Alignment', items: [{ title: 'Left', icon: 'alignleft', format: 'alignleft' }, { title: 'Center', icon: 'aligncenter', format: 'aligncenter' }, { title: 'Right', icon: 'alignright', format: 'alignright' }, { title: 'Justify', icon: 'alignjustify', format: 'alignjustify' }] }]; const Yd = jr([(Xl = Yn(), Yl = function (n, e) { let t; let r; const o = e.event().originator(); const i = e.event().target(); return r = i, !(He(t = o, n.element()) && !He(t, r) && (console.warn(`${Yn()} did not get interpreted by the desired target. \nOriginator: ${Uo(o)}\nTarget: ${Uo(i)}\nCheck the ${Yn()} event handlers`), 1)) }, { key: Xl, value: Dr({ can: Yl }) })]); const Kd = Object.freeze({ events: Yd }); const Jd = b; const Qd = function (e) { const n = function (n) { return function () { throw new Error(`The component must be in a context to send: ${n}\n${Uo(e().element())} is not in context.`) } }; return { debugInfo: h('fake'), triggerEvent: n('triggerEvent'), triggerFocus: n('triggerFocus'), triggerEscape: n('triggerEscape'), build: n('build'), addToWorld: n('addToWorld'), removeFromWorld: n('removeFromWorld'), addToGui: n('addToGui'), removeFromGui: n('removeFromGui'), getByUid: n('getByUid'), getByDom: n('getByDom'), broadcast: n('broadcast'), broadcastOn: n('broadcastOn'), broadcastEvent: n('broadcastEvent'), isConnected: h(!1) } }; const Zd = Qd(); const nm = function (n, o) { const i = {}; return D(n, (n, r) => { D(n, (n, e) => { const t = xt(e, [])(i); i[e] = t.concat([o(r, n)]) }) }), i }; const em = function (n, e) { return t = l.apply(undefined, [n.handler].concat(e)), r = n.purpose(), { cHandler: t, purpose: h(r) }; let t, r }; const tm = function (n) { return n.cHandler }; const rm = function (n, e) { return { name: h(n), handler: h(e) } }; const om = function (n, e, t) { let r; let o; const i = y({}, t, (r = n, o = {}, On(e, (n) => { o[n.name()] = n.handlers(r) }), o)); return nm(i, rm) }; const im = function (n) { let e; const i = bn(e = n) ? { can: h(!0), abort: h(!1), run: e } : e; return function (n, e) { for (var t = [], r = 2; r < arguments.length; r++)t[r - 2] = arguments[r]; const o = [n, e].concat(t); i.abort.apply(undefined, o) ? e.stop() : i.can.apply(undefined, o) && i.run.apply(undefined, o) } }; const um = function (n, e, t) { let r; let o; const i = e[t]; return i ? (function (u, a, n, c) { const e = n.slice(0); try { const t = e.sort((n, e) => { const t = n[a](); const r = e[a](); const o = c.indexOf(t); const i = c.indexOf(r); if (o === -1) throw new Error(`The ordering for ${u} does not have an entry for ${t}.\nOrder specified: ${_t(c, null, 2)}`); if (i === -1) throw new Error(`The ordering for ${u} does not have an entry for ${r}.\nOrder specified: ${_t(c, null, 2)}`); return o < i ? -1 : i < o ? 1 : 0 }); return ot.value(t) } catch (r) { return ot.error([r]) } }(`Event: ${t}`, 'name', n, i)).map((n) => { const e = Sn(n, (n) => n.handler()); return Mr(e) }) : (r = t, o = n, ot.error([`The event (${r}) has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ${_t(Sn(o, (n) => n.name()), null, 2)}`])) }; const am = function (n, i) { const e = I(n, (r, o) => (r.length === 1 ? ot.value(r[0].handler()) : um(r, i, o)).map((n) => { const e = im(n); const t = r.length > 1 ? Tn(i, (e) => wn(r, (n) => n.name() === e)).join(' > ') : r[0].name(); return St(o, { handler: e, purpose: h(t) }) })); return Tt(e, {}) }; const cm = function (n) { return lr('custom.definition', er([ir('dom', 'dom', dt(), er([br('tag'), Tr('styles', {}), Tr('classes', []), Tr('attributes', {}), wr('value'), wr('innerHtml')])), br('components'), br('uid'), Tr('events', {}), Tr('apis', {}), ir('eventOrder', 'eventOrder', (e = { 'alloy.execute': ['disabling', 'alloy.base.behaviour', 'toggling', 'typeaheadevents'], 'alloy.focus': ['alloy.base.behaviour', 'focusing', 'keying'], 'alloy.system.init': ['alloy.base.behaviour', 'disabling', 'toggling', 'representing'], input: ['alloy.base.behaviour', 'representing', 'streaming', 'invalidating'], 'alloy.system.detached': ['alloy.base.behaviour', 'representing'], mousedown: ['focusing', 'alloy.base.behaviour', 'item-type-events'] }, st.mergeWithThunk(h(e))), vr()), wr('domModification')]), n); let e }; const fm = function (e, n) { On(n, (n) => { wo(e, n) }) }; const sm = function (e, n) { On(n, (n) => { Oo(e, n) }) }; const lm = function (n, e) { return t = n, o = Sn(r = e, (n) => Sr(n.name(), [br('config'), Tr('state', ro)])), i = lr('component.behaviours', er(o), t.behaviours).fold((n) => { throw new Error(`${gr(n)}\nComplete spec:\n${_t(t, null, 2)}`) }, (n) => n), { list: r, data: M(i, (n) => { const e = n.map((n) => ({ config: n.config, state: n.state.init(n.config) })); return function () { return e } }) }; let t, r, o, i }; const dm = function (n) { let e; let t; let r; const o = (e = n, t = xt('behaviours', {})(e), r = Tn(E(t), (n) => t[n] !== undefined), Sn(r, (n) => t[n].me)); return lm(n, o) }; const mm = function (n, e, t) { let r; let o; let i; const u = y({}, (r = n).dom, { uid: r.uid, domChildren: Sn(r.components, (n) => n.element()) }); const a = n.domModification.fold(() => Jr({}), Jr); const c = { 'alloy.base.modification': a }; const f = e.length > 0 ? (function (e, n, t, r) { const o = y({}, n); On(t, (n) => { o[n.name()] = n.exhibit(e, r) }); const i = nm(o, (n, e) => ({ name: n, modification: e })); const u = function (n) { return kn(n, (n, e) => y({}, e.modification, n), {}) }; const a = kn(i.classes, (n, e) => e.modification.concat(n), []); const c = u(i.attributes); const f = u(i.styles); return Jr({ classes: a, attributes: c, styles: f }) }(t, c, e, u)) : a; return i = f, y({}, o = u, { attributes: y({}, o.attributes, i.attributes), styles: y({}, o.styles, i.styles), classes: o.classes.concat(i.classes) }) }; const gm = function (n, e, t) { let r; let o; let i; let u; let a; let c; const f = { 'alloy.base.behaviour': (r = n, r.events) }; return (o = t, i = n.eventOrder, u = e, a = f, c = om(o, u, a), am(c, i)).getOrDie() }; const pm = function (t) { const n = function () { return s }; const r = Mo(Zd); const e = dr(cm(t)); const o = dm(t); const i = o.list; const u = o.data; const a = (function (n) { const e = me.fromTag(n.tag); mo(e, n.attributes), fm(e, n.classes), zi(e, n.styles), n.innerHtml.each((n) => zo(e, n)); const t = n.domChildren; return _e(e, t), n.value.each((n) => { vd(e, n) }), n.uid, tf(e, n.uid), e }(mm(e, i, u))); const c = gm(e, i, u); const f = Mo(e.components); var s = { getSystem: r.get, config(n) { const e = u; return (bn(e[n.name()]) ? e[n.name()] : function () { throw new Error(`Could not find ${n.name()} in ${_t(t, null, 2)}`) })() }, hasConfigured(n) { return bn(u[n.name()]) }, spec: h(t), readState(n) { return u[n]().map((n) => n.state.readState()).getOr('not enabled') }, getApis() { return e.apis }, connect(n) { r.set(n) }, disconnect() { r.set(Qd(n)) }, element: h(a), syncComponents() { const n = Le(a); const e = Bn(n, (n) => r.get().getByDom(n).fold(() => [], (n) => [n])); f.set(e) }, components: f.get, events: h(c) }; return s }; const vm = function (n) { let e; let t; const r = Jd(n); const o = r.events; const i = c(r, ['events']); const u = (e = i, t = xt('components', [])(e), Sn(t, xm)); const a = y({}, i, { events: y({}, Kd, o), components: u }); return ot.value(pm(a)) }; const hm = function (n) { const e = me.fromText(n); return bm({ element: e }) }; var bm = function (n) { const e = mr('external.component', nr([br('element'), wr('uid')]), n); const t = Mo(Qd()); e.uid.each((n) => { tf(e.element, n) }); var r = { getSystem: t.get, config: k.none, hasConfigured: h(!1), connect(n) { t.set(n) }, disconnect() { t.set(Qd(() => r)) }, getApis() { return {} }, element: h(e.element), spec: h(n), readState: h('No state'), syncComponents: x, components: h([]), events: h({}) }; return Kc(r) }; const ym = of; var xm = function (e) { return (n = e, wt(n, Yc)).fold(() => { const n = e.hasOwnProperty('uid') ? e : y({ uid: ym('') }, e); return vm(n).getOrDie() }, (n) => n); let n }; const wm = Kc; const Sm = 'alloy.item-hover'; const Om = 'alloy.item-focus'; const Tm = function (n) { (Ro(n.element()).isNone() || Vi.isFocused(n)) && (Vi.isFocused(n) || Vi.focus(n), ce(n, Sm, { item: n })) }; const km = function (n) { ce(n, Om, { item: n }) }; const Em = h(Sm); const Cm = h(Om); const Dm = [br('data'), br('components'), br('dom'), Tr('hasSubmenu', !1), wr('toggling'), lc('itemBehaviours', [ki, Vi, ac, $f]), Tr('ignoreFocus', !1), Tr('domModification', {}), ci('builder', (n) => ({ dom: n.dom, domModification: y({}, n.domModification, { attributes: y({ role: n.toggling.isSome() ? 'menuitemcheckbox' : 'menuitem' }, n.domModification.attributes, { 'aria-haspopup': n.hasSubmenu }, n.hasSubmenu ? { 'aria-expanded': !1 } : {}) }), behaviours: dc(n.itemBehaviours, [n.toggling.fold(ki.revoke, (n) => ki.config(y({ aria: { mode: 'checked' } }, n))), Vi.config({ ignore: n.ignoreFocus, stopMousedown: n.ignoreFocus, onFocus(n) { km(n) } }), ac.config({ mode: 'execution' }), $f.config({ store: { mode: 'memory', initialValue: n.data } }), fd('item-type-events', [Lr(ee(), fe), $r(N()), Lr(z(), Tm), Lr(Zn(), Vi.focus)])]), components: n.components, eventOrder: n.eventOrder })), Tr('eventOrder', {})]; const Mm = [br('dom'), br('components'), ci('builder', (n) => { return { dom: n.dom, components: n.components, events: jr([(e = Zn(), Lr(e, (n, e) => { e.stop() }))]) }; let e })]; const Am = h([Nc({ name: 'widget', overrides(e) { return { behaviours: io([$f.config({ store: { mode: 'manual', getValue(n) { return e.data }, setValue() {} } })]) } } })]); const Im = [br('uid'), br('data'), br('components'), br('dom'), Tr('autofocus', !1), Tr('ignoreFocus', !1), lc('widgetBehaviours', [$f, Vi, ac]), Tr('domModification', {}), Xc(Am()), ci('builder', (t) => { const n = Gc(0, t, Am()); const e = $c('item-widget', t, n.internals()); const r = function (n) { return Wc(n, t, 'widget').map((n) => ac.focusIn(n), n) }; const o = function (n, e) { return Fu(e.event().target()) || t.autofocus && e.setSource(n.element()), k.none() }; return { dom: t.dom, components: e, domModification: t.domModification, events: jr([Xr((n, e) => { r(n).each((n) => { e.stop() }) }), Lr(z(), Tm), Lr(Zn(), (n, e) => { t.autofocus ? r(n) : Vi.focus(n) })]), behaviours: dc(t.widgetBehaviours, [$f.config({ store: { mode: 'memory', initialValue: t.data } }), Vi.config({ ignore: t.ignoreFocus, onFocus(n) { km(n) } }), ac.config({ mode: 'special', focusIn: t.autofocus ? function (n) { r(n) } : fo(), onLeft: o, onRight: o, onEscape(n, e) { return Vi.isFocused(n) || t.autofocus ? (t.autofocus && e.setSource(n.element()), k.none()) : (Vi.focus(n), k.some(!0)) } })]) } })]; const Bm = pr('type', { widget: Im, item: Dm, separator: Mm }); const Rm = h([jc({ factory: { sketch(n) { const e = mr('menu.spec item', Bm, n); return e.builder(e) } }, name: 'items', unit: 'item', defaults(n, e) { return e.hasOwnProperty('uid') ? e : y({}, e, { uid: of('item') }) }, overrides(n, e) { return { type: e.type, ignoreFocus: n.fakeFocus, domModification: { classes: [n.markers.item] } } } })]); const Fm = h([br('value'), br('items'), br('dom'), br('components'), Tr('eventOrder', {}), cc('menuBehaviours', [ku, $f, dd, ac]), kr('movement', { mode: 'menu', moveOnTab: !0 }, pr('mode', { grid: [si(), ci('config', (n, e) => ({ mode: 'flatgrid', selector: `.${n.markers.item}`, initSize: { numColumns: e.initSize.numColumns, numRows: e.initSize.numRows }, focusManager: n.focusManager }))], matrix: [ci('config', (n, e) => ({ mode: 'matrix', selectors: { row: e.rowSelector, cell: `.${n.markers.item}` }, focusManager: n.focusManager })), br('rowSelector')], menu: [Tr('moveOnTab', !0), ci('config', (n, e) => ({ mode: 'menu', selector: `.${n.markers.item}`, moveOnTab: e.moveOnTab, focusManager: n.focusManager }))] })), yr('markers', ei()), Tr('fakeFocus', !1), Tr('focusManager', Cu()), oi('onHighlight')]); const Vm = h('alloy.menu-focus'); const Nm = df({ name: 'Menu', configFields: Fm(), partFields: Rm(), factory(n, e, t, r) { return { uid: n.uid, dom: n.dom, markers: n.markers, behaviours: sc(n.menuBehaviours, [ku.config({ highlightClass: n.markers.selectedItem, itemClass: n.markers.item, onHighlight: n.onHighlight }), $f.config({ store: { mode: 'memory', initialValue: n.value } }), dd.config({ find: k.some }), ac.config(n.movement.config(n, n.movement))]), events: jr([Lr(Cm(), (e, t) => { const n = t.event(); e.getSystem().getByDom(n.target()).each((n) => { ku.highlight(e, n), t.stop(), ce(e, Vm(), { menu: e, item: n }) }) }), Lr(Em(), (n, e) => { const t = e.event().item(); ku.highlight(n, t) })]), components: e, eventOrder: n.eventOrder, domModification: { attributes: { role: 'menu' } } } } }); const Hm = function (n, e, t, r) { const o = n.getSystem().build(r); Qe(n, o, t) }; const jm = function (n, e, t, r) { const o = zm(n, e); Cn(o, (n) => He(r.element(), n.element())).each(nt) }; var zm = function (n, e) { return n.components() }; const Lm = function (e, t, n, o, r) { const i = zm(e, t); return k.from(i[o]).map((n) => jm(e, t, 0, n), r.each((n) => { Hm(e, 0, (n, e) => { let t, r; r = e, Pe(t = n, o).fold(() => { We(t, r) }, (n) => { Ue(n, r) }) }, n) }), n) }; const Pm = ao({ fields: [], name: 'replacing', apis: Object.freeze({ append(n, e, t, r) { Hm(n, 0, We, r) }, prepend(n, e, t, r) { Hm(n, 0, $e, r) }, remove: jm, replaceAt: Lm, replaceBy(e, t, n, r, o) { const i = zm(e, t); return Dn(i, r).bind((n) => Lm(e, t, 0, n, o)) }, set(e, n, t, r) { let o, i, u, a, c, f; i = (o = e).components(), On(i, Ze), qe(o.element()), o.syncComponents(), u = function () { const n = Sn(r, e.getSystem().build); On(n, (n) => { Je(e, n) }) }, a = e.element(), c = je(a), f = Bo(c).bind((e) => { const n = function (n) { return He(e, n) }; return n(a) ? k.some(a) : Nr(a, n) }), u(a), f.each((e) => { Bo(c).filter((n) => He(n, e)).fold(() => { Ao(e) }, x) }) }, contents: zm }) }); var Um = function (t, r, o, n) { return wt(o, n).bind((n) => wt(t, n).bind((n) => { const e = Um(t, r, o, n); return k.some([n].concat(e)) })).getOr([]) }; const Gm = function (n, e) { const t = {}; D(n, (n, e) => { On(n, (n) => { t[n] = e }) }); const r = e; const o = A(e, (n, e) => ({ k: n, v: e })); const i = M(o, (n, e) => [e].concat(Um(t, r, o, e))); return M(t, (n) => wt(i, n).getOr([n])) }; const $m = function () { const i = Mo({}); const u = Mo({}); const a = Mo({}); const c = Mo(k.none()); const f = Mo({}); const e = function (n) { return wt(u.get(), n) }; return { setMenuBuilt(n, e) { let t; u.set(y({}, u.get(), ((t = {})[n] = { type: 'prepared', menu: e }, t))) }, setContents(n, e, t, r) { c.set(k.some(n)), i.set(t), u.set(e), f.set(r); const o = Gm(r, t); a.set(o) }, expand(t) { return wt(i.get(), t).map((n) => { const e = wt(a.get(), t).getOr([]); return [n].concat(e) }) }, refresh(n) { return wt(a.get(), n) }, collapse(n) { return wt(a.get(), n).bind((n) => n.length > 1 ? k.some(n.slice(1)) : k.none()) }, lookupMenu: e, otherMenus(n) { let e; let t; const r = f.get(); return e = E(r), t = n, Tn(e, (n) => !wn(t, n)) }, getPrimary() { return c.get().bind((n) => e(n).bind((n) => n.type === 'prepared' ? k.some(n.menu) : k.none())) }, getMenus() { return u.get() }, clear() { i.set({}), u.set({}), a.set({}), c.set(k.none()) }, isClear() { return c.get().isNone() } } }; const Wm = h('collapse-item'); const _m = lf({ name: 'TieredMenu', configFields: [ai('onExecute'), ai('onEscape'), ui('onOpenMenu'), ui('onOpenSubmenu'), oi('onCollapseMenu'), Tr('highlightImmediately', !0), xr('data', [br('primary'), br('menus'), br('expansions')]), Tr('fakeFocus', !1), oi('onHighlight'), oi('onHover'), xr('markers', [br('backgroundMenu')].concat(Zo()).concat(ni())), br('dom'), Tr('navigateOnHover', !0), Tr('stayInDom', !1), cc('tmenuBehaviours', [ac, ku, dd, Pm]), Tr('eventOrder', {})], apis: { collapseMenu(n, e) { n.collapseMenu(e) }, highlightPrimary(n, e) { n.highlightPrimary(e) } }, factory(a, n) { let c; let e; const i = Mo(k.none()); const u = function (r, o, n) { return M(n, (n, e) => { const t = function () { return Nm.sketch(y({ dom: n.dom }, n, { value: e, items: n.items, markers: a.markers, fakeFocus: a.fakeFocus, onHighlight: a.onHighlight, focusManager: a.fakeFocus ? (o = function (n) { return ku.getHighlighted(n).map((n) => n.element()) }, { get: o, set(e, n) { const t = o(e); e.getSystem().getByDom(n).fold(x, (n) => { ku.highlight(e, n) }); const r = o(e); Eu(e, t, r) } }) : Cu() })); let o }; return e === o ? { type: 'prepared', menu: r.getSystem().build(t()) } : { type: 'notbuilt', nbMenu: t } }) }; const f = $m(); const s = function (n) { return $f.getValue(n).value }; const l = function (n) { return M(a.data.menus, (n, e) => Bn(n.items, (n) => n.type === 'separator' ? [] : [n.data.value])) }; const d = function (e, n) { ku.highlight(e, n), ku.getHighlighted(n).orThunk(() => ku.getFirst(n)).each((n) => { se(e, n.element(), Zn()) }) }; const m = function (e, n) { return $o(Sn(n, (n) => e.lookupMenu(n).bind((n) => n.type === 'prepared' ? k.some(n.menu) : k.none()))) }; const g = function (e, n, t) { const r = m(n, n.otherMenus(t)); On(r, (n) => { sm(n.element(), [a.markers.backgroundMenu]), a.stayInDom || Pm.remove(e, n) }) }; const p = function (n, r) { let o; const e = (o = n, i.get().getOrThunk(() => { const t = {}; const n = Qi(o.element(), `.${a.markers.item}`); const e = Tn(n, (n) => go(n, 'aria-haspopup') === 'true'); return On(e, (n) => { o.getSystem().getByDom(n).each((n) => { const e = s(n); t[e] = n }) }), i.set(k.some(t)), t })); D(e, (n, e) => { const t = wn(r, e); lo(n.element(), 'aria-expanded', t) }) }; const v = function (r, o, i) { return k.from(i[0]).bind((n) => o.lookupMenu(n).bind((n) => { if (n.type === 'notbuilt') return k.none(); const e = n.menu; const t = m(o, i.slice(1)); return On(t, (n) => { wo(n.element(), a.markers.backgroundMenu) }), we(e.element()) || Pm.append(r, wm(e)), sm(e.element(), [a.markers.backgroundMenu]), d(r, e), g(r, o, i), k.some(e) })) }; (e = c || (c = {}))[e.HighlightSubmenu = 0] = 'HighlightSubmenu', e[e.HighlightParent = 1] = 'HighlightParent'; const h = function (o, i, u) { void 0 === u && (u = c.HighlightSubmenu); const n = s(i); return f.expand(n).bind((r) => p(o, r), k.from(r[0]).bind((t) => f.lookupMenu(t).bind((n) => { const e = (function (n, e, t) { if (t.type !== 'notbuilt') return t.menu; const r = n.getSystem().build(t.nbMenu()); return f.setMenuBuilt(e, r), r }(o, t, n)); return we(e.element()) || Pm.append(o, wm(e)), a.onOpenSubmenu(o, i, e), u === c.HighlightSubmenu ? (ku.highlightFirst(e), v(o, f, r)) : (ku.dehighlightAll(e), k.some(i)) }))) }; const r = function (e, t) { const n = s(t); return f.collapse(n).bind((n) => p(e, n), v(e, f, n).map((n) => a.onCollapseMenu(e, t, n), n)) }; const t = function (t) { return function (e, n) { return tu(n.getSource(), `.${a.markers.item}`).bind((n) => e.getSystem().getByDom(n).toOption().bind((n) => t(e, n).map(() => !0))) } }; const o = jr([Lr(Vm(), (e, n) => { const t = n.event().menu(); ku.highlight(e, t); const r = s(n.event().item()); f.refresh(r).each((n) => g(e, f, n)) }), Xr((e, n) => { const t = n.event().target(); e.getSystem().getByDom(t).each((n) => { s(n).indexOf('collapse-item') === 0 && r(e, n), h(e, n, c.HighlightSubmenu).fold(() => { a.onExecute(e, n) }, () => {}) }) }), Wr((e, n) => { let t, r, o; (t = e, r = u(t, a.data.primary, a.data.menus), o = l(t), f.setContents(a.data.primary, r, a.data.expansions, o), f.getPrimary()).each((n) => { Pm.append(e, wm(n)), a.onOpenMenu(e, n), a.highlightImmediately && d(e, n) }) })].concat(a.navigateOnHover ? [Lr(Em(), (n, e) => { let t; let r; const o = e.event().item(); t = n, r = s(o), f.refresh(r).bind((n) => p(t, n), v(t, f, n)), h(n, o, c.HighlightParent), a.onHover(n, o) })] : [])); const b = { collapseMenu(e) { ku.getHighlighted(e).each((n) => { ku.getHighlighted(n).each((n) => { r(e, n) }) }) }, highlightPrimary(e) { f.getPrimary().each((n) => { d(e, n) }) } }; return { uid: a.uid, dom: a.dom, markers: a.markers, behaviours: sc(a.tmenuBehaviours, [ac.config({ mode: 'special', onRight: t((n, e) => Fu(e.element()) ? k.none() : h(n, e, c.HighlightSubmenu)), onLeft: t((n, e) => Fu(e.element()) ? k.none() : r(n, e)), onEscape: t((n, e) => r(n, e).orThunk(() => a.onEscape(n, e).map(() => n))), focusIn(e, n) { f.getPrimary().each((n) => { se(e, n.element(), Zn()) }) } }), ku.config({ highlightClass: a.markers.selectedMenu, itemClass: a.markers.menu }), dd.config({ find(n) { return ku.getHighlighted(n) } }), Pm.config({})]), eventOrder: a.eventOrder, apis: b, events: o } }, extraApis: { tieredData(n, e, t) { return { primary: n, menus: e, expansions: t } }, singleData(n, e) { return { primary: n, menus: St(n, e), expansions: {} } }, collapseItem(n) { return { value: Sc(Wm()), meta: { text: n } } } } }); const qm = function (n, e, t, r) { return wt(e.routes, r.start).bind((n) => wt(n, r.destination)) }; const Xm = function (n, e, t, r) { return qm(0, e, 0, r).bind((e) => e.transition.map((n) => ({ transition: n, route: e }))) }; const Ym = function (t, r, n) { let e, o, i; (e = t, o = r, i = n, Km(e, o, i).bind((n) => Xm(e, o, i, n))).each((n) => { const e = n.transition; Oo(t.element(), e.transitionClass), vo(t.element(), r.destinationAttr) }) }; var Km = function (n, e, t) { const r = n.element(); return po(r, e.destinationAttr) ? k.some({ start: go(n.element(), e.stateAttr), destination: go(n.element(), e.destinationAttr) }) : k.none() }; const Jm = function (n, e, t, r) { Ym(n, e, t), po(n.element(), e.stateAttr) && go(n.element(), e.stateAttr) !== r && e.onFinish(n, r), lo(n.element(), e.stateAttr, r) }; const Qm = Object.freeze({ findRoute: qm, disableTransition: Ym, getCurrentRoute: Km, jumpTo: Jm, progressTo(t, r, o, i) { let n, e; e = r, po((n = t).element(), e.destinationAttr) && (lo(n.element(), e.stateAttr, go(n.element(), e.destinationAttr)), vo(n.element(), e.destinationAttr)); let u; let a; const c = (u = r, a = i, { start: go(t.element(), u.stateAttr), destination: a }); Xm(t, r, o, c).fold(() => { Jm(t, r, o, i) }, (n) => { Ym(t, r, o); const e = n.transition; wo(t.element(), e.transitionClass), lo(t.element(), r.destinationAttr, i) }) }, getState(n, e, t) { const r = n.element(); return po(r, e.stateAttr) ? k.some(go(r, e.stateAttr)) : k.none() } }); const Zm = Object.freeze({ events(o, i) { return jr([Lr(W(), (t, n) => { const r = n.event().raw(); Km(t, o, i).each((e) => { qm(0, o, 0, e).each((n) => { n.transition.each((n) => { r.propertyName === n.property && (Jm(t, o, i, e.destination), o.onTransition(t, e)) }) }) }) }), Wr((n, e) => { Jm(n, o, i, o.initialState) })]) } }); const ng = [Tr('destinationAttr', 'data-transitioning-destination'), Tr('stateAttr', 'data-transitioning-state'), br('initialState'), oi('onTransition'), oi('onFinish'), yr('routes', sr(ot.value, sr(ot.value, nr([Or('transition', [br('property'), br('transitionClass')])]))))]; const eg = ao({ fields: ng, name: 'transitioning', active: Zm, apis: Qm, extra: { createRoutes(n) { const r = {}; return D(n, (n, e) => { const t = e.split('<->'); r[t[0]] = St(t[1], n), r[t[1]] = St(t[0], n) }), r }, createBistate(n, e, t) { return Ot([{ key: n, value: St(e, t) }, { key: e, value: St(n, t) }]) }, createTristate(n, e, t, r) { return Ot([{ key: n, value: Ot([{ key: e, value: r }, { key: t, value: r }]) }, { key: e, value: Ot([{ key: n, value: r }, { key: t, value: r }]) }, { key: t, value: Ot([{ key: n, value: r }, { key: e, value: r }]) }]) } } }); const tg = Ai.resolve('scrollable'); const rg = { register(n) { wo(n, tg) }, deregister(n) { Oo(n, tg) }, scrollable: h(tg) }; const og = function (n) { return wt(n, 'format').getOr(n.title) }; const ig = function (n, e, t, r, o) { return { data: { value: n, text: e }, type: 'item', dom: { tag: 'div', classes: o ? [Ai.resolve('styles-item-is-menu')] : [] }, toggling: { toggleOnExecute: !1, toggleClass: Ai.resolve('format-matches'), selected: t }, itemBehaviours: io(o ? [] : [Ei(n, (n, e) => { (e ? ki.on : ki.off)(n) })]), components: [{ dom: { tag: 'div', attributes: { style: r }, innerHtml: e } }] } }; const ug = function (n, e, t, r) { return { value: n, dom: { tag: 'div' }, components: [mf.sketch({ dom: { tag: 'div', classes: [Ai.resolve('styles-collapser')] }, components: r ? [{ dom: { tag: 'span', classes: [Ai.resolve('styles-collapse-icon')] } }, hm(n)] : [hm(n)], action(n) { if (r) { const e = t().get(n); _m.collapseMenu(e) } } }), { dom: { tag: 'div', classes: [Ai.resolve('styles-menu-items-container')] }, components: [Nm.parts().items({})], behaviours: io([fd('adhoc-scrollable-menu', [Wr((n, e) => { ji(n.element(), 'overflow-y', 'auto'), ji(n.element(), '-webkit-overflow-scrolling', 'touch'), rg.register(n.element()) }), _r((n) => { Gi(n.element(), 'overflow-y'), Gi(n.element(), '-webkit-overflow-scrolling'), rg.deregister(n.element()) })])]) }], items: e, menuBehaviours: io([eg.config({ initialState: 'after', routes: eg.createTristate('before', 'current', 'after', { transition: { property: 'transform', transitionClass: 'transitioning' } }) })]) } }; const ag = function (r) { let o; let i; let n; let e; let t; const u = (o = r.formats, i = function () { return a }, n = ug('Styles', [].concat(Sn(o.items, (n) => ig(og(n), n.title, n.isSelected(), n.getPreview(), kt(o.expansions, og(n))))), i, !1), e = M(o.menus, (n, e) => { const t = Sn(n, (n) => ig(og(n), n.title, n.isSelected !== undefined && n.isSelected(), n.getPreview !== undefined ? n.getPreview() : '', kt(o.expansions, og(n)))); return ug(e, t, i, !0) }), t = ct(e, St('styles', n)), { tmenu: _m.tieredData('styles', t, o.expansions) }); var a = Fl(_m.sketch({ dom: { tag: 'div', classes: [Ai.resolve('styles-menu')] }, components: [], fakeFocus: !0, stayInDom: !0, onExecute(n, e) { const t = $f.getValue(e); return r.handle(e, t.value), k.none() }, onEscape() { return k.none() }, onOpenMenu(n, e) { const t = rs(n.element()); ts(e.element(), t), eg.jumpTo(e, 'current') }, onOpenSubmenu(n, e, t) { const r = rs(n.element()); const o = nu(e.element(), '[role="menu"]').getOrDie('hacky'); const i = n.getSystem().getByDom(o).getOrDie(); ts(t.element(), r), eg.progressTo(i, 'before'), eg.jumpTo(t, 'after'), eg.progressTo(t, 'current') }, onCollapseMenu(n, e, t) { const r = nu(e.element(), '[role="menu"]').getOrDie('hacky'); const o = n.getSystem().getByDom(r).getOrDie(); eg.progressTo(o, 'after'), eg.progressTo(t, 'current') }, navigateOnHover: !1, highlightImmediately: !0, data: u.tmenu, markers: { backgroundMenu: Ai.resolve('styles-background-menu'), menu: Ai.resolve('styles-menu'), selectedMenu: Ai.resolve('styles-selected-menu'), item: Ai.resolve('styles-item'), selectedItem: Ai.resolve('styles-selected-item') } })); return a.asSpec() }; const cg = function (n) { return kt(n, 'items') ? (i = ct((it([{ bothErrors: ['error1', 'error2'] }, { firstError: ['error1', 'value2'] }, { secondError: ['value1', 'error2'] }, { bothValues: ['value1', 'value2'] }]), e = o = n, t = ['items'], r = {}, D(e, (n, e) => { wn(t, e) || (r[e] = n) }), r), { menu: !0 }), u = fg(o.items), { item: i, menus: ct(u.menus, St(o.title, u.items)), expansions: ct(u.expansions, St(o.title, o.title)) }) : { item: n, menus: {}, expansions: {} }; let e, t, r, o, i, u }; var fg = function (n) { return kn(n, (n, e) => { const t = cg(e); return { menus: ct(n.menus, t.menus), items: [t.item].concat(n.items), expansions: ct(n.expansions, t.expansions) } }, { menus: {}, expansions: {}, items: [] }) }; const sg = { expand: fg }; const lg = function (u, n) { const a = function (n) { return function () { return u.formatter.match(n) } }; const c = function (n) { return function () { return u.formatter.getCssText(n) } }; const e = wt(n, 'style_formats').getOr(Xd); var f = function (n) { return Sn(n, (n) => { if (kt(n, 'items')) { const e = f(n.items); return ct(ct(n, { isSelected: h(!1), getPreview: h('') }), { items: e }) } return kt(n, 'format') ? ct(i = n, { isSelected: a(i.format), getPreview: c(i.format) }) : (r = Sc((t = n).title), o = ct(t, { format: r, isSelected: a(r), getPreview: c(r) }), u.formatter.register(r, o), o); let t, r, o, i }) }; return f(e) }; const dg = function (t, n, r) { let e; let o; let i; const u = (e = t, i = (o = function (n) { return Bn(n, (n) => n.items === undefined ? !kt(n, 'format') || e.formatter.canApply(n.format) ? [n] : [] : o(n.items).length > 0 ? [n] : []) })(n), sg.expand(i)); return ag({ formats: u, handle(n, e) { t.undoManager.transact(() => { ki.isOn(n) ? t.formatter.remove(e) : t.formatter.apply(e) }), r() } }) }; const mg = ['undo', 'bold', 'italic', 'link', 'image', 'bullist', 'styleselect']; const gg = function (n) { const e = n.replace(/\|/g, ' ').trim(); return e.length > 0 ? e.split(/\s+/) : [] }; var pg = function (n) { return Bn(n, (n) => vn(n) ? pg(n) : gg(n)) }; const vg = function (n) { const e = n.toolbar !== undefined ? n.toolbar : mg; return vn(e) ? pg(e) : gg(e) }; const hg = function (r, o) { const n = function (n) { return function () { return xf.forToolbarCommand(o, n) } }; const e = function (n) { return function () { return xf.forToolbarStateCommand(o, n) } }; const t = function (n, e, t) { return function () { return xf.forToolbarStateAction(o, n, e, t) } }; const i = n('undo'); const u = n('redo'); const a = e('bold'); const c = e('italic'); const f = e('underline'); const s = n('removeformat'); const l = t('unlink', 'link', () => { o.execCommand('unlink', null, !1) }); const d = t('unordered-list', 'ul', () => { o.execCommand('InsertUnorderedList', null, !1) }); const m = t('ordered-list', 'ol', () => { o.execCommand('InsertOrderedList', null, !1) }); const g = lg(o, o.settings); const p = function () { return dg(o, g, () => { o.fire('scrollIntoView') }) }; const v = function (n, e) { return { isSupported() { return n.forall((n) => kt(o.buttons, n)) }, sketch: e } }; return { undo: v(k.none(), i), redo: v(k.none(), u), bold: v(k.none(), a), italic: v(k.none(), c), underline: v(k.none(), f), removeformat: v(k.none(), s), link: v(k.none(), () => { return e = r, t = o, xf.forToolbarStateAction(t, 'link', 'link', () => { const n = qd(e, t); e.setContextToolbar(n), cd(t, () => { e.focusToolbar() }), id.query(t).each((n) => { t.selection.select(n.dom()) }) }); let e, t }), unlink: v(k.none(), l), image: v(k.none(), () => Zl(o)), bullist: v(k.some('bullist'), d), numlist: v(k.some('numlist'), m), fontsizeselect: v(k.none(), () => { return e = o, n = { onChange(n) { Il.apply(e, n) }, getInitialValue() { return Il.get(e) } }, Tl(r, 'font-size', () => Rl(n)); let e, n }), forecolor: v(k.none(), () => El(r, o)), styleselect: v(k.none(), () => xf.forToolbar('style-formats', (n) => { o.fire('toReading'), r.dropup().appear(p, ki.on, n) }, io([ki.config({ toggleClass: Ai.resolve('toolbar-button-selected'), toggleOnExecute: !1, aria: { mode: 'pressed' } }), di.config({ channels: Ot([Di(Ho.orientationChanged(), ki.off), Di(Ho.dropupDismissed(), ki.off)]) })]))) } }; const bg = function (n, t) { const e = vg(n); const r = {}; return Bn(e, (n) => { const e = !kt(r, n) && kt(t, n) && t[n].isSupported() ? [t[n].sketch()] : []; return r[n] = !0, e }) }; const yg = function (m, g) { return function (n) { if (m(n)) { let e; let t; let r; let o; let i; let u; let a; const c = me.fromDom(n.target); const f = function () { n.stopPropagation() }; const s = function () { n.preventDefault() }; const l = p(s, f); const d = (e = c, t = n.clientX, r = n.clientY, o = f, i = s, u = l, a = n, { target: h(e), x: h(t), y: h(r), stop: o, prevent: i, kill: u, raw: h(a) }); g(d) } } }; const xg = function (n, e, t, r, o) { const i = yg(t, r); return n.dom().addEventListener(e, i, o), { unbind: l(wg, n, e, i, o) } }; var wg = function (n, e, t, r) { n.dom().removeEventListener(e, t, r) }; const Sg = h(!0); const Og = function (n, e, t) { return xg(n, e, Sg, t, !1) }; const Tg = function (n, e, t) { return xg(n, e, Sg, t, !0) }; const kg = function (n) { const e = n.matchMedia('(orientation: portrait)').matches; return { isPortrait: h(e) } }; const Eg = kg; const Cg = function (r, e) { const n = me.fromDom(r); let o = null; const t = Og(n, 'orientationchange', () => { clearInterval(o); const n = kg(r); e.onChange(n), i(() => { e.onReady(n) }) }); var i = function (n) { clearInterval(o); const e = r.innerHeight; let t = 0; o = setInterval(() => { e !== r.innerHeight ? (clearInterval(o), n(k.some(r.innerHeight))) : t > 20 && (clearInterval(o), n(k.none())), t++ }, 50) }; return { onAdjustment: i, destroy() { t.unbind() } } }; const Dg = function (n) { const e = qn.detect().os.isiOS(); const t = kg(n).isPortrait(); return e && !t ? n.screen.height : n.screen.width }; const Mg = function (n) { const e = n.raw(); return e.touches === undefined || e.touches.length !== 1 ? k.none() : k.some(e.touches[0]) }; const Ag = function (t) { const u = Mo(k.none()); const r = (function n(t, r) { let o = null; return { cancel() { o !== null && (clearTimeout(o), o = null) }, schedule() { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; o = setTimeout(() => { t.apply(null, n), o = null }, r) } } }((n) => { u.set(k.none()), t.triggerEvent(te(), n) }, 400)); const o = Ot([{ key: R(), value(t) { return Mg(t).each((n) => { r.cancel(); const e = { x: h(n.clientX), y: h(n.clientY), target: t.target }; r.schedule(t), u.set(k.some(e)) }), k.none() } }, { key: F(), value(n) { return r.cancel(), Mg(n).each((i) => { u.get().each((n) => { let e, t, r, o; e = i, t = n, r = Math.abs(e.clientX - t.x()), o = Math.abs(e.clientY - t.y()), (r > 5 || o > 5) && u.set(k.none()) }) }), k.none() } }, { key: V(), value(e) { return r.cancel(), u.get().filter((n) => He(n.target(), e.target())).map((n) => t.triggerEvent(ne(), e)) } }]); return { fireIfReady(e, n) { return wt(o, n).bind((n) => n(e)) } } }; const Ig = function (t) { const e = Ag({ triggerEvent(n, e) { t.onTapContent(e) } }); return { fireTouchstart(n) { e.fireIfReady(n, 'touchstart') }, onTouchend() { return Og(t.body(), 'touchend', (n) => { e.fireIfReady(n, 'touchend') }) }, onTouchmove() { return Og(t.body(), 'touchmove', (n) => { e.fireIfReady(n, 'touchmove') }) } } }; const Bg = qn.detect().os.version.major >= 6; const Rg = function (r, e, t) { const o = Ig(r); const i = je(e); const u = function (n) { return !He(n.start(), n.finish()) || n.soffset() !== n.foffset() }; const n = function () { const n = r.doc().dom().hasFocus() && r.getSelection().exists(u); t.getByDom(e).each(!0 === (n || Bo(i).filter((n) => he(n) === 'input').exists((n) => n.dom().selectionStart !== n.dom().selectionEnd)) ? ki.on : ki.off) }; const a = [Og(r.body(), 'touchstart', (n) => { r.onTouchContent(), o.fireTouchstart(n) }), o.onTouchmove(), o.onTouchend(), Og(e, 'touchstart', (n) => { r.onTouchToolstrip() }), r.onToReading(() => { Io(r.body()) }), r.onToEditing(x), r.onScrollToCursor((n) => { n.preventDefault(), r.getCursorBox().each((n) => { const e = r.win(); const t = n.top() > e.innerHeight || n.bottom() > e.innerHeight ? n.bottom() - e.innerHeight + 50 : 0; t !== 0 && e.scrollTo(e.pageXOffset, e.pageYOffset + t) }) })].concat(!0 === Bg ? [] : [Og(me.fromDom(r.win()), 'blur', () => { t.getByDom(e).each(ki.off) }), Og(i, 'select', n), Og(r.doc(), 'selectionchange', n)]); return { destroy() { On(a, (n) => { n.unbind() }) } } }; const Fg = function (n, e) { const t = parseInt(go(n, e), 10); return isNaN(t) ? 0 : t }; const Vg = (function Ph(t, r) { const o = function (n) { return t(n) ? k.from(n.dom().nodeValue) : k.none() }; const n = qn.detect().browser; const e = n.isIE() && n.version.major === 10 ? function (n) { try { return o(n) } catch (e) { return k.none() } } : o; return { get(n) { if (!t(n)) throw new Error(`Can only get ${r} value of a ${r} node`); return e(n).getOr('') }, getOption: e, set(n, e) { if (!t(n)) throw new Error(`Can only set raw ${r} value of a ${r} node`); n.dom().nodeValue = e } } }(xe, 'text')); const Ng = function (n) { return Vg.getOption(n) }; const Hg = it([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]); const jg = { before: Hg.before, on: Hg.on, after: Hg.after, cata(n, e, t, r) { return n.fold(e, t, r) }, getStart(n) { return n.fold(b, b, b) } }; const zg = it([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }]); const Lg = Te('start', 'soffset', 'finish', 'foffset'); const Pg = zg.relative; const Ug = zg.exact; const Gg = function (n, e, t, r) { let o; let i; let u; let a; let c; const f = (i = e, u = t, a = r, (c = je(o = n).dom().createRange()).setStart(o.dom(), i), c.setEnd(u.dom(), a), c); const s = He(n, t) && e === r; return f.collapsed && !s }; const $g = function (n, e, t) { let r; let o; const i = n.document.createRange(); return r = i, e.fold((n) => { r.setStartBefore(n.dom()) }, (n, e) => { r.setStart(n.dom(), e) }, (n) => { r.setStartAfter(n.dom()) }), o = i, t.fold((n) => { o.setEndBefore(n.dom()) }, (n, e) => { o.setEnd(n.dom(), e) }, (n) => { o.setEndAfter(n.dom()) }), i }; const Wg = function (n, e, t, r, o) { const i = n.document.createRange(); return i.setStart(e.dom(), t), i.setEnd(r.dom(), o), i }; const _g = function (n) { return { left: h(n.left), top: h(n.top), right: h(n.right), bottom: h(n.bottom), width: h(n.width), height: h(n.height) } }; const qg = it([{ ltr: ['start', 'soffset', 'finish', 'foffset'] }, { rtl: ['start', 'soffset', 'finish', 'foffset'] }]); const Xg = function (n, e, t) { return e(me.fromDom(t.startContainer), t.startOffset, me.fromDom(t.endContainer), t.endOffset) }; const Yg = function (n, e) { let o; let t; let r; const i = (o = n, e.match({ domRange(n) { return { ltr: h(n), rtl: k.none } }, relative(n, e) { return { ltr: q(() => $g(o, n, e)), rtl: q(() => k.some($g(o, e, n))) } }, exact(n, e, t, r) { return { ltr: q(() => Wg(o, n, e, t, r)), rtl: q(() => k.some(Wg(o, t, r, n, e))) } } })); return (r = (t = i).ltr()).collapsed ? t.rtl().filter((n) => !1 === n.collapsed).map((n) => qg.rtl(me.fromDom(n.endContainer), n.endOffset, me.fromDom(n.startContainer), n.startOffset)).getOrThunk(() => Xg(0, qg.ltr, r)) : Xg(0, qg.ltr, r) }; const Kg = (document.caretPositionFromPoint || document.caretRangeFromPoint, function (n, e) { const t = he(n); return t === 'input' ? jg.after(n) : wn(['br', 'img'], t) ? e === 0 ? jg.before(n) : jg.after(n) : jg.on(n, e) }); const Jg = function (n, e, t, r, o) { let i; let u; const a = Wg(n, e, t, r, o); i = n, u = a, k.from(i.getSelection()).each((n) => { n.removeAllRanges(), n.addRange(u) }) }; const Qg = function (n, e, t, r, o) { let i; let u; let a; let c; let l; const f = (i = r, u = o, a = Kg(e, t), c = Kg(i, u), Pg(a, c)); Yg(l = n, f).match({ ltr(n, e, t, r) { Jg(l, n, e, t, r) }, rtl(n, e, t, r) { let o; let i; let u; let a; let c; const f = l.getSelection(); if (f.setBaseAndExtent)f.setBaseAndExtent(n.dom(), e, t.dom(), r); else if (f.extend) try { i = n, u = e, a = t, c = r, (o = f).collapse(i.dom(), u), o.extend(a.dom(), c) } catch (s) { Jg(l, t, r, n, e) } else Jg(l, t, r, n, e) } }) }; const Zg = function (n) { const e = me.fromDom(n.anchorNode); const t = me.fromDom(n.focusNode); return Gg(e, n.anchorOffset, t, n.focusOffset) ? k.some(Lg(me.fromDom(n.anchorNode), n.anchorOffset, me.fromDom(n.focusNode), n.focusOffset)) : (function (n) { if (n.rangeCount > 0) { const e = n.getRangeAt(0); const t = n.getRangeAt(n.rangeCount - 1); return k.some(Lg(me.fromDom(e.startContainer), e.startOffset, me.fromDom(t.endContainer), t.endOffset)) } return k.none() }(n)) }; const np = function (n) { return k.from(n.getSelection()).filter((n) => n.rangeCount > 0).bind(Zg) }; const ep = function (n, e) { let i; let t; let r; let o; const u = Yg(i = n, e).match({ ltr(n, e, t, r) { const o = i.document.createRange(); return o.setStart(n.dom(), e), o.setEnd(t.dom(), r), o }, rtl(n, e, t, r) { const o = i.document.createRange(); return o.setStart(t.dom(), r), o.setEnd(n.dom(), e), o } }); return r = (t = u).getClientRects(), (o = r.length > 0 ? r[0] : t.getBoundingClientRect()).width > 0 || o.height > 0 ? k.some(o).map(_g) : k.none() }; const tp = function (n) { return { left: n.left, top: n.top, right: n.right, bottom: n.bottom, width: h(2), height: n.height } }; const rp = function (n) { return { left: h(n.left), top: h(n.top), right: h(n.right), bottom: h(n.bottom), width: h(n.width), height: h(n.height) } }; const op = function (r) { if (r.collapsed) { const o = me.fromDom(r.startContainer); return ze(o).bind((n) => { let e; const t = Ug(o, r.startOffset, n, he(e = n) === 'img' ? 1 : Ng(e).fold(() => Le(e).length, (n) => n.length)); return ep(r.startContainer.ownerDocument.defaultView, t).map(tp).map(Nn) }).getOr([]) } return Sn(r.getClientRects(), rp) }; const ip = function (n) { const e = n.getSelection(); return e !== undefined && e.rangeCount > 0 ? op(e.getRangeAt(0)) : [] }; const up = function (n) { n.focus(); const e = me.fromDom(n.document.body); (Bo().exists((n) => wn(['input', 'textarea'], he(n))) ? function (n) { setTimeout(() => { n() }, 0) } : s)(() => { Bo().each(Io), Ao(e) }) }; const ap = `data-${Ai.resolve('last-outer-height')}`; const cp = function (n, e) { lo(n, ap, e) }; const fp = function (n) { return { top: h(n.top()), bottom: h(n.top() + n.height()) } }; const sp = function (n, e) { const t = Fg(e, ap); const r = n.innerHeight; return r < t ? k.some(t - r) : k.none() }; const lp = function (n, u) { const e = me.fromDom(u.document.body); const t = Og(me.fromDom(n), 'resize', () => { sp(n, e).each((i) => { let n, e; (n = u, e = ip(n), e.length > 0 ? k.some(e[0]).map(fp) : k.none()).each((n) => { let e; let t; let r; const o = (e = u, r = i, (t = n).top() > e.innerHeight || t.bottom() > e.innerHeight ? Math.min(r, t.bottom() - e.innerHeight + 50) : 0); o !== 0 && u.scrollTo(u.pageXOffset, u.pageYOffset + o) }) }), cp(e, n.innerHeight) }); return cp(e, n.innerHeight), { toEditing() { up(u) }, destroy() { t.unbind() } } }; const dp = function (n) { return k.some(me.fromDom(n.dom().contentWindow.document.body)) }; const mp = function (n) { return k.some(me.fromDom(n.dom().contentWindow.document)) }; const gp = function (n) { return k.from(n.dom().contentWindow) }; const pp = function (n) { return gp(n).bind(np) }; const vp = function (n) { return n.getFrame() }; const hp = function (n, t) { return function (e) { return e[n].getOrThunk(() => { const n = vp(e); return function () { return t(n) } })() } }; const bp = function (n, e, t, r) { return n[t].getOrThunk(() => function (n) { return Og(e, r, n) }) }; const yp = function (n) { return { left: h(n.left), top: h(n.top), right: h(n.right), bottom: h(n.bottom), width: h(n.width), height: h(n.height) } }; const xp = { getBody: hp('getBody', dp), getDoc: hp('getDoc', mp), getWin: hp('getWin', gp), getSelection: hp('getSelection', pp), getFrame: vp, getActiveApi(a) { const c = vp(a); return dp(c).bind((u) => mp(c).bind((i) => gp(c).map((o) => { const n = me.fromDom(i.dom().documentElement); const e = a.getCursorBox.getOrThunk(() => function () { return (n = o, np(n).map((n) => Ug(n.start(), n.soffset(), n.finish(), n.foffset()))).bind((n) => ep(o, n).orThunk(() => np(o).filter((n) => He(n.start(), n.finish()) && n.soffset() === n.foffset()).bind((n) => { const e = n.start().dom().getBoundingClientRect(); return e.width > 0 || e.height > 0 ? k.some(e).map(yp) : k.none() }))); let n }); const t = a.setSelection.getOrThunk(() => function (n, e, t, r) { Qg(o, n, e, t, r) }); const r = a.clearSelection.getOrThunk(() => function () { o.getSelection().removeAllRanges() }); return { body: h(u), doc: h(i), win: h(o), html: h(n), getSelection: l(pp, c), setSelection: t, clearSelection: r, frame: h(c), onKeyup: bp(a, i, 'onKeyup', 'keyup'), onNodeChanged: bp(a, i, 'onNodeChanged', 'selectionchange'), onDomChanged: a.onDomChanged, onScrollToCursor: a.onScrollToCursor, onScrollToElement: a.onScrollToElement, onToReading: a.onToReading, onToEditing: a.onToEditing, onToolbarScrollStart: a.onToolbarScrollStart, onTouchContent: a.onTouchContent, onTapContent: a.onTapContent, onTouchToolstrip: a.onTouchToolstrip, getCursorBox: e } }))) } }; const wp = 'data-ephox-mobile-fullscreen-style'; const Sp = 'position:absolute!important;'; const Op = 'top:0!important;left:0!important;margin:0!important;padding:0!important;width:100%!important;'; const Tp = qn.detect().os.isAndroid(); const kp = function (n, e) { let t; let r; let o; const i = function (r) { return function (n) { const e = go(n, 'style'); const t = e === undefined ? 'no-styles' : e.trim(); t !== r && (lo(n, wp, t), lo(n, 'style', r)) } }; const u = (t = '*', Ki(n, (n) => Re(n, t), r)); const a = Bn(u, (n) => { let e; return e = '*', Ji(n, (n) => Re(n, e)) }); const c = (o = Li(e, 'background-color')) !== undefined && o !== '' ? `background-color:${o}!important` : 'background-color:rgb(255,255,255)!important;'; On(a, i('display:none!important;')), On(u, i(Sp + Op + c)), i((!0 === Tp ? '' : Sp) + Op + c)(n) }; const Ep = function () { const n = Ve(`[${wp}]`); On(n, (n) => { const e = go(n, wp); e !== 'no-styles' ? lo(n, 'style', e) : vo(n, 'style'), vo(n, wp) }) }; const Cp = function () { const e = Zi('head').getOrDie(); const n = Zi('meta[name="viewport"]').getOrThunk(() => { const n = me.fromTag('meta'); return lo(n, 'name', 'viewport'), We(e, n), n }); const t = go(n, 'content'); return { maximize() { lo(n, 'content', 'width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0') }, restore() { t !== undefined && t !== null && t.length > 0 ? lo(n, 'content', t) : lo(n, 'content', 'user-scalable=yes') } } }; const Dp = function (e, n) { const t = Cp(); const r = Pd(); const o = Pd(); return { enter() { n.hide(), wo(e.container, Ai.resolve('fullscreen-maximized')), wo(e.container, Ai.resolve('android-maximized')), t.maximize(), wo(e.body, Ai.resolve('android-scroll-reload')), r.set(lp(e.win, xp.getWin(e.editor).getOrDie('no'))), xp.getActiveApi(e.editor).each((n) => { kp(e.container, n.body()), o.set(Rg(n, e.toolstrip, e.alloy)) }) }, exit() { t.restore(), n.show(), Oo(e.container, Ai.resolve('fullscreen-maximized')), Oo(e.container, Ai.resolve('android-maximized')), Ep(), Oo(e.body, Ai.resolve('android-scroll-reload')), o.clear(), r.clear() } } }; const Mp = function (t, r) { let o = null; return { cancel() { o !== null && (clearTimeout(o), o = null) }, throttle() { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; o !== null && clearTimeout(o), o = setTimeout(() => { t.apply(null, n), o = null }, r) } } }; const Ap = function (n, e) { let t; let r; let o; const i = Fl(md.sketch({ dom: vf('<div aria-hidden="true" class="${prefix}-mask-tap-icon"></div>'), containerBehaviours: io([ki.config({ toggleClass: Ai.resolve('mask-tap-icon-selected'), toggleOnExecute: !1 })]) })); const u = (t = n, r = 200, o = null, { cancel() { o !== null && (clearTimeout(o), o = null) }, throttle() { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; o === null && (o = setTimeout(() => { t.apply(null, n), o = null }, r)) } }); return md.sketch({ dom: vf('<div class="${prefix}-disabled-mask"></div>'), components: [md.sketch({ dom: vf('<div class="${prefix}-content-container"></div>'), components: [mf.sketch({ dom: vf('<div class="${prefix}-content-tap-section"></div>'), components: [i.asSpec()], action(n) { u.throttle() }, buttonBehaviours: io([ki.config({ toggleClass: Ai.resolve('mask-tap-icon-selected') })]) })] })] }) }; const Ip = er([xr('editor', [br('getFrame'), wr('getBody'), wr('getDoc'), wr('getWin'), wr('getSelection'), wr('setSelection'), wr('clearSelection'), wr('cursorSaver'), wr('onKeyup'), wr('onNodeChanged'), wr('getCursorBox'), br('onDomChanged'), Tr('onTouchContent', x), Tr('onTapContent', x), Tr('onTouchToolstrip', x), Tr('onScrollToCursor', h({ unbind: x })), Tr('onScrollToElement', h({ unbind: x })), Tr('onToEditing', h({ unbind: x })), Tr('onToReading', h({ unbind: x })), Tr('onToolbarScrollStart', b)]), br('socket'), br('toolstrip'), br('dropup'), br('toolbar'), br('container'), br('alloy'), Er('win', (n) => je(n.socket).dom().defaultView), Er('body', (n) => me.fromDom(n.socket.dom().ownerDocument.body)), Tr('translate', b), Tr('setReadOnly', x), Tr('readOnlyOnInit', h(!0))]); const Bp = function (n) { const e = mr('Getting AndroidWebapp schema', Ip, n); ji(e.toolstrip, 'width', '100%'); const t = xm(Ap(() => { e.setReadOnly(e.readOnlyOnInit()), o.enter() }, e.translate)); e.alloy.add(t); const r = { show() { e.alloy.add(t) }, hide() { e.alloy.remove(t) } }; We(e.container, t.element()); var o = Dp(e, r); return { setReadOnly: e.setReadOnly, refreshStructure: x, enter: o.enter, exit: o.exit, destroy: x } }; const Rp = h([Tr('shell', !0), cc('toolbarBehaviours', [Pm])]); const Fp = h([Hc({ name: 'groups', overrides(n) { return { behaviours: io([Pm.config({})]) } } })]); const Vp = df({ name: 'Toolbar', configFields: Rp(), partFields: Fp(), factory(e, n, t, r) { const o = function (n) { return e.shell ? k.some(n) : Wc(n, e, 'groups') }; const i = e.shell ? { behaviours: [Pm.config({})], components: [] } : { behaviours: [], components: n }; return { uid: e.uid, dom: e.dom, components: i.components, behaviours: sc(e.toolbarBehaviours, i.behaviours), apis: { setGroups(n, e) { o(n).fold(() => { throw console.error('Toolbar was defined to not be a shell, but no groups container was specified in components'), new Error('Toolbar was defined to not be a shell, but no groups container was specified in components') }, (n) => { Pm.set(n, e) }) } }, domModification: { attributes: { role: 'group' } } } }, apis: { setGroups(n, e, t) { n.setGroups(e, t) } } }); const Np = h([br('items'), (Kl = ['itemSelector'], xr('markers', Sn(Kl, br))), cc('tgroupBehaviours', [ac])]); const Hp = h([jc({ name: 'items', unit: 'item' })]); const jp = df({ name: 'ToolbarGroup', configFields: Np(), partFields: Hp(), factory(n, e, t, r) { return { uid: n.uid, dom: n.dom, components: e, behaviours: sc(n.tgroupBehaviours, [ac.config({ mode: 'flow', selector: n.markers.itemSelector })]), domModification: { attributes: { role: 'toolbar' } } } } }); const zp = `data-${Ai.resolve('horizontal-scroll')}`; const Lp = function (n) { return go(n, zp) === 'true' ? (t = n).dom().scrollLeft > 0 || (function (n) { n.dom().scrollLeft = 1; const e = n.dom().scrollLeft !== 0; return n.dom().scrollLeft = 0, e }(t)) : (e = n).dom().scrollTop > 0 || (function (n) { n.dom().scrollTop = 1; const e = n.dom().scrollTop !== 0; return n.dom().scrollTop = 0, e }(e)); let e, t }; const Pp = { exclusive(n, e) { return Og(n, 'touchmove', (n) => { tu(n.target(), e).filter(Lp).fold(() => { n.raw().preventDefault() }, x) }) }, markAsHorizontal(n) { lo(n, zp, 'true') } }; function Up() { const e = function (n) { const e = !0 === n.scrollable ? '${prefix}-toolbar-scrollable-group' : ''; return { dom: vf(`<div aria-label="${n.label}" class="\${prefix}-toolbar-group ${e}"></div>`), tgroupBehaviours: io([fd('adhoc-scrollable-toolbar', !0 === n.scrollable ? [qr((n, e) => { ji(n.element(), 'overflow-x', 'auto'), Pp.markAsHorizontal(n.element()), rg.register(n.element()) })] : [])]), components: [md.sketch({ components: [jp.parts().items({})] })], markers: { itemSelector: `.${Ai.resolve('toolbar-group-item')}` }, items: n.items } }; const t = xm(Vp.sketch({ dom: vf('<div class="${prefix}-toolbar"></div>'), components: [Vp.parts().groups({})], toolbarBehaviours: io([ki.config({ toggleClass: Ai.resolve('context-toolbar'), toggleOnExecute: !1, aria: { mode: 'none' } }), ac.config({ mode: 'cyclic' })]), shell: !0 })); const n = xm(md.sketch({ dom: { classes: [Ai.resolve('toolstrip')] }, components: [wm(t)], containerBehaviours: io([ki.config({ toggleClass: Ai.resolve('android-selection-context-toolbar'), toggleOnExecute: !1 })]) })); const r = function () { Vp.setGroups(t, o.get()), ki.off(t) }; var o = Mo([]); return { wrapper: h(n), toolbar: h(t), createGroups(n) { return Sn(n, p(jp.sketch, e)) }, setGroups(n) { o.set(n), r() }, setContextToolbar(n) { ki.on(t), Vp.setGroups(t, n) }, restoreToolbar() { ki.isOn(t) && r() }, refresh() {}, focus() { ac.focusIn(t) } } } let Gp; const $p = function (n, e) { Pm.append(n, wm(e)) }; const Wp = function (n, e) { Pm.remove(n, e) }; const _p = function (n) { return xm(mf.sketch({ dom: vf('<div class="${prefix}-mask-edit-icon ${prefix}-icon"></div>'), action() { n.run((n) => { n.setReadOnly(!1) }) } })) }; const qp = function () { return xm(md.sketch({ dom: vf('<div class="${prefix}-editor-socket"></div>'), components: [], containerBehaviours: io([Pm.config({})]) })) }; const Xp = function (n, e, t, r) { (!0 === t ? Do.toAlpha : Do.toOmega)(r), (t ? $p : Wp)(n, e) }; const Yp = function (e, n) { return n.getAnimationRoot.fold(() => e.element(), (n) => n(e)) }; const Kp = function (n) { return n.dimension.property }; const Jp = function (n, e) { return n.dimension.getDimension(e) }; const Qp = function (n, e) { const t = Yp(n, e); sm(t, [e.shrinkingClass, e.growingClass]) }; const Zp = function (n, e) { Oo(n.element(), e.openClass), wo(n.element(), e.closedClass), ji(n.element(), Kp(e), '0px'), $i(n.element()) }; const nv = function (n, e) { Oo(n.element(), e.closedClass), wo(n.element(), e.openClass), Gi(n.element(), Kp(e)) }; const ev = function (n, e, t, r) { t.setCollapsed(), ji(n.element(), Kp(e), Jp(e, n.element())), $i(n.element()), Qp(n, e), Zp(n, e), e.onStartShrink(n), e.onShrunk(n) }; const tv = function (n, e, t, r) { const o = r.getOrThunk(() => Jp(e, n.element())); t.setCollapsed(), ji(n.element(), Kp(e), o), $i(n.element()); const i = Yp(n, e); Oo(i, e.growingClass), wo(i, e.shrinkingClass), Zp(n, e), e.onStartShrink(n) }; const rv = function (n, e, t) { const r = Jp(e, n.element()); (r === '0px' ? ev : tv)(n, e, t, k.some(r)) }; const ov = function (n, e, t) { const r = Yp(n, e); const o = To(r, e.shrinkingClass); const i = Jp(e, n.element()); nv(n, e); const u = Jp(e, n.element()); (o ? function () { ji(n.element(), Kp(e), i), $i(n.element()) } : function () { Zp(n, e) })(), Oo(r, e.shrinkingClass), wo(r, e.growingClass), nv(n, e), ji(n.element(), Kp(e), u), t.setExpanded(), e.onStartGrow(n) }; const iv = function (n, e, t) { const r = Yp(n, e); return !0 === To(r, e.growingClass) }; const uv = function (n, e, t) { const r = Yp(n, e); return !0 === To(r, e.shrinkingClass) }; const av = Object.freeze({ grow(n, e, t) { t.isExpanded() || ov(n, e, t) }, shrink(n, e, t) { t.isExpanded() && rv(n, e, t) }, immediateShrink(n, e, t) { t.isExpanded() && ev(n, e, t, k.none()) }, hasGrown(n, e, t) { return t.isExpanded() }, hasShrunk(n, e, t) { return t.isCollapsed() }, isGrowing: iv, isShrinking: uv, isTransitioning(n, e, t) { return !0 === iv(n, e) || !0 === uv(n, e) }, toggleGrow(n, e, t) { (t.isExpanded() ? rv : ov)(n, e, t) }, disableTransitions: Qp }); const cv = Object.freeze({ exhibit(n, e) { const t = e.expanded; return Jr(t ? { classes: [e.openClass], styles: {} } : { classes: [e.closedClass], styles: St(e.dimension.property, '0px') }) }, events(t, r) { return jr([(n = W(), e = function (n, e) { e.event().raw().propertyName === t.dimension.property && (Qp(n, t), r.isExpanded() && Gi(n.element(), t.dimension.property), (r.isExpanded() ? t.onGrown : t.onShrunk)(n)) }, Ur(n)(e))]); let n, e } }); const fv = [br('closedClass'), br('openClass'), br('shrinkingClass'), br('growingClass'), wr('getAnimationRoot'), oi('onShrunk'), oi('onStartShrink'), oi('onGrown'), oi('onStartGrow'), Tr('expanded', !1), yr('dimension', pr('property', { width: [ci('property', 'width'), ci('getDimension', (n) => `${rs(n)}px`)], height: [ci('property', 'height'), ci('getDimension', (n) => `${Yi(n)}px`)] }))]; const sv = ao({ fields: fv, name: 'sliding', active: cv, apis: av, state: Object.freeze({ init(n) { const e = Mo(n.expanded); return oo({ isExpanded() { return !0 === e.get() }, isCollapsed() { return !1 === e.get() }, setCollapsed: l(e.set, !1), setExpanded: l(e.set, !0), readState() { return `expanded: ${e.get()}` } }) } }) }); const lv = function (e, t) { const r = xm(md.sketch({ dom: { tag: 'div', classes: [Ai.resolve('dropup')] }, components: [], containerBehaviours: io([Pm.config({}), sv.config({ closedClass: Ai.resolve('dropup-closed'), openClass: Ai.resolve('dropup-open'), shrinkingClass: Ai.resolve('dropup-shrinking'), growingClass: Ai.resolve('dropup-growing'), dimension: { property: 'height' }, onShrunk(n) { e(), t(), Pm.set(n, []) }, onGrown(n) { e(), t() } }), Ci((n, e) => { o(x) })]) })); var o = function (n) { window.requestAnimationFrame(() => { n(), sv.shrink(r) }) }; return { appear(n, e, t) { !0 === sv.hasShrunk(r) && !1 === sv.isTransitioning(r) && window.requestAnimationFrame(() => { e(t), Pm.set(r, [n()]), sv.grow(r) }) }, disappear: o, component: h(r), element: r.element } }; const dv = function (n) { let e, t; return n.raw().which === 8 && !wn(['input', 'textarea'], he(n.target())) && (e = n.target(), !tu(e, '[contenteditable="true"]', t).isSome()) }; const mv = qn.detect().browser.isFirefox(); const gv = nr([(Gp = 'triggerEvent', yr(Gp, hr)), Tr('stopBackspace', !0)]); const pv = function (e, n) { let t; let r; let o; let i; const u = mr('Getting GUI events settings', gv, n); const a = qn.detect().deviceType.isTouch() ? ['touchstart', 'touchmove', 'touchend', 'gesturestart'] : ['mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout', 'click']; const c = Ag(u); const f = Sn(a.concat(['selectstart', 'input', 'contextmenu', 'change', 'paste', 'transitionend', 'drag', 'dragstart', 'dragend', 'dragenter', 'dragleave', 'dragover', 'drop', 'keyup']), (n) => Og(e, n, (e) => { c.fireIfReady(e, n).each((n) => { n && e.kill() }), u.triggerEvent(n, e) && e.kill() })); const s = Og(e, 'keydown', (n) => { u.triggerEvent('keydown', n) ? n.kill() : !0 === u.stopBackspace && dv(n) && n.prevent() }); const l = (t = e, r = function (n) { u.triggerEvent('focusin', n) && n.kill() }, mv ? Tg(t, 'focus', r) : Og(t, 'focusin', r)); const d = (o = e, i = function (n) { u.triggerEvent('focusout', n) && n.kill(), setTimeout(() => { u.triggerEvent(Kn(), n) }, 0) }, mv ? Tg(o, 'blur', i) : Og(o, 'focusout', i)); return { unbind() { On(f, (n) => { n.unbind() }), s.unbind(), l.unbind(), d.unbind() } } }; const vv = function (n, e) { const t = wt(n, 'target').map((n) => n()).getOr(e); return Mo(t) }; const hv = it([{ stopped: [] }, { resume: ['element'] }, { complete: [] }]); const bv = function (n, r, e, t, o, i) { let u; let a; let c; let f; const s = n(r, t); const l = (u = e, a = o, c = Mo(!1), f = Mo(!1), { stop() { c.set(!0) }, cut() { f.set(!0) }, isStopped: c.get, isCut: f.get, event: h(u), setSource: a.set, getSource: a.get }); return s.fold(() => i.logEventNoHandlers(r, t), hv.complete(), (e) => { const t = e.descHandler(); return tm(t)(l), l.isStopped() ? (i.logEventStopped(r, e.element(), t.purpose()), hv.stopped()) : l.isCut() ? (i.logEventCut(r, e.element(), t.purpose()), hv.complete()) : ze(e.element()).fold(() => i.logNoParent(r, e.element(), t.purpose()), hv.complete(), (n) => i.logEventResponse(r, e.element(), t.purpose()), hv.resume(n)) }) }; var yv = function (e, t, r, n, o, i) { return bv(e, t, r, n, o, i).fold(() => !0, (n) => yv(e, t, r, n, o, i), () => !1) }; const xv = function (n, e, t) { let r; let o; const i = (r = e, o = Mo(!1), { stop() { o.set(!0) }, cut: x, isStopped: o.get, isCut: h(!1), event: h(r), setSource: f('Cannot set source of a broadcasted event'), getSource: f('Cannot get source of a broadcasted event') }); return On(n, (n) => { const e = n.descHandler(); tm(e)(i) }), i.isStopped() }; const wv = function (n, e, t, r, o) { const i = vv(t, r); return yv(n, e, t, r, i, o) }; const Sv = Te('element', 'descHandler'); const Ov = function (n, e) { return { id: h(n), descHandler: h(e) } }; function Tv() { const i = {}; return { registerId(r, o, n) { D(n, (n, e) => { const t = i[e] !== undefined ? i[e] : {}; t[o] = em(n, r), i[e] = t }) }, unregisterId(t) { D(i, (n, e) => { n.hasOwnProperty(t) && delete n[t] }) }, filterByType(n) { return wt(i, n).map((n) => I(n, (n, e) => Ov(e, n))).getOr([]) }, find(n, e, t) { const o = yt(e)(i); return Hr(t, (n) => { return t = o, rf(r = n).fold(() => k.none(), (n) => { const e = yt(n); return t.bind(e).map((n) => Sv(r, n)) }); let t, r }, n) } } } function kv() { const r = Tv(); const o = {}; const i = function (r) { const n = r.element(); return rf(n).fold(() => { return n = 'uid-', e = r.element(), t = Sc(nf + n), tf(e, t), t; let n, e, t }, (n) => n) }; const u = function (n) { rf(n.element()).each((n) => { o[n] = undefined, r.unregisterId(n) }) }; return { find(n, e, t) { return r.find(n, e, t) }, filter(n) { return r.filterByType(n) }, register(n) { const e = i(n); kt(o, e) && (function (n, e) { const t = o[e]; if (t !== n) throw new Error(`The tagId "${e}" is already used by: ${Uo(t.element())}\nCannot use it for: ${Uo(n.element())}\nThe conflicting element is${we(t.element()) ? ' ' : ' not '}already in the DOM`); u(n) }(n, e)); const t = [n]; r.registerId(t, e, n.events()), o[e] = n }, unregister: u, getById(n) { return yt(n)(o) } } } const Ev = function (t) { const r = function (e) { return ze(t.element()).fold(() => !0, (n) => He(e, n)) }; const o = kv(); const f = function (n, e) { return o.find(r, n, e) }; const n = pv(t.element(), { triggerEvent(u, a) { return Jo(u, a.target(), (n) => { return e = f, t = u, o = n, i = (r = a).target(), wv(e, t, r, i, o); let e, t, r, o, i }) } }); var i = { debugInfo: h('real'), triggerEvent(e, t, r) { Jo(e, t, (n) => { wv(f, e, r, t, n) }) }, triggerFocus(a, c) { rf(a).fold(() => { Ao(a) }, (n) => { Jo(Yn(), a, (n) => { let e, t, r, o, i, u; e = f, t = Yn(), r = { originator: h(c), kill: x, prevent: x, target: h(a) }, i = n, u = vv(r, o = a), bv(e, t, r, o, u, i) }) }) }, triggerEscape(n, e) { i.triggerEvent('keydown', n.element(), e.event()) }, getByUid(n) { return g(n) }, getByDom(n) { return p(n) }, build: xm, addToGui(n) { a(n) }, removeFromGui(n) { c(n) }, addToWorld(n) { e(n) }, removeFromWorld(n) { u(n) }, broadcast(n) { l(n) }, broadcastOn(n, e) { d(n, e) }, broadcastEvent(n, e) { m(n, e) }, isConnected: h(!0) }; var e = function (n) { n.connect(i), xe(n.element()) || (o.register(n), On(n.components(), e), i.triggerEvent(re(), n.element(), { target: h(n.element()) })) }; var u = function (n) { xe(n.element()) || (On(n.components(), u), o.unregister(n)), n.disconnect() }; var a = function (n) { Je(t, n) }; var c = function (n) { nt(n) }; const s = function (t) { const n = o.filter(Jn()); On(n, (n) => { const e = n.descHandler(); tm(e)(t) }) }; var l = function (n) { s({ universal: h(!0), data: h(n) }) }; var d = function (n, e) { s({ universal: h(!1), channels: h(n), data: h(e) }) }; var m = function (n, e) { const t = o.filter(n); return xv(t, e) }; var g = function (n) { return o.getById(n).fold(() => ot.error(new Error(`Could not find component with uid: "${n}" in system.`)), ot.value) }; var p = function (n) { const e = rf(n).getOr('not found'); return g(e) }; return e(t), { root: h(t), element: t.element, destroy() { n.unbind(), Xe(t.element()) }, add: a, remove: c, getByUid: g, getByDom: p, addToWorld: e, removeFromWorld: u, broadcast: l, broadcastOn: d, broadcastEvent: m } }; const Cv = h(Ai.resolve('readonly-mode')); const Dv = h(Ai.resolve('edit-mode')); function Mv(n) { const e = xm(md.sketch({ dom: { classes: [Ai.resolve('outer-container')].concat(n.classes) }, containerBehaviours: io([Do.config({ alpha: Cv(), omega: Dv() })]) })); return Ev(e) } const Av = function (n, e) { const t = me.fromTag('input'); zi(t, { opacity: '0', position: 'absolute', top: '-1000px', left: '-1000px' }), We(n, t), Ao(t), e(t), Xe(t) }; const Iv = function (n) { const e = n.getSelection(); if (e.rangeCount > 0) { const t = e.getRangeAt(0); const r = n.document.createRange(); r.setStart(t.startContainer, t.startOffset), r.setEnd(t.endContainer, t.endOffset), e.removeAllRanges(), e.addRange(r) } }; const Bv = function (n, e) { Bo().each((n) => { He(n, e) || Io(n) }), n.focus(), Ao(me.fromDom(n.document.body)), Iv(n) }; const Rv = { stubborn(n, e, t, r) { const o = function () { Bv(e, r) }; const i = Og(t, 'keydown', (n) => { wn(['input', 'textarea'], he(n.target())) || o() }); return { toReading() { Av(n, Io) }, toEditing: o, onToolbarTouch() {}, destroy() { i.unbind() } } }, timid(n, e, t, r) { const o = function () { Io(r) }; return { toReading() { o() }, toEditing() { Bv(e, r) }, onToolbarTouch() { o() }, destroy: x } } }; const Fv = function (t, r, o, i, n) { const u = function () { r.run((n) => { n.refreshSelection() }) }; const e = function (n, e) { const t = n - i.dom().scrollTop; r.run((n) => { n.scrollIntoView(t, t + e) }) }; const a = function () { r.run((n) => { n.clearSelection() }) }; const c = function () { t.getCursorBox().each((n) => { e(n.top(), n.height()) }), r.run((n) => { n.syncHeight() }) }; const f = Ig(t); const s = Mp(c, 300); const l = [t.onKeyup(() => { a(), s.throttle() }), t.onNodeChanged(u), t.onDomChanged(s.throttle), t.onDomChanged(u), t.onScrollToCursor((n) => { n.preventDefault(), s.throttle() }), t.onScrollToElement((n) => { n.element(), e(r, i) }), t.onToEditing(() => { r.run((n) => { n.toEditing() }) }), t.onToReading(() => { r.run((n) => { n.toReading() }) }), Og(t.doc(), 'touchend', (n) => { He(t.html(), n.target()) || He(t.body(), n.target()) }), Og(o, 'transitionend', (n) => { let e; n.raw().propertyName === 'height' && (e = Yi(o), r.run((n) => { n.setViewportOffset(e) }), u(), c()) }), Tg(o, 'touchstart', (n) => { let e; r.run((n) => { n.highlightSelection() }), e = n, r.run((n) => { n.onToolbarTouch(e) }), t.onTouchToolstrip() }), Og(t.body(), 'touchstart', (n) => { a(), t.onTouchContent(), f.fireTouchstart(n) }), f.onTouchmove(), f.onTouchend(), Og(t.body(), 'click', (n) => { n.kill() }), Og(o, 'touchmove', () => { t.onToolbarScrollStart() })]; return { destroy() { On(l, (n) => { n.unbind() }) } } }; var Vv = function (n) { let t = k.none(); let e = []; const r = function (n) { o() ? u(n) : e.push(n) }; var o = function () { return t.isSome() }; const i = function (n) { On(n, u) }; var u = function (e) { t.each((n) => { setTimeout(() => { e(n) }, 0) }) }; return n((n) => { t = k.some(n), i(e), e = [] }), { get: r, map(t) { return Vv((e) => { r((n) => { e(t(n)) }) }) }, isReady: o } }; const Nv = { nu: Vv, pure(e) { return Vv((n) => { n(e) }) } }; var Hv = function (e) { const n = function (n) { let r; e((r = n, function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; const t = this; setTimeout(() => { r.apply(t, n) }, 0) })) }; const t = function () { return Nv.nu(n) }; return { map(r) { return Hv((t) => { n((n) => { const e = r(n); t(e) }) }) }, bind(t) { return Hv((e) => { n((n) => { t(n).get(e) }) }) }, anonBind(t) { return Hv((e) => { n((n) => { t.get(e) }) }) }, toLazy: t, toCached() { let e = null; return Hv((n) => { e === null && (e = t()), e.get(n) }) }, get: n } }; const jv = { nu: Hv, pure(e) { return Hv((n) => { n(e) }) } }; const zv = function (n, e, t) { return Math.abs(n - e) <= t ? k.none() : n < e ? k.some(n + t) : k.some(n - t) }; const Lv = function () { let f = null; return { animate(r, o, n, i, e, t) { let u = !1; const a = function (n) { u = !0, e(n) }; clearInterval(f); const c = function (n) { clearInterval(f), a(n) }; f = setInterval(() => { const t = r(); zv(t, o, n).fold(() => { clearInterval(f), a(o) }, (n) => { if (i(n, c), !u) { const e = r(); (e !== n || Math.abs(e - o) > Math.abs(t - o)) && (clearInterval(f), a(o)) } }) }, t) } } }; const Pv = function (e, t) { return Wo([{ width: 320, height: 480, keyboard: { portrait: 300, landscape: 240 } }, { width: 320, height: 568, keyboard: { portrait: 300, landscape: 240 } }, { width: 375, height: 667, keyboard: { portrait: 305, landscape: 240 } }, { width: 414, height: 736, keyboard: { portrait: 320, landscape: 240 } }, { width: 768, height: 1024, keyboard: { portrait: 320, landscape: 400 } }, { width: 1024, height: 1366, keyboard: { portrait: 380, landscape: 460 } }], (n) => e <= n.width && t <= n.height ? k.some(n.keyboard) : k.none()).getOr({ portrait: t / 5, landscape: e / 4 }) }; const Uv = function (n) { let e; const t = Eg(n).isPortrait(); const r = Pv((e = n).screen.width, e.screen.height); const o = t ? r.portrait : r.landscape; return (t ? n.screen.height : n.screen.width) - n.innerHeight > o ? 0 : o }; const Gv = function (n, e) { const t = je(n).dom().defaultView; return Yi(n) + Yi(e) - Uv(t) }; const $v = Gv; const Wv = function (n, e, t) { const r = Gv(e, t); const o = Yi(e) + Yi(t) - r; ji(n, 'padding-bottom', `${o}px`) }; const _v = it([{ fixed: ['element', 'property', 'offsetY'] }, { scroller: ['element', 'offsetY'] }]); const qv = `data-${Ai.resolve('position-y-fixed')}`; const Xv = `data-${Ai.resolve('y-property')}`; const Yv = `data-${Ai.resolve('scrolling')}`; const Kv = `data-${Ai.resolve('last-window-height')}`; const Jv = function (n) { return Fg(n, qv) }; const Qv = function (n, e) { const t = go(n, Xv); return _v.fixed(n, t, e) }; const Zv = function (n, e) { return _v.scroller(n, e) }; const nh = function (n) { const e = Jv(n); return (go(n, Yv) === 'true' ? Zv : Qv)(n, e) }; const eh = function (n, e, t) { const r = je(n).dom().defaultView.innerHeight; return lo(n, Kv, `${r}px`), r - e - t }; const th = function (n) { const e = Qi(n, `[${qv}]`); return Sn(e, nh) }; const rh = function (r, o, i, u) { let n; let e; let t; let a; let c; let f; let s; let l; const d = je(r).dom().defaultView; const m = (l = go(s = i, 'style'), zi(s, { position: 'absolute', top: '0px' }), lo(s, qv, '0px'), lo(s, Xv, 'top'), { restore() { lo(s, 'style', l || ''), vo(s, qv), vo(s, Xv) } }); const g = Yi(i); const p = Yi(u); const v = eh(r, g, p); const h = (t = g, a = v, f = go(c = r, 'style'), rg.register(c), zi(c, { position: 'absolute', height: `${a}px`, width: '100%', top: `${t}px` }), lo(c, qv, `${t}px`), lo(c, Yv, 'true'), lo(c, Xv, 'top'), { restore() { rg.deregister(c), lo(c, 'style', f || ''), vo(c, qv), vo(c, Yv), vo(c, Xv) } }); const b = (e = go(n = u, 'style'), zi(n, { position: 'absolute', bottom: '0px' }), lo(n, qv, '0px'), lo(n, Xv, 'bottom'), { restore() { lo(n, 'style', e || ''), vo(n, qv), vo(n, Xv) } }); let y = !0; const x = function () { const n = d.innerHeight; return Fg(r, Kv) < n }; const w = function () { if (y) { const n = Yi(i); const e = Yi(u); const t = eh(r, n, e); lo(r, qv, `${n}px`), ji(r, 'height', `${t}px`), ji(u, 'bottom', `${-(n + t + e)}px`), Wv(o, r, u) } }; return Wv(o, r, u), { setViewportOffset(n) { lo(r, qv, `${n}px`), w() }, isExpanding: x, isShrinking: S(x), refresh: w, restore() { y = !1, m.restore(), h.restore(), b.restore() } } }; const oh = Jv; const ih = Lv(); const uh = `data-${Ai.resolve('last-scroll-top')}`; const ah = function (n) { const e = Ui(n, 'top').getOr('0'); return parseInt(e, 10) }; const ch = function (n) { return parseInt(n.dom().scrollTop, 10) }; const fh = function (n, e) { const t = `${e + oh(n)}px`; ji(n, 'top', t) }; const sh = function (t, r, o) { return jv.nu((n) => { const e = l(ch, t); ih.animate(e, r, 15, (n) => { t.dom().scrollTop = n, ji(t, 'top', `${ah(t) + 15}px`) }, () => { t.dom().scrollTop = r, ji(t, 'top', `${o}px`), n(r) }, 10) }) }; const lh = function (o, i) { return jv.nu((n) => { const e = l(ch, o); lo(o, uh, e()); const t = Math.abs(i - e()); const r = Math.ceil(t / 10); ih.animate(e, i, r, (n, e) => { Fg(o, uh) !== o.dom().scrollTop ? e(o.dom().scrollTop) : (o.dom().scrollTop = n, lo(o, uh, n)) }, () => { o.dom().scrollTop = i, lo(o, uh, i), n(i) }, 10) }) }; const dh = function (i, u) { return jv.nu((n) => { const e = l(ah, i); const t = function (n) { ji(i, 'top', `${n}px`) }; const r = Math.abs(u - e()); const o = Math.ceil(r / 10); ih.animate(e, u, o, t, () => { t(u), n(u) }, 10) }) }; const mh = function (e, t, r) { const o = je(e).dom().defaultView; return jv.nu((n) => { fh(e, r), fh(t, r), o.scrollTo(0, r), n(r) }) }; const gh = function (n, e, t, r, o) { const i = $v(e, t); const u = l(Iv, n); i < r || i < o ? lh(e, e.dom().scrollTop - i + o).get(u) : r < 0 && lh(e, e.dom().scrollTop + r).get(u) }; const ph = function (u, n) { return n((r) => { const o = []; let i = 0; u.length === 0 ? r([]) : On(u, (n, e) => { let t; n.get((t = e, function (n) { o[t] = n, ++i >= u.length && r(o) })) }) }) }; const vh = function (n, c) { return n.fold((n, e, t) => { return ji(n, e, `${c + (r = t)}px`), jv.pure(r); let r }, (n, e) => { return o = c + (r = e), i = Ui(t = n, 'top').getOr(r), u = o - parseInt(i, 10), a = t.dom().scrollTop + u, sh(t, a, o); let t, r, o, i, u, a }) }; const hh = function (n, e) { const t = th(n); const r = Sn(t, (n) => vh(n, e)); return ph(r, jv.nu) }; const bh = function (e, t, n, r, o, i) { const u = (function f(t) { const r = Mo(Nv.pure({})); return { start(e) { const n = Nv.nu((n) => t(e).get(n)); r.set(n) }, idle(n) { r.get().get(() => { n() }) } } }((n) => mh(e, t, n))); const a = Mp(() => { u.idle(() => { hh(n, r.pageYOffset).get(() => { let n; (n = ip(i), k.from(n[0]).bind((n) => { const e = n.top() - t.dom().scrollTop; return e > r.innerHeight + 5 || e < -5 ? k.some({ top: h(e), bottom: h(e + n.height()) }) : k.none() })).each((n) => { t.dom().scrollTop = t.dom().scrollTop + n.top() }), u.start(0), o.refresh() }) }) }, 1e3); const c = Og(me.fromDom(r), 'scroll', () => { r.pageYOffset < 0 || a.throttle() }); return hh(n, r.pageYOffset).get(b), { unbind: c.unbind } }; const yh = function (n) { const t = n.cWin(); const e = n.ceBody(); const r = n.socket(); const o = n.toolstrip(); const i = n.toolbar(); const u = n.contentElement(); const a = n.keyboardType(); const c = n.outerWindow(); const f = n.dropup(); const s = rh(r, e, o, f); const l = a(n.outerBody(), t, Se(), u, o, i); const d = Cg(c, { onChange: x, onReady: s.refresh }); d.onAdjustment(() => { s.refresh() }); const m = Og(me.fromDom(c), 'resize', () => { s.isExpanding() && s.refresh() }); const g = bh(o, r, n.outerBody(), c, s, t); const p = (function h(t, e) { const n = t.document; const r = me.fromTag('div'); wo(r, Ai.resolve('unfocused-selections')), We(me.fromDom(n.documentElement), r); const o = Og(r, 'touchstart', (n) => { n.prevent(), Bv(t, e), u() }); const i = function (n) { const e = me.fromTag('span'); return fm(e, [Ai.resolve('layer-editor'), Ai.resolve('unfocused-selection')]), zi(e, { left: `${n.left()}px`, top: `${n.top()}px`, width: `${n.width()}px`, height: `${n.height()}px` }), e }; var u = function () { qe(r) }; return { update() { u(); const n = ip(t); const e = Sn(n, i); _e(r, e) }, isActive() { return Le(r).length > 0 }, destroy() { o.unbind(), Xe(r) }, clear: u } }(t, u)); const v = function () { p.clear() }; return { toEditing() { l.toEditing(), v() }, toReading() { l.toReading() }, onToolbarTouch(n) { l.onToolbarTouch(n) }, refreshSelection() { p.isActive() && p.update() }, clearSelection: v, highlightSelection() { p.update() }, scrollIntoView(n, e) { gh(t, r, f, n, e) }, updateToolbarPadding: x, setViewportOffset(n) { s.setViewportOffset(n), dh(r, n).get(b) }, syncHeight() { ji(u, 'height', `${u.dom().contentWindow.document.body.scrollHeight}px`) }, refreshStructure: s.refresh, destroy() { s.restore(), d.destroy(), g.unbind(), m.unbind(), l.destroy(), p.destroy(), Av(Se(), Io) } } }; const xh = function (r, n) { const o = Cp(); const i = Ud(); const u = Ud(); const a = Pd(); const c = Pd(); return { enter() { n.hide(); const t = me.fromDom(document); xp.getActiveApi(r.editor).each((n) => { i.set({ socketHeight: Ui(r.socket, 'height'), iframeHeight: Ui(n.frame(), 'height'), outerScroll: document.body.scrollTop }), u.set({ exclusives: Pp.exclusive(t, `.${rg.scrollable()}`) }), wo(r.container, Ai.resolve('fullscreen-maximized')), kp(r.container, n.body()), o.maximize(), ji(r.socket, 'overflow', 'scroll'), ji(r.socket, '-webkit-overflow-scrolling', 'touch'), Ao(n.body()); const e = Ce(['cWin', 'ceBody', 'socket', 'toolstrip', 'toolbar', 'dropup', 'contentElement', 'cursor', 'keyboardType', 'isScrolling', 'outerWindow', 'outerBody'], []); a.set(yh(e({ cWin: n.win(), ceBody: n.body(), socket: r.socket, toolstrip: r.toolstrip, toolbar: r.toolbar, dropup: r.dropup.element(), contentElement: n.frame(), cursor: x, outerBody: r.body, outerWindow: r.win, keyboardType: Rv.stubborn, isScrolling() { return u.get().exists((n) => n.socket.isScrolling()) } }))), a.run((n) => { n.syncHeight() }), c.set(Fv(n, a, r.toolstrip, r.socket, r.dropup)) }) }, refreshStructure() { a.run((n) => { n.refreshStructure() }) }, exit() { o.restore(), c.clear(), a.clear(), n.show(), i.on((n) => { n.socketHeight.each((n) => { ji(r.socket, 'height', n) }), n.iframeHeight.each((n) => { ji(r.editor.getFrame(), 'height', n) }), document.body.scrollTop = n.scrollTop }), i.clear(), u.on((n) => { n.exclusives.unbind() }), u.clear(), Oo(r.container, Ai.resolve('fullscreen-maximized')), Ep(), rg.deregister(r.toolbar), Gi(r.socket, 'overflow'), Gi(r.socket, '-webkit-overflow-scrolling'), Io(r.editor.getFrame()), xp.getActiveApi(r.editor).each((n) => { n.clearSelection() }) } } }; const wh = function (n) { const e = mr('Getting IosWebapp schema', Ip, n); ji(e.toolstrip, 'width', '100%'), ji(e.container, 'position', 'relative'); const t = xm(Ap(() => { e.setReadOnly(e.readOnlyOnInit()), r.enter() }, e.translate)); e.alloy.add(t); var r = xh(e, { show() { e.alloy.add(t) }, hide() { e.alloy.remove(t) } }); return { setReadOnly: e.setReadOnly, refreshStructure: r.refreshStructure, enter: r.enter, exit: r.exit, destroy: x } }; const Sh = tinymce.util.Tools.resolve('tinymce.EditorManager'); const Oh = function (n) { const e = wt(n.settings, 'skin_url').fold(() => `${Sh.baseURL}/skins/ui/oxide`, (n) => n); return { content: `${e}/content.mobile.min.css`, ui: `${e}/skin.mobile.min.css` } }; const Th = function (n, e, t) { n.system().broadcastOn([Ho.formatChanged()], { command: e, state: t }) }; const kh = function (r, n) { const e = E(n.formatter.get()); On(e, (e) => { n.formatter.formatChanged(e, (n) => { Th(r, e, n) }) }), On(['ul', 'ol'], (t) => { n.selection.selectorChanged(t, (n, e) => { Th(r, t, n) }) }) }; const Eh = (h(['x-small', 'small', 'medium', 'large', 'x-large']), function (n) { const e = function () { n._skinLoaded = !0, n.fire('SkinLoaded') }; return function () { n.initialized ? e() : n.on('init', e) } }); const Ch = h('toReading'); const Dh = h('toEditing'); const Mh = function (p) { return { getNotificationManagerImpl() { return { open: h({ progressBar: { value: x }, close: x }), close: x, reposition: x, getArgs: b } }, renderUI() { const n = p.getElement(); const e = Oh(p); (!1 === p.settings.skin) == 0 ? (p.contentCSS.push(e.content), Fo.DOM.styleSheetLoader.load(e.ui, Eh(p))) : Eh(p)(); let t; let r; const o = function () { p.fire('scrollIntoView') }; const i = me.fromTag('div'); const f = qn.detect().os.isAndroid() ? (function m(n) { const e = Mv({ classes: [Ai.resolve('android-container')] }); const t = Up(); const r = Pd(); const o = _p(r); const i = qp(); const u = lv(x, n); return e.add(t.wrapper()), e.add(i), e.add(u.component()), { system: h(e), element: e.element, init(n) { r.set(Bp(n)) }, exit() { r.run((n) => { n.exit(), Pm.remove(i, o) }) }, setToolbarGroups(n) { const e = t.createGroups(n); t.setGroups(e) }, setContextToolbar(n) { const e = t.createGroups(n); t.setContextToolbar(e) }, focusToolbar() { t.focus() }, restoreToolbar() { t.restoreToolbar() }, updateMode(n) { Xp(i, o, n, e.root()) }, socket: h(i), dropup: h(u) } }(o)) : (function g(n) { const e = Mv({ classes: [Ai.resolve('ios-container')] }); const t = Up(); const r = Pd(); const o = _p(r); const i = qp(); const u = lv(() => { r.run((n) => { n.refreshStructure() }) }, n); return e.add(t.wrapper()), e.add(i), e.add(u.component()), { system: h(e), element: e.element, init(n) { r.set(wh(n)) }, exit() { r.run((n) => { Pm.remove(i, o), n.exit() }) }, setToolbarGroups(n) { const e = t.createGroups(n); t.setGroups(e) }, setContextToolbar(n) { const e = t.createGroups(n); t.setContextToolbar(e) }, focusToolbar() { t.focus() }, restoreToolbar() { t.restoreToolbar() }, updateMode(n) { Xp(i, o, n, e.root()) }, socket: h(i), dropup: h(u) } }(o)); const u = me.fromDom(n); Ge(u, i), t = i, r = f.system(), et(t, r, We); const a = n.ownerDocument.defaultView; const s = Cg(a, { onChange() { f.system().broadcastOn([Ho.orientationChanged()], { width: Dg(a) }) }, onReady: x }); const l = function (n, e, t, r) { !1 === r && p.selection.collapse(); const o = c(n, e, t); f.setToolbarGroups(!0 === r ? o.readOnly : o.main), p.setMode(!0 === r ? 'readonly' : 'design'), p.fire(!0 === r ? Ch() : Dh()), f.updateMode(r) }; var c = function (n, e, t) { const r = n.get(); return { readOnly: r.backToMask.concat(e.get()), main: r.backToMask.concat(t.get()) } }; const d = function (n, e) { return p.on(n, e), { unbind() { p.off(n) } } }; return p.on('init', () => { f.init({ editor: { getFrame() { return me.fromDom(p.contentAreaContainer.querySelector('iframe')) }, onDomChanged() { return { unbind: x } }, onToReading(n) { return d(Ch(), n) }, onToEditing(n) { return d(Dh(), n) }, onScrollToCursor(e) { return p.on('scrollIntoView', (n) => { e(n) }), { unbind() { p.off('scrollIntoView'), s.destroy() } } }, onTouchToolstrip() { t() }, onTouchContent() { let n; const e = me.fromDom(p.editorContainer.querySelector(`.${Ai.resolve('toolbar')}`)); (n = e, Ro(n).bind((n) => f.system().getByDom(n).toOption())).each(fe), f.restoreToolbar(), t() }, onTapContent(n) { const e = n.target(); he(e) === 'img' ? (p.selection.select(e.dom()), n.kill()) : he(e) === 'a' && f.system().getByDom(me.fromDom(p.editorContainer)).each((n) => { Do.isAlpha(n) && No(e.dom()) }) } }, container: me.fromDom(p.editorContainer), socket: me.fromDom(p.contentAreaContainer), toolstrip: me.fromDom(p.editorContainer.querySelector(`.${Ai.resolve('toolstrip')}`)), toolbar: me.fromDom(p.editorContainer.querySelector(`.${Ai.resolve('toolbar')}`)), dropup: f.dropup(), alloy: f.system(), translate: x, setReadOnly(n) { l(c, a, u, n) }, readOnlyOnInit() { return !1 } }); var t = function () { f.dropup().disappear(() => { f.system().broadcastOn([Ho.dropupDismissed()], {}) }) }; const n = { label: 'The first group', scrollable: !1, items: [xf.forToolbar('back', () => { p.selection.collapse(), f.exit() }, {})] }; const e = { label: 'Back to read only', scrollable: !1, items: [xf.forToolbar('readonly-back', () => { l(c, a, u, !0) }, {})] }; const r = hg(f, p); const o = bg(p.settings, r); const i = { label: 'The extra group', scrollable: !1, items: [] }; var u = Mo([{ label: 'the action group', scrollable: !0, items: o }, i]); var a = Mo([{ label: 'The read only mode group', scrollable: !0, items: [] }, i]); var c = Mo({ backToMask: [n], backToReadOnly: [e] }); kh(f, p) }), { iframeContainer: f.socket().element().dom(), editorContainer: f.element().dom() } } } }; Vo.add('mobile', Mh), n.renderMobileTheme = Mh, n.default = function Uh() {}
}({}))
