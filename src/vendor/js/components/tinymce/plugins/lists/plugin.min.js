!(function () {
  let e; let t; let n; let r; let o; let i; let u; let s; let l; let a; const c = tinymce.util.Tools.resolve('tinymce.PluginManager'); const f = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils'); const d = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker'); const m = tinymce.util.Tools.resolve('tinymce.util.VK'); const p = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager'); const v = tinymce.util.Tools.resolve('tinymce.util.Tools'); const g = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const h = function (e) { return e && e.nodeName === 'BR' }; const y = function (e) { return e && e.nodeType === 3 }; const N = function (e) { return e && /^(OL|UL|DL)$/.test(e.nodeName) }; const S = function (e) { return e && /^(OL|UL)$/.test(e.nodeName) }; const O = function (e) { return e && /^(DT|DD)$/.test(e.nodeName) }; const C = function (e) { return e && /^(LI|DT|DD)$/.test(e.nodeName) }; const L = function (e) { return e && /^(TH|TD)$/.test(e.nodeName) }; const b = h; const T = function (e, t) { return t && !!e.schema.getTextBlockElements()[t.nodeName] }; const D = function (e, t) { return e && e.nodeName in t }; const E = function (e, t) { return !!h(t) && !(!e.isBlock(t.nextSibling) || h(t.previousSibling)) }; const w = function (e, t, n) { const r = e.isEmpty(t); return !(n && e.select('span[data-mce-type=bookmark]', t).length > 0) && r }; const k = function (e, t) { return e.isChildOf(t, e.getRoot()) }; const A = function (e, t) { if (y(e)) return { container: e, offset: t }; const n = f.getNode(e, t); return y(n) ? { container: n, offset: t >= e.childNodes.length ? n.data.length : 0 } : n.previousSibling && y(n.previousSibling) ? { container: n.previousSibling, offset: n.previousSibling.data.length } : n.nextSibling && y(n.nextSibling) ? { container: n.nextSibling, offset: 0 } : { container: e, offset: t } }; const x = function (e) { const t = e.cloneRange(); const n = A(e.startContainer, e.startOffset); t.setStart(n.container, n.offset); const r = A(e.endContainer, e.endOffset); return t.setEnd(r.container, r.offset), t }; const R = g.DOM; const I = function (o) { const i = {}; const e = function (e) { let t, n, r; n = o[e ? 'startContainer' : 'endContainer'], r = o[e ? 'startOffset' : 'endOffset'], n.nodeType === 1 && (t = R.create('span', { 'data-mce-type': 'bookmark' }), n.hasChildNodes() ? (r = Math.min(r, n.childNodes.length - 1), e ? n.insertBefore(t, n.childNodes[r]) : R.insertAfter(t, n.childNodes[r])) : n.appendChild(t), n = t, r = 0), i[e ? 'startContainer' : 'endContainer'] = n, i[e ? 'startOffset' : 'endOffset'] = r }; return e(!0), o.collapsed || e(), i }; const B = function (o) { function e(e) { let t, n, r; t = r = o[e ? 'startContainer' : 'endContainer'], n = o[e ? 'startOffset' : 'endOffset'], t && (t.nodeType === 1 && (n = (function (e) { for (let t = e.parentNode.firstChild, n = 0; t;) { if (t === e) return n; t.nodeType === 1 && t.getAttribute('data-mce-type') === 'bookmark' || n++, t = t.nextSibling } return -1 }(t)), t = t.parentNode, R.remove(r), !t.hasChildNodes() && R.isBlock(t) && t.appendChild(R.create('br'))), o[e ? 'startContainer' : 'endContainer'] = t, o[e ? 'startOffset' : 'endOffset'] = n) }e(!0), e(); const t = R.createRng(); return t.setStart(o.startContainer, o.startOffset), o.endContainer && t.setEnd(o.endContainer, o.endOffset), x(t) }; const _ = function (e) { return function () { return e } }; const P = function (n) { return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return !n.apply(null, e) } }; const M = _(!1); const U = _(!0); const F = M; const j = U; const H = function () { return $ }; var $ = (r = { fold(e, t) { return e() }, is: F, isSome: F, isNone: j, getOr: n = function (e) { return e }, getOrThunk: t = function (e) { return e() }, getOrDie(e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: n, orThunk: t, map: H, ap: H, each() {}, bind: H, flatten: H, exists: F, forall: j, filter: H, equals: e = function (e) { return e.isNone() }, equals_: e, toArray() { return [] }, toString: _('none()') }, Object.freeze && Object.freeze(r), r); var q = function (n) { const e = function () { return n }; const t = function () { return o }; const r = function (e) { return e(n) }; var o = { fold(e, t) { return t(n) }, is(e) { return n === e }, isSome: j, isNone: F, getOr: e, getOrThunk: e, getOrDie: e, getOrNull: e, getOrUndefined: e, or: t, orThunk: t, map(e) { return q(e(n)) }, ap(e) { return e.fold(H, (e) => q(e(n))) }, each(e) { e(n) }, bind: r, flatten: e, exists: r, forall: r, filter(e) { return e(n) ? o : $ }, equals(e) { return e.is(n) }, equals_(e, t) { return e.fold(F, (e) => t(n, e)) }, toArray() { return [n] }, toString() { return `some(${n})` } }; return o }; const W = { some: q, none: H, from(e) { return e === null || e === undefined ? $ : q(e) } }; const z = function (t) { return function (e) { return (function (e) { if (e === null) return 'null'; const t = typeof e; return t === 'object' && Array.prototype.isPrototypeOf(e) ? 'array' : t === 'object' && String.prototype.isPrototypeOf(e) ? 'string' : t }(e)) === t } }; const K = z('string'); const V = z('boolean'); const X = z('function'); const Q = z('number'); const Y = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o, e) } return r }; const G = function (e, t) { for (let n = 0, r = e.length; n < r; n++)t(e[n], n, e) }; const J = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r, e) && n.push(i) } return n }; const Z = function (e, t, n) { return G(e, (e) => { n = t(n, e) }), n }; const ee = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n, e)) return W.some(o) } return W.none() }; const te = Array.prototype.push; const ne = function (e, t) { return (function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!Array.prototype.isPrototypeOf(e[n])) throw new Error(`Arr.flatten item ${n} was not an array, input: ${e}`); te.apply(t, e[n]) } return t }(Y(e, t))) }; const re = Array.prototype.slice; const oe = function (e) { return e.length === 0 ? W.none() : W.some(e[0]) }; const ie = function (e) { return e.length === 0 ? W.none() : W.some(e[e.length - 1]) }; const ue = (X(Array.from) && Array.from, typeof window !== 'undefined' ? window : Function('return this;')()); const se = function (e, t) { return (function (e, t) { for (var n = t !== undefined && t !== null ? t : ue, r = 0; r < e.length && n !== undefined && n !== null; ++r)n = n[e[r]]; return n }(e.split('.'), t)) }; const ae = function (e, t) { const n = se(e, t); if (n === undefined || n === null) throw `${e} not available on this browser`; return n }; const ce = function (e) { let t; const n = se('ownerDocument.defaultView', e); return (t = n, ae('HTMLElement', t)).prototype.isPrototypeOf(e) }; const fe = tinymce.util.Tools.resolve('tinymce.dom.DomQuery'); const le = function (e) { const t = e.selection.getStart(!0); return e.dom.getParent(t, 'OL,UL,DL', me(e, t)) }; const de = function (e) { let n; let t; let r; const o = e.selection.getSelectedBlocks(); return v.grep((n = e, t = o, r = v.map(t, (e) => { const t = n.dom.getParent(e, 'li,dd,dt', me(n, e)); return t || e }), fe.unique(r)), (e) => C(e)) }; var me = function (e, t) { const n = e.dom.getParents(t, 'TD,TH'); return n.length > 0 ? n[0] : e.getBody() }; const ge = function (e, t) { const n = e.dom.getParents(t, 'ol,ul', me(e, t)); return ie(n) }; const pe = function (t, e) { const n = Y(e, (e) => ge(t, e).getOr(e)); return fe.unique(n) }; const ve = { isList(e) { const t = le(e); return ce(t) }, getParentList: le, getSelectedSubLists(e) { let t; let n; let r; const o = le(e); const i = e.selection.getSelectedBlocks(); return r = i, (n = o) && r.length === 1 && r[0] === n ? (t = o, v.grep(t.querySelectorAll('ol,ul,dl'), (e) => N(e))) : v.grep(i, (e) => N(e) && o !== e) }, getSelectedListItems: de, getClosestListRootElm: me, getSelectedDlItems(e) { return J(de(e), O) }, getSelectedListRoots(e) { let t; let n; let r; const o = (n = ge(t = e, t.selection.getStart()), r = J(t.selection.getSelectedBlocks(), S), n.toArray().concat(r)); return pe(e, o) } }; const he = function (e, t) { const n = (function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) return r } return undefined }(e, t)); if (!n) return { major: 0, minor: 0 }; const r = function (e) { return Number(t.replace(n, `$${e}`)) }; return Ne(r(1), r(2)) }; const ye = function () { return Ne(0, 0) }; var Ne = function (e, t) { return { major: e, minor: t } }; const Se = { nu: Ne, detect(e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? ye() : he(e, n) }, unknown: ye }; const Oe = 'Firefox'; const Ce = function (e, t) { return function () { return t === e } }; const Le = function (e) { const t = e.current; return { current: t, version: e.version, isEdge: Ce('Edge', t), isChrome: Ce('Chrome', t), isIE: Ce('IE', t), isOpera: Ce('Opera', t), isFirefox: Ce(Oe, t), isSafari: Ce('Safari', t) } }; const be = { unknown() { return Le({ current: undefined, version: Se.unknown() }) }, nu: Le, edge: _('Edge'), chrome: _('Chrome'), ie: _('IE'), opera: _('Opera'), firefox: _(Oe), safari: _('Safari') }; const Te = 'Windows'; const De = 'Android'; const Ee = 'Solaris'; const we = 'FreeBSD'; const ke = function (e, t) { return function () { return t === e } }; const Ae = function (e) { const t = e.current; return { current: t, version: e.version, isWindows: ke(Te, t), isiOS: ke('iOS', t), isAndroid: ke(De, t), isOSX: ke('OSX', t), isLinux: ke('Linux', t), isSolaris: ke(Ee, t), isFreeBSD: ke(we, t) } }; const xe = { unknown() { return Ae({ current: undefined, version: Se.unknown() }) }, nu: Ae, windows: _(Te), ios: _('iOS'), android: _(De), linux: _('Linux'), osx: _('OSX'), solaris: _(Ee), freebsd: _(we) }; const Re = function (e, t) { const n = String(t).toLowerCase(); return ee(e, (e) => e.search(n)) }; const Ie = function (e, n) { return Re(e, n).map((e) => { const t = Se.detect(e.versionRegexes, n); return { current: e.name, version: t } }) }; const Be = function (e, n) { return Re(e, n).map((e) => { const t = Se.detect(e.versionRegexes, n); return { current: e.name, version: t } }) }; const _e = function (e, t) { return e.indexOf(t) !== -1 }; const Pe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const Me = function (t) { return function (e) { return _e(e, t) } }; const Ue = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search(e) { return _e(e, 'edge/') && _e(e, 'chrome') && _e(e, 'safari') && _e(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Pe], search(e) { return _e(e, 'chrome') && !_e(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search(e) { return _e(e, 'msie') || _e(e, 'trident') } }, { name: 'Opera', versionRegexes: [Pe, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: Me('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: Me('firefox') }, { name: 'Safari', versionRegexes: [Pe, /.*?cpu os ([0-9]+)_([0-9]+).*/], search(e) { return (_e(e, 'safari') || _e(e, 'mobile/')) && _e(e, 'applewebkit') } }]; const Fe = [{ name: 'Windows', search: Me('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search(e) { return _e(e, 'iphone') || _e(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: Me('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: Me('os x'), versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: Me('linux'), versionRegexes: [] }, { name: 'Solaris', search: Me('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: Me('freebsd'), versionRegexes: [] }]; const je = { browsers: _(Ue), oses: _(Fe) }; const He = function (e) { let t; let n; let r; let o; let i; let u; let s; let a; let c; let f; let l; const d = je.browsers(); const m = je.oses(); const g = Ie(d, e).fold(be.unknown, be.nu); const p = Be(m, e).fold(xe.unknown, xe.nu); return { browser: g, os: p, deviceType: (n = g, r = e, o = (t = p).isiOS() && !0 === /ipad/i.test(r), i = t.isiOS() && !o, u = t.isAndroid() && t.version.major === 3, s = t.isAndroid() && t.version.major === 4, a = o || u || s && !0 === /mobile/i.test(r), c = t.isiOS() || t.isAndroid(), f = c && !a, l = n.isSafari() && t.isiOS() && !1 === /safari/i.test(r), { isiPad: _(o), isiPhone: _(i), isTablet: _(a), isPhone: _(f), isTouch: _(c), isAndroid: t.isAndroid, isiOS: t.isiOS, isWebView: _(l) }) } }; const $e = { detect: (o = function () { const e = navigator.userAgent; return He(e) }, u = !1, function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return u || (u = !0, i = o.apply(null, e)), i }) }; const qe = function (e) { if (e === null || e === undefined) throw new Error('Node cannot be null or undefined'); return { dom: _(e) } }; const We = { fromHtml(e, t) { const n = (t || document).createElement('div'); if (n.innerHTML = e, !n.hasChildNodes() || n.childNodes.length > 1) throw console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node'); return qe(n.childNodes[0]) }, fromTag(e, t) { const n = (t || document).createElement(e); return qe(n) }, fromText(e, t) { const n = (t || document).createTextNode(e); return qe(n) }, fromDom: qe, fromPoint(e, t, n) { const r = e.dom(); return W.from(r.elementFromPoint(t, n)).map(qe) } }; const ze = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE); const Ke = (Node.TEXT_NODE, Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, ze); const Ve = ($e.detect().browser.isIE(), function (e, t) { const n = e.dom(); if (n.nodeType !== Ke) return !1; if (n.matches !== undefined) return n.matches(t); if (n.msMatchesSelector !== undefined) return n.msMatchesSelector(t); if (n.webkitMatchesSelector !== undefined) return n.webkitMatchesSelector(t); if (n.mozMatchesSelector !== undefined) return n.mozMatchesSelector(t); throw new Error('Browser lacks native selectors') }); const Xe = Object.keys; const Qe = function (e) { return e.dom().nodeName.toLowerCase() }; const Ye = function (e, t) { const n = e.dom(); !(function (e, t) { for (let n = Xe(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; t(e[i], i, e) } }(t, (e, t) => { !(function (e, t, n) { if (!(K(n) || V(n) || Q(n))) throw console.error('Invalid call to Attr.set. Key ', t, ':: Value ', n, ':: Element ', e), new Error('Attribute value was not simple'); e.setAttribute(t, `${n}`) }(n, t, e)) })) }; const Ge = function (e) { return Z(e.dom().attributes, (e, t) => e[t.name] = t.value, e, {}) }; const Je = function (e) { const t = e.dom(); return W.from(t.parentNode).map(We.fromDom) }; const Ze = function (e) { const t = e.dom(); return Y(t.childNodes, We.fromDom) }; const et = function (e, t) { const n = e.dom().childNodes; return W.from(n[t]).map(We.fromDom) }; const tt = function (e) { return et(e, 0) }; const nt = function (e) { return et(e, e.dom().childNodes.length - 1) }; const rt = ((function () { for (let e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t] }('element', 'offset')), function (t, n) { Je(t).each((e) => { e.dom().insertBefore(n.dom(), t.dom()) }) }); const ot = function (e, t) { e.dom().appendChild(t.dom()) }; const it = function (t, e) { G(e, (e) => { ot(t, e) }) }; const ut = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const st = function (e) { return t = e, n = !0, We.fromDom(t.dom().cloneNode(n)); let t, n }; const at = function (e, t) { let n; let r; let o; let i; const u = (n = e, r = t, o = We.fromTag(r), i = Ge(n), Ye(o, i), o); rt(e, u); const s = Ze(e); return it(u, s), ut(e), u }; const ct = tinymce.util.Tools.resolve('tinymce.Env'); const ft = g.DOM; const lt = function (e, t, n) { let r; let o; let i; const u = ft.createFragment(); const s = e.schema.getBlockElements(); if (e.settings.forced_root_block && (n = n || e.settings.forced_root_block), n && ((o = ft.create(n)).tagName === e.settings.forced_root_block && ft.setAttribs(o, e.settings.forced_root_block_attrs), D(t.firstChild, s) || u.appendChild(o)), t) for (;r = t.firstChild;) { const a = r.nodeName; i || a === 'SPAN' && r.getAttribute('data-mce-type') === 'bookmark' || (i = !0), D(r, s) ? (u.appendChild(r), o = null) : n ? (o || (o = ft.create(n), u.appendChild(o)), o.appendChild(r)) : u.appendChild(r) } return e.settings.forced_root_block ? i || ct.ie && !(ct.ie > 10) || o.appendChild(ft.create('br', { 'data-mce-bogus': '1' })) : u.appendChild(ft.create('br')), u }; const dt = g.DOM; const mt = function (e, t, n, r) { let o, i, u, s, a; for (u = dt.select('span[data-mce-type="bookmark"]', t), r = r || lt(e, n), (o = dt.createRng()).setStartAfter(n), o.setEndAfter(t), s = (i = o.extractContents()).firstChild; s; s = s.firstChild) if (s.nodeName === 'LI' && e.dom.isEmpty(s)) { dt.remove(s); break }e.dom.isEmpty(i) || dt.insertAfter(i, t), dt.insertAfter(r, t), w(e.dom, n.parentNode) && (a = n.parentNode, v.each(u, (e) => { a.parentNode.insertBefore(e, n.parentNode) }), dt.remove(a)), dt.remove(n), w(e.dom, t) && dt.remove(t) }; const gt = function (e, t) { for (var n = [], r = 0; r < e.length; r++) { const o = e[r]; if (!o.isSome()) return W.none(); n.push(o.getOrDie()) } return W.some(t.apply(null, n)) }; const pt = function (e, t, n) { if (!K(n)) throw console.error('Invalid call to CSS.set. Property ', t, ':: Value ', n, ':: Element ', e), new Error(`CSS value must be a string: ${n}`); e.style !== undefined && e.style.setProperty(t, n) }; const vt = function (e, t) { ot(e.item, t.list) }; const ht = function (i, e, u) { for (var s = [], t = function (e) { let t; let n; let r; const o = (t = i, n = u, r = { list: We.fromTag(n, t), item: We.fromTag('li', t) }, ot(r.list, r.item), r); ie(s).each((e) => vt(e, o)), s.push(o) }, n = 0; n < e; n++)t(); return s }; const yt = function (c, e, f) { const t = e.slice(0, f.depth); return ie(t).each((e) => { let t, n, r, o, i, u, s, a; t = e, r = c, o = f.itemAttributes, i = f.content, u = We.fromTag('li', r), Ye(u, o), it(u, i), n = u, ot(t.list, n), t.item = n, a = f, Qe((s = e).list).toUpperCase() !== a.listType && (s.list = at(s.list, a.listType)), Ye(s.list, a.listAttributes) }), t }; const Nt = function (e, t, n) { const r = ht(e, n.depth - t.length, n.listType); return (function (e, t) { ie(e).each((e) => { Ye(e.list, t.listAttributes), Ye(e.item, t.itemAttributes), it(e.item, t.content) }); for (let n = 0; n < e.length - 1; n++)r = e[n].item, o = 'list-style-type', i = 'none', u = r.dom(), pt(u, o, i); let r, o, i, u }(r, n)), gt([ie(t), oe(r)], vt), t.concat(r) }; const St = function (e) { return e.depth > 0 }; const Ot = function (e) { return e.isSelected }; const Ct = Object.prototype.hasOwnProperty; const Lt = (s = function (e, t) { return t }, function () { for (var e = new Array(arguments.length), t = 0; t < e.length; t++)e[t] = arguments[t]; if (e.length === 0) throw new Error("Can't merge zero objects"); for (var n = {}, r = 0; r < e.length; r++) { const o = e[r]; for (const i in o)Ct.call(o, i) && (n[i] = s(n[i], o[i])) } return n }); const bt = function (e, r) { const t = r.depth - 1; e[t].each((e) => { return n = e, (t = r).listType = n.listType, void (t.listAttributes = Lt({}, n.listAttributes)); let t, n }); const n = e.slice(0, t); return n.push(W.some(r)), n }; const Tt = function (e) { Z(e, (e, t) => t.depth > e.length ? (function (e, t) { for (var n = e.slice(0), r = t.depth - e.length, o = 1; o < r; o++)n.push(W.none()); return n.push(W.some(t)), n }(e, t)) : bt(e, t), []) }; var Dt = function (e) { let t = e; const n = function () { return t }; return { get: n, set(e) { t = e }, clone() { return Dt(n()) } } }; (a = l || (l = {})).OL = 'OL', a.UL = 'UL', a.DL = 'DL'; const Et = function (e) { switch (Qe(e)) { case 'ol':return W.some(l.OL); case 'ul':return W.some(l.UL); case 'dl':return W.some(l.DL); default:return W.none() } }; const wt = function (e) { return Ve(e, 'OL,UL,DL') }; const kt = function (e) { return tt(e).map(wt).getOr(!1) }; const At = function (e) { const t = Ze(e); const n = t.length + (nt(e).map(wt).getOr(!1) ? -1 : 0); return Y(t.slice(0, n), st) }; const xt = function (u, e, s, a) { const c = (function t(r) { for (var o = [], e = 1; e < arguments.length; e++)o[e - 1] = arguments[e]; return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; const n = o.concat(e); return r.apply(null, n) } }(Rt, u, e, s)); const f = function (r) { return e.each((e) => { let t, n; t = r === 'Start' ? e.start : e.end, n = a, t.dom() === n.dom() && s.set(r === 'Start') }) }; return tt(a).filter(wt).fold(() => { f('Start'); let e; let t; let n; let r; const o = (e = a, t = u, n = s.get(), r = Je(e), { depth: t, isSelected: n, content: At(e), listType: r.bind(Et).getOr(l.OL), listAttributes: r.map(Ge).getOr({}), itemAttributes: Ge(e) }); f('End'); const i = nt(a).filter(wt).map(c).getOr([]); return [o].concat(i) }, c) }; var Rt = function (e, t, n, r) { const o = e + 1; return ne(Ze(r), (e) => wt(e) ? Rt(o, t, n, e) : xt(o, t, n, e)) }; const It = function (e, t, n) { return e.fire('ListMutation', { action: t, element: n }) }; const Bt = function (i, e) { return Y(e, (e) => { let t; let n; let r; const o = (t = e.content, r = (n || document).createDocumentFragment(), G(t, (e) => { r.appendChild(e.dom()) }), We.fromDom(r)); return We.fromDom(lt(i, o.dom())) }) }; const _t = function (e, t) { return Tt(t), (n = e.contentDocument, r = t, o = Z(r, (e, t) => t.depth > e.length ? Nt(n, e, t) : yt(n, e, t), []), oe(o).map((e) => e.list)).toArray(); let n, r, o }; const Pt = function (e) { let t; let n; const r = Y(ve.getSelectedListItems(e), We.fromDom); return gt([ee(r, P(kt)), ee((t = r, n = re.call(t, 0), n.reverse(), n), P(kt))], (e, t) => ({ start: e, end: t })) }; const Mt = function (s, e, a) { let t; let n; let r; const o = (t = e, n = Pt(s), r = Dt(!1), Y(t, (e) => ({ entries: Rt(0, n, r, e), sourceList: e }))); G(o, (e) => { let t, n; t = e.entries, n = a, G(J(t, Ot), (e) => (function (e, t) { switch (e) { case 'Indent':t.depth++; break; case 'Outdent':t.depth--; break; case 'Flatten':t.depth = 0 } }(n, e))); let r; let o; let i; const u = (r = s, o = e.entries, ne((function (e, t) { if (e.length === 0) return []; for (var n = t(e[0]), r = [], o = [], i = 0, u = e.length; i < u; i++) { const s = e[i]; const a = t(s); a !== n && (r.push(o), o = []), n = a, o.push(s) } return o.length !== 0 && r.push(o), r }(o, St)), (e) => oe(e).map(St).getOr(!1) ? _t(r, e) : Bt(r, e))); G(u, (e) => { It(s, a === 'Indent' ? 'IndentList' : 'OutdentList', e.dom()) }), i = e.sourceList, G(u, (e) => { rt(i, e) }), ut(e.sourceList) }) }; const Ut = function (e) { Ve(e, 'DT') && at(e, 'DD') }; const Ft = function (r, e, t) { G(t, e === 'Indent' ? Ut : (e) => { return t = r, void (Ve(n = e, 'DD') ? at(n, 'DT') : Ve(n, 'DT') && Je(n).each((e) => mt(t, e.dom(), n.dom()))); let t, n }) }; const jt = function (e, t) { const n = Y(ve.getSelectedDlItems(e), We.fromDom); const r = Y(ve.getSelectedListRoots(e), We.fromDom); if (n.length || r.length) { const o = e.selection.getBookmark(); Ft(e, t, n), Mt(e, r, t), e.selection.moveToBookmark(o), e.selection.setRng(x(e.selection.getRng())), e.nodeChanged() } }; const Ht = function (e) { jt(e, 'Indent') }; const $t = function (e) { jt(e, 'Outdent') }; const qt = function (e) { jt(e, 'Flatten') }; const Wt = function (e) { return /\btox\-/.test(e.className) }; const zt = function (e) { switch (e) { case 'UL':return 'ToggleUlList'; case 'OL':return 'ToggleOlList'; case 'DL':return 'ToggleDLList' } }; const Kt = function (n, e) { v.each(e, (e, t) => { n.setAttribute(t, e) }) }; const Vt = function (e, t, n) { let r, o, i, u, s, a, c; r = e, o = t, u = (i = n)['list-style-type'] ? i['list-style-type'] : null, r.setStyle(o, 'list-style-type', u), s = e, Kt(a = t, (c = n)['list-attributes']), v.each(s.select('li', a), (e) => { Kt(e, c['list-item-attributes']) }) }; const Xt = function (e, t, n, r) { let o, i; for (o = t[n ? 'startContainer' : 'endContainer'], i = t[n ? 'startOffset' : 'endOffset'], o.nodeType === 1 && (o = o.childNodes[Math.min(i, o.childNodes.length - 1)] || o), !n && b(o.nextSibling) && (o = o.nextSibling); o.parentNode !== r;) { if (T(e, o)) return o; if (/^(TD|TH)$/.test(o.parentNode.nodeName)) return o; o = o.parentNode } return o }; const Qt = function (f, l, d) { void 0 === d && (d = {}); let e; const t = f.selection.getRng(!0); let m = 'LI'; const n = ve.getClosestListRootElm(f, f.selection.getStart(!0)); const g = f.dom; g.getContentEditable(f.selection.getNode()) !== 'false' && ((l = l.toUpperCase()) === 'DL' && (m = 'DT'), e = I(t), v.each((function (n, e, r) { for (var o, i = [], u = n.dom, t = Xt(n, e, !0, r), s = Xt(n, e, !1, r), a = [], c = t; c && (a.push(c), c !== s); c = c.nextSibling);return v.each(a, (e) => { if (T(n, e)) return i.push(e), void (o = null); if (u.isBlock(e) || b(e)) return b(e) && u.remove(e), void (o = null); const t = e.nextSibling; p.isBookmarkNode(e) && (T(n, t) || !t && e.parentNode === r) ? o = null : (o || (o = u.create('p'), e.parentNode.insertBefore(o, e), i.push(o)), o.appendChild(e)) }), i }(f, t, n)), (e) => { let t, n, r, o, i, u, s, a, c; (n = e.previousSibling) && N(n) && n.nodeName === l && (r = n, o = d, i = g.getStyle(r, 'list-style-type'), u = o ? o['list-style-type'] : '', i === (u = u === null ? '' : u)) ? (t = n, e = g.rename(e, m), n.appendChild(e)) : (t = g.create(l), e.parentNode.insertBefore(t, e), t.appendChild(e), e = g.rename(e, m)), s = g, a = e, c = ['margin', 'margin-right', 'margin-bottom', 'margin-left', 'margin-top', 'padding', 'padding-right', 'padding-bottom', 'padding-left', 'padding-top'], v.each(c, (e) => { let t; return s.setStyle(a, ((t = {})[e] = '', t)) }), Vt(g, t, d), Gt(f.dom, t) }), f.selection.setRng(B(e))) }; const Yt = function (e, t, n) { return a = n, (s = t) && a && N(s) && s.nodeName === a.nodeName && (i = t, u = n, (o = e).getStyle(i, 'list-style-type', !0) === o.getStyle(u, 'list-style-type', !0)) && (r = n, t.className === r.className); let r, o, i, u, s, a }; var Gt = function (e, t) { let n, r; if (n = t.nextSibling, Yt(e, t, n)) { for (;r = n.firstChild;)t.appendChild(r); e.remove(n) } if (n = t.previousSibling, Yt(e, t, n)) { for (;r = n.lastChild;)t.insertBefore(r, t.firstChild); e.remove(n) } }; const Jt = function (t, e, n, r, o) { if (e.nodeName !== r || Zt(o)) { const i = I(t.selection.getRng(!0)); v.each([e].concat(n), (e) => { !(function (e, t, n, r) { if (t.nodeName !== n) { const o = e.dom.rename(t, n); Vt(e.dom, o, r), It(e, zt(n), o) } else Vt(e.dom, t, r), It(e, zt(n), t) }(t, e, r, o)) }), t.selection.setRng(B(i)) } else qt(t) }; var Zt = function (e) { return 'list-style-type' in e }; const en = { toggleList(e, t, n) { const r = ve.getParentList(e); const o = ve.getSelectedSubLists(e); n = n || {}, r && o.length > 0 ? Jt(e, r, o, t, n) : (function (e, t, n, r) { if (t !== e.getBody()) if (t) if (t.nodeName !== n || Zt(r) || Wt(t)) { const o = I(e.selection.getRng(!0)); Vt(e.dom, t, r); const i = e.dom.rename(t, n); Gt(e.dom, i), e.selection.setRng(B(o)), It(e, zt(n), i) } else qt(e); else Qt(e, n, r), It(e, zt(n), t) }(e, r, t, n)) }, mergeWithAdjacentLists: Gt }; const tn = g.DOM; const nn = function (e, t) { let n; const r = t.parentNode; r.nodeName === 'LI' && r.firstChild === t && ((n = r.previousSibling) && n.nodeName === 'LI' ? (n.appendChild(t), w(e, r) && tn.remove(r)) : tn.setStyle(r, 'listStyleType', 'none')), N(r) && (n = r.previousSibling) && n.nodeName === 'LI' && n.appendChild(t) }; const rn = function (t, e) { v.each(v.grep(t.select('ol,ul', e)), (e) => { nn(t, e) }) }; const on = function (e, t, n, r) { let o; let i; let u = t.startContainer; const s = t.startOffset; if (u.nodeType === 3 && (n ? s < u.data.length : s > 0)) return u; for (o = e.schema.getNonEmptyElements(), u.nodeType === 1 && (u = f.getNode(u, s)), i = new d(u, r), n && E(e.dom, u) && i.next(); u = i[n ? 'next' : 'prev2']();) { if (u.nodeName === 'LI' && !u.hasChildNodes()) return u; if (o[u.nodeName]) return u; if (u.nodeType === 3 && u.data.length > 0) return u } }; const un = function (e, t) { const n = t.childNodes; return n.length === 1 && !N(n[0]) && e.isBlock(n[0]) }; const sn = function (e, t, n) { let r, o, i, u; if (o = un(e, n) ? n.firstChild : n, un(i = e, u = t) && i.remove(u.firstChild, !0), !w(e, t, !0)) for (;r = t.firstChild;)o.appendChild(r) }; const an = function (e, t, n) { let r; let o; const i = t.parentNode; k(e, t) && k(e, n) && (N(n.lastChild) && (o = n.lastChild), i === n.lastChild && b(i.previousSibling) && e.remove(i.previousSibling), (r = n.lastChild) && b(r) && t.hasChildNodes() && e.remove(r), w(e, n, !0) && e.$(n).empty(), sn(e, t, n), o && n.appendChild(o), e.remove(t), w(e, i) && i !== e.getRoot() && e.remove(i)) }; const cn = function (e, t, n, r) { let o; let i; let u; const s = e.dom; if (s.isEmpty(r))i = n, u = r, (o = e).dom.$(u).empty(), an(o.dom, i, u), o.selection.setCursorLocation(u); else { const a = I(t); an(s, n, r), e.selection.setRng(B(a)) } }; const fn = function (e, t) { let n; let r; let o; const i = e.dom; const u = e.selection; const s = u.getStart(); const a = ve.getClosestListRootElm(e, s); const c = i.getParent(u.getStart(), 'LI', a); if (c) { if ((n = c.parentNode) === e.getBody() && w(i, n)) return !0; if (r = x(u.getRng(!0)), (o = i.getParent(on(e, r, t, a), 'LI', a)) && o !== c) return t ? cn(e, r, o, c) : (function (e, t, n, r) { const o = I(t); an(e.dom, n, r); const i = B(o); e.selection.setRng(i) }(e, r, c, o)), !0; if (!o && !t) return qt(e), !0 } return !1 }; const ln = function (e, t) { return fn(e, t) || (function (o, i) { const u = o.dom; const e = o.selection.getStart(); const s = ve.getClosestListRootElm(o, e); const a = u.getParent(e, u.isBlock, s); if (a && u.isEmpty(a)) { const t = x(o.selection.getRng(!0)); const c = u.getParent(on(o, t, i, s), 'LI', s); if (c) return o.undoManager.transact(() => { let e, t, n, r; t = a, n = s, r = (e = u).getParent(t.parentNode, e.isBlock, n), e.remove(t), r && e.isEmpty(r) && e.remove(r), en.mergeWithAdjacentLists(u, c.parentNode), o.selection.select(c, !0), o.selection.collapse(i) }), !0 } return !1 }(e, t)) }; const dn = function (e, t) { return e.selection.isCollapsed() ? ln(e, t) : (r = (n = e).selection.getStart(), o = ve.getClosestListRootElm(n, r), !!(n.dom.getParent(r, 'LI,DT,DD', o) || ve.getSelectedListItems(n).length > 0) && (n.undoManager.transact(() => { n.execCommand('Delete'), rn(n.dom, n.getBody()) }), !0)); let n, r, o }; const mn = function (t) { t.on('keydown', (e) => { e.keyCode === m.BACKSPACE ? dn(t, !1) && e.preventDefault() : e.keyCode === m.DELETE && dn(t, !0) && e.preventDefault() }) }; const gn = dn; const pn = function (t) { return { backspaceDelete(e) { gn(t, e) } } }; const vn = function (t, n) { return function () { const e = t.dom.getParent(t.selection.getStart(), 'UL,OL,DL'); return e && e.nodeName === n } }; const hn = function (n) { n.on('BeforeExecCommand', (e) => { const t = e.command.toLowerCase(); t === 'indent' ? Ht(n) : t === 'outdent' && $t(n) }), n.addCommand('InsertUnorderedList', (e, t) => { en.toggleList(n, 'UL', t) }), n.addCommand('InsertOrderedList', (e, t) => { en.toggleList(n, 'OL', t) }), n.addCommand('InsertDefinitionList', (e, t) => { en.toggleList(n, 'DL', t) }), n.addCommand('RemoveList', () => { qt(n) }), n.addQueryStateHandler('InsertUnorderedList', vn(n, 'UL')), n.addQueryStateHandler('InsertOrderedList', vn(n, 'OL')), n.addQueryStateHandler('InsertDefinitionList', vn(n, 'DL')) }; const yn = function (e) { return e.getParam('lists_indent_on_tab', !0) }; const Nn = function (e) { let t; yn(e) && (t = e).on('keydown', (e) => { e.keyCode !== m.TAB || m.metaKeyPressed(e) || ve.isList(t) && (e.preventDefault(), t.undoManager.transact(() => { e.shiftKey ? $t(t) : Ht(t) })) }), mn(e) }; const Sn = function (t, i) { return function (o) { const e = function (e) { const t = (function (e, t) { for (let n = 0; n < e.length; n++) if (t(e[n])) return n; return -1 }(e.parents, L)); const n = t !== -1 ? e.parents.slice(0, t) : e.parents; const r = v.grep(n, N); o.setActive(r.length > 0 && r[0].nodeName === i && !Wt(r[0])) }; return t.on('NodeChange', e), function () { return t.off('NodeChange', e) } } }; const On = function (t) { let e; let n; let r; const o = function (e) { return function () { return t.execCommand(e) } }; n = 'advlist', r = (e = t).settings.plugins ? e.settings.plugins : '', v.inArray(r.split(/[ ,]/), n) === -1 && (t.ui.registry.addToggleButton('numlist', { icon: 'ordered-list', active: !1, tooltip: 'Numbered list', onAction: o('InsertOrderedList'), onSetup: Sn(t, 'OL') }), t.ui.registry.addToggleButton('bullist', { icon: 'unordered-list', active: !1, tooltip: 'Bullet list', onAction: o('InsertUnorderedList'), onSetup: Sn(t, 'UL') })) }; c.add('lists', (e) => Nn(e), On(e), hn(e), pn(e)), function Cn() {}
}())
