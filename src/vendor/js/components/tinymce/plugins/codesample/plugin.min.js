!(function () {
  const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const r = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const t = {}; const n = t; const c = void 0 !== t ? t : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {}; const i = (function () { const u = /\blang(?:uage)?-(?!\*)(\w+)\b/i; var S = c.Prism = { util: { encode(e) { return e instanceof s ? new s(e.type, S.util.encode(e.content), e.alias) : S.util.type(e) === 'Array' ? e.map(S.util.encode) : e.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ') }, type(e) { return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1] }, clone(e) { switch (S.util.type(e)) { case 'Object':var t = {}; for (const n in e)e.hasOwnProperty(n) && (t[n] = S.util.clone(e[n])); return t; case 'Array':return e.map && e.map((e) => S.util.clone(e)) } return e } }, languages: { extend(e, t) { const n = S.util.clone(S.languages[e]); for (const a in t)n[a] = t[a]; return n }, insertBefore(n, e, t, a) { const r = (a = a || S.languages)[n]; if (arguments.length === 2) { for (var i in t = e)t.hasOwnProperty(i) && (r[i] = t[i]); return r } const o = {}; for (const s in r) if (r.hasOwnProperty(s)) { if (s === e) for (var i in t)t.hasOwnProperty(i) && (o[i] = t[i]); o[s] = r[s] } return S.languages.DFS(S.languages, function (e, t) { t === a[n] && e !== n && (this[e] = o) }), a[n] = o }, DFS(e, t, n) { for (const a in e)e.hasOwnProperty(a) && (t.call(e, a, e[a], n || a), S.util.type(e[a]) === 'Object' ? S.languages.DFS(e[a], t) : S.util.type(e[a]) === 'Array' && S.languages.DFS(e[a], t, a)) } }, plugins: {}, highlightAll(e, t) { for (let n = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'), a = 0, r = void 0; r = n[a++];)S.highlightElement(r, !0 === e, t) }, highlightElement(e, t, n) { for (var a, r, i = e; i && !u.test(i.className);)i = i.parentNode; i && (a = (i.className.match(u) || [, ''])[1], r = S.languages[a]), e.className = `${e.className.replace(u, '').replace(/\s+/g, ' ')} language-${a}`, i = e.parentNode, /pre/i.test(i.nodeName) && (i.className = `${i.className.replace(u, '').replace(/\s+/g, ' ')} language-${a}`); const o = e.textContent; const s = { element: e, language: a, grammar: r, code: o }; if (o && r) if (S.hooks.run('before-highlight', s), t && c.Worker) { const l = new Worker(S.filename); l.onmessage = function (e) { s.highlightedCode = e.data, S.hooks.run('before-insert', s), s.element.innerHTML = s.highlightedCode, n && n.call(s.element), S.hooks.run('after-highlight', s), S.hooks.run('complete', s) }, l.postMessage(JSON.stringify({ language: s.language, code: s.code, immediateClose: !0 })) } else s.highlightedCode = S.highlight(s.code, s.grammar, s.language), S.hooks.run('before-insert', s), s.element.innerHTML = s.highlightedCode, n && n.call(e), S.hooks.run('after-highlight', s), S.hooks.run('complete', s); else S.hooks.run('complete', s) }, highlight(e, t, n) { const a = S.tokenize(e, t); return s.stringify(S.util.encode(a), n) }, tokenize(e, t, n) { const a = S.Token; const r = [e]; const i = t.rest; if (i) { for (var o in i)t[o] = i[o]; delete t.rest }e:for (var o in t) if (t.hasOwnProperty(o) && t[o]) { let s = t[o]; s = S.util.type(s) === 'Array' ? s : [s]; for (let l = 0; l < s.length; ++l) { let u = s[l]; const c = u.inside; const g = !!u.lookbehind; let d = 0; const p = u.alias; u = u.pattern || u; for (let f = 0; f < r.length; f++) { const h = r[f]; if (r.length > e.length) break e; if (!(h instanceof a)) { u.lastIndex = 0; let m = u.exec(h); if (m) { g && (d = m[1].length); const b = m.index - 1 + d; const y = b + (m = m[0].slice(d)).length; const k = h.slice(0, b + 1); const v = h.slice(y + 1); const w = [f, 1]; k && w.push(k); const x = new a(o, c ? S.tokenize(m, c) : m, p); w.push(x), v && w.push(v), Array.prototype.splice.apply(r, w) } } } } } return r }, hooks: { all: {}, add(e, t) { const n = S.hooks.all; n[e] = n[e] || [], n[e].push(t) }, run(e, t) { const n = S.hooks.all[e]; if (n && n.length) for (let a = 0, r = void 0; r = n[a++];)r(t) } } }; var s = S.Token = function (e, t, n) { this.type = e, this.content = t, this.alias = n }; if (s.stringify = function (t, n, e) { if (typeof t === 'string') return t; if (S.util.type(t) === 'Array') return t.map((e) => s.stringify(e, n, t)).join(''); const a = { type: t.type, content: s.stringify(t.content, n, e), tag: 'span', classes: ['token', t.type], attributes: {}, language: n, parent: e }; if (a.type === 'comment' && (a.attributes.spellcheck = 'true'), t.alias) { const r = S.util.type(t.alias) === 'Array' ? t.alias : [t.alias]; Array.prototype.push.apply(a.classes, r) }S.hooks.run('wrap', a); let i = ''; for (const o in a.attributes)i += `${(i ? ' ' : '') + o}="${a.attributes[o] || ''}"`; return `<${a.tag} class="${a.classes.join(' ')}" ${i}>${a.content}</${a.tag}>` }, !c.document) return c.addEventListener && c.addEventListener('message', (e) => { const t = JSON.parse(e.data); const n = t.language; const a = t.code; const r = t.immediateClose; c.postMessage(S.highlight(a, S.languages[n], n)), r && c.close() }, !1), c.Prism }()); void 0 !== n && (n.Prism = i), i.languages.markup = { comment: /<!--[\w\W]*?-->/, prolog: /<\?[\w\W]+?\?>/, doctype: /<!DOCTYPE[\w\W]+?>/, cdata: /<!\[CDATA\[[\w\W]*?]]>/i, tag: { pattern: /<\/?[^\s>\/=.]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i, inside: { tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, 'attr-value': { pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i, inside: { punctuation: /[=>"']/ } }, punctuation: /\/?>/, 'attr-name': { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: /&#?[\da-z]{1,8};/i }, i.hooks.add('wrap', (e) => { e.type === 'entity' && (e.attributes.title = e.content.replace(/&amp;/, '&')) }), i.languages.xml = i.languages.markup, i.languages.html = i.languages.markup, i.languages.mathml = i.languages.markup, i.languages.svg = i.languages.markup, i.languages.css = { comment: /\/\*[\w\W]*?\*\//, atrule: { pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i, inside: { rule: /@[\w-]+/ } }, url: /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i, selector: /[^\{\}\s][^\{\};]*?(?=\s*\{)/, string: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/, property: /(\b|\B)[\w-]+(?=\s*:)/i, important: /\B!important\b/i, function: /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:]/ }, i.languages.css.atrule.inside.rest = i.util.clone(i.languages.css), i.languages.markup && (i.languages.insertBefore('markup', 'tag', { style: { pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/i, inside: { tag: { pattern: /<style[\w\W]*?>|<\/style>/i, inside: i.languages.markup.tag.inside }, rest: i.languages.css }, alias: 'language-css' } }), i.languages.insertBefore('inside', 'attr-value', { 'style-attr': { pattern: /\s*style=("|').*?\1/i, inside: { 'attr-name': { pattern: /^\s*style/i, inside: i.languages.markup.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, 'attr-value': { pattern: /.+/i, inside: i.languages.css } }, alias: 'language-css' } }, i.languages.markup.tag)), i.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\w\W]*?\*\//, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0 }], string: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, 'class-name': { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i, lookbehind: !0, inside: { punctuation: /(\.|\\)/ } }, keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(true|false)\b/, function: /[a-z0-9_]+(?=\()/i, number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ }, i.languages.javascript = i.languages.extend('clike', { keyword: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/, number: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/, function: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i }), i.languages.insertBefore('javascript', 'keyword', { regex: { pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/, lookbehind: !0 } }), i.languages.insertBefore('javascript', 'class-name', { 'template-string': { pattern: /`(?:\\`|\\?[^`])*`/, inside: { interpolation: { pattern: /\$\{[^}]+\}/, inside: { 'interpolation-punctuation': { pattern: /^\$\{|\}$/, alias: 'punctuation' }, rest: i.languages.javascript } }, string: /[\s\S]+/ } } }), i.languages.markup && i.languages.insertBefore('markup', 'tag', { script: { pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/i, inside: { tag: { pattern: /<script[\w\W]*?>|<\/script>/i, inside: i.languages.markup.tag.inside }, rest: i.languages.javascript }, alias: 'language-javascript' } }), i.languages.js = i.languages.javascript, i.languages.c = i.languages.extend('clike', { keyword: /\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/, operator: /\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/, number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i }), i.languages.insertBefore('c', 'string', { macro: { pattern: /(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im, lookbehind: !0, alias: 'property', inside: { string: { pattern: /(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/, lookbehind: !0 } } } }), delete i.languages.c['class-name'], delete i.languages.c.boolean, i.languages.csharp = i.languages.extend('clike', { keyword: /\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/, string: [/@("|')(\1\1|\\\1|\\?(?!\1)[\s\S])*\1/, /("|')(\\?.)*?\1/], number: /\b-?(0x[\da-f]+|\d*\.?\d+)\b/i }), i.languages.insertBefore('csharp', 'keyword', { preprocessor: { pattern: /(^\s*)#.*/m, lookbehind: !0 } }), i.languages.cpp = i.languages.extend('c', { keyword: /\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, boolean: /\b(true|false)\b/, operator: /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/ }), i.languages.insertBefore('cpp', 'keyword', { 'class-name': { pattern: /(class\s+)[a-z0-9_]+/i, lookbehind: !0 } }), i.languages.java = i.languages.extend('clike', { keyword: /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/, number: /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i, operator: { pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m, lookbehind: !0 } }), i.languages.php = i.languages.extend('clike', { keyword: /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i, constant: /\b[A-Z0-9_]{2,}\b/, comment: { pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/, lookbehind: !0 } }), i.languages.insertBefore('php', 'class-name', { 'shell-comment': { pattern: /(^|[^\\])#.*/, lookbehind: !0, alias: 'comment' } }), i.languages.insertBefore('php', 'keyword', { delimiter: /\?>|<\?(?:php)?/i, variable: /\$\w+\b/i, package: { pattern: /(\\|namespace\s+|use\s+)[\w\\]+/, lookbehind: !0, inside: { punctuation: /\\/ } } }), i.languages.insertBefore('php', 'operator', { property: { pattern: /(->)[\w]+/, lookbehind: !0 } }), i.languages.markup && (i.hooks.add('before-highlight', (t) => { t.language === 'php' && (t.tokenStack = [], t.backupCode = t.code, t.code = t.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/gi, (e) => t.tokenStack.push(e), `{{{PHP${t.tokenStack.length}}}}`)) }), i.hooks.add('before-insert', (e) => { e.language === 'php' && (e.code = e.backupCode, delete e.backupCode) }), i.hooks.add('after-highlight', (e) => { if (e.language === 'php') { for (let t = 0, n = void 0; n = e.tokenStack[t]; t++)e.highlightedCode = e.highlightedCode.replace(`{{{PHP${t + 1}}}}`, i.highlight(n, e.grammar, 'php').replace(/\$/g, '$$$$')); e.element.innerHTML = e.highlightedCode } }), i.hooks.add('wrap', (e) => { e.language === 'php' && e.type === 'markup' && (e.content = e.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, '<span class="token php">$1</span>')) }), i.languages.insertBefore('php', 'comment', { markup: { pattern: /<[^?]\/?(.*?)>/, inside: i.languages.markup }, php: /\{\{\{PHP[0-9]+\}\}\}/ })), i.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0 }, string: /"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(?:\\?.)*?\1/, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g, lookbehind: !0 }, 'class-name': { pattern: /(\bclass\s+)[a-z0-9_]+/i, lookbehind: !0 }, keyword: /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/, boolean: /\b(?:True|False)\b/, number: /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i, operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/, punctuation: /[{}[\];(),.:]/ }, (function (e) { e.languages.ruby = e.languages.extend('clike', { comment: /#(?!\{[^\r\n]*?\}).*/, keyword: /\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/ }); const t = { pattern: /#\{[^}]+\}/, inside: { delimiter: { pattern: /^#\{|\}$/, alias: 'tag' }, rest: e.util.clone(e.languages.ruby) } }; e.languages.insertBefore('ruby', 'keyword', { regex: [{ pattern: /%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/, inside: { interpolation: t } }, { pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/, inside: { interpolation: t } }, { pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/, inside: { interpolation: t } }, { pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/, inside: { interpolation: t } }, { pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/, inside: { interpolation: t } }, { pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/, lookbehind: !0 }], variable: /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/, symbol: /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/ }), e.languages.insertBefore('ruby', 'number', { builtin: /\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/, constant: /\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/ }), e.languages.ruby.string = [{ pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/, inside: { interpolation: t } }, { pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/, inside: { interpolation: t } }, { pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/, inside: { interpolation: t } }, { pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/, inside: { interpolation: t } }, { pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/, inside: { interpolation: t } }, { pattern: /("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/, inside: { interpolation: t } }] }(i)); let a; let o; let s; let l; let u; const g = { isCodeSample: function T(e) { return e && e.nodeName === 'PRE' && e.className.indexOf('language-') !== -1 }, trimArg: function B(n) { return function (e, t) { return n(t) } } }; const d = function (e) { return function () { return e } }; const p = d(!1); const f = d(!0); const h = p; const m = f; const b = function () { return y }; var y = (l = { fold(e, t) { return e() }, is: h, isSome: h, isNone: m, getOr: s = function (e) { return e }, getOrThunk: o = function (e) { return e() }, getOrDie(e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: s, orThunk: o, map: b, ap: b, each() {}, bind: b, flatten: b, exists: h, forall: m, filter: b, equals: a = function (e) { return e.isNone() }, equals_: a, toArray() { return [] }, toString: d('none()') }, Object.freeze && Object.freeze(l), l); var k = function (n) { const e = function () { return n }; const t = function () { return r }; const a = function (e) { return e(n) }; var r = { fold(e, t) { return t(n) }, is(e) { return n === e }, isSome: m, isNone: h, getOr: e, getOrThunk: e, getOrDie: e, getOrNull: e, getOrUndefined: e, or: t, orThunk: t, map(e) { return k(e(n)) }, ap(e) { return e.fold(b, (e) => k(e(n))) }, each(e) { e(n) }, bind: a, flatten: e, exists: a, forall: a, filter(e) { return e(n) ? r : y }, equals(e) { return e.is(n) }, equals_(e, t) { return e.fold(h, (e) => t(n, e)) }, toArray() { return [n] }, toString() { return `some(${n})` } }; return r }; const v = { some: k, none: b, from(e) { return e === null || e === undefined ? y : k(e) } }; const w = function (e) { const t = e.selection ? e.selection.getNode() : null; return g.isCodeSample(t) ? v.some(t) : v.none() }; const x = w; const S = function (t, n, a) { t.undoManager.transact(() => { const e = w(t); return a = r.DOM.encode(a), e.fold(() => { t.insertContent(`<pre id="__new" class="language-${n}">${a}</pre>`), t.selection.select(t.$('#__new').removeAttr('id')[0]) }, (e) => { t.dom.setAttrib(e, 'class', `language-${n}`), e.innerHTML = a, i.highlightElement(e), t.selection.select(e) }) }) }; const A = function (e) { return w(e).fold(() => '', (e) => e.textContent) }; const C = function (e) { return e.settings.codesample_languages }; const _ = function (e) { const t = C(e); return t || [{ text: 'HTML/XML', value: 'markup' }, { text: 'JavaScript', value: 'javascript' }, { text: 'CSS', value: 'css' }, { text: 'PHP', value: 'php' }, { text: 'Ruby', value: 'ruby' }, { text: 'Python', value: 'python' }, { text: 'Java', value: 'java' }, { text: 'C', value: 'c' }, { text: 'C#', value: 'csharp' }, { text: 'C++', value: 'cpp' }] }; const O = function (e, n) { return x(e).fold(() => n, (e) => { const t = e.className.match(/language-(\w+)/); return t ? t[1] : n }) }; const N = (u = 'function', function (e) { return (function (e) { if (e === null) return 'null'; const t = typeof e; return t === 'object' && Array.prototype.isPrototypeOf(e) ? 'array' : t === 'object' && String.prototype.isPrototypeOf(e) ? 'string' : t }(e)) === u }); const z = (Array.prototype.slice, N(Array.from) && Array.from, function (n) { let e; const t = _(n); const a = (e = t, e.length === 0 ? v.none() : v.some(e[0])).fold(() => '', (e) => e.value); const r = O(n, a); const i = A(n); n.windowManager.open({ title: 'Insert/Edit Code Sample', size: 'large', body: { type: 'panel', items: [{ type: 'selectbox', name: 'language', label: 'Language', items: t }, { type: 'textarea', name: 'code', flex: !0, label: 'Code view' }] }, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: { language: r, code: i }, onSubmit(e) { const t = e.getData(); S(n, t.language, t.code), e.close() } }) }); const P = function (t) { t.addCommand('codesample', () => { const e = t.selection.getNode(); t.selection.isCollapsed() || g.isCodeSample(e) ? z(t) : t.formatter.toggle('code') }) }; const W = function (n) { const r = n.$; n.on('PreProcess', (e) => { r('pre[contenteditable=false]', e.node).filter(g.trimArg(g.isCodeSample)).each((e, t) => { const n = r(t); const a = t.textContent; n.attr('class', r.trim(n.attr('class'))), n.removeAttr('contentEditable'), n.empty().append(r('<code></code>').each(function () { this.textContent = a })) }) }), n.on('SetContent', () => { const e = r('pre').filter(g.trimArg(g.isCodeSample)).filter((e, t) => t.contentEditable !== 'false'); e.length && n.undoManager.transact(() => { e.each((e, t) => { r(t).find('br').each((e, t) => { t.parentNode.replaceChild(n.getDoc().createTextNode('\n'), t) }), t.contentEditable = !1, t.innerHTML = n.dom.encode(t.textContent), i.highlightElement(t), t.className = r.trim(t.className) }) }) }) }; const j = function (e) { e.ui.registry.addButton('codesample', { icon: 'code-sample', tooltip: 'Insert/edit code sample', onAction() { return z(e) } }), e.ui.registry.addMenuItem('codesample', { text: 'Code sample...', icon: 'code-sample', onAction() { return z(e) } }) }; e.add('codesample', (t, e) => { W(t), j(t), P(t), t.on('dblclick', (e) => { g.isCodeSample(e.target) && z(t) }) }), function M() {}
}())
