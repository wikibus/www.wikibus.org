!(function () {
  var a = function (e) { let t = e; const n = function () { return t }; return { get: n, set(e) { t = e }, clone() { return a(n()) } } }; const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const c = function (e) { return !(!/(^|[ ,])tinymcespellchecker([, ]|$)/.test(e.settings.plugins) || !t.get('tinymcespellchecker') || (typeof window.console !== 'undefined' && window.console.log && window.console.log("Spell Checker Pro is incompatible with Spell Checker plugin! Remove 'spellchecker' from the 'plugins' option."), 0)) }; const f = function (e) { return e.getParam('spellchecker_languages', 'English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr_FR,German=de,Italian=it,Polish=pl,Portuguese=pt_BR,Spanish=es,Swedish=sv') }; const s = function (e) { const t = e.getParam('language', 'en'); return e.getParam('spellchecker_language', t) }; const d = function (e) { return e.getParam('spellchecker_rpc_url') }; const g = function (e) { return e.getParam('spellchecker_callback') }; const l = function (e) { const t = new RegExp('[^\\s!"#$%&()*+,-./:;<=>?@[\\]^_{|}`\xa7\xa9\xab\xae\xb1\xb6\xb7\xb8\xbb\xbc\xbd\xbe\xbf\xd7\xf7\xa4\u201d\u201c\u201e\xa0\u2002\u2003\u2009]+', 'g'); return e.getParam('spellchecker_wordchar_pattern', t) }; const N = tinymce.util.Tools.resolve('tinymce.util.Tools'); const h = tinymce.util.Tools.resolve('tinymce.util.URI'); const p = tinymce.util.Tools.resolve('tinymce.util.XHR'); const u = function (e) { return e.fire('SpellcheckStart') }; const o = function (e) { return e.fire('SpellcheckEnd') }; function b(e) { return e && e.nodeType === 1 && e.contentEditable === 'false' } let m; const r = function (a, r) { let n; let o; let g; let h; let p; let i = []; const v = r.dom; function c(e, t) { if (!e[0]) throw new Error('findAndReplaceDOMText cannot handle zero-length matches'); return { start: e.index, end: e.index + e[0].length, text: e[0], data: t } } function s(e) { const t = a.getElementsByTagName('*'); const n = []; e = typeof e === 'number' ? `${e}` : null; for (let r = 0; r < t.length; r++) { const o = t[r]; const i = o.getAttribute('data-mce-index'); i !== null && i.length && o.className.indexOf('mce-spellchecker-word') !== -1 && (i !== e && e !== null || n.push(o)) } return n } function l(e) { for (let t = i.length; t--;) if (i[t] === e) return t; return -1 } function e(e) { for (let t = 0, n = i.length; t < n && !1 !== e(i[t], t); t++);return this } function t(e) { let t; let n; const r = s(e ? l(e) : null); for (t = r.length; t--;)(n = r[t]).parentNode.insertBefore(n.firstChild, n), n.parentNode.removeChild(n); return this } function u(e) { const t = s(l(e)); const n = r.dom.createRng(); return n.setStartBefore(t[0]), n.setEndAfter(t[t.length - 1]), n } return g = r.schema.getBlockElements(), h = r.schema.getWhiteSpaceElements(), p = r.schema.getShortEndedElements(), { text: o = (function d(e) { let t; if (e.nodeType === 3) return e.data; if (h[e.nodeName] && !g[e.nodeName]) return ''; if (b(e)) return '\n'; if (t = '', (g[e.nodeName] || p[e.nodeName]) && (t += '\n'), e = e.firstChild) for (;t += d(e), e = e.nextSibling;);return t }(a)), matches: i, each: e, filter: function f(n) { const r = []; return e((e, t) => { n(e, t) && r.push(e) }), i = r, this }, reset: function m() { return i.splice(0, i.length), t(), this }, matchFromElement: function x(e) { return i[e.getAttribute('data-mce-index')] }, elementFromMatch: function k(e) { return s(l(e))[0] }, find: function N(e, t) { if (o && e.global) for (;n = e.exec(o);)i.push(c(n, t)); return this }, add: function y(e, t, n) { return i.push({ start: e, end: e + t, text: o.substr(e, t), data: n }), this }, wrap: function S(e) { return i.length && (function f(e, t, n) { let r; let o; let i; let a; let c; let s = []; let l = 0; let u = e; let d = 0; (t = t.slice(0)).sort((e, t) => e.start - t.start), c = t.shift(); e:for (;;) { if ((g[u.nodeName] || p[u.nodeName] || b(u)) && l++, u.nodeType === 3 && (!o && u.length + l >= c.end ? (o = u, a = c.end - l) : r && s.push(u), !r && u.length + l > c.start && (r = u, i = c.start - l), l += u.length), r && o) { if (u = n({ startNode: r, startNodeIndex: i, endNode: o, endNodeIndex: a, innerNodes: s, match: c.text, matchIndex: d }), l -= o.length - a, o = r = null, s = [], d++, !(c = t.shift())) break } else if (h[u.nodeName] && !g[u.nodeName] || !u.firstChild) { if (u.nextSibling) { u = u.nextSibling; continue } } else if (!b(u)) { u = u.firstChild; continue } for (;;) { if (u.nextSibling) { u = u.nextSibling; break } if (u.parentNode === e) break e; u = u.parentNode } } }(a, i, (function t(o) { function m(e, t) { const n = i[t]; n.stencil || (n.stencil = o(n)); const r = n.stencil.cloneNode(!1); return r.setAttribute('data-mce-index', t), e && r.appendChild(v.doc.createTextNode(e)), r } return function (e) { let t; let n; let r; const o = e.startNode; const i = e.endNode; const a = e.matchIndex; const c = v.doc; if (o === i) { const s = o; r = s.parentNode, e.startNodeIndex > 0 && (t = c.createTextNode(s.data.substring(0, e.startNodeIndex)), r.insertBefore(t, s)); const l = m(e.match, a); return r.insertBefore(l, s), e.endNodeIndex < s.length && (n = c.createTextNode(s.data.substring(e.endNodeIndex)), r.insertBefore(n, s)), s.parentNode.removeChild(s), l }t = c.createTextNode(o.data.substring(0, e.startNodeIndex)), n = c.createTextNode(i.data.substring(e.endNodeIndex)); for (var u = m(o.data.substring(e.startNodeIndex), a), d = 0, f = e.innerNodes.length; d < f; ++d) { const g = e.innerNodes[d]; const h = m(g.data, a); g.parentNode.replaceChild(h, g) } const p = m(i.data.substring(0, e.endNodeIndex), a); return (r = o.parentNode).insertBefore(t, o), r.insertBefore(u, o), r.removeChild(o), (r = i.parentNode).insertBefore(p, i), r.insertBefore(n, i), r.removeChild(i), p } }(e)))), this }, unwrap: t, replace: function w(e, t) { const n = u(e); return n.deleteContents(), t.length > 0 && n.insertNode(r.dom.doc.createTextNode(t)), n }, rangeFromMatch: u, indexOf: l } }; const v = function (e, t) { if (!t.get()) { const n = r(e.getBody(), e); t.set(n) } return t.get() }; const x = function (e, t, n, r, o, i, a) { let c; let s; let l; const u = g(e); (u || (c = e, s = t, l = n, function (e, t, n, r) { const o = { method: e, lang: l.get() }; let i = ''; o[e === 'addToDictionary' ? 'word' : 'text'] = t, N.each(o, (e, t) => { i && (i += '&'), i += `${t}=${encodeURIComponent(e)}` }), p.send({ url: new h(s).toAbsolute(d(c)), type: 'post', content_type: 'application/x-www-form-urlencoded', data: i, success(e) { if (e = JSON.parse(e))e.error ? r(e.error) : n(e); else { const t = c.translate("Server response wasn't proper JSON."); r(t) } }, error() { const e = c.translate('The spelling service was not found: (') + d(c) + c.translate(')'); r(e) } }) })).call(e.plugins.spellchecker, r, o, i, a) }; const k = function (e, t, n) { e.dom.select('span.mce-spellchecker-word').length || y(e, t, n) }; var y = function (e, t, n) { const r = e.selection.getBookmark(); if (v(e, n).reset(), e.selection.moveToBookmark(r), n.set(null), t.get()) return t.set(!1), o(e), !0 }; const S = function (e) { const t = e.getAttribute('data-mce-index'); return typeof t === 'number' ? `${t}` : t }; const w = function (t, e, n, r, o) { const i = !!o.dictionary; const a = o.words; if (t.setProgressState(!1), (function (e) { for (const t in e) return !1; return !0 }(a))) { const c = t.translate('No misspellings found.'); return t.notificationManager.open({ text: c, type: 'info' }), void e.set(!1) }r.set({ suggestions: a, hasDictionarySupport: i }); const s = t.selection.getBookmark(); v(t, n).find(l(t)).filter((e) => !!a[e.text]).wrap((e) => t.dom.create('span', { class: 'mce-spellchecker-word', 'aria-invalid': 'spelling', 'data-mce-bogus': 1, 'data-mce-word': e.text })), t.selection.moveToBookmark(s), e.set(!0), u(t) }; const T = { spellcheck(t, e, n, r, o, i) { y(t, n, r) || (t.setProgressState(!0), x(t, e, i, 'spellcheck', v(t, r).text, (e) => { w(t, n, r, o, e) }, (e) => { t.notificationManager.open({ text: e, type: 'error' }), t.setProgressState(!1), y(t, n, r) }), t.focus()) }, checkIfFinished: k, addToDictionary(t, e, n, r, o, i, a) { t.setProgressState(!0), x(t, e, o, 'addToDictionary', i, () => { t.setProgressState(!1), t.dom.remove(a, !0), k(t, n, r) }, (e) => { t.notificationManager.open({ text: e, type: 'error' }), t.setProgressState(!1) }) }, ignoreWord(t, e, n, r, o, i) { t.selection.collapse(), i ? N.each(t.dom.select('span.mce-spellchecker-word'), (e) => { e.getAttribute('data-mce-word') === r && t.dom.remove(e, !0) }) : t.dom.remove(o, !0), k(t, e, n) }, findSpansByIndex(e, t) { let n; const r = []; if ((n = N.toArray(e.getBody().getElementsByTagName('span'))).length) for (let o = 0; o < n.length; o++) { const i = S(n[o]); i !== null && i.length && i === t.toString() && r.push(n[o]) } return r }, getElmIndex: S, markErrors: w }; const I = function (t, n, r, o, e, i) { return { getTextMatcher() { return o.get() }, getWordCharPattern() { return l(t) }, markErrors(e) { T.markErrors(t, n, o, r, e) }, getLanguage() { return e.get() } } }; const A = function (e, t, n, r, o, i) { e.addCommand('mceSpellCheck', () => { T.spellcheck(e, t, n, r, o, i) }) }; const B = Object.prototype.hasOwnProperty; const E = (m = function (e, t) { return t }, function () { for (var e = new Array(arguments.length), t = 0; t < e.length; t++)e[t] = arguments[t]; if (e.length === 0) throw new Error("Can't merge zero objects"); for (var n = {}, r = 0; r < e.length; r++) { const o = e[r]; for (const i in o)B.call(o, i) && (n[i] = m(n[i], o[i])) } return n }); const C = 'SpellcheckStart SpellcheckEnd'; const P = function (n, e, r, t, o, i) { let a; let c; let s; const l = (s = n, a = N.map(f(s).split(','), (e) => ({ name: (e = e.split('='))[0], value: e[1] })), c = [], N.each(a, (e) => { c.push({ selectable: !0, text: e.name, data: e.value }) }), c); const u = function () { T.spellcheck(n, e, r, t, i, o) }; const d = { tooltip: 'Spellcheck', onAction: u, icon: 'spell-check', onSetup(e) { const t = function () { e.setActive(r.get()) }; return n.on(C, t), function () { n.off(C, t) } } }; n.ui.registry.addButton('spellchecker', E(d, l.length > 1 ? { type: 'splitbutton', menu: l, select(e) { return e === o.get() }, fetch(e) { e(N.map(l, (e) => ({ type: 'choiceitem', value: e.data, text: e.text }))) }, onItemAction(e, t) { o.set(t) } } : { type: 'togglebutton' })), n.ui.registry.addToggleMenuItem('spellchecker', { text: 'Spellcheck', onSetup(e) { e.setActive(r.get()); const t = function () { e.setActive(r.get()) }; return n.on(C, t), function () { n.off(C, t) } }, onAction: u }) }; const R = function (h, p, m, v, x, k) { h.ui.registry.addContextMenu('spellchecker', { update(e) { const t = e; if (t.className !== 'mce-spellchecker-word') return []; let n; let r; let o; let i; let a; let c; let s; let l; let u; let d; const f = T.findSpansByIndex(h, T.getElmIndex(t)); if (f.length > 0) { const g = h.dom.createRng(); return g.setStartBefore(f[0]), g.setEndAfter(f[f.length - 1]), h.selection.setRng(g), n = h, r = p, o = m, i = v, a = x, c = k, s = t.getAttribute('data-mce-word'), l = f, u = [], d = o.get().suggestions[s], N.each(d, (e) => { u.push({ text: e, onAction() { n.insertContent(n.dom.encode(e)), n.dom.remove(l), T.checkIfFinished(n, i, a) } }) }), o.get().hasDictionarySupport && u.push({ text: 'Add to Dictionary', onAction() { T.addToDictionary(n, r, i, a, c, s, l) } }), u.push.apply(u, [{ text: 'Ignore', onAction() { T.ignoreWord(n, i, a, s, l) } }, { text: 'Ignore all', onAction() { T.ignoreWord(n, i, a, s, l, !0) } }]), u } } }) }; t.add('spellchecker', (e, t) => { if (!1 === c(e)) { const n = a(!1); const r = a(s(e)); const o = a(null); const i = a(null); return P(e, t, n, o, r, i), R(e, t, i, n, o, r), A(e, t, n, o, i, r), I(e, n, i, o, r, t) } }), function e() {}
}())
