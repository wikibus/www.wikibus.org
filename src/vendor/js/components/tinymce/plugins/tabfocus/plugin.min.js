!(function () {
  const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const c = tinymce.util.Tools.resolve('tinymce.EditorManager'); const s = tinymce.util.Tools.resolve('tinymce.Env'); const a = tinymce.util.Tools.resolve('tinymce.util.Delay'); const y = tinymce.util.Tools.resolve('tinymce.util.Tools'); const f = tinymce.util.Tools.resolve('tinymce.util.VK'); const d = function (e) { return e.getParam('tab_focus', e.getParam('tabfocus_elements', ':prev,:next')) }; const m = t.DOM; const n = function (e) { e.keyCode !== f.TAB || e.ctrlKey || e.altKey || e.metaKey || e.preventDefault() }; const i = function (r) { function e(n) { let i, o, e, l; if (!(n.keyCode !== f.TAB || n.ctrlKey || n.altKey || n.metaKey || n.isDefaultPrevented()) && ((e = y.explode(d(r))).length === 1 && (e[1] = e[0], e[0] = ':prev'), o = n.shiftKey ? e[0] === ':prev' ? u(-1) : m.get(e[0]) : e[1] === ':next' ? u(1) : m.get(e[1]))) { const t = c.get(o.id || o.name); o.id && t ? t.focus() : a.setTimeout(() => { s.webkit || window.focus(), o.focus() }, 10), n.preventDefault() } function u(e) { function t(e) { return /INPUT|TEXTAREA|BUTTON/.test(e.tagName) && c.get(n.id) && e.tabIndex !== -1 && (function t(e) { return e.nodeName === 'BODY' || e.type !== 'hidden' && e.style.display !== 'none' && e.style.visibility !== 'hidden' && t(e.parentNode) }(e)) } if (o = m.select(':input:enabled,*[tabindex]:not(iframe)'), y.each(o, (e, t) => { if (e.id === r.id) return i = t, !1 }), e > 0) { for (l = i + 1; l < o.length; l++) if (t(o[l])) return o[l] } else for (l = i - 1; l >= 0; l--) if (t(o[l])) return o[l]; return null } }r.on('init', () => { r.inline && m.setAttrib(r.getBody(), 'tabIndex', null), r.on('keyup', n), s.gecko ? r.on('keypress keydown', e) : r.on('keydown', e) }) }; e.add('tabfocus', (e) => { i(e) }), function o() {}
}())
