!(function () {
  let n; let t; let e; let r; let o; const i = tinymce.util.Tools.resolve('tinymce.PluginManager'); const u = function () { for (let n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t] }; const c = function (n) { return function () { return n } }; const a = function (n) { return n }; const l = c(!1); const f = c(!0); const s = l; const d = f; const m = function () { return g }; var g = (r = { fold(n, t) { return n() }, is: s, isSome: s, isNone: d, getOr: e = function (n) { return n }, getOrThunk: t = function (n) { return n() }, getOrDie(n) { throw new Error(n || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: e, orThunk: t, map: m, ap: m, each() {}, bind: m, flatten: m, exists: s, forall: d, filter: m, equals: n = function (n) { return n.isNone() }, equals_: n, toArray() { return [] }, toString: c('none()') }, Object.freeze && Object.freeze(r), r); var y = function (e) { const n = function () { return e }; const t = function () { return o }; const r = function (n) { return n(e) }; var o = { fold(n, t) { return t(e) }, is(n) { return e === n }, isSome: d, isNone: s, getOr: n, getOrThunk: n, getOrDie: n, getOrNull: n, getOrUndefined: n, or: t, orThunk: t, map(n) { return y(n(e)) }, ap(n) { return n.fold(m, (n) => y(n(e))) }, each(n) { n(e) }, bind: r, flatten: n, exists: r, forall: r, filter(n) { return n(e) ? o : g }, equals(n) { return n.is(e) }, equals_(n, t) { return n.fold(s, (n) => t(e, n)) }, toArray() { return [e] }, toString() { return `some(${e})` } }; return o }; const p = { some: y, none: m, from(n) { return n === null || n === undefined ? g : y(n) } }; const h = (o = 'function', function (n) { return (function (n) { if (n === null) return 'null'; const t = typeof n; return t === 'object' && Array.prototype.isPrototypeOf(n) ? 'array' : t === 'object' && String.prototype.isPrototypeOf(n) ? 'string' : t }(n)) === o }); const v = function (n, t) { for (let e = 0, r = n.length; e < r; e++) if (t(n[e], e, n)) return p.some(e); return p.none() }; const O = (Array.prototype.slice, h(Array.from) && Array.from, function (n, t, e) { for (var r, o = [], i = e.fold(() => l, (t) => function (n) { return t <= n }), u = 0; u < n.length && (!(t.length === 0 || n[u].title.indexOf(t) > -1 || (r = n[u].keywords, v(r, (n) => n.indexOf(t) > -1).isSome())) || (o.push({ value: n[u].char, text: n[u].title, icon: n[u].char }), !i(o.length))); u++);return o }); const b = function (n, t) { return n.startOffset === 0 || /\s/.test(t.charAt(n.startOffset - 1)) }; var w = function (n) { let t = n; const e = function () { return t }; return { get: e, set(n) { t = n }, clone() { return w(e()) } } }; const A = typeof window !== 'undefined' ? window : Function('return this;')(); const k = Object.keys; const T = Object.hasOwnProperty; var C = function (e) { return { is(n) { return e === n }, isValue: f, isError: l, getOr: c(e), getOrThunk: c(e), getOrDie: c(e), or(n) { return C(e) }, orThunk(n) { return C(e) }, fold(n, t) { return t(e) }, map(n) { return C(n(e)) }, mapError(n) { return C(e) }, each(n) { n(e) }, bind(n) { return n(e) }, exists(n) { return n(e) }, forall(n) { return n(e) }, toOption() { return p.some(e) } } }; var j = function (e) { return { is: l, isValue: l, isError: f, getOr: a, getOrThunk(n) { return n() }, getOrDie() { return n = String(e), (function () { throw new Error(n) }()); let n }, or(n) { return n }, orThunk(n) { return n() }, fold(n, t) { return n(e) }, map(n) { return j(e) }, mapError(n) { return j(n(e)) }, each: u, bind(n) { return j(e) }, exists: l, forall: f, toOption: p.none } }; const S = { value: C, error: j }; const x = tinymce.util.Tools.resolve('tinymce.dom.ScriptLoader'); const _ = tinymce.util.Tools.resolve('tinymce.util.Promise'); const L = 'All'; const D = { symbols: 'Symbols', people: 'People', animals_and_nature: 'Animals and Nature', food_and_drink: 'Food and Drink', activity: 'Activity', travel_and_places: 'Travel and Places', objects: 'Objects', flags: 'Flags' }; const E = 'emoticons_plugin_database'; const P = function (n) { return t = D, e = n, T.call(t, e) ? D[n] : n; let t, e }; const F = function (n, u) { const e = w(p.none()); const t = w(p.none()); n.on('init', () => { x.ScriptLoader.loadScript(u, () => { const o = {}; const i = []; (function (n) { if (A.tinymce[E]) { const t = S.value(A.tinymce[E]); return delete A.tinymce[E], t } return S.error(`URL ${n} did not contain the expected format for emoticons`) })(u).fold((n) => { console.log(n), e.set(p.some({})), t.set(p.some([])) }, (n) => { !(function (n, t) { for (let e = k(n), r = 0, o = e.length; r < o; r++) { const i = e[r]; t(n[i], i, n) } }(n, (n, t) => { const e = { title: t, keywords: n.keywords, char: n.char, category: P(n.category) }; const r = o[e.category] !== undefined ? o[e.category] : []; o[e.category] = r.concat([e]), i.push(e) })), e.set(p.some(o)), t.set(p.some(i)) }) }, () => {}) }); const r = function () { return t.get().getOr([]) }; const o = function () { return e.get().isSome() && t.get().isSome() }; return { listCategories() { return [L].concat(k(e.get().getOr({}))) }, hasLoaded: o, waitForLoad() { return o() ? _.resolve(!0) : new _((n, t) => { let e = 3; var r = setInterval(() => { o() ? (clearInterval(r), n(!0)) : --e < 0 && (console.log(`Could not load emojis from url: ${u}`), clearInterval(r), t(!1)) }, 500) }) }, listAll: r, listCategory(t) { return t === L ? r() : e.get().bind((n) => p.from(n[t])).getOr([]) } } }; const N = 'pattern'; const q = function (o, c) { let e; let r; let i; const n = { pattern: '', results: O(c.listAll(), '', p.some(50)) }; const u = (e = function (n) { let t; let e; let r; let o; let i; const u = a.get(); e = u, r = (t = n).getData(), o = c.listCategory(e), i = O(o, r[N].toLowerCase(), e === L ? p.some(50) : p.none()), t.setData({ results: i }) }, r = 200, i = null, { cancel() { i !== null && (clearTimeout(i), i = null) }, throttle() { for (var n = [], t = 0; t < arguments.length; t++)n[t] = arguments[t]; i !== null && clearTimeout(i), i = setTimeout(() => { e.apply(null, n), i = null }, r) } }); var a = w(L); const t = { label: 'Search', type: 'input', name: N }; const l = { type: 'collection', name: 'results', columns: 'auto' }; const f = function () { return { title: 'Emoticons', size: 'normal', body: { type: 'tabpanel', tabs: (function (n, t) { for (var e = n.length, r = new Array(e), o = 0; o < e; o++) { const i = n[o]; r[o] = t(i, o, n) } return r }(c.listCategories(), (n) => ({ title: n, items: [t, l] }))) }, initialData: n, onTabChange(n, t) { a.set(t), u.throttle(n) }, onChange: u.throttle, onAction(n, t) { let e, r; t.name === 'results' && (e = o, r = t.value, e.insertContent(r), n.close()) }, buttons: [{ type: 'cancel', text: 'Close' }] } }; const s = o.windowManager.open(f()); s.focus(N), c.hasLoaded() || (s.block('Loading emoticons...'), c.waitForLoad().then(() => { s.redial(f()), u.throttle(s), s.focus(N), s.unblock() }).catch((n) => { s.redial({ title: 'Emoticons', body: { type: 'panel', items: [{ type: 'alertbanner', level: 'error', icon: 'warning', text: '<p>Could not load emoticons</p>' }] }, buttons: [{ type: 'cancel', text: 'Close' }], initialData: { pattern: '', results: [] } }), s.focus(N), s.unblock() })) }; const I = function (n, t) { const e = function () { return q(n, t) }; n.ui.registry.addButton('emoticons', { tooltip: 'Emoticons', icon: 'emoji', onAction: e }), n.ui.registry.addMenuItem('emoticons', { text: 'Emoticons...', icon: 'emoji', onAction: e }) }; const z = function (n, t) { return n.getParam('emoticons_database_url', `${t}/js/emojis${n.suffix}.js`) }; i.add('emoticons', (n, t) => { let r; let o; const e = z(n, t); const i = F(n, e); I(n, i), o = i, (r = n).ui.registry.addAutocompleter('emoticons', { ch: ':', columns: 'auto', minChars: 2, matches: b, fetch(t, e) { return o.waitForLoad().then(() => { const n = o.listAll(); return O(n, t.toLowerCase(), p.some(e)) }) }, onAction(n, t, e) { r.selection.setRng(t), r.insertContent(e), n.hide() } }) }), function M() {}
}())
