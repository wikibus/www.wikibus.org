!(function () {
  const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const c = tinymce.util.Tools.resolve('tinymce.util.Tools'); const n = function (t, n) { let e; const i = t.dom; const o = t.selection.getSelectedBlocks(); o.length && (e = i.getAttrib(o[0], 'dir'), c.each(o, (t) => { i.getParent(t.parentNode, `*[dir="${n}"]`, i.getRoot()) || i.setAttrib(t, 'dir', e !== n ? n : null) }), t.nodeChanged()) }; const e = function (t) { t.addCommand('mceDirectionLTR', () => { n(t, 'ltr') }), t.addCommand('mceDirectionRTL', () => { n(t, 'rtl') }) }; const i = function (n) { const e = []; return c.each('h1 h2 h3 h4 h5 h6 div p'.split(' '), (t) => { e.push(`${t}[dir=${n}]`) }), e.join(',') }; const o = function (n) { n.ui.registry.addToggleButton('ltr', { tooltip: 'Left to right', icon: 'ltr', onAction() { return n.execCommand('mceDirectionLTR') }, onSetup(t) { return n.selection.selectorChangedWithUnbind(i('ltr'), t.setActive).unbind } }), n.ui.registry.addToggleButton('rtl', { tooltip: 'Right to left', icon: 'rtl', onAction() { return n.execCommand('mceDirectionRTL') }, onSetup(t) { return n.selection.selectorChangedWithUnbind(i('rtl'), t.setActive).unbind } }) }; t.add('directionality', (t) => { e(t), o(t) }), function r() {}
}())
