!(function () {
  let e; let n; const t = tinymce.util.Tools.resolve('tinymce.PluginManager'); const s = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const f = tinymce.util.Tools.resolve('tinymce.util.I18n'); const i = tinymce.util.Tools.resolve('tinymce.util.Tools'); const a = function (t) { return t.getParam('toc_class', 'mce-toc') }; const m = function (t) { const e = t.getParam('toc_header', 'h2'); return /^h[1-6]$/.test(e) ? e : 'h2' }; const c = function (t) { const e = parseInt(t.getParam('toc_depth', '3'), 10); return e >= 1 && e <= 9 ? e : 3 }; const l = (e = 'mcetoc_', n = 0, function () { const t = (new Date()).getTime().toString(32); return e + t + (n++).toString(32) }); const u = function u(t) { let e; const n = []; for (e = 1; e <= t; e++)n.push(`h${e}`); return n.join(',') }; const v = function (n) { const o = a(n); const t = m(n); const e = u(c(n)); let r = n.$(e); return r.length && /^h[1-9]$/i.test(t) && (r = r.filter((t, e) => !n.dom.hasClass(e.parentNode, o))), i.map(r, (t) => ({ id: t.id ? t.id : l(), level: parseInt(t.nodeName.replace(/^H/i, ''), 10), title: n.$.text(t), element: t })) }; const d = function (t) { let e; let n; let o; let r; let i; let c; let a; let l = ''; const u = v(t); let d = (function (t) { let e; let n = 9; for (e = 0; e < t.length; e++) if (t[e].level < n && (n = t[e].level), n === 1) return n; return n }(u)) - 1; if (!u.length) return ''; for (l += (i = m(t), c = f.translate('Table of Contents'), a = `</${i}>`, `<${i} contenteditable="true">${s.DOM.encode(c)}${a}`), e = 0; e < u.length; e++) { if ((o = u[e]).element.id = o.id, r = u[e + 1] && u[e + 1].level, d === o.level)l += '<li>'; else for (n = d; n < o.level; n++)l += '<ul><li>'; if (l += `<a href="#${o.id}">${o.title}</a>`, r !== o.level && r) for (n = o.level; r < n; n--)l += '</li></ul><li>'; else l += '</li>', r || (l += '</ul>'); d = o.level } return l }; const g = function (t) { const e = a(t); const n = t.$(`.${e}`); n.length && t.undoManager.transact(() => { n.html(d(t)) }) }; const o = { hasHeaders(t) { return v(t).length > 0 }, insertToc(t) { let e; let n; let o; let r; const i = a(t); const c = t.$(`.${i}`); o = t, !(r = c).length || o.dom.getParents(r[0], '.mce-offscreen-selection').length > 0 ? t.insertContent((n = d(e = t), `<div class="${e.dom.encode(a(e))}" contenteditable="false">${n}</div>`)) : g(t) }, updateToc: g }; const r = function (t) { t.addCommand('mceInsertToc', () => { o.insertToc(t) }), t.addCommand('mceUpdateToc', () => { o.updateToc(t) }) }; const h = function (t) { const n = t.$; const o = a(t); t.on('PreProcess', (t) => { const e = n(`.${o}`, t.node); e.length && (e.removeAttr('contentEditable'), e.find('[contenteditable]').removeAttr('contentEditable')) }), t.on('SetContent', () => { const t = n(`.${o}`); t.length && (t.attr('contentEditable', !1), t.children(':first-child').attr('contentEditable', !0)) }) }; const p = function (n) { return function (t) { const e = function () { return t.setDisabled(n.readonly || !o.hasHeaders(n)) }; return e(), n.on('LoadContent SetContent change', e), function () { return n.on('LoadContent SetContent change', e) } } }; const T = function (t) { let e; t.ui.registry.addButton('toc', { icon: 'toc', tooltip: 'Table of contents', onAction() { return t.execCommand('mceInsertToc') }, onSetup: p(t) }), t.ui.registry.addButton('tocupdate', { icon: 'reload', tooltip: 'Update', onAction() { return t.execCommand('mceUpdateToc') } }), t.ui.registry.addMenuItem('toc', { icon: 'toc', text: 'Table of contents', onAction() { return t.execCommand('mceInsertToc') }, onSetup: p(t) }), t.ui.registry.addContextToolbar('toc', { items: 'tocupdate', predicate: (e = t, function (t) { return t && e.dom.is(t, `.${a(e)}`) && e.getBody().contains(t) }), scope: 'node', position: 'node' }) }; t.add('toc', (t) => { r(t), T(t), h(t) }), function y() {}
}())
