!(function () {
  let e; let n; let r; let t; const o = tinymce.util.Tools.resolve('tinymce.PluginManager'); let s = 0; const i = function (e, n, r) { let t, o, i; e.plugins.table ? e.plugins.table.insertTable(n, r) : (o = n, i = r, (t = e).undoManager.transact(() => { let e, n; t.insertContent(function (e, n) { let r, t, o; for (o = '<table data-mce-id="mce" style="width: 100%">', o += '<tbody>', t = 0; t < n; t++) { for (o += '<tr>', r = 0; r < e; r++)o += '<td><br></td>'; o += '</tr>' } return o += '</tbody>', o += '</table>' }(o, i)), (e = t.dom.select('*[data-mce-id]')[0]).removeAttribute('data-mce-id'), n = t.dom.select('td,th', e), t.selection.setCursorLocation(n[0], 0) })) }; const u = function (e, n, r) { let t, o, i, u; o = (t = e.editorUpload.blobCache).create((i = 'mceu', u = (new Date()).getTime(), `${i}_${Math.floor(1e9 * Math.random())}${++s}${String(u)}`), r, n), t.add(o), e.insertContent(e.dom.createHTML('img', { src: o.blobUri() })) }; const a = typeof window !== 'undefined' ? window : Function('return this;')(); const c = function (e, n) { return (function (e, n) { for (var r = n !== undefined && n !== null ? n : a, t = 0; t < e.length && r !== undefined && r !== null; ++t)r = r[e[t]]; return r }(e.split('.'), n)) }; const f = function (e, n) { const r = c(e, n); if (r === undefined || r === null) throw `${e} not available on this browser`; return r }; const d = tinymce.util.Tools.resolve('tinymce.util.Promise'); const l = function (t) { return new d((e) => { const n = (function r() { return new (f('FileReader'))() }()); n.onloadend = function () { e(n.result.split(',')[1]) }, n.readAsDataURL(t) }) }; const m = function () { return new d((n) => { let e; (e = document.createElement('input')).type = 'file', e.style.position = 'fixed', e.style.left = 0, e.style.top = 0, e.style.opacity = 0.001, document.body.appendChild(e), e.onchange = function (e) { n(Array.prototype.slice.call(e.target.files)) }, e.click(), e.parentNode.removeChild(e) }) }; const v = function (r) { r.ui.registry.addButton('quickimage', { icon: 'image', tooltip: 'Insert image', onAction() { m().then((e) => { const n = e[0]; l(n).then((e) => { u(r, e, n) }) }) } }), r.ui.registry.addButton('quicktable', { icon: 'table', tooltip: 'Insert table', onAction() { i(r, 2, 2) } }) }; const h = function (e) { return function () { return e } }; const g = h(!1); const p = h(!0); const b = g; const O = p; const N = function () { return T }; var T = (t = { fold(e, n) { return e() }, is: b, isSome: b, isNone: O, getOr: r = function (e) { return e }, getOrThunk: n = function (e) { return e() }, getOrDie(e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: r, orThunk: n, map: N, ap: N, each() {}, bind: N, flatten: N, exists: b, forall: O, filter: N, equals: e = function (e) { return e.isNone() }, equals_: e, toArray() { return [] }, toString: h('none()') }, Object.freeze && Object.freeze(t), t); var w = function (r) { const e = function () { return r }; const n = function () { return o }; const t = function (e) { return e(r) }; var o = { fold(e, n) { return n(r) }, is(e) { return r === e }, isSome: O, isNone: b, getOr: e, getOrThunk: e, getOrDie: e, getOrNull: e, getOrUndefined: e, or: n, orThunk: n, map(e) { return w(e(r)) }, ap(e) { return e.fold(N, (e) => w(e(r))) }, each(e) { e(r) }, bind: t, flatten: e, exists: t, forall: t, filter(e) { return e(r) ? o : T }, equals(e) { return e.is(r) }, equals_(e, n) { return e.fold(b, (e) => n(r, e)) }, toArray() { return [r] }, toString() { return `some(${r})` } }; return o }; const E = { some: w, none: N, from(e) { return e === null || e === undefined ? T : w(e) } }; const y = function (e) { if (e === null || e === undefined) throw new Error('Node cannot be null or undefined'); return { dom: h(e) } }; const S = { fromHtml(e, n) { const r = (n || document).createElement('div'); if (r.innerHTML = e, !r.hasChildNodes() || r.childNodes.length > 1) throw console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node'); return y(r.childNodes[0]) }, fromTag(e, n) { const r = (n || document).createElement(e); return y(r) }, fromText(e, n) { const r = (n || document).createTextNode(e); return y(r) }, fromDom: y, fromPoint(e, n, r) { const t = e.dom(); return E.from(t.elementFromPoint(n, r)).map(y) } }; const x = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE); const k = (Node.TEXT_NODE, Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, function (n) { return function (e) { return (function (e) { if (e === null) return 'null'; const n = typeof e; return n === 'object' && Array.prototype.isPrototypeOf(e) ? 'array' : n === 'object' && String.prototype.isPrototypeOf(e) ? 'string' : n }(e)) === n } }); const C = k('string'); const D = k('object'); const _ = k('array'); const A = k('boolean'); const R = k('undefined'); const M = k('function'); Array.prototype.slice; function I(e, n, r, t, o) { return e(r, t) ? E.some(r) : M(o) && o(r) ? E.none() : n(r, t, o) }M(Array.from) && Array.from; let q; let L; let U; let F; const B = function (e, n) { const r = (function (e, n) { for (let r = 0; r < e.length; r++) { const t = e[r]; if (t.test(n)) return t } return undefined }(e, n)); if (!r) return { major: 0, minor: 0 }; const t = function (e) { return Number(n.replace(r, `$${e}`)) }; return j(t(1), t(2)) }; const P = function () { return j(0, 0) }; var j = function (e, n) { return { major: e, minor: n } }; const H = { nu: j, detect(e, n) { const r = String(n).toLowerCase(); return e.length === 0 ? P() : B(e, r) }, unknown: P }; const W = 'Firefox'; const X = function (e, n) { return function () { return n === e } }; const z = function (e) { const n = e.current; return { current: n, version: e.version, isEdge: X('Edge', n), isChrome: X('Chrome', n), isIE: X('IE', n), isOpera: X('Opera', n), isFirefox: X(W, n), isSafari: X('Safari', n) } }; const Y = { unknown() { return z({ current: undefined, version: H.unknown() }) }, nu: z, edge: h('Edge'), chrome: h('Chrome'), ie: h('IE'), opera: h('Opera'), firefox: h(W), safari: h('Safari') }; const G = 'Windows'; const $ = 'Android'; const V = 'Solaris'; const J = 'FreeBSD'; const K = function (e, n) { return function () { return n === e } }; const Q = function (e) { const n = e.current; return { current: n, version: e.version, isWindows: K(G, n), isiOS: K('iOS', n), isAndroid: K($, n), isOSX: K('OSX', n), isLinux: K('Linux', n), isSolaris: K(V, n), isFreeBSD: K(J, n) } }; const Z = { unknown() { return Q({ current: undefined, version: H.unknown() }) }, nu: Q, windows: h(G), ios: h('iOS'), android: h($), linux: h('Linux'), osx: h('OSX'), solaris: h(V), freebsd: h(J) }; const ee = function (e, n) { const r = String(n).toLowerCase(); return (function (e, n) { for (let r = 0, t = e.length; r < t; r++) { const o = e[r]; if (n(o, r, e)) return E.some(o) } return E.none() }(e, (e) => e.search(r))) }; const ne = function (e, r) { return ee(e, r).map((e) => { const n = H.detect(e.versionRegexes, r); return { current: e.name, version: n } }) }; const re = function (e, r) { return ee(e, r).map((e) => { const n = H.detect(e.versionRegexes, r); return { current: e.name, version: n } }) }; const te = function (e, n) { return e.indexOf(n) !== -1 }; const oe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const ie = function (n) { return function (e) { return te(e, n) } }; const ue = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search(e) { return te(e, 'edge/') && te(e, 'chrome') && te(e, 'safari') && te(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, oe], search(e) { return te(e, 'chrome') && !te(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search(e) { return te(e, 'msie') || te(e, 'trident') } }, { name: 'Opera', versionRegexes: [oe, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: ie('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: ie('firefox') }, { name: 'Safari', versionRegexes: [oe, /.*?cpu os ([0-9]+)_([0-9]+).*/], search(e) { return (te(e, 'safari') || te(e, 'mobile/')) && te(e, 'applewebkit') } }]; const se = [{ name: 'Windows', search: ie('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search(e) { return te(e, 'iphone') || te(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: ie('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: ie('os x'), versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: ie('linux'), versionRegexes: [] }, { name: 'Solaris', search: ie('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: ie('freebsd'), versionRegexes: [] }]; const ae = { browsers: h(ue), oses: h(se) }; const ce = function (e) { let n; let r; let t; let o; let i; let u; let s; let a; let c; let f; let d; const l = ae.browsers(); const m = ae.oses(); const v = ne(l, e).fold(Y.unknown, Y.nu); const g = re(m, e).fold(Z.unknown, Z.nu); return { browser: v, os: g, deviceType: (r = v, t = e, o = (n = g).isiOS() && !0 === /ipad/i.test(t), i = n.isiOS() && !o, u = n.isAndroid() && n.version.major === 3, s = n.isAndroid() && n.version.major === 4, a = o || u || s && !0 === /mobile/i.test(t), c = n.isiOS() || n.isAndroid(), f = c && !a, d = r.isSafari() && n.isiOS() && !1 === /safari/i.test(t), { isiPad: h(o), isiPhone: h(i), isTablet: h(a), isPhone: h(f), isTouch: h(c), isAndroid: n.isAndroid, isiOS: n.isiOS, isWebView: h(d) }) } }; const fe = (U = !(q = function () { const e = navigator.userAgent; return ce(e) }), function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; return U || (U = !0, L = q.apply(null, e)), L }); const de = x; const le = function (e, n) { const r = e.dom(); if (r.nodeType !== de) return !1; if (r.matches !== undefined) return r.matches(n); if (r.msMatchesSelector !== undefined) return r.msMatchesSelector(n); if (r.webkitMatchesSelector !== undefined) return r.webkitMatchesSelector(n); if (r.mozMatchesSelector !== undefined) return r.mozMatchesSelector(n); throw new Error('Browser lacks native selectors') }; const me = (fe().browser.isIE(), function (e, n, r) { for (let t = e.dom(), o = M(r) ? r : h(!1); t.parentNode;) { t = t.parentNode; const i = S.fromDom(t); if (n(i)) return E.some(i); if (o(i)) break } return E.none() }); const ve = function (e, n, r) { return me(e, (e) => le(e, n), r) }; const ge = { getToolbarItemsOr: (F = C, function (e, n, r) { const t = n in e.settings ? e.settings[n] : r; return (function (e, n) { if (!n(e)) throw new Error("Default value doesn't match requested type.") }(r, F)), (function (e, n) { if (_(e) || D(e)) throw new Error(`expected a string but found: ${e}`); return R(e) ? n : A(e) ? !1 === e ? '' : n : e }(t, r)) }) }; const he = function (e) { return ge.getToolbarItemsOr(e, 'quickbars_selection_toolbar', 'bold forecolor italic | form:link-form h2 h3 blockquote') }; const pe = function (e) { return ge.getToolbarItemsOr(e, 'quickbars_insert_toolbar', 'quickimage quicktable') }; const be = function (s) { s.ui.registry.addContextToolbar('quickblock', { predicate(e) { let n; let r; let t; const o = S.fromDom(e); const i = s.schema.getTextBlockElements(); const u = function (e) { return e.dom() === s.getBody() }; return (n = o, r = 'table', t = u, I(le, ve, n, r, t)).fold(() => { return (e = o, n = function (e) { return e.dom().nodeName.toLowerCase() in i && s.dom.isEmpty(e.dom()) }, r = u, I((e) => n(e), me, e, n, r)).isSome(); let e, n, r }, () => !1) }, items: pe(s), position: 'line', scope: 'editor' }) }; const Oe = (tinymce.util.Tools.resolve('tinymce.util.Tools'), tinymce.util.Tools.resolve('tinymce.dom.TreeWalker'), tinymce.util.Tools.resolve('tinymce.dom.RangeUtils'), function (e, n) { e.execCommand('FormatBlock', !1, n) }); const Ne = function (t) { for (let e = function (e) { let n; const r = `h${e}`; t.ui.registry.addToggleButton(r, { text: r.toUpperCase(), tooltip: `Heading ${e}`, onSetup(e) { return t.selection.selectorChangedWithUnbind(r, e.setActive).unbind }, onAction: (n = r, function () { Oe(t, n) }) }) }, n = 1; n < 6; n++)e(n) }; const Te = function (n) { n.ui.registry.addContextToolbar('textselection', { predicate(e) { return !n.selection.isCollapsed() }, items: he(n), position: 'selection' }) }; o.add('quickbars', (e) => { v(e), be(e), Ne(e), Te(e) }), function we() {}
}())
