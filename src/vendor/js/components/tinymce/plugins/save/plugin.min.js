!(function () {
  const n = tinymce.util.Tools.resolve('tinymce.PluginManager'); const t = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const o = tinymce.util.Tools.resolve('tinymce.util.Tools'); const a = function (n) { return n.getParam('save_enablewhendirty', !0) }; const i = function (n) { return !!n.getParam('save_onsavecallback') }; const c = function (n) { return !!n.getParam('save_oncancelcallback') }; const r = function (n, e) { n.notificationManager.open({ text: e, type: 'error' }) }; const e = function (n) { let e; if (e = t.DOM.getParent(n.id, 'form'), !a(n) || n.isDirty()) { if (n.save(), i(n)) return n.execCallback('save_onsavecallback', n), void n.nodeChanged(); e ? (n.setDirty(!1), e.onsubmit && !e.onsubmit() || (typeof e.submit === 'function' ? e.submit() : r(n, 'Error: Form submit field collision.')), n.nodeChanged()) : r(n, 'Error: No form element found.') } }; const u = function (n) { const e = o.trim(n.startContent); c(n) ? n.execCallback('save_oncancelcallback', n) : (n.setContent(e), n.undoManager.clear(), n.nodeChanged()) }; const l = function (n) { n.addCommand('mceSave', () => { e(n) }), n.addCommand('mceCancel', () => { u(n) }) }; const d = function (t) { return function (n) { const e = function () { n.setDisabled(a(t) && !t.isDirty()) }; return t.on('nodeChange dirty', e), function () { return t.off('nodeChange dirty', e) } } }; const s = function (n) { n.ui.registry.addButton('save', { icon: 'save', tooltip: 'Save', disabled: !0, onAction() { return n.execCommand('mceSave') }, onSetup: d(n) }), n.ui.registry.addButton('cancel', { icon: 'cancel', tooltip: 'Cancel', disabled: !0, onAction() { return n.execCommand('mceCancel') }, onSetup: d(n) }), n.addShortcut('Meta+S', '', 'mceSave') }; n.add('save', (n) => { s(n), l(n) }), function m() {}
}())
