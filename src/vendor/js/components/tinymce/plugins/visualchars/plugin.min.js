!(function () {
  let n; let e; let r; let t; let o; let u; var i = function (n) { let e = n; const r = function () { return e }; return { get: r, set(n) { e = n }, clone() { return i(r()) } } }; const c = tinymce.util.Tools.resolve('tinymce.PluginManager'); const a = function (n) { return { isEnabled() { return n.get() } } }; const f = function (n, e) { return n.fire('VisualChars', { state: e }) }; const l = { '\xa0': 'nbsp', '\xad': 'shy' }; const s = function (n, e) { let r; let t = ''; for (r in n)t += r; return new RegExp(`[${t}]`, e ? 'g' : '') }; const d = function (n) { let e; let r = ''; for (e in n)r && (r += ','), r += `span.mce-${n[e]}`; return r }; const m = { charMap: l, regExp: s(l), regExpGlobal: s(l, !0), selector: d(l), charMapToRegExp: s, charMapToSelector: d }; const N = function (n) { return function () { return n } }; const g = N(!1); const E = N(!0); const h = g; const p = E; const T = function () { return v }; var v = (t = { fold(n, e) { return n() }, is: h, isSome: h, isNone: p, getOr: r = function (n) { return n }, getOrThunk: e = function (n) { return n() }, getOrDie(n) { throw new Error(n || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: r, orThunk: e, map: T, ap: T, each() {}, bind: T, flatten: T, exists: h, forall: p, filter: T, equals: n = function (n) { return n.isNone() }, equals_: n, toArray() { return [] }, toString: N('none()') }, Object.freeze && Object.freeze(t), t); var O = function (r) { const n = function () { return r }; const e = function () { return o }; const t = function (n) { return n(r) }; var o = { fold(n, e) { return e(r) }, is(n) { return r === n }, isSome: p, isNone: h, getOr: n, getOrThunk: n, getOrDie: n, getOrNull: n, getOrUndefined: n, or: e, orThunk: e, map(n) { return O(n(r)) }, ap(n) { return n.fold(T, (n) => O(n(r))) }, each(n) { n(r) }, bind: t, flatten: n, exists: t, forall: t, filter(n) { return n(r) ? o : v }, equals(n) { return n.is(r) }, equals_(n, e) { return n.fold(h, (n) => e(r, n)) }, toArray() { return [r] }, toString() { return `some(${r})` } }; return o }; const y = function (n) { return n === null || n === undefined ? v : O(n) }; const D = (o = 'function', function (n) { return (function (n) { if (n === null) return 'null'; const e = typeof n; return e === 'object' && Array.prototype.isPrototypeOf(n) ? 'array' : e === 'object' && String.prototype.isPrototypeOf(n) ? 'string' : e }(n)) === o }); const C = function (n, e) { for (let r = 0, t = n.length; r < t; r++)e(n[r], r, n) }; const _ = (Array.prototype.slice, D(Array.from) && Array.from, function (n) { if (n === null || n === undefined) throw new Error('Node cannot be null or undefined'); return { dom: N(n) } }); const M = { fromHtml(n, e) { const r = (e || document).createElement('div'); if (r.innerHTML = n, !r.hasChildNodes() || r.childNodes.length > 1) throw console.error('HTML does not have a single root node', n), new Error('HTML must have a single root node'); return _(r.childNodes[0]) }, fromTag(n, e) { const r = (e || document).createElement(n); return _(r) }, fromText(n, e) { const r = (e || document).createTextNode(n); return _(r) }, fromDom: _, fromPoint(n, e, r) { const t = n.dom(); return y(t.elementFromPoint(e, r)).map(_) } }; const A = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE, Node.TEXT_NODE); const b = (Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, function (n) { return n.dom().nodeValue }); const S = (u = A, function (n) { return n.dom().nodeType === u }); const k = function (n) { return `<span data-mce-bogus="1" class="mce-${m.charMap[n]}">${n}</span>` }; var x = function (n, e) { let r = []; const t = (function (n, e) { for (var r = n.length, t = new Array(r), o = 0; o < r; o++) { const u = n[o]; t[o] = e(u, o, n) } return t }(n.dom().childNodes, M.fromDom)); return C(t, (n) => { e(n) && (r = r.concat([n])), r = r.concat(x(n, e)) }), r }; const w = { isMatch(n) { return S(n) && b(n) !== undefined && m.regExp.test(b(n)) }, filterDescendants: x, findParentElm(n, e) { for (;n.parentNode;) { if (n.parentNode === e) return n; n = n.parentNode } }, replaceWithSpans(n) { return n.replace(m.regExpGlobal, k) } }; const I = function (r, n) { let t; let o; const e = w.filterDescendants(M.fromDom(n), w.isMatch); C(e, (n) => { const e = w.replaceWithSpans(b(n)); for (o = r.dom.create('div', null, e); t = o.lastChild;)r.dom.insertAfter(t, n.dom()); r.dom.remove(n.dom()) }) }; const P = function (e, n) { const r = e.dom.select(m.selector, n); C(r, (n) => { e.dom.remove(n, 1) }) }; const B = I; const R = P; const U = function (n) { const e = n.getBody(); const r = n.selection.getBookmark(); let t = w.findParentElm(n.selection.getNode(), e); t = t !== undefined ? t : e, P(n, t), I(n, t), n.selection.moveToBookmark(r) }; const V = function (n, e) { let r; const t = n.getBody(); const o = n.selection; e.set(!e.get()), f(n, e.get()), r = o.getBookmark(), !0 === e.get() ? B(n, t) : R(n, t), o.moveToBookmark(r) }; const j = function (n, e) { n.addCommand('mceVisualChars', () => { V(n, e) }) }; const q = tinymce.util.Tools.resolve('tinymce.util.Delay'); const G = function (e, r) { const t = q.debounce(() => { U(e) }, 300); !1 !== e.settings.forced_root_block && e.on('keydown', (n) => { !0 === r.get() && (n.keyCode === 13 ? U(e) : t()) }) }; const H = function (r, t) { return function (e) { e.setActive(t.get()); const n = function (n) { return e.setActive(n.state) }; return r.on('VisualChars', n), function () { return r.off('VisualChars', n) } } }; c.add('visualchars', (n) => { let e; let r; const t = i(!1); return j(n, t), r = t, (e = n).ui.registry.addToggleButton('visualchars', { tooltip: 'Show invisible characters', icon: 'paragraph', onAction() { return e.execCommand('mceVisualChars') }, onSetup: H(e, r) }), e.ui.registry.addToggleMenuItem('visualchars', { text: 'Show invisible characters', onAction() { return e.execCommand('mceVisualChars') }, onSetup: H(e, r) }), G(n, t), a(t) }), function L() {}
}())
