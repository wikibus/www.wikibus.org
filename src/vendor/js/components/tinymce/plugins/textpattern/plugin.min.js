!(function () {
  let t; let n; let e; let r; let a; var o = function (t) { let n = t; const e = function () { return n }; return { get: e, set(t) { n = t }, clone() { return o(e()) } } }; const i = tinymce.util.Tools.resolve('tinymce.PluginManager'); const f = function (t) { return function () { return t } }; const u = f(!1); const s = f(!0); const c = u; const l = s; const d = function () { return g }; var g = (r = { fold(t, n) { return t() }, is: c, isSome: c, isNone: l, getOr: e = function (t) { return t }, getOrThunk: n = function (t) { return t() }, getOrDie(t) { throw new Error(t || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: e, orThunk: n, map: d, ap: d, each() {}, bind: d, flatten: d, exists: c, forall: l, filter: d, equals: t = function (t) { return t.isNone() }, equals_: t, toArray() { return [] }, toString: f('none()') }, Object.freeze && Object.freeze(r), r); var m = function (e) { const t = function () { return e }; const n = function () { return a }; const r = function (t) { return t(e) }; var a = { fold(t, n) { return n(e) }, is(t) { return e === t }, isSome: l, isNone: c, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: n, orThunk: n, map(t) { return m(t(e)) }, ap(t) { return t.fold(d, (t) => m(t(e))) }, each(t) { t(e) }, bind: r, flatten: t, exists: r, forall: r, filter(t) { return t(e) ? a : g }, equals(t) { return t.is(e) }, equals_(t, n) { return t.fold(c, (t) => n(e, t)) }, toArray() { return [e] }, toString() { return `some(${e})` } }; return a }; const h = { some: m, none: d, from(t) { return t === null || t === undefined ? g : m(t) } }; const p = (a = 'function', function (t) { return (function (t) { if (t === null) return 'null'; const n = typeof t; return n === 'object' && Array.prototype.isPrototypeOf(t) ? 'array' : n === 'object' && String.prototype.isPrototypeOf(t) ? 'string' : n }(t)) === a }); const v = function (t, n) { for (var e = [], r = 0, a = t.length; r < a; r++) { const o = t[r]; n(o, r, t) && e.push(o) } return e }; const O = Array.prototype.slice; const y = (p(Array.from) && Array.from, Object.hasOwnProperty); const P = function (t, n) { return y.call(t, n) }; const x = function (t) { return P(t, 'start') && P(t, 'end') }; const T = function (t) { return !P(t, 'end') && !P(t, 'replacement') }; const b = function (t) { return P(t, 'replacement') }; const k = function (t) { return n = t, e = function (t, n) { return t.start.length === n.start.length ? 0 : t.start.length > n.start.length ? -1 : 1 }, (r = O.call(n, 0)).sort(e), r; let n, e, r }; const C = function (t) { return { inlinePatterns: k(v(t, x)), blockPatterns: k(v(t, T)), replacementPatterns: v(t, b) } }; const D = function (n) { return { setPatterns(t) { n.set(C(t)) }, getPatterns() { return n.get().inlinePatterns.concat(n.get().blockPatterns, n.get().replacementPatterns) } } }; const S = [{ start: '*', end: '*', format: 'italic' }, { start: '**', end: '**', format: 'bold' }, { start: '***', end: '***', format: ['bold', 'italic'] }, { start: '#', format: 'h1' }, { start: '##', format: 'h2' }, { start: '###', format: 'h3' }, { start: '####', format: 'h4' }, { start: '#####', format: 'h5' }, { start: '######', format: 'h6' }, { start: '1. ', cmd: 'InsertOrderedList' }, { start: '* ', cmd: 'InsertUnorderedList' }, { start: '- ', cmd: 'InsertUnorderedList' }]; const A = function (t) { let n; let e; const r = (n = t, e = 'textpattern_patterns', P(n, e) ? h.some(n[e]) : h.none()).getOr(S); return C(r) }; const N = tinymce.util.Tools.resolve('tinymce.util.Delay'); const R = tinymce.util.Tools.resolve('tinymce.util.VK'); const I = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker'); const j = tinymce.util.Tools.resolve('tinymce.util.Tools'); const w = function (t, n) { for (let e = 0; e < t.length; e++) { const r = t[e]; if (n.indexOf(r.start) === 0 && (!r.end || n.lastIndexOf(r.end) === n.length - r.end.length)) return r } }; const E = function (t, n, e) { if (!1 !== n.collapsed) { const r = n.startContainer; const a = r.data; const o = !0 === e ? 1 : 0; if (r.nodeType === 3) { const i = (function (t, n, e, r) { let a, o, i, f, u, s; for (o = 0; o < t.length; o++) if ((a = t[o]).end !== undefined && (f = a, u = e, s = r, n.substr(u - f.end.length - s, f.end.length) === f.end) && e - r - (i = a).end.length - i.start.length > 0) return a }(t, a, n.startOffset, o)); if (i !== undefined) { let f = a.lastIndexOf(i.end, n.startOffset - o); const u = a.lastIndexOf(i.start, f - i.end.length); if (f = a.indexOf(i.end, u + i.start.length), u !== -1) { const s = document.createRange(); s.setStart(r, u), s.setEnd(r, f + i.end.length); const c = w(t, s.toString()); if (!(i === undefined || c !== i || r.data.length <= i.start.length + i.end.length)) return { pattern: i, startOffset: u, endOffset: f } } } } } }; const q = function (t) { return t && t.nodeType === 3 }; const L = function (t, n, e) { const r = t.dom.createRng(); r.setStart(n, e), r.setEnd(n, e), t.selection.setRng(r) }; const M = function (n, t, e) { const r = n.selection.getRng(); return h.from(E(t, r, e)).map((t) => (function (a, o, i, f) { const u = j.isArray(i.pattern.format) ? i.pattern.format : [i.pattern.format]; if (j.grep(u, (t) => { const n = a.formatter.get(t); return n && n[0].inline }).length !== 0) return a.undoManager.transact(() => { let t, n, e, r; t = o, n = i.pattern, e = i.endOffset, r = i.startOffset, (t = r > 0 ? t.splitText(r) : t).splitText(e - r + n.end.length), t.deleteData(0, n.start.length), t.deleteData(t.data.length - n.end.length, n.end.length), o = t, f && a.selection.setCursorLocation(o.nextSibling, 1), u.forEach((t) => { a.formatter.apply(t, {}, o) }) }), o }(n, r.startContainer, t, e))) }; const U = function (s, t, c) { const n = s.selection.getRng(); const l = n.startContainer; n.collapsed && q(l) && (function (t, n, e) { for (let r = 0; r < t.length; r++) { const a = e.lastIndexOf(t[r].start, n); if (a !== -1) return h.some({ pattern: t[r], startOffset: a }) } return h.none() }(t, n.startOffset, l.data)).each((t) => { let n; let e; let r; let a; let o; let i; let f; const u = c ? h.some((n = l, r = (e = t).startOffset + e.pattern.start.length, a = n.data.slice(r, r + 1), n.deleteData(r, 1), a)) : h.none(); o = s, f = t, (i = l).deleteData(f.startOffset, f.pattern.start.length), o.insertContent(f.pattern.replacement), h.from(i.nextSibling).filter(q).each((t) => { t.insertData(0, i.data), o.dom.remove(i) }), u.each((t) => (function (t, n) { const e = t.selection.getRng(); const r = e.startContainer; if (q(r)) { const a = e.startOffset; r.insertData(a, n), L(t, r, a + n.length) } else { const o = t.dom.doc.createTextNode(n); e.insertNode(o), L(t, o, o.length) } }(s, t))) }) }; const _ = function (t, n, e) { for (let r = 0; r < t.length; r++) if (e(t[r], n)) return !0 }; const z = function (t, n) { let e, r, a, o; e = t, r = n.replacementPatterns, U(e, r, !1), a = t, o = n.inlinePatterns, M(a, o, !1).each((t) => { L(a, t, t.data.length) }), (function (t, n) { let e, r, a, o, i, f, u, s, c, l, d; if (e = t.selection, r = t.dom, e.isCollapsed() && (u = r.getParent(e.getStart(), 'p'))) { for (c = new I(u, u); i = c.next();) if (q(i)) { o = i; break } if (o) { if (!(s = w(n, o.data))) return; if (a = (l = e.getRng(!0)).startContainer, d = l.startOffset, o === a && (d = Math.max(0, d - s.start.length)), j.trim(o.data).length === s.start.length) return; s.format && (f = t.formatter.get(s.format)) && f[0].block && (o.deleteData(0, s.start.length), t.formatter.apply(s.format, {}, o), l.setStart(a, d), l.collapse(!0), e.setRng(l)), s.cmd && t.undoManager.transact(() => { o.deleteData(0, s.start.length), t.execCommand(s.cmd) }) } } }(t, n.blockPatterns)) }; const K = function (t, n) { let e, r, a, o; e = t, r = n.replacementPatterns, U(e, r, !0), a = t, o = n.inlinePatterns, M(a, o, !0).each((t) => { const n = t.data.slice(-1); if (/[\u00a0 ]/.test(n)) { t.deleteData(t.data.length - 1, 1); const e = a.dom.doc.createTextNode(n); a.dom.insertAfter(e, t.parentNode), L(a, e, 1) } }) }; const V = function (t, n) { return _(t, n, (t, n) => t.charCodeAt(0) === n.charCode) }; const W = function (t, n) { return _(t, n, (t, n) => t === n.keyCode && !1 === R.modifierPressed(n)) }; const B = function (n, e) { const r = [',', '.', ';', ':', '!', '?']; const a = [32]; n.on('keydown', (t) => { t.keyCode !== 13 || R.modifierPressed(t) || z(n, e.get()) }, !0), n.on('keyup', (t) => { W(a, t) && K(n, e.get()) }), n.on('keypress', (t) => { V(r, t) && N.setEditorTimeout(n, () => { K(n, e.get()) }) }) }; i.add('textpattern', (t) => { const n = o(A(t.settings)); return B(t, n), D(n) }), function F() {}
}())
