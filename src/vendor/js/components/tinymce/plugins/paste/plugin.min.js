!(function () {
  var l = function (t) { let e = t; const n = function () { return e }; return { get: n, set(t) { e = t }, clone() { return l(n()) } } }; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const a = function (t) { return !(!/(^|[ ,])powerpaste([, ]|$)/.test(t.settings.plugins) || !e.get('powerpaste') || (typeof window.console !== 'undefined' && window.console.log && window.console.log("PowerPaste is incompatible with Paste plugin! Remove 'paste' from the 'plugins' option."), 0)) }; const u = function (t, e) { return { clipboard: t, quirks: e } }; const f = function (t, e, n, r) { return t.fire('PastePreProcess', { content: e, internal: n, wordContent: r }) }; const d = function (t, e, n, r) { return t.fire('PastePostProcess', { node: e, internal: n, wordContent: r }) }; const i = function (t, e) { return t.fire('PastePlainTextToggle', { state: e }) }; const n = function (t, e) { return t.fire('paste', { ieFake: e }) }; const m = { shouldPlainTextInform(t) { return t.getParam('paste_plaintext_inform', !0) }, shouldBlockDrop(t) { return t.getParam('paste_block_drop', !1) }, shouldPasteDataImages(t) { return t.getParam('paste_data_images', !1) }, shouldFilterDrop(t) { return t.getParam('paste_filter_drop', !0) }, getPreProcess(t) { return t.getParam('paste_preprocess') }, getPostProcess(t) { return t.getParam('paste_postprocess') }, getWebkitStyles(t) { return t.getParam('paste_webkit_styles') }, shouldRemoveWebKitStyles(t) { return t.getParam('paste_remove_styles_if_webkit', !0) }, shouldMergeFormats(t) { return t.getParam('paste_merge_formats', !0) }, isSmartPasteEnabled(t) { return t.getParam('smart_paste', !0) }, isPasteAsTextEnabled(t) { return t.getParam('paste_as_text', !1) }, getRetainStyleProps(t) { return t.getParam('paste_retain_style_properties') }, getWordValidElements(t) { return t.getParam('paste_word_valid_elements', '-strong/b,-em/i,-u,-span,-p,-ol,-ul,-li,-h1,-h2,-h3,-h4,-h5,-h6,-p/div,-a[href|name],sub,sup,strike,br,del,table[width],tr,td[colspan|rowspan|width],th[colspan|rowspan|width],thead,tfoot,tbody') }, shouldConvertWordFakeLists(t) { return t.getParam('paste_convert_word_fake_lists', !0) }, shouldUseDefaultFilters(t) { return t.getParam('paste_enable_default_filters', !0) } }; const r = function (t, e, n) { let r, o; e.pasteFormat.get() === 'text' ? (e.pasteFormat.set('html'), i(t, !1)) : (e.pasteFormat.set('text'), i(t, !0), o = t, !1 === n.get() && m.shouldPlainTextInform(o) && (r = 'Paste is now in plain text mode. Contents will now be pasted as plain text until you toggle this option off.', t.notificationManager.open({ text: r, type: 'info' }), n.set(!0))), t.focus() }; const s = function (t, n, e) { t.addCommand('mceTogglePlainTextPaste', () => { r(t, n, e) }), t.addCommand('mceInsertClipboardContent', (t, e) => { e.content && n.pasteHtml(e.content, e.internal), e.text && n.pasteText(e.text) }) }; const v = tinymce.util.Tools.resolve('tinymce.Env'); const h = tinymce.util.Tools.resolve('tinymce.util.Delay'); const y = tinymce.util.Tools.resolve('tinymce.util.Tools'); const o = tinymce.util.Tools.resolve('tinymce.util.VK'); const t = 'x-tinymce/html'; const c = `\x3c!-- ${t} --\x3e`; const g = function (t) { return c + t }; const p = function (t) { return t.replace(c, '') }; const b = function (t) { return t.indexOf(c) !== -1 }; const x = function () { return t }; const P = tinymce.util.Tools.resolve('tinymce.html.Entities'); const w = function (t) { return t.replace(/\r?\n/g, '<br>') }; const T = function (t, e, n) { const r = t.split(/\n\n/); const o = (function (t, e) { let n; const r = []; let o = `<${t}`; if (typeof e === 'object') { for (n in e)e.hasOwnProperty(n) && r.push(`${n}="${P.encodeAllRaw(e[n])}"`); r.length && (o += ` ${r.join(' ')}`) } return `${o}>` }(e, n)); const i = `</${e}>`; const a = y.map(r, (t) => t.split(/\n/).join('<br />')); return a.length === 1 ? a[0] : y.map(a, (t) => o + t + i).join('') }; const _ = function (t) { return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(t) }; const D = function (t, e, n) { return e ? T(t, e, n) : w(t) }; const C = tinymce.util.Tools.resolve('tinymce.html.DomParser'); const k = tinymce.util.Tools.resolve('tinymce.html.Node'); const S = tinymce.util.Tools.resolve('tinymce.html.Schema'); const O = tinymce.util.Tools.resolve('tinymce.html.Serializer'); function R(e, t) { return y.each(t, (t) => { e = t.constructor === RegExp ? e.replace(t, '') : e.replace(t[0], t[1]) }), e } const A = { filter: R, innerText: function Zt(t) { const e = S(); const n = C({}, e); let r = ''; const o = e.getShortEndedElements(); const i = y.makeMap('script noscript style textarea video audio iframe object', ' '); const a = e.getBlockElements(); return t = R(t, [/<!\[[^\]]+\]>/g]), (function u(t) { const e = t.name; const n = t; if (e !== 'br') { if (e !== 'wbr') if (o[e] && (r += ' '), i[e])r += ' '; else { if (t.type === 3 && (r += t.value), !t.shortEnded && (t = t.firstChild)) for (;u(t), t = t.next;);a[e] && n.next && (r += '\n', e === 'p' && (r += '\n')) } } else r += '\n' }(n.parse(t))), r }, trimHtml: function Jt(t) { return t = R(t, [/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/gi, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, function r(t, e, n) { return e || n ? '\xa0' : ' ' }], /<br class="Apple-interchange-newline">/g, /<br>$/i]) }, createIdGenerator: function Qt(t) { let e = 0; return function () { return t + e++ } }, isMsEdge() { return navigator.userAgent.indexOf(' Edge/') !== -1 } }; function E(e) { let n, t; return t = [/^[IVXLMCD]{1,2}\.[ \u00a0]/, /^[ivxlmcd]{1,2}\.[ \u00a0]/, /^[a-z]{1,2}[\.\)][ \u00a0]/, /^[A-Z]{1,2}[\.\)][ \u00a0]/, /^[0-9]+\.[ \u00a0]/, /^[\u3007\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d]+\.[ \u00a0]/, /^[\u58f1\u5f10\u53c2\u56db\u4f0d\u516d\u4e03\u516b\u4e5d\u62fe]+\.[ \u00a0]/], e = e.replace(/^[\u00a0 ]+/, ''), y.each(t, (t) => { if (t.test(e)) return !(n = !0) }), n } function F(t) { let i; let a; let u = 1; function n(t) { let e = ''; if (t.type === 3) return t.value; if (t = t.firstChild) for (;e += n(t), t = t.next;);return e } function s(t, e) { if (t.type === 3 && e.test(t.value)) return t.value = t.value.replace(e, ''), !1; if (t = t.firstChild) do { if (!s(t, e)) return !1 } while (t = t.next);return !0 } function e(t, e, n) { const r = t._listLevel || u; r !== u && (r < u ? i && (i = i.parent.parent) : (a = i, i = null)), i && i.name === e ? i.append(t) : (a = a || i, i = new k(e, 1), n > 1 && i.attr('start', `${n}`), t.wrap(i)), t.name = 'li', u < r && a && a.lastChild.append(i), u = r, (function o(t) { if (t._listIgnore)t.remove(); else if (t = t.firstChild) for (;o(t), t = t.next;); }(t)), s(t, /^\u00a0+/), s(t, /^\s*([\u2022\u00b7\u00a7\u25CF]|\w+\.)/), s(t, /^\u00a0+/) } for (var r = [], o = t.firstChild; o != null;) if (r.push(o), (o = o.walk()) !== null) for (;void 0 !== o && o.parent !== t;)o = o.walk(); for (let l = 0; l < r.length; l++) if ((t = r[l]).name === 'p' && t.firstChild) { const c = n(t); if (/^[\s\u00a0]*[\u2022\u00b7\u00a7\u25CF]\s*/.test(c)) { e(t, 'ul'); continue } if (E(c)) { const f = /([0-9]+)\./.exec(c); let d = 1; f && (d = parseInt(f[1], 10)), e(t, 'ol', d); continue } if (t._listLevel) { e(t, 'ul', 1); continue }i = null } else a = i, i = null } function I(n, r, o, i) { let a; let u = {}; const t = n.dom.parseStyle(i); return y.each(t, (t, e) => { switch (e) { case 'mso-list':(a = /\w+ \w+([0-9]+)/i.exec(i)) && (o._listLevel = parseInt(a[1], 10)), /Ignore/i.test(t) && o.firstChild && (o._listIgnore = !0, o.firstChild._listIgnore = !0); break; case 'horiz-align':e = 'text-align'; break; case 'vert-align':e = 'vertical-align'; break; case 'font-color':case 'mso-foreground':e = 'color'; break; case 'mso-background':case 'mso-highlight':e = 'background'; break; case 'font-weight':case 'font-style':return void (t !== 'normal' && (u[e] = t)); case 'mso-element':if (/^(comment|comment-list)$/i.test(t)) return void o.remove() }e.indexOf('mso-comment') !== 0 ? e.indexOf('mso-') !== 0 && (m.getRetainStyleProps(n) === 'all' || r && r[e]) && (u[e] = t) : o.remove() }), /(bold)/i.test(u['font-weight']) && (delete u['font-weight'], o.wrap(new k('b', 1))), /(italic)/i.test(u['font-style']) && (delete u['font-style'], o.wrap(new k('i', 1))), (u = n.dom.serializeStyle(u, o.name)) || null } let M; let B; let H; let j; let L; const N = { preProcess(t, e) { return m.shouldUseDefaultFilters(t) ? (function (r, t) { let e, o; (e = m.getRetainStyleProps(r)) && (o = y.makeMap(e.split(/[, ]/))), t = A.filter(t, [/<br class="?Apple-interchange-newline"?>/gi, /<b[^>]+id="?docs-internal-[^>]*>/gi, /<!--[\s\S]+?-->/gi, /<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, [/<(\/?)s>/gi, '<$1strike>'], [/&nbsp;/gi, '\xa0'], [/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function (t, e) { return e.length > 0 ? e.replace(/./, ' ').slice(Math.floor(e.length / 2)).split('').join('\xa0') : '' }]]); const n = m.getWordValidElements(r); const i = S({ valid_elements: n, valid_children: '-li[p]' }); y.each(i.elements, (t) => { t.attributes.class || (t.attributes.class = {}, t.attributesOrder.push('class')), t.attributes.style || (t.attributes.style = {}, t.attributesOrder.push('style')) }); const a = C({}, i); a.addAttributeFilter('style', (t) => { for (var e, n = t.length; n--;)(e = t[n]).attr('style', I(r, o, e, e.attr('style'))), e.name === 'span' && e.parent && !e.attributes.length && e.unwrap() }), a.addAttributeFilter('class', (t) => { for (var e, n, r = t.length; r--;)n = (e = t[r]).attr('class'), /^(MsoCommentReference|MsoCommentText|msoDel)$/i.test(n) && e.remove(), e.attr('class', null) }), a.addNodeFilter('del', (t) => { for (let e = t.length; e--;)t[e].remove() }), a.addNodeFilter('a', (t) => { for (var e, n, r, o = t.length; o--;) if (n = (e = t[o]).attr('href'), r = e.attr('name'), n && n.indexOf('#_msocom_') !== -1)e.remove(); else if (n && n.indexOf('file://') === 0 && (n = n.split('#')[1]) && (n = `#${n}`), n || r) { if (r && !/^_?(?:toc|edn|ftn)/i.test(r)) { e.unwrap(); continue }e.attr({ href: n, name: r }) } else e.unwrap() }); const u = a.parse(t); return m.shouldConvertWordFakeLists(r) && F(u), t = O({ validate: r.settings.validate }, i).serialize(u) }(t, e)) : e }, isWordContent: function te(t) { return /<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i.test(t) || /class="OutlineElement/.test(t) || /id="?docs\-internal\-guid\-/.test(t) } }; const $ = function (t, e) { return { content: t, cancelled: e } }; const W = function (t, e, n, r) { let o; let i; let a; let u; let s; let l; const c = f(t, e, n, r); return t.hasEventListeners('PastePostProcess') && !c.isDefaultPrevented() ? (o = t, i = c.content, a = n, u = r, s = o.dom.create('div', { style: 'display:none' }, i), l = d(o, s, a, u), $(l.node.innerHTML, l.isDefaultPrevented())) : $(c.content, c.isDefaultPrevented()) }; const z = function (t, e, n) { const r = N.isWordContent(e); const o = r ? N.preProcess(t, e) : e; return W(t, o, n, r) }; const U = function (t, e) { let n, r; return t.insertContent((n = e, r = t.dom.create('body', {}, n), y.each(r.querySelectorAll('meta'), (t) => t.parentNode.removeChild(t)), r.innerHTML), { merge: m.shouldMergeFormats(t), paste: !0 }), !0 }; const V = function (t) { return /^https?:\/\/[\w\?\-\/+=.&%@~#]+$/i.test(t) }; const q = function (t) { return V(t) && /.(gif|jpe?g|png)$/.test(t) }; const K = function (t, e, n) { return !(!1 !== t.selection.isCollapsed() || !V(e) || (o = e, i = n, (r = t).undoManager.extra(() => { i(r, o) }, () => { r.execCommand('mceInsertLink', !1, o) }), 0)); let r, o, i }; const G = function (t, e, n) { return !!q(e) && (o = e, i = n, (r = t).undoManager.extra(() => { i(r, o) }, () => { r.insertContent(`<img src="${o}">`) }), !0); let r, o, i }; const X = function (t, e) { let n, r; !1 === m.isSmartPasteEnabled(t) ? U(t, e) : (n = t, r = e, y.each([K, G, U], (t) => !0 !== t(n, r, U))) }; const Y = function (t) { return function () { return t } }; const Z = Y(!1); const J = Y(!0); const Q = Z; const tt = J; const et = function () { return nt }; var nt = (j = { fold(t, e) { return t() }, is: Q, isSome: Q, isNone: tt, getOr: H = function (t) { return t }, getOrThunk: B = function (t) { return t() }, getOrDie(t) { throw new Error(t || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: H, orThunk: B, map: et, ap: et, each() {}, bind: et, flatten: et, exists: Q, forall: tt, filter: et, equals: M = function (t) { return t.isNone() }, equals_: M, toArray() { return [] }, toString: Y('none()') }, Object.freeze && Object.freeze(j), j); var rt = function (n) { const t = function () { return n }; const e = function () { return o }; const r = function (t) { return t(n) }; var o = { fold(t, e) { return e(n) }, is(t) { return n === t }, isSome: tt, isNone: Q, getOr: t, getOrThunk: t, getOrDie: t, getOrNull: t, getOrUndefined: t, or: e, orThunk: e, map(t) { return rt(t(n)) }, ap(t) { return t.fold(et, (t) => rt(t(n))) }, each(t) { t(n) }, bind: r, flatten: t, exists: r, forall: r, filter(t) { return t(n) ? o : nt }, equals(t) { return t.is(n) }, equals_(t, e) { return t.fold(Q, (t) => e(n, t)) }, toArray() { return [n] }, toString() { return `some(${n})` } }; return o }; const ot = { some: rt, none: et, from(t) { return t === null || t === undefined ? nt : rt(t) } }; const it = (L = 'function', function (t) { return (function (t) { if (t === null) return 'null'; const e = typeof t; return e === 'object' && Array.prototype.isPrototypeOf(t) ? 'array' : e === 'object' && String.prototype.isPrototypeOf(t) ? 'string' : e }(t)) === L }); const at = function (t, e) { for (var n = t.length, r = new Array(n), o = 0; o < n; o++) { const i = t[o]; r[o] = e(i, o, t) } return r }; const ut = function (t, e) { for (let n = 0, r = t.length; n < r; n++)e(t[n], n, t) }; const st = Array.prototype.slice; const lt = it(Array.from) ? Array.from : function (t) { return st.call(t) }; var ct = function (t) { let n = ot.none(); let e = []; const r = function (t) { o() ? a(t) : e.push(t) }; var o = function () { return n.isSome() }; const i = function (t) { ut(t, a) }; var a = function (e) { n.each((t) => { setTimeout(() => { e(t) }, 0) }) }; return t((t) => { n = ot.some(t), i(e), e = [] }), { get: r, map(n) { return ct((e) => { r((t) => { e(n(t)) }) }) }, isReady: o } }; const ft = { nu: ct, pure(e) { return ct((t) => { t(e) }) } }; var dt = function (e) { const t = function (t) { let r; e((r = t, function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; const n = this; setTimeout(() => { r.apply(n, t) }, 0) })) }; const n = function () { return ft.nu(t) }; return { map(r) { return dt((n) => { t((t) => { const e = r(t); n(e) }) }) }, bind(n) { return dt((e) => { t((t) => { n(t).get(e) }) }) }, anonBind(n) { return dt((e) => { t((t) => { n.get(e) }) }) }, toLazy: n, toCached() { let e = null; return dt((t) => { e === null && (e = n()), e.get(t) }) }, get: t } }; const mt = { nu: dt, pure(e) { return dt((t) => { t(e) }) } }; const gt = function (a, t) { return t((r) => { const o = []; let i = 0; a.length === 0 ? r([]) : ut(a, (t, e) => { let n; t.get((n = e, function (t) { o[n] = t, ++i >= a.length && r(o) })) }) }) }; const pt = function (t, e) { const n = at(t, e); return gt(n, mt.nu) }; const vt = function (t, e, n) { const r = n || b(e); const o = z(t, p(e), r); !1 === o.cancelled && X(t, o.content) }; const ht = function (t, e) { e = t.dom.encode(e).replace(/\r\n/g, '\n'), e = D(e, t.settings.forced_root_block, t.settings.forced_root_block_attrs), vt(t, e, !1) }; const yt = function (t) { const e = {}; if (t) { if (t.getData) { const n = t.getData('Text'); n && n.length > 0 && n.indexOf('data:text/mce-internal,') === -1 && (e['text/plain'] = n) } if (t.types) for (let r = 0; r < t.types.length; r++) { const o = t.types[r]; try { e[o] = t.getData(o) } catch (i) { e[o] = '' } } } return e }; const bt = function (t, e) { return e in t && t[e].length > 0 }; const xt = function (t) { return bt(t, 'text/html') || bt(t, 'text/plain') }; const Pt = A.createIdGenerator('mceclip'); const wt = function (e, t, n) { let r; let o; let i; let a; const u = t.type === 'paste' ? t.clipboardData : t.dataTransfer; if (e.settings.paste_data_images && u) { const s = (i = (o = u).items ? at(lt(o.items), (t) => t.getAsFile()) : [], a = o.files ? lt(o.files) : [], (function (t, e) { for (var n = [], r = 0, o = t.length; r < o; r++) { const i = t[r]; e(i, r, t) && n.push(i) } return n }(i.length > 0 ? i : a, (t) => /^image\/(jpeg|png|gif|bmp)$/.test(t.type)))); if (s.length > 0) return t.preventDefault(), (r = s, pt(r, (r) => mt.nu((t) => { const e = r.getAsFile ? r.getAsFile() : r; const n = new window.FileReader(); n.onload = function () { t({ blob: e, uri: n.result }) }, n.readAsDataURL(e) }))).get((t) => { n && e.selection.setRng(n), ut(t, (t) => { !(function (t, e) { let n; let r; let o; let i; let a; let u; let s; const l = (n = e.uri, (r = n.indexOf(',')) !== -1 ? n.substr(r + 1) : null); const c = Pt(); const f = t.settings.images_reuse_filename && e.blob.name ? (o = t, i = e.blob.name, (a = i.match(/([\s\S]+?)\.(?:jpeg|jpg|png|gif)$/i)) ? o.dom.encode(a[1]) : null) : c; const d = new Image(); if (d.src = e.uri, u = t.settings, s = d, !u.images_dataimg_filter || u.images_dataimg_filter(s)) { let m; const g = t.editorUpload.blobCache; let p = void 0; (m = g.findFirst((t) => t.base64() === l)) ? p = m : (p = g.create(c, e.blob, l, f), g.add(p)), vt(t, `<img src="${p.blobUri()}">`, !1) } else vt(t, `<img src="${e.uri}">`, !1) }(e, t)) }) }), !0 } return !1 }; const Tt = function (t) { return o.metaKeyPressed(t) && t.keyCode === 86 || t.shiftKey && t.keyCode === 45 }; const _t = function (c, f, d) { let m; let g = 0; function p(t, e, n, r) { let o, i; bt(t, 'text/html') ? o = t['text/html'] : (o = f.getHtml(), r = r || b(o), f.isDefaultContent(o) && (n = !0)), o = A.trimHtml(o), f.remove(), i = !1 === r && _(o), o.length && !i || (n = !0), n && (o = bt(t, 'text/plain') && i ? t['text/plain'] : A.innerText(o)), f.isDefaultContent(o) ? e || c.windowManager.alert('Please use Ctrl+V/Cmd+V keyboard shortcuts to paste contents.') : n ? ht(c, o) : vt(c, o, r) }c.on('keydown', (t) => { function e(t) { Tt(t) && !t.isDefaultPrevented() && f.remove() } if (Tt(t) && !t.isDefaultPrevented()) { if ((m = t.shiftKey && t.keyCode === 86) && v.webkit && navigator.userAgent.indexOf('Version/') !== -1) return; if (t.stopImmediatePropagation(), g = (new Date()).getTime(), v.ie && m) return t.preventDefault(), void n(c, !0); f.remove(), f.create(), c.once('keyup', e), c.once('paste', () => { c.off('keyup', e) }) } }), c.on('paste', (t) => { let e; let n; let r; const o = (new Date()).getTime(); const i = (e = c, n = yt(t.clipboardData || e.getDoc().dataTransfer), A.isMsEdge() ? y.extend(n, { 'text/html': '' }) : n); const a = (new Date()).getTime() - o; const u = (new Date()).getTime() - g - a < 1e3; const s = d.get() === 'text' || m; let l = bt(i, x()); m = !1, t.isDefaultPrevented() || (r = t.clipboardData, navigator.userAgent.indexOf('Android') !== -1 && r && r.items && r.items.length === 0) ? f.remove() : xt(i) || !wt(c, t, f.getLastRng() || c.selection.getRng()) ? (u || t.preventDefault(), !v.ie || u && !t.ieFake || bt(i, 'text/html') || (f.create(), c.dom.bind(f.getEl(), 'paste', (t) => { t.stopPropagation() }), c.getDoc().execCommand('Paste', !1, null), i['text/html'] = f.getHtml()), bt(i, 'text/html') ? (t.preventDefault(), l || (l = b(i['text/html'])), p(i, u, s, l)) : h.setEditorTimeout(c, () => { p(i, u, s, l) }, 0)) : f.remove() }) }; const Dt = function (t) { return v.ie && t.inline ? document.body : t.getBody() }; const Ct = function (e, t, n) { let r; Dt(r = e) !== r.getBody() && e.dom.bind(t, 'paste keyup', (t) => { Ot(e, n) || e.fire('paste') }) }; const kt = function (t) { return t.dom.get('mcepastebin') }; const St = function (t, e) { return e === t }; var Ot = function (t, e) { let n; const r = kt(t); return (n = r) && n.id === 'mcepastebin' && St(e, r.innerHTML) }; const Rt = function (a) { const u = l(null); const s = '%MCEPASTEBIN%'; return { create() { return e = u, n = s, o = (t = a).dom, i = t.getBody(), e.set(t.selection.getRng()), r = t.dom.add(Dt(t), 'div', { id: 'mcepastebin', class: 'mce-pastebin', contentEditable: !0, 'data-mce-bogus': 'all', style: 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0' }, n), (v.ie || v.gecko) && o.setStyle(r, 'left', o.getStyle(i, 'direction', !0) === 'rtl' ? 65535 : -65535), o.bind(r, 'beforedeactivate focusin focusout', (t) => { t.stopPropagation() }), Ct(t, r, n), r.focus(), void t.selection.select(r, !0); let t, e, n, r, o, i }, remove() { return (function (t, e) { if (kt(t)) { for (var n = void 0, r = e.get(); n = t.dom.get('mcepastebin');)t.dom.remove(n), t.dom.unbind(n); r && t.selection.setRng(r) }e.set(null) }(a, u)) }, getEl() { return kt(a) }, getHtml() { return (function (n) { let e; let t; let r; let o; let i; const a = function (t, e) { t.appendChild(e), n.dom.remove(e, !0) }; for (t = y.grep(Dt(n).childNodes, (t) => t.id === 'mcepastebin'), e = t.shift(), y.each(t, (t) => { a(e, t) }), r = (o = n.dom.select('div[id=mcepastebin]', e)).length - 1; r >= 0; r--)i = n.dom.create('div'), e.insertBefore(i, o[r]), a(i, o[r]); return e ? e.innerHTML : '' }(a)) }, getLastRng() { return u.get() }, isDefault() { return Ot(a, s) }, isDefaultContent(t) { return St(s, t) } } }; const At = function (n, t) { const e = Rt(n); return n.on('preInit', () => { return _t(a = n, e, t), void a.parser.addNodeFilter('img', (t, e, n) => { let r; const o = function (t) { t.attr('data-mce-object') || u === v.transparentSrc || t.remove() }; if (!a.settings.paste_data_images && (r = n).data && !0 === r.data.paste) for (let i = t.length; i--;)(u = t[i].attributes.map.src) && (u.indexOf('webkit-fake-url') === 0 ? o(t[i]) : a.settings.allow_html_data_urls || u.indexOf('data:') !== 0 || o(t[i])) }); let a, u }), { pasteFormat: t, pasteHtml(t, e) { return vt(n, t, e) }, pasteText(t) { return ht(n, t) }, pasteImageData(t, e) { return wt(n, t, e) }, getDataTransferItems: yt, hasHtmlOrText: xt, hasContentType: bt } }; const Et = function () {}; const Ft = function (t, e, n) { if (r = t, !1 !== v.iOS || r === undefined || typeof r.setData !== 'function' || !0 === A.isMsEdge()) return !1; try { return t.clearData(), t.setData('text/html', e), t.setData('text/plain', n), t.setData(x(), e), !0 } catch (o) { return !1 } let r }; const It = function (t, e, n, r) { Ft(t.clipboardData, e.html, e.text) ? (t.preventDefault(), r()) : n(e.html, r) }; const Mt = function (u) { return function (t, e) { const n = g(t); const r = u.dom.create('div', { contenteditable: 'false', 'data-mce-bogus': 'all' }); const o = u.dom.create('div', { contenteditable: 'true' }, n); u.dom.setStyles(r, { position: 'fixed', top: '0', left: '-3000px', width: '1000px', overflow: 'hidden' }), r.appendChild(o), u.dom.add(u.getBody(), r); const i = u.selection.getRng(); o.focus(); const a = u.dom.createRng(); a.selectNodeContents(o), u.selection.setRng(a), setTimeout(() => { u.selection.setRng(i), r.parentNode.removeChild(r), e() }, 0) } }; const Bt = function (t) { return { html: t.selection.getContent({ contextual: !0 }), text: t.selection.getContent({ format: 'text' }) } }; const Ht = function (t) { return !t.selection.isCollapsed() || !!(e = t).dom.getParent(e.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', e.getBody()); let e }; const jt = function (t) { let e, n; t.on('cut', (e = t, function (t) { Ht(e) && It(t, Bt(e), Mt(e), () => { setTimeout(() => { e.execCommand('Delete') }, 0) }) })), t.on('copy', (n = t, function (t) { Ht(n) && It(t, Bt(n), Mt(n), Et) })) }; const Lt = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils'); const Nt = function (t, e) { return Lt.getCaretRangeFromPoint(e.clientX, e.clientY, t.getDoc()) }; const $t = function (t, e) { t.focus(), t.selection.setRng(e) }; const Wt = function (a, u, s) { m.shouldBlockDrop(a) && a.on('dragend dragover draggesture dragdrop drop drag', (t) => { t.preventDefault(), t.stopPropagation() }), m.shouldPasteDataImages(a) || a.on('drop', (t) => { const e = t.dataTransfer; e && e.files && e.files.length > 0 && t.preventDefault() }), a.on('drop', (t) => { let e, n; if (n = Nt(a, t), !t.isDefaultPrevented() && !s.get()) { e = u.getDataTransferItems(t.dataTransfer); let r; const o = u.hasContentType(e, x()); if ((u.hasHtmlOrText(e) && (!(r = e['text/plain']) || r.indexOf('file://') !== 0) || !u.pasteImageData(t, n)) && n && m.shouldFilterDrop(a)) { let i = e['mce-internal'] || e['text/html'] || e['text/plain']; i && (t.preventDefault(), h.setEditorTimeout(a, () => { a.undoManager.transact(() => { e['mce-internal'] && a.execCommand('Delete'), $t(a, n), i = A.trimHtml(i), e['text/html'] ? u.pasteHtml(i, o) : u.pasteText(i) }) })) } } }), a.on('dragstart', (t) => { s.set(!0) }), a.on('dragover dragend', (t) => { m.shouldPasteDataImages(a) && !1 === s.get() && (t.preventDefault(), $t(a, Nt(a, t))), t.type === 'dragend' && s.set(!1) }) }; const zt = function (t) { const e = t.plugins.paste; const n = m.getPreProcess(t); n && t.on('PastePreProcess', (t) => { n.call(e, e, t) }); const r = m.getPostProcess(t); r && t.on('PastePostProcess', (t) => { r.call(e, e, t) }) }; function Ut(e, n) { e.on('PastePreProcess', (t) => { t.content = n(e, t.content, t.internal, t.wordContent) }) } function Vt(t, e) { if (!N.isWordContent(e)) return e; const n = []; y.each(t.schema.getBlockElements(), (t, e) => { n.push(e) }); const r = new RegExp(`(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*(<\\/?(${n.join('|')})[^>]*>)(?:<br>&nbsp;[\\s\\r\\n]+|<br>)*`, 'g'); return e = A.filter(e, [[r, '$1']]), e = A.filter(e, [[/<br><br>/g, '<BR><BR>'], [/<br>/g, ' '], [/<BR><BR>/g, '<br>']]) } function qt(t, e, n, r) { if (r || n) return e; let l; const o = m.getWebkitStyles(t); if (!1 === m.shouldRemoveWebKitStyles(t) || o === 'all') return e; if (o && (l = o.split(/[, ]/)), l) { const c = t.dom; const f = t.selection.getNode(); e = e.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (t, e, n, r) => { const o = c.parseStyle(c.decode(n)); let i = {}; if (l === 'none') return e + r; for (let a = 0; a < l.length; a++) { let u = o[l[a]]; let s = c.getStyle(f, l[a], !0); /color/.test(l[a]) && (u = c.toHex(u), s = c.toHex(s)), s !== u && (i[l[a]] = u) } return (i = c.serializeStyle(i, 'span')) ? `${e} style="${i}"${r}` : e + r }) } else e = e.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, '$1$3'); return e = e.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (t, e, n, r) => `${e} style="${n}"${r}`) } function Kt(n, t) { n.$('a', t).find('font,u').each((t, e) => { n.dom.remove(e, !0) }) } const Gt = function (t) { v.webkit && Ut(t, qt), v.ie && (Ut(t, Vt), (function r(e, n) { e.on('PastePostProcess', (t) => { n(e, t.node) }) }(t, Kt))) }; const Xt = function (n, r) { return function (e) { e.setActive(r.pasteFormat.get() === 'text'); const t = function (t) { return e.setActive(t.state) }; return n.on('PastePlainTextToggle', t), function () { return n.off('PastePlainTextToggle', t) } } }; const Yt = function (t, e) { t.ui.registry.addToggleButton('pastetext', { active: !1, icon: 'paste-text', tooltip: 'Paste as text', onAction() { return t.execCommand('mceTogglePlainTextPaste') }, onSetup: Xt(t, e) }), t.ui.registry.addToggleMenuItem('pastetext', { text: 'Paste as text', onAction() { return t.execCommand('mceTogglePlainTextPaste') }, onSetup: Xt(t, e) }) }; e.add('paste', (t) => { if (!1 === a(t)) { const e = l(!1); const n = l(!1); const r = l(m.isPasteAsTextEnabled(t) ? 'text' : 'html'); const o = At(t, r); const i = Gt(t); return Yt(t, o), s(t, o, e), zt(t), jt(t), Wt(t, o, n), u(o, i) } }), function ee() {}
}())
