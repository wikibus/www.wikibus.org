!(function () {
  let t; let e; let n; let r; let i; const o = tinymce.util.Tools.resolve('tinymce.PluginManager'); const d = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils'); const f = tinymce.util.Tools.resolve('tinymce.EditorManager'); const m = tinymce.util.Tools.resolve('tinymce.Env'); const v = tinymce.util.Tools.resolve('tinymce.util.Tools'); const c = function (t) { return t.getParam('importcss_merge_classes') }; const u = function (t) { return t.getParam('importcss_exclusive') }; const h = function (t) { return t.getParam('importcss_selector_converter') }; const l = function (t) { return t.getParam('importcss_selector_filter') }; const p = function (t) { return t.getParam('importcss_groups') }; const _ = function (t) { return t.getParam('importcss_append') }; const O = function (t) { return t.getParam('importcss_file_filter') }; const s = function (t) { return function () { return t } }; const a = s(!1); const y = s(!0); const g = function () { return x }; var x = (r = { fold(t, e) { return t() }, is: a, isSome: a, isNone: y, getOr: n = function (t) { return t }, getOrThunk: e = function (t) { return t() }, getOrDie(t) { throw new Error(t || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: n, orThunk: e, map: g, ap: g, each() {}, bind: g, flatten: g, exists: a, forall: y, filter: g, equals: t = function (t) { return t.isNone() }, equals_: t, toArray() { return [] }, toString: s('none()') }, Object.freeze && Object.freeze(r), r); const T = (i = 'function', function (t) { return (function (t) { if (t === null) return 'null'; const e = typeof t; return e === 'object' && Array.prototype.isPrototypeOf(t) ? 'array' : e === 'object' && String.prototype.isPrototypeOf(t) ? 'string' : e }(t)) === i }); const b = Array.prototype.push; const k = function (t, e) { return (function (t) { for (var e = [], n = 0, r = t.length; n < r; ++n) { if (!Array.prototype.isPrototypeOf(t[n])) throw new Error(`Arr.flatten item ${n} was not an array, input: ${t}`); b.apply(e, t[n]) } return e }(function (t, e) { for (var n = t.length, r = new Array(n), i = 0; i < n; i++) { const o = t[i]; r[i] = e(o, i, t) } return r }(t, e))) }; const P = (Array.prototype.slice, T(Array.from) && Array.from, function (e) { return typeof e === 'string' ? function (t) { return t.indexOf(e) !== -1 } : e instanceof RegExp ? function (t) { return e.test(t) } : e }); const S = function (c, t, s) { const a = []; const n = {}; function l(t, e) { let n; let r; let i; let o = t.href; if (r = o, i = m.cacheSuffix, typeof r === 'string' && (r = r.replace(`?${i}`, '').replace(`&${i}`, '')), (o = r) && s(o, e) && !(function (t, e) { const n = t.settings; const r = !1 !== n.skin && (n.skin || 'oxide'); if (r) { const i = n.skin_url ? t.documentBaseURI.toAbsolute(n.skin_url) : `${f.baseURL}/skins/ui/${r}`; const o = `${f.baseURL}/skins/content/`; return e === `${i}/content${t.inline ? '.inline' : ''}.min.css` || e.indexOf(o) !== -1 } return !1 }(c, o))) { v.each(t.imports, (t) => { l(t, !0) }); try { n = t.cssRules || t.rules } catch (u) {}v.each(n, (t) => { t.styleSheet ? l(t.styleSheet, !0) : t.selectorText && v.each(t.selectorText.split(','), (t) => { a.push(v.trim(t)) }) }) } }v.each(c.contentCSS, (t) => { n[t] = !0 }), s || (s = function (t, e) { return e || n[t] }); try { v.each(t.styleSheets, (t) => { l(t) }) } catch (e) {} return a }; const A = function (t, e) { let n; const r = /^(?:([a-z0-9\-_]+))?(\.[a-z0-9_\-\.]+)$/i.exec(e); if (r) { const i = r[1]; const o = r[2].substr(1).split('.').join(' '); const u = v.makeMap('a,img'); return r[1] ? (n = { title: e }, t.schema.getTextBlockElements()[i] ? n.block = i : t.schema.getBlockElements()[i] || u[i.toLowerCase()] ? n.selector = i : n.inline = i) : r[2] && (n = { inline: 'span', title: e.substr(1), classes: o }), !1 !== c(t) ? n.classes = o : n.attributes = { class: o }, n } }; const w = function (t, e) { return e === null || !1 !== u(t) }; const E = A; const I = function (g) { g.on('init', (t) => { let e; let n; let r; let i; const o = (e = [], n = [], r = {}, { addItemToGroup(t, e) { r[t] ? r[t].push(e) : (n.push(t), r[t] = [e]) }, addItem(t) { e.push(t) }, toFormats() { return k(n, (t) => { const e = r[t]; return e.length === 0 ? [] : [{ title: t, items: e }] }).concat(e) } }); const y = {}; const u = P(l(g)); const c = (i = p(g), v.map(i, (t) => v.extend({}, t, { original: t, selectors: {}, filter: P(t.filter), item: { text: t.title, menu: [] } }))); const s = function (t, e) { if (f = t, p = y, !(w(g, m = e) ? f in p : f in m.selectors)) { s = t, l = y, w(g, a = e) ? l[s] = !0 : a.selectors[s] = !0; const n = (o = (i = g).plugins.importcss, u = t, ((c = e) && c.selector_converter ? c.selector_converter : h(i) ? h(i) : function () { return A(i, u) }).call(o, u, c)); if (n) { const r = n.name || d.DOM.uniqueId(); return g.formatter.register(r, n), v.extend({}, { title: n.title, format: r }) } } let i, o, u, c, s, a, l, f, m, p; return null }; v.each(S(g, t.doc || g.getDoc(), P(O(g))), (n) => { if (n.indexOf('.mce-') === -1 && (!u || u(n))) { const t = (r = c, i = n, v.grep(r, (t) => !t.filter || t.filter(i))); if (t.length > 0)v.each(t, (t) => { const e = s(n, t); e && o.addItemToGroup(t.title, e) }); else { const e = s(n, null); e && o.addItem(e) } } let r, i }); const a = o.toFormats(); g.fire('addStyleModifications', { items: a, replace: !_(g) }) }) }; const M = function (e) { return { convertSelectorToFormat(t) { return E(e, t) } } }; o.add('importcss', (t) => I(t), M(t)), function j() {}
}())
