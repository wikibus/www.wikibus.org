!(function () {
  var r = function (e) { let t = e; const n = function () { return t }; return { get: n, set(e) { t = e }, clone() { return r(n()) } } }; const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const p = tinymce.util.Tools.resolve('tinymce.util.Tools'); function x(e) { return e && e.nodeType === 1 && e.contentEditable === 'false' } let t; let n; let a; let o; let i; const s = { findAndReplaceDOMText: function D(e, t, n, r, a) { let o; let i; let m; let f; let p; let g; const d = []; let c = 0; function l(e, t) { if (t = t || 0, !e[0]) throw new Error('findAndReplaceDOMText cannot handle zero-length matches'); let n = e.index; if (t > 0) { const r = e[t]; if (!r) throw new Error('Invalid capture group'); n += e[0].indexOf(r), e[0] = r } return [n, n + e[0].length, [e[0]]] } if (m = t.ownerDocument, f = a.getBlockElements(), p = a.getWhiteSpaceElements(), g = a.getShortEndedElements(), i = (function u(e) { let t; if (e.nodeType === 3) return e.data; if (p[e.nodeName] && !f[e.nodeName]) return ''; if (t = '', x(e)) return '\n'; if ((f[e.nodeName] || g[e.nodeName]) && (t += '\n'), e = e.firstChild) for (;t += u(e), e = e.nextSibling;);return t }(t))) { if (e.global) for (;o = e.exec(i);)d.push(l(o, r)); else o = i.match(e), d.push(l(o, r)); return d.length && (c = d.length, (function h(e, t, n) { let r; let a; let o; let i; let d = []; let c = 0; let l = e; let u = t.shift(); let s = 0; e:for (;;) { if ((f[l.nodeName] || g[l.nodeName] || x(l)) && c++, l.nodeType === 3 && (!a && l.length + c >= u[1] ? (a = l, i = u[1] - c) : r && d.push(l), !r && l.length + c > u[0] && (r = l, o = u[0] - c), c += l.length), r && a) { if (l = n({ startNode: r, startNodeIndex: o, endNode: a, endNodeIndex: i, innerNodes: d, match: u[2], matchIndex: s }), c -= a.length - i, a = r = null, d = [], s++, !(u = t.shift())) break } else if (p[l.nodeName] && !f[l.nodeName] || !l.firstChild) { if (l.nextSibling) { l = l.nextSibling; continue } } else if (!x(l)) { l = l.firstChild; continue } for (;;) { if (l.nextSibling) { l = l.nextSibling; break } if (l.parentNode === e) break e; l = l.parentNode } } }(t, d, (function s(e) { let h; if (typeof e !== 'function') { const r = e.nodeType ? e : m.createElement(e); h = function (e, t) { const n = r.cloneNode(!1); return n.setAttribute('data-mce-index', t), e && n.appendChild(m.createTextNode(e)), n } } else h = e; return function (e) { let t; let n; let r; const a = e.startNode; const o = e.endNode; const i = e.matchIndex; if (a === o) { const d = a; r = d.parentNode, e.startNodeIndex > 0 && (t = m.createTextNode(d.data.substring(0, e.startNodeIndex)), r.insertBefore(t, d)); const c = h(e.match[0], i); return r.insertBefore(c, d), e.endNodeIndex < d.length && (n = m.createTextNode(d.data.substring(e.endNodeIndex)), r.insertBefore(n, d)), d.parentNode.removeChild(d), c }t = m.createTextNode(a.data.substring(0, e.startNodeIndex)), n = m.createTextNode(o.data.substring(e.endNodeIndex)); for (var l = h(a.data.substring(e.startNodeIndex), i), u = 0, s = e.innerNodes.length; u < s; ++u) { const f = e.innerNodes[u]; const p = h(f.data, i); f.parentNode.replaceChild(p, f) } const g = h(o.data.substring(0, e.endNodeIndex), i); return (r = a.parentNode).insertBefore(t, a), r.insertBefore(l, a), r.removeChild(a), (r = o.parentNode).insertBefore(g, o), r.insertBefore(n, o), r.removeChild(o), g } }(n))))), c } } }; const g = function (e) { const t = e.getAttribute('data-mce-index'); return typeof t === 'number' ? `${t}` : t }; const h = function (e) { const t = e.parentNode; e.firstChild && t.insertBefore(e.firstChild, e), e.parentNode.removeChild(e) }; const d = function (e, t) { let n; const r = []; if ((n = p.toArray(e.getBody().getElementsByTagName('span'))).length) for (let a = 0; a < n.length; a++) { const o = g(n[a]); o !== null && o.length && o === t.toString() && r.push(n[a]) } return r }; const f = function (e, t, n) { let r = t.get(); const a = e.dom; (n = !1 !== n) ? r++ : r--, a.removeClass(d(e, t.get()), 'mce-match-marker-selected'); const o = d(e, r); return o.length ? (a.addClass(d(e, r), 'mce-match-marker-selected'), e.selection.scrollIntoView(o[0]), r) : -1 }; const m = function (e, t) { const n = t.parentNode; e.remove(t), e.isEmpty(n) && e.remove(n) }; const v = function (e, t) { const n = f(e, t, !0); n !== -1 && t.set(n) }; const b = function (e, t) { const n = f(e, t, !1); n !== -1 && t.set(n) }; const N = function (e) { const t = g(e); return t !== null && t.length > 0 }; const y = function (e, t, n) { let r, a, o, i; for (a = p.toArray(e.getBody().getElementsByTagName('span')), r = 0; r < a.length; r++) { const d = g(a[r]); d !== null && d.length && (d === t.get().toString() && (o || (o = a[r].firstChild), i = a[r].firstChild), h(a[r])) } if (o && i) { const c = e.dom.createRng(); return c.setStart(o, 0), c.setEnd(i, i.data.length), !1 !== n && e.selection.setRng(c), c } }; const w = function (e, t) { return d(e, t.get() + 1).length > 0 }; const C = function (e, t) { return d(e, t.get() - 1).length > 0 }; const u = { done: y, find(e, t, n, r, a) { n = (n = n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&')).replace(/\s/g, '[^\\S\\r\\n]'), n = a ? `\\b${n}\\b` : n; let o; let i; let d; let c; let l; const u = (o = e, i = t, d = new RegExp(n, r ? 'g' : 'gi'), (l = o.dom.create('span', { 'data-mce-bogus': 1 })).className = 'mce-match-marker', c = o.getBody(), y(o, i, !1), s.findAndReplaceDOMText(d, c, l, !1, o.schema)); return u && (t.set(-1), t.set(f(e, t, !0))), u }, next: v, prev: b, replace(e, t, n, r, a) { let o; let i; let d; let c; let l; let u; let s = t.get(); for (r = !1 !== r, d = e.getBody(), i = p.grep(p.toArray(d.getElementsByTagName('span')), N), o = 0; o < i.length; o++) { const f = g(i[o]); if (c = l = parseInt(f, 10), a || c === t.get()) { for (n.length ? (i[o].firstChild.nodeValue = n, h(i[o])) : m(e.dom, i[o]); i[++o];) { if ((c = parseInt(g(i[o]), 10)) !== l) { o--; break }m(e.dom, i[o]) }r && s-- } else l > t.get() && i[o].setAttribute('data-mce-index', l - 1) } return t.set(s), r ? (u = w(e, t), v(e, t)) : (u = C(e, t), b(e, t)), !a && u }, hasNext: w, hasPrev: C }; const c = function (r, a) { return { done(e) { return u.done(r, a, e) }, find(e, t, n) { return u.find(r, a, e, t, n) }, next() { return u.next(r, a) }, prev() { return u.prev(r, a) }, replace(e, t, n) { return u.replace(r, a, e, t, n) } } }; const l = function (e) { return function () { return e } }; const T = l(!1); const k = l(!0); const A = function () { return S }; var S = (o = { fold(e, t) { return e() }, is: T, isSome: T, isNone: k, getOr: a = function (e) { return e }, getOrThunk: n = function (e) { return e() }, getOrDie(e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: a, orThunk: n, map: A, ap: A, each() {}, bind: A, flatten: A, exists: T, forall: k, filter: A, equals: t = function (e) { return e.isNone() }, equals_: t, toArray() { return [] }, toString: l('none()') }, Object.freeze && Object.freeze(o), o); const B = (i = 'function', function (e) { return (function (e) { if (e === null) return 'null'; const t = typeof e; return t === 'object' && Array.prototype.isPrototypeOf(e) ? 'array' : t === 'object' && String.prototype.isPrototypeOf(e) ? 'string' : t }(e)) === i }); const I = (Array.prototype.slice, B(Array.from) && Array.from, function (e) { return e === 'checked' }); const E = function (r, a) { let e; let o = {}; function i(e) { (u.hasNext(r, a) ? e.enable : e.disable)('next'), (u.hasPrev(r, a) ? e.enable : e.disable)('prev') }r.undoManager.add(), e = p.trim(r.selection.getContent({ format: 'text' })); const d = function (e, t) { !(function (e, t) { for (let n = 0, r = e.length; n < r; n++)t(e[n], n, e) }(['replace', 'replaceall', 'prev', 'next'], t ? e.disable : e.enable)) }; function c(e) { r.windowManager.alert('Could not find the specified string.', () => { e.focus('findtext') }) } const l = function (e) { const t = e.getData(); if (!t.findtext.length) return u.done(r, a, !1), d(e, !0), void i(e); if (o.text === t.findtext && o.caseState === t.matchcase && o.wholeWord === t.wholewords) return u.hasNext(r, a) ? (u.next(r, a), void i(e)) : void c(e); const n = u.find(r, a, t.findtext, I(t.matchcase), I(t.wholewords)); n || c(e), d(e, n === 0), i(e), o = { text: t.findtext, caseState: t.matchcase, wholeWord: t.wholewords } }; const t = { findtext: e, replacetext: '', matchcase: 'unchecked', wholewords: 'unchecked' }; r.windowManager.open({ title: 'Find and Replace', size: 'normal', body: { type: 'panel', items: [{ type: 'input', name: 'findtext', label: 'Find' }, { type: 'input', name: 'replacetext', label: 'Replace with' }, { type: 'grid', columns: 2, items: [{ type: 'checkbox', name: 'matchcase', label: 'Match case' }, { type: 'checkbox', name: 'wholewords', label: 'Find whole words only' }] }] }, buttons: [{ type: 'custom', name: 'find', text: 'Find', align: 'start', primary: !0 }, { type: 'custom', name: 'replace', text: 'Replace', align: 'start', disabled: !0 }, { type: 'custom', name: 'replaceall', text: 'Replace All', align: 'start', disabled: !0 }, { type: 'custom', name: 'prev', text: 'Previous', align: 'end', icon: 'arrow-left', disabled: !0 }, { type: 'custom', name: 'next', text: 'Next', align: 'end', icon: 'arrow-right', disabled: !0 }], initialData: t, onAction(e, t) { const n = e.getData(); switch (t.name) { case 'find':l(e); break; case 'replace':u.replace(r, a, n.replacetext) || (d(e, !0), a.set(-1), o = {}); break; case 'replaceall':u.replace(r, a, n.replacetext, !0, !0), d(e, !0), o = {}; break; case 'prev':u.prev(r, a), i(e); break; case 'next':u.next(r, a), i(e) } }, onSubmit: l, onClose() { r.focus(), u.done(r, a), r.undoManager.add() } }) }; const O = function (e, t) { e.addCommand('SearchReplace', () => { E(e, t) }) }; const M = function (e, t) { return function () { E(e, t) } }; const R = function (e, t) { e.ui.registry.addMenuItem('searchreplace', { text: 'Find and replace...', shortcut: 'Meta+F', onAction: M(e, t), icon: 'search' }), e.ui.registry.addButton('searchreplace', { tooltip: 'Find and replace', onAction: M(e, t), icon: 'search' }), e.shortcuts.add('Meta+F', '', M(e, t)) }; e.add('searchreplace', (e) => { const t = r(-1); return O(e, t), R(e, t), c(e, t) }), function F() {}
}())
