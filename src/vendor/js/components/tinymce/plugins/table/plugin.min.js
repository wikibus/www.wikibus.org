!(function () {
  const e = tinymce.util.Tools.resolve('tinymce.PluginManager'); const y = function () { for (let e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t] }; const x = function (n, r) { return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return n(r.apply(null, e)) } }; const C = function (e) { return function () { return e } }; const o = function (e) { return e }; function b(r) { for (var o = [], e = 1; e < arguments.length; e++)o[e - 1] = arguments[e]; return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; const n = o.concat(e); return r.apply(null, n) } } let t; let n; let r; let i; let u; const m = function (n) { return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return !n.apply(null, e) } }; const a = function (e) { return e() }; const c = C(!1); const l = C(!0); const f = c; const s = l; const d = function () { return g }; var g = (i = { fold(e, t) { return e() }, is: f, isSome: f, isNone: s, getOr: r = function (e) { return e }, getOrThunk: n = function (e) { return e() }, getOrDie(e) { throw new Error(e || 'error: getOrDie called on none.') }, getOrNull() { return null }, getOrUndefined() { return undefined }, or: r, orThunk: n, map: d, ap: d, each() {}, bind: d, flatten: d, exists: f, forall: s, filter: d, equals: t = function (e) { return e.isNone() }, equals_: t, toArray() { return [] }, toString: C('none()') }, Object.freeze && Object.freeze(i), i); var p = function (n) { const e = function () { return n }; const t = function () { return o }; const r = function (e) { return e(n) }; var o = { fold(e, t) { return t(n) }, is(e) { return n === e }, isSome: s, isNone: f, getOr: e, getOrThunk: e, getOrDie: e, getOrNull: e, getOrUndefined: e, or: t, orThunk: t, map(e) { return p(e(n)) }, ap(e) { return e.fold(d, (e) => p(e(n))) }, each(e) { e(n) }, bind: r, flatten: e, exists: r, forall: r, filter(e) { return e(n) ? o : g }, equals(e) { return e.is(n) }, equals_(e, t) { return e.fold(f, (e) => t(n, e)) }, toArray() { return [n] }, toString() { return `some(${n})` } }; return o }; const S = { some: p, none: d, from(e) { return e === null || e === undefined ? g : p(e) } }; const h = function (t) { return function (e) { return (function (e) { if (e === null) return 'null'; const t = typeof e; return t === 'object' && Array.prototype.isPrototypeOf(e) ? 'array' : t === 'object' && String.prototype.isPrototypeOf(e) ? 'string' : t }(e)) === t } }; const v = h('string'); const w = h('array'); const R = h('boolean'); const T = h('function'); const D = h('number'); const O = (u = Array.prototype.indexOf) === undefined ? function (e, t) { return _(e, t) } : function (e, t) { return u.call(e, t) }; const A = function (e, t) { return O(e, t) > -1 }; const E = function (e, t) { return W(e, t).isSome() }; const N = function (e, t) { for (var n = e.length, r = new Array(n), o = 0; o < n; o++) { const i = e[o]; r[o] = t(i, o, e) } return r }; const k = function (e, t) { for (let n = 0, r = e.length; n < r; n++)t(e[n], n, e) }; const I = function (e, t) { for (var n = [], r = 0, o = e.length; r < o; r++) { const i = e[r]; t(i, r, e) && n.push(i) } return n }; const P = function (e, t, n) { return (function (e, t) { for (let n = e.length - 1; n >= 0; n--)t(e[n], n, e) }(e, (e) => { n = t(n, e) })), n }; const B = function (e, t, n) { return k(e, (e) => { n = t(n, e) }), n }; const M = function (e, t) { for (let n = 0, r = e.length; n < r; n++) { const o = e[n]; if (t(o, n, e)) return S.some(o) } return S.none() }; var W = function (e, t) { for (let n = 0, r = e.length; n < r; n++) if (t(e[n], n, e)) return S.some(n); return S.none() }; var _ = function (e, t) { for (let n = 0, r = e.length; n < r; ++n) if (e[n] === t) return n; return -1 }; const L = Array.prototype.push; const j = function (e) { for (var t = [], n = 0, r = e.length; n < r; ++n) { if (!Array.prototype.isPrototypeOf(e[n])) throw new Error(`Arr.flatten item ${n} was not an array, input: ${e}`); L.apply(t, e[n]) } return t }; const z = function (e, t) { const n = N(e, t); return j(n) }; const H = function (e, t) { for (let n = 0, r = e.length; n < r; ++n) if (!0 !== t(e[n], n, e)) return !1; return !0 }; const F = Array.prototype.slice; const U = function (e) { const t = F.call(e, 0); return t.reverse(), t }; const q = (T(Array.from) && Array.from, Object.keys); const V = Object.hasOwnProperty; const G = function (e, t) { for (let n = q(e), r = 0, o = n.length; r < o; r++) { const i = n[r]; t(e[i], i, e) } }; const Y = function (e, r) { return K(e, (e, t, n) => ({ k: t, v: r(e, t, n) })) }; var K = function (r, o) { const i = {}; return G(r, (e, t) => { const n = o(e, t, r); i[n.k] = n.v }), i }; const X = function (e, t) { return $(e, t) ? S.some(e[t]) : S.none() }; var $ = function (e, t) { return V.call(e, t) }; const J = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return function () { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; if (t.length !== n.length) throw new Error(`Wrong number of arguments to struct. Expected "[${t.length}]", got ${n.length} arguments`); const r = {}; return k(t, (e, t) => { r[e] = C(n[t]) }), r } }; const Q = function (e) { return e.slice(0).sort() }; const Z = function (e, t) { throw new Error(`All required keys (${Q(e).join(', ')}) were not specified. Specified keys were: ${Q(t).join(', ')}.`) }; const ee = function (e) { throw new Error(`Unsupported keys for object: ${Q(e).join(', ')}`) }; const te = function (t, e) { if (!w(e)) throw new Error(`The ${t} fields must be an array. Was: ${e}.`); k(e, (e) => { if (!v(e)) throw new Error(`The value ${e} in the ${t} fields was not a string.`) }) }; const ne = function (e) { const n = Q(e); M(n, (e, t) => t < n.length - 1 && e === n[t + 1]).each((e) => { throw new Error(`The field: ${e} occurs more than once in the combined fields: [${n.join(', ')}].`) }) }; const re = function (o, i) { const u = o.concat(i); if (u.length === 0) throw new Error('You must specify at least one required or optional field.'); return te('required', o), te('optional', i), ne(u), function (t) { const n = q(t); H(o, (e) => A(n, e)) || Z(o, n); const e = I(n, (e) => !A(u, e)); e.length > 0 && ee(e); const r = {}; return k(o, (e) => { r[e] = C(t[e]) }), k(i, (e) => { r[e] = C(Object.prototype.hasOwnProperty.call(t, e) ? S.some(t[e]) : S.none()) }), r } }; const oe = J('width', 'height'); const ie = J('rows', 'columns'); const ue = J('row', 'column'); const ce = J('x', 'y'); const ae = J('element', 'rowspan', 'colspan'); const le = J('element', 'rowspan', 'colspan', 'isNew'); const fe = { dimensions: oe, grid: ie, address: ue, coords: ce, extended: J('element', 'rowspan', 'colspan', 'row', 'column'), detail: ae, detailnew: le, rowdata: J('element', 'cells', 'section'), elementnew: J('element', 'isNew'), rowdatanew: J('element', 'cells', 'section', 'isNew'), rowcells: J('cells', 'section'), rowdetails: J('details', 'section'), bounds: J('startRow', 'startCol', 'finishRow', 'finishCol') }; const se = function (e) { if (e === null || e === undefined) throw new Error('Node cannot be null or undefined'); return { dom: C(e) } }; const de = { fromHtml(e, t) { const n = (t || document).createElement('div'); if (n.innerHTML = e, !n.hasChildNodes() || n.childNodes.length > 1) throw console.error('HTML does not have a single root node', e), new Error('HTML must have a single root node'); return se(n.childNodes[0]) }, fromTag(e, t) { const n = (t || document).createElement(e); return se(n) }, fromText(e, t) { const n = (t || document).createTextNode(e); return se(n) }, fromDom: se, fromPoint(e, t, n) { const r = e.dom(); return S.from(r.elementFromPoint(t, n)).map(se) } }; const me = (Node.ATTRIBUTE_NODE, Node.CDATA_SECTION_NODE, Node.COMMENT_NODE); const ge = Node.DOCUMENT_NODE; const pe = (Node.DOCUMENT_TYPE_NODE, Node.DOCUMENT_FRAGMENT_NODE, Node.ELEMENT_NODE); const he = Node.TEXT_NODE; const ve = (Node.PROCESSING_INSTRUCTION_NODE, Node.ENTITY_REFERENCE_NODE, Node.ENTITY_NODE, Node.NOTATION_NODE, pe); const be = ge; const we = function (e, t) { const n = e.dom(); if (n.nodeType !== ve) return !1; if (n.matches !== undefined) return n.matches(t); if (n.msMatchesSelector !== undefined) return n.msMatchesSelector(t); if (n.webkitMatchesSelector !== undefined) return n.webkitMatchesSelector(t); if (n.mozMatchesSelector !== undefined) return n.mozMatchesSelector(t); throw new Error('Browser lacks native selectors') }; const ye = function (e) { return e.nodeType !== ve && e.nodeType !== be || e.childElementCount === 0 }; const xe = typeof window !== 'undefined' ? window : Function('return this;')(); const Ce = function (e, t) { return (function (e, t) { for (var n = t !== undefined && t !== null ? t : xe, r = 0; r < e.length && n !== undefined && n !== null; ++r)n = n[e[r]]; return n }(e.split('.'), t)) }; const Se = function (e, t) { const n = Ce(e, t); if (n === undefined || n === null) throw `${e} not available on this browser`; return n }; const Re = function () { return Se('Node') }; const Te = function (e, t, n) { return (e.compareDocumentPosition(t) & n) != 0 }; const De = function (e, t) { return Te(e, t, Re().DOCUMENT_POSITION_CONTAINED_BY) }; const Oe = function (n) { let r; let o = !1; return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return o || (o = !0, r = n.apply(null, e)), r } }; const Ae = function (e, t) { const n = (function (e, t) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (r.test(t)) return r } return undefined }(e, t)); if (!n) return { major: 0, minor: 0 }; const r = function (e) { return Number(t.replace(n, `$${e}`)) }; return Ne(r(1), r(2)) }; const Ee = function () { return Ne(0, 0) }; var Ne = function (e, t) { return { major: e, minor: t } }; const ke = { nu: Ne, detect(e, t) { const n = String(t).toLowerCase(); return e.length === 0 ? Ee() : Ae(e, n) }, unknown: Ee }; const Ie = 'Firefox'; const Pe = function (e, t) { return function () { return t === e } }; const Be = function (e) { const t = e.current; return { current: t, version: e.version, isEdge: Pe('Edge', t), isChrome: Pe('Chrome', t), isIE: Pe('IE', t), isOpera: Pe('Opera', t), isFirefox: Pe(Ie, t), isSafari: Pe('Safari', t) } }; const Me = { unknown() { return Be({ current: undefined, version: ke.unknown() }) }, nu: Be, edge: C('Edge'), chrome: C('Chrome'), ie: C('IE'), opera: C('Opera'), firefox: C(Ie), safari: C('Safari') }; const We = 'Windows'; const _e = 'Android'; const Le = 'Solaris'; const je = 'FreeBSD'; const ze = function (e, t) { return function () { return t === e } }; const He = function (e) { const t = e.current; return { current: t, version: e.version, isWindows: ze(We, t), isiOS: ze('iOS', t), isAndroid: ze(_e, t), isOSX: ze('OSX', t), isLinux: ze('Linux', t), isSolaris: ze(Le, t), isFreeBSD: ze(je, t) } }; const Fe = { unknown() { return He({ current: undefined, version: ke.unknown() }) }, nu: He, windows: C(We), ios: C('iOS'), android: C(_e), linux: C('Linux'), osx: C('OSX'), solaris: C(Le), freebsd: C(je) }; const Ue = function (e, t) { const n = String(t).toLowerCase(); return M(e, (e) => e.search(n)) }; const qe = function (e, n) { return Ue(e, n).map((e) => { const t = ke.detect(e.versionRegexes, n); return { current: e.name, version: t } }) }; const Ve = function (e, n) { return Ue(e, n).map((e) => { const t = ke.detect(e.versionRegexes, n); return { current: e.name, version: t } }) }; const Ge = function (e, t, n) { return t === '' || !(e.length < t.length) && e.substr(n, n + t.length) === t }; const Ye = function (e, t) { return e.indexOf(t) !== -1 }; const Ke = function (e, t) { return Ge(e, t, 0) }; const Xe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/; const $e = function (t) { return function (e) { return Ye(e, t) } }; const Je = [{ name: 'Edge', versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search(e) { return Ye(e, 'edge/') && Ye(e, 'chrome') && Ye(e, 'safari') && Ye(e, 'applewebkit') } }, { name: 'Chrome', versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Xe], search(e) { return Ye(e, 'chrome') && !Ye(e, 'chromeframe') } }, { name: 'IE', versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search(e) { return Ye(e, 'msie') || Ye(e, 'trident') } }, { name: 'Opera', versionRegexes: [Xe, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: $e('opera') }, { name: 'Firefox', versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: $e('firefox') }, { name: 'Safari', versionRegexes: [Xe, /.*?cpu os ([0-9]+)_([0-9]+).*/], search(e) { return (Ye(e, 'safari') || Ye(e, 'mobile/')) && Ye(e, 'applewebkit') } }]; const Qe = [{ name: 'Windows', search: $e('win'), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'iOS', search(e) { return Ye(e, 'iphone') || Ye(e, 'ipad') }, versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: 'Android', search: $e('android'), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: 'OSX', search: $e('os x'), versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: 'Linux', search: $e('linux'), versionRegexes: [] }, { name: 'Solaris', search: $e('sunos'), versionRegexes: [] }, { name: 'FreeBSD', search: $e('freebsd'), versionRegexes: [] }]; const Ze = { browsers: C(Je), oses: C(Qe) }; const et = function (e) { let t; let n; let r; let o; let i; let u; let c; let a; let l; let f; let s; const d = Ze.browsers(); const m = Ze.oses(); const g = qe(d, e).fold(Me.unknown, Me.nu); const p = Ve(m, e).fold(Fe.unknown, Fe.nu); return { browser: g, os: p, deviceType: (n = g, r = e, o = (t = p).isiOS() && !0 === /ipad/i.test(r), i = t.isiOS() && !o, u = t.isAndroid() && t.version.major === 3, c = t.isAndroid() && t.version.major === 4, a = o || u || c && !0 === /mobile/i.test(r), l = t.isiOS() || t.isAndroid(), f = l && !a, s = n.isSafari() && t.isiOS() && !1 === /safari/i.test(r), { isiPad: C(o), isiPhone: C(i), isTablet: C(a), isPhone: C(f), isTouch: C(l), isAndroid: t.isAndroid, isiOS: t.isiOS, isWebView: C(s) }) } }; const tt = { detect: Oe(() => { const e = navigator.userAgent; return et(e) }) }; const nt = function (e, t) { return e.dom() === t.dom() }; const rt = tt.detect().browser.isIE() ? function (e, t) { return De(e.dom(), t.dom()) } : function (e, t) { const n = e.dom(); const r = t.dom(); return n !== r && n.contains(r) }; const ot = we; const it = function (e) { return de.fromDom(e.dom().ownerDocument) }; const ut = function (e) { const t = e.dom(); return S.from(t.parentNode).map(de.fromDom) }; const ct = function (e, t) { for (var n = T(t) ? t : C(!1), r = e.dom(), o = []; r.parentNode !== null && r.parentNode !== undefined;) { const i = r.parentNode; const u = de.fromDom(i); if (o.push(u), !0 === n(u)) break; r = i } return o }; const at = function (e) { const t = e.dom(); return S.from(t.previousSibling).map(de.fromDom) }; const lt = function (e) { const t = e.dom(); return S.from(t.nextSibling).map(de.fromDom) }; const ft = function (e) { const t = e.dom(); return N(t.childNodes, de.fromDom) }; const st = function (e, t) { const n = e.dom().childNodes; return S.from(n[t]).map(de.fromDom) }; var dt = (J('element', 'offset'), function (e, t, n) { return z(ft(e), (e) => we(e, t) ? n(e) ? [e] : [] : dt(e, t, n)) }); const mt = { firstLayer(e, t) { return dt(e, t, C(!0)) }, filterFirstLayer: dt }; const gt = function (e) { return e.dom().nodeName.toLowerCase() }; const pt = function (e) { return e.dom().nodeType }; const ht = function (t) { return function (e) { return pt(e) === t } }; const vt = function (e) { return pt(e) === me || gt(e) === '#comment' }; const bt = ht(pe); const wt = ht(he); const yt = ht(ge); const xt = function (e, t, n) { if (!(v(n) || R(n) || D(n))) throw console.error('Invalid call to Attr.set. Key ', t, ':: Value ', n, ':: Element ', e), new Error('Attribute value was not simple'); e.setAttribute(t, `${n}`) }; const Ct = function (e, t, n) { xt(e.dom(), t, n) }; const St = function (e, t) { const n = e.dom(); G(t, (e, t) => { xt(n, t, e) }) }; const Rt = function (e, t) { const n = e.dom().getAttribute(t); return n === null ? undefined : n }; const Tt = function (e, t) { const n = e.dom(); return !(!n || !n.hasAttribute) && n.hasAttribute(t) }; const Dt = function (e, t) { e.dom().removeAttribute(t) }; const Ot = function (e) { return B(e.dom().attributes, (e, t) => e[t.name] = t.value, e, {}) }; const At = function (e) { const t = wt(e) ? e.dom().parentNode : e.dom(); return t !== undefined && t !== null && t.ownerDocument.body.contains(t) }; const Et = Oe(() => Nt(de.fromDom(document))); var Nt = function (e) { const t = e.dom().body; if (t === null || t === undefined) throw new Error('Body is not available yet'); return de.fromDom(t) }; var kt = function (e, t) { let n = []; return k(ft(e), (e) => { t(e) && (n = n.concat([e])), n = n.concat(kt(e, t)) }), n }; const It = function (e, t, n) { return r = function (e) { return we(e, t) }, I(ct(e, n), r); let r }; const Pt = function (e, t) { return n = function (e) { return we(e, t) }, I(ft(e), n); let n }; const Bt = function (e, t) { return n = t, o = (r = e) === undefined ? document : r.dom(), ye(o) ? [] : N(o.querySelectorAll(n), de.fromDom); let n, r, o }; function Mt(e, t, n, r, o) { return e(n, r) ? S.some(n) : T(o) && o(n) ? S.none() : t(n, r, o) } const Wt = function (e, t, n) { for (let r = e.dom(), o = T(n) ? n : C(!1); r.parentNode;) { r = r.parentNode; const i = de.fromDom(r); if (t(i)) return S.some(i); if (o(i)) break } return S.none() }; const _t = function (e, t, n) { return Wt(e, (e) => we(e, t), n) }; const Lt = function (e, t) { return n = function (e) { return we(e, t) }, M(e.dom().childNodes, x(n, de.fromDom)).map(de.fromDom); let n }; const jt = function (e, t) { return n = t, o = (r = e) === undefined ? document : r.dom(), ye(o) ? S.none() : S.from(o.querySelector(n)).map(de.fromDom); let n, r, o }; const zt = function (e, t, n) { return Mt(we, _t, e, t, n) }; const Ht = function (e, t, n) { const r = n !== undefined ? n : C(!1); return r(t) ? S.none() : A(e, gt(t)) ? S.some(t) : _t(t, e.join(','), (e) => we(e, 'table') || r(e)) }; const Ft = function (t, e) { return ut(e).map((e) => Pt(e, t)) }; const Ut = b(Ft, 'th,td'); const qt = b(Ft, 'tr'); const Vt = function (e, t) { return parseInt(Rt(e, t), 10) }; const Gt = { cell(e, t) { return Ht(['td', 'th'], e, t) }, firstCell(e) { return jt(e, 'th,td') }, cells(e) { return mt.firstLayer(e, 'th,td') }, neighbourCells: Ut, table(e, t) { return zt(e, 'table', t) }, row(e, t) { return Ht(['tr'], e, t) }, rows(e) { return mt.firstLayer(e, 'tr') }, notCell(e, t) { return Ht(['caption', 'tr', 'tbody', 'tfoot', 'thead'], e, t) }, neighbourRows: qt, attr: Vt, grid(e, t, n) { const r = Vt(e, t); const o = Vt(e, n); return fe.grid(r, o) } }; const Yt = function (e) { const t = Gt.rows(e); return N(t, (e) => { const t = e; const n = ut(t).map((e) => { const t = gt(e); return t === 'tfoot' || t === 'thead' || t === 'tbody' ? t : 'tbody' }).getOr('tbody'); const r = N(Gt.cells(e), (e) => { const t = Tt(e, 'rowspan') ? parseInt(Rt(e, 'rowspan'), 10) : 1; const n = Tt(e, 'colspan') ? parseInt(Rt(e, 'colspan'), 10) : 1; return fe.detail(e, t, n) }); return fe.rowdata(t, r, n) }) }; const Kt = function (e, n) { return N(e, (e) => { const t = N(Gt.cells(e), (e) => { const t = Tt(e, 'rowspan') ? parseInt(Rt(e, 'rowspan'), 10) : 1; const n = Tt(e, 'colspan') ? parseInt(Rt(e, 'colspan'), 10) : 1; return fe.detail(e, t, n) }); return fe.rowdata(e, t, n.section()) }) }; const Xt = function (e, t) { return `${e},${t}` }; const $t = function (e, t) { const n = z(e.all(), (e) => e.cells()); return I(n, t) }; const Jt = { generate(e) { const f = {}; const t = []; const n = e.length; let s = 0; k(e, (e, a) => { const l = []; k(e.cells(), (e, t) => { for (var n = 0; f[Xt(a, n)] !== undefined;)n++; for (var r = fe.extended(e.element(), e.rowspan(), e.colspan(), a, n), o = 0; o < e.colspan(); o++) for (let i = 0; i < e.rowspan(); i++) { const u = n + o; const c = Xt(a + i, u); f[c] = r, s = Math.max(s, u + 1) }l.push(r) }), t.push(fe.rowdata(e.element(), l, e.section())) }); const r = fe.grid(n, s); return { grid: C(r), access: C(f), all: C(t) } }, getAt(e, t, n) { const r = e.access()[Xt(t, n)]; return r !== undefined ? S.some(r) : S.none() }, findItem(e, t, n) { const r = $t(e, (e) => n(t, e.element())); return r.length > 0 ? S.some(r[0]) : S.none() }, filterItems: $t, justCells(e) { const t = N(e.all(), (e) => e.cells()); return j(t) } }; const Qt = function (e) { return e.style !== undefined }; const Zt = function (e, t, n) { if (!v(n)) throw console.error('Invalid call to CSS.set. Property ', t, ':: Value ', n, ':: Element ', e), new Error(`CSS value must be a string: ${n}`); Qt(e) && e.style.setProperty(t, n) }; const en = function (e, t, n) { const r = e.dom(); Zt(r, t, n) }; const tn = function (e, t) { const n = e.dom(); G(t, (e, t) => { Zt(n, t, e) }) }; const nn = function (e, t) { const n = e.dom(); const r = window.getComputedStyle(n).getPropertyValue(t); const o = r !== '' || At(e) ? r : rn(n, t); return o === null ? undefined : o }; var rn = function (e, t) { return Qt(e) ? e.style.getPropertyValue(t) : '' }; const on = function (e, t) { const n = e.dom(); const r = rn(n, t); return S.from(r).filter((e) => e.length > 0) }; const un = function (e, t) { let n; let r; const o = e.dom(); r = t, Qt(n = o) && n.style.removeProperty(r), Tt(e, 'style') && Rt(e, 'style').replace(/^\s+|\s+$/g, '') === '' && Dt(e, 'style') }; const cn = function (t, n) { ut(t).each((e) => { e.dom().insertBefore(n.dom(), t.dom()) }) }; const an = function (e, t) { lt(e).fold(() => { ut(e).each((e) => { fn(e, t) }) }, (e) => { cn(e, t) }) }; const ln = function (t, n) { st(t, 0).fold(() => { fn(t, n) }, (e) => { t.dom().insertBefore(n.dom(), e.dom()) }) }; var fn = function (e, t) { e.dom().appendChild(t.dom()) }; const sn = function (e, t) { cn(e, t), fn(t, e) }; const dn = function (r, o) { k(o, (e, t) => { const n = t === 0 ? r : o[t - 1]; an(n, e) }) }; const mn = function (t, e) { k(e, (e) => { fn(t, e) }) }; const gn = function (e) { e.dom().textContent = '', k(ft(e), (e) => { pn(e) }) }; var pn = function (e) { const t = e.dom(); t.parentNode !== null && t.parentNode.removeChild(t) }; const hn = function (e) { let t; const n = ft(e); n.length > 0 && (t = e, k(n, (e) => { cn(t, e) })), pn(e) }; const vn = J('minRow', 'minCol', 'maxRow', 'maxCol'); const bn = function (e, t) { let n; let i; let r; let u; let c; let a; let l; let o; let f; let s; const d = function (e) { return we(e.element(), t) }; const m = Yt(e); const g = Jt.generate(m); const p = (i = d, r = (n = g).grid().columns(), u = n.grid().rows(), c = r, l = a = 0, G(n.access(), (e) => { if (i(e)) { const t = e.row(); const n = t + e.rowspan() - 1; const r = e.column(); const o = r + e.colspan() - 1; t < u ? u = t : a < n && (a = n), r < c ? c = r : l < o && (l = o) } }), vn(u, c, a, l)); const h = `th:not(${t}),td:not(${t})`; const v = mt.filterFirstLayer(e, 'th,td', (e) => we(e, h)); return k(v, pn), (function (e, t, n, r) { for (var o, i, u, c = t.grid().columns(), a = t.grid().rows(), l = 0; l < a; l++) for (let f = !1, s = 0; s < c; s++)l < n.minRow() || l > n.maxRow() || s < n.minCol() || s > n.maxCol() || (Jt.getAt(t, l, s).filter(r).isNone() ? (o = f, i = e[l].element(), u = de.fromTag('td'), fn(u, de.fromTag('br')), (o ? fn : ln)(i, u)) : f = !0) }(m, g, p, d)), o = e, f = p, s = I(mt.firstLayer(o, 'tr'), (e) => e.dom().childElementCount === 0), k(s, pn), f.minCol() !== f.maxCol() && f.minRow() !== f.maxRow() || k(mt.firstLayer(o, 'th,td'), (e) => { Dt(e, 'rowspan'), Dt(e, 'colspan') }), Dt(o, 'width'), Dt(o, 'height'), un(o, 'width'), un(o, 'height'), e }; const wn = function (e, t) { return de.fromDom(e.dom().cloneNode(t)) }; const yn = function (e) { return wn(e, !1) }; const xn = function (e) { return wn(e, !0) }; const Cn = function (e, t) { let n; let r; let o; let i; const u = (n = e, r = t, o = de.fromTag(r), i = Ot(n), St(o, i), o); const c = ft(xn(e)); return mn(u, c), u }; const Sn = (function ls(n, r) { const o = function (e) { return n(e) ? S.from(e.dom().nodeValue) : S.none() }; const e = tt.detect().browser; const t = e.isIE() && e.version.major === 10 ? function (e) { try { return o(e) } catch (t) { return S.none() } } : o; return { get(e) { if (!n(e)) throw new Error(`Can only get ${r} value of a ${r} node`); return t(e).getOr('') }, getOption: t, set(e, t) { if (!n(e)) throw new Error(`Can only set raw ${r} value of a ${r} node`); e.dom().nodeValue = t } } }(wt, 'text')); const Rn = function (e) { return Sn.get(e) }; const Tn = function (e) { return Sn.getOption(e) }; const Dn = function (e, t) { Sn.set(e, t) }; const On = function (e) { return gt(e) === 'img' ? 1 : Tn(e).fold(() => ft(e).length, (e) => e.length) }; const An = ['img', 'br']; const En = function (e) { return Tn(e).filter((e) => e.trim().length !== 0 || e.indexOf('\xa0') > -1).isSome() || A(An, gt(e)) }; const Nn = function (e) { return r = En, (o = function (e) { for (let t = 0; t < e.childNodes.length; t++) { if (r(de.fromDom(e.childNodes[t]))) return S.some(de.fromDom(e.childNodes[t])); const n = o(e.childNodes[t]); if (n.isSome()) return n } return S.none() })(e.dom()); let r, o }; const kn = function (e) { return In(e, En) }; var In = function (e, i) { var u = function (e) { for (let t = ft(e), n = t.length - 1; n >= 0; n--) { const r = t[n]; if (i(r)) return S.some(r); const o = u(r); if (o.isSome()) return o } return S.none() }; return u(e) }; const Pn = function () { const e = de.fromTag('td'); return fn(e, de.fromTag('br')), e }; const Bn = function (e, t, n) { const r = Cn(e, t); return G(n, (e, t) => { e === null ? Dt(r, t) : Ct(r, t, e) }), r }; const Mn = function (e) { return e }; const Wn = function (e) { return function () { return de.fromTag('tr', e.dom()) } }; const _n = function (d, e, m) { return { row: Wn(e), cell(e) { let r; let o; let i; let t; let n; let u; let c; const a = it(e.element()); const l = de.fromTag(gt(e.element()), a.dom()); const f = m.getOr(['strong', 'em', 'b', 'i', 'span', 'font', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div']); const s = f.length > 0 ? (r = e.element(), o = l, i = f, Nn(r).map((e) => { const t = i.join(','); const n = It(e, t, (e) => nt(e, r)); return P(n, (e, t) => { const n = yn(t); return Dt(n, 'contenteditable'), fn(e, n), n }, o) }).getOr(o)) : l; return fn(s, de.fromTag('br')), t = e.element(), n = l, u = t.dom(), c = n.dom(), Qt(u) && Qt(c) && (c.style.cssText = u.style.cssText), un(l, 'height'), e.colspan() !== 1 && un(e.element(), 'width'), d(e.element(), l), l }, replace: Bn, gap: Pn } }; const Ln = function (e) { return { row: Wn(e), cell: Pn, replace: Mn, gap: Pn } }; const jn = ['body', 'p', 'div', 'article', 'aside', 'figcaption', 'figure', 'footer', 'header', 'nav', 'section', 'ol', 'ul', 'li', 'table', 'thead', 'tbody', 'tfoot', 'caption', 'tr', 'td', 'th', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'address']; function zn() { return { up: C({ selector: _t, closest: zt, predicate: Wt, all: ct }), down: C({ selector: Bt, predicate: kt }), styles: C({ get: nn, getRaw: on, set: en, remove: un }), attrs: C({ get: Rt, set: Ct, remove: Dt, copyTo(e, t) { const n = Ot(e); St(t, n) } }), insert: C({ before: cn, after: an, afterAll: dn, append: fn, appendAll: mn, prepend: ln, wrap: sn }), remove: C({ unwrap: hn, remove: pn }), create: C({ nu: de.fromTag, clone(e) { return de.fromDom(e.dom().cloneNode(!1)) }, text: de.fromText }), query: C({ comparePosition(e, t) { return e.dom().compareDocumentPosition(t.dom()) }, prevSibling: at, nextSibling: lt }), property: C({ children: ft, name: gt, parent: ut, isText: wt, isComment: vt, isElement: bt, getText: Rn, setText: Dn, isBoundary(e) { return !!bt(e) && (gt(e) === 'body' || A(jn, gt(e))) }, isEmptyTag(e) { return !!bt(e) && A(['br', 'img', 'hr', 'input'], gt(e)) } }), eq: nt, is: ot } } const Hn = J('left', 'right'); const Fn = function (e, t, n) { const r = e.property().children(t); return W(r, b(e.eq, n)).map((e) => ({ before: C(r.slice(0, e)), after: C(r.slice(e + 1)) })) }; const Un = function (n, r, o) { return Fn(n, r, o).map((e) => { const t = n.create().clone(r); return n.insert().appendAll(t, e.before().concat([o])), n.insert().appendAll(r, e.after()), n.insert().before(r, t), Hn(t, r) }) }; const qn = function (n, r, e) { return Fn(n, r, e).map((e) => { const t = n.create().clone(r); return n.insert().appendAll(t, e.after()), n.insert().after(r, t), Hn(r, t) }) }; const Vn = function (i, e, u, c) { const r = J('first', 'second', 'splits'); var a = function (e, t, o) { const n = r(e, S.none(), o); return u(e) ? r(e, t, o) : i.property().parent(e).bind((r) => c(i, r, e).map((e) => { const t = [{ first: e.left, second: e.right }]; const n = u(r) ? r : e.left(); return a(n, S.some(e.right()), o.concat(t)) }).getOr(n)) }; return a(e, S.none(), []) }; const Gn = function (r, o, e, t) { const n = o(r, e); return P(t, (e, t) => { const n = o(r, t); return Yn(r, e, n) }, n) }; var Yn = function (t, e, n) { return e.bind((e) => n.filter(b(t.eq, e))) }; const Kn = function (e, t, n) { return n.length > 0 ? Gn(e, t, (r = n)[0], r.slice(1)) : S.none(); let r }; const Xn = function (e, t) { return b(e.eq, t) }; const $n = function (t, e, n, r) { const o = r !== undefined ? r : C(!1); const i = [e].concat(t.up().all(e)); const u = [n].concat(t.up().all(n)); const c = function (t) { return W(t, o).fold(() => t, (e) => t.slice(0, e + 1)) }; const a = c(i); const l = c(u); const f = M(a, (e) => E(l, Xn(t, e))); return { firstpath: C(a), secondpath: C(l), shared: C(f) } }; const Jn = function (t, e, n) { const r = $n(t, e, n); return r.shared().bind((e) => (function (o, i, e, t) { const u = o.property().children(i); if (o.eq(i, e[0])) return S.some([e[0]]); if (o.eq(i, t[0])) return S.some([t[0]]); const n = function (e) { const t = U(e); const n = W(t, Xn(o, i)).getOr(-1); const r = n < t.length - 1 ? t[n + 1] : t[n]; return W(u, Xn(o, r)) }; const r = n(e); const c = n(t); return r.bind((r) => c.map((e) => { const t = Math.min(r, e); const n = Math.max(r, e); return u.slice(t, n + 1) })) }(t, e, r.firstpath(), r.secondpath()))) }; const Qn = $n; const Zn = function (e, t, n) { return Kn(e, t, n) }; const er = function (e, t, n) { return Jn(e, t, n) }; const tr = function (e, t, n, r) { return Qn(e, t, n, r) }; const nr = function (e, t, n) { return Un(e, t, n) }; const rr = function (e, t, n) { return qn(e, t, n) }; const or = function (e, t, n, r) { return Vn(e, t, n, r) }; const ir = zn(); const ur = { sharedOne(n, e) { return Zn(ir, (e, t) => n(t), e) }, subset(e, t) { return er(ir, e, t) }, ancestors(e, t, n) { return tr(ir, e, t, n) }, breakToLeft(e, t) { return nr(ir, e, t) }, breakToRight(e, t) { return rr(ir, e, t) }, breakPath(e, t, r) { return or(ir, e, t, (e, t, n) => r(t, n)) } }; const cr = function (e, t) { return t.column() >= e.startCol() && t.column() + t.colspan() - 1 <= e.finishCol() && t.row() >= e.startRow() && t.row() + t.rowspan() - 1 <= e.finishRow() }; const ar = function (e, t) { const n = t.column(); const r = t.column() + t.colspan() - 1; const o = t.row(); const i = t.row() + t.rowspan() - 1; return n <= e.finishCol() && r >= e.startCol() && o <= e.finishRow() && i >= e.startRow() }; const lr = function (e, t) { for (var n = !0, r = b(cr, t), o = t.startRow(); o <= t.finishRow(); o++) for (let i = t.startCol(); i <= t.finishCol(); i++)n = n && Jt.getAt(e, o, i).exists(r); return n ? S.some(t) : S.none() }; const fr = function (e, t, n) { const r = Jt.findItem(e, t, nt); const o = Jt.findItem(e, n, nt); return r.bind((r) => o.map((e) => { return t = r, n = e, fe.bounds(Math.min(t.row(), n.row()), Math.min(t.column(), n.column()), Math.max(t.row() + t.rowspan() - 1, n.row() + n.rowspan() - 1), Math.max(t.column() + t.colspan() - 1, n.column() + n.colspan() - 1)); let t, n })) }; const sr = fr; const dr = function (t, e, n) { return fr(t, e, n).bind((e) => lr(t, e)) }; const mr = function (r, e, o, i) { return Jt.findItem(r, e, nt).bind((e) => { const t = o > 0 ? e.row() + e.rowspan() - 1 : e.row(); const n = i > 0 ? e.column() + e.colspan() - 1 : e.column(); return Jt.getAt(r, t + o, n + i).map((e) => e.element()) }) }; const gr = function (n, e, t) { return sr(n, e, t).map((e) => { const t = Jt.filterItems(n, b(ar, e)); return N(t, (e) => e.element()) }) }; const pr = function (e, t) { return Jt.findItem(e, t, (e, t) => rt(t, e)).bind((e) => e.element()) }; const hr = function (e) { const t = Yt(e); return Jt.generate(t) }; const vr = function (n, r, o) { return Gt.table(n).bind((e) => { const t = hr(e); return mr(t, n, r, o) }) }; const br = function (e, t, n) { const r = hr(e); return gr(r, t, n) }; const wr = function (e, t, n, r, o) { const i = hr(e); const u = nt(e, n) ? t : pr(i, t); const c = nt(e, o) ? r : pr(i, r); return gr(i, u, c) }; const yr = function (e, t, n) { const r = hr(e); return dr(r, t, n) }; const xr = function (e, t) { return _t(e, 'table') }; const Cr = re(['boxes', 'start', 'finish'], []); const Sr = function (c, a, r) { const l = function (t) { return function (e) { return r(e) || nt(e, t) } }; return nt(c, a) ? S.some(Cr({ boxes: S.some([c]), start: c, finish: a })) : xr(c).bind((u) => xr(a).bind((i) => { if (nt(u, i)) return S.some(Cr({ boxes: br(u, c, a), start: c, finish: a })); if (rt(u, i)) { const e = (t = It(a, 'td,th', l(u))).length > 0 ? t[t.length - 1] : a; return S.some(Cr({ boxes: wr(u, c, u, a, i), start: c, finish: e })) } if (rt(i, u)) { var t; const n = (t = It(c, 'td,th', l(i))).length > 0 ? t[t.length - 1] : c; return S.some(Cr({ boxes: wr(i, c, u, a, i), start: c, finish: n })) } return ur.ancestors(c, a).shared().bind((e) => zt(e, 'table', r).bind((e) => { const t = It(a, 'td,th', l(e)); const n = t.length > 0 ? t[t.length - 1] : a; const r = It(c, 'td,th', l(e)); const o = r.length > 0 ? r[r.length - 1] : c; return S.some(Cr({ boxes: wr(e, c, u, a, i), start: o, finish: n })) })) })) }; const Rr = Sr; const Tr = function (e, t) { const n = Bt(e, t); return n.length > 0 ? S.some(n) : S.none() }; const Dr = function (e, t, n, r, o) { return (i = e, u = o, M(i, (e) => we(e, u))).bind((e) => vr(e, t, n).bind((e) => { return n = r, _t(t = e, 'table').bind((e) => jt(e, n).bind((e) => Sr(e, t).bind((t) => t.boxes().map((e) => ({ boxes: C(e), start: C(t.start()), finish: C(t.finish()) }))))); let t, n })); let i, u }; const Or = function (e, t, r) { return jt(e, t).bind((n) => jt(e, r).bind((t) => ur.sharedOne(xr, [n, t]).map((e) => ({ first: C(n), last: C(t), table: C(e) })))) }; const Ar = function (e, t) { return Tr(e, t) }; const Er = function (o, e, t) { return Or(o, e, t).bind((n) => { const e = function (e) { return nt(o, e) }; const t = _t(n.first(), 'thead,tfoot,tbody,table', e); const r = _t(n.last(), 'thead,tfoot,tbody,table', e); return t.bind((t) => r.bind((e) => nt(t, e) ? yr(n.table(), n.first(), n.last()) : S.none())) }) }; const Nr = 'data-mce-selected'; const kr = 'data-mce-first-selected'; const Ir = 'data-mce-last-selected'; const Pr = { selected: C(Nr), selectedSelector: C('td[data-mce-selected],th[data-mce-selected]'), attributeSelector: C('[data-mce-selected]'), firstSelected: C(kr), firstSelectedSelector: C('td[data-mce-first-selected],th[data-mce-first-selected]'), lastSelected: C(Ir), lastSelectedSelector: C('td[data-mce-last-selected],th[data-mce-last-selected]') }; const Br = function (u) { if (!w(u)) throw new Error('cases must be an array'); if (u.length === 0) throw new Error('there must be at least one case'); const c = []; const n = {}; return k(u, (e, r) => { const t = q(e); if (t.length !== 1) throw new Error('one and only one name per case'); const o = t[0]; const i = e[o]; if (n[o] !== undefined) throw new Error(`duplicate key detected:${o}`); if (o === 'cata') throw new Error('cannot have a case named cata (sorry)'); if (!w(i)) throw new Error('case arguments must be an array'); c.push(o), n[o] = function () { const e = arguments.length; if (e !== i.length) throw new Error(`Wrong number of arguments to case ${o}. Expected ${i.length} (${i}), got ${e}`); for (var n = new Array(e), t = 0; t < n.length; t++)n[t] = arguments[t]; return { fold() { if (arguments.length !== u.length) throw new Error(`Wrong number of arguments to fold. Expected ${u.length}, got ${arguments.length}`); return arguments[r].apply(null, n) }, match(e) { const t = q(e); if (c.length !== t.length) throw new Error(`Wrong number of arguments to match. Expected: ${c.join(',')}\nActual: ${t.join(',')}`); if (!H(c, (e) => A(t, e))) throw new Error(`Not all branches were specified when using match. Specified: ${t.join(', ')}\nRequired: ${c.join(', ')}`); return e[o].apply(null, n) }, log(e) { console.log(e, { constructors: c, constructor: o, params: n }) } } } }), n }; const Mr = Br([{ none: [] }, { multiple: ['elements'] }, { single: ['selection'] }]); const Wr = { cata(e, t, n, r) { return e.fold(t, n, r) }, none: Mr.none, multiple: Mr.multiple, single: Mr.single }; const _r = function (e, t) { return Wr.cata(t.get(), C([]), o, C([e])) }; const Lr = function (n, e) { return Wr.cata(e.get(), S.none, (t, e) => t.length === 0 ? S.none() : Er(n, Pr.firstSelectedSelector(), Pr.lastSelectedSelector()).bind((e) => t.length > 1 ? S.some({ bounds: C(e), cells: C(t) }) : S.none()), S.none) }; const jr = function (e, t) { const n = _r(e, t); return n.length > 0 && H(n, (e) => Tt(e, 'rowspan') && parseInt(Rt(e, 'rowspan'), 10) > 1 || Tt(e, 'colspan') && parseInt(Rt(e, 'colspan'), 10) > 1) ? S.some(n) : S.none() }; const zr = _r; const Hr = function (e) { return { element: C(e), mergable: S.none, unmergable: S.none, selection: C([e]) } }; const Fr = J('element', 'clipboard', 'generators'); const Ur = { noMenu: Hr, forMenu(e, t, n) { return { element: C(n), mergable: C(Lr(t, e)), unmergable: C(jr(n, e)), selection: C(zr(n, e)) } }, notCell(e) { return Hr(e) }, paste: Fr, pasteRows(e, t, n, r, o) { return { element: C(n), mergable: S.none, unmergable: S.none, selection: C(zr(n, e)), clipboard: C(r), generators: C(o) } } }; const qr = function (f, e, s, d) { f.on('BeforeGetContent', (n) => { !0 === n.selection && Wr.cata(e.get(), y, (e) => { let t; n.preventDefault(), (t = e, Gt.table(t[0]).map(xn).map((e) => [bn(e, Pr.attributeSelector())])).each((e) => { let t; n.content = n.format === 'text' ? N(e, (e) => e.dom().innerText).join('') : (t = f, N(e, (e) => t.selection.serializer.serialize(e.dom(), {})).join('')) }) }, y) }), f.on('BeforeSetContent', (l) => { !0 === l.selection && !0 === l.paste && S.from(f.dom.getParent(f.selection.getStart(), 'th,td')).each((e) => { const a = de.fromDom(e); Gt.table(a).bind((t) => { let e; let n; let r; const o = I((e = l.content, (r = (n || document).createElement('div')).innerHTML = e, ft(de.fromDom(r))), (e) => gt(e) !== 'meta'); if (o.length === 1 && gt(o[0]) === 'table') { l.preventDefault(); const i = de.fromDom(f.getDoc()); const u = Ln(i); const c = Ur.paste(a, o[0], u); s.pasteCells(t, c).each((e) => { f.selection.setRng(e), f.focus(), d.clear(t) }) } }) }) }) }; function Vr(r, o) { const e = function (e) { const t = o(e); if (t <= 0 || t === null) { const n = nn(e, r); return parseFloat(n) || 0 } return t }; const i = function (o, e) { return B(e, (e, t) => { const n = nn(o, t); const r = n === undefined ? 0 : parseInt(n, 10); return isNaN(r) ? e : e + r }, 0) }; return { set(e, t) { if (!D(t) && !t.match(/^[0-9]+$/)) throw new Error(`${r}.set accepts only positive integer values. Value was ${t}`); const n = e.dom(); Qt(n) && (n.style[r] = `${t}px`) }, get: e, getOuter: e, aggregate: i, max(e, t, n) { const r = i(e, n); return r < t ? t - r : 0 } } } const Gr = Vr('height', (e) => { const t = e.dom(); return At(e) ? t.getBoundingClientRect().height : t.offsetHeight }); const Yr = function (e) { return Gr.get(e) }; const Kr = function (e) { return Gr.getOuter(e) }; const Xr = Vr('width', (e) => e.dom().offsetWidth); const $r = function (e) { return Xr.get(e) }; const Jr = function (e) { return Xr.getOuter(e) }; const Qr = tt.detect(); const Zr = function (e, t, n) { return r = nn(e, t), o = n, i = parseFloat(r), isNaN(i) ? o : i; let r, o, i }; const eo = function (e) { return Qr.browser.isIE() || Qr.browser.isEdge() ? (n = Zr(t = e, 'padding-top', 0), r = Zr(t, 'padding-bottom', 0), o = Zr(t, 'border-top-width', 0), i = Zr(t, 'border-bottom-width', 0), u = t.dom().getBoundingClientRect().height, nn(t, 'box-sizing') === 'border-box' ? u : u - n - r - (o + i)) : Zr(e, 'height', Yr(e)); let t, n, r, o, i, u }; const to = /(\d+(\.\d+)?)(\w|%)*/; const no = /(\d+(\.\d+)?)%/; const ro = /(\d+(\.\d+)?)px|em/; const oo = function (e, t) { en(e, 'height', `${t}px`) }; const io = function (e, t, n, r) { let o; let i; let u; let c; let a; let l; let f; const s = parseInt(e, 10); return Ge(l = e, f = '%', l.length - f.length) && gt(t) !== 'table' ? (o = t, i = s, u = n, c = r, a = Gt.table(o).map((e) => { const t = u(e); return Math.floor(i / 100 * t) }).getOr(i), c(o, a), a) : s }; const uo = function (e) { let t; const n = on(t = e, 'height').getOrThunk(() => `${eo(t)}px`); return n ? io(n, e, Yr, oo) : Yr(e) }; const co = function (e, t) { return Tt(e, t) ? parseInt(Rt(e, t), 10) : 1 }; const ao = function (e) { return on(e, 'width').fold(() => S.from(Rt(e, 'width')), (e) => S.some(e)) }; const lo = function (e, t) { return e / t.pixelWidth() * 100 }; const fo = { percentageBasedSizeRegex: C(no), pixelBasedSizeRegex: C(ro), setPixelWidth(e, t) { en(e, 'width', `${t}px`) }, setPercentageWidth(e, t) { en(e, 'width', `${t}%`) }, setHeight: oo, getPixelWidth(t, n) { return ao(t).fold(() => $r(t), (e) => (function (e, t, n) { if (ro.test(t)) { const r = ro.exec(t); return parseInt(r[1], 10) } if (no.test(t)) { const o = no.exec(t); const i = parseFloat(o[1]); return i / 100 * n.pixelWidth() } return $r(e) }(t, e, n))) }, getPercentageWidth(t, n) { return ao(t).fold(() => { const e = $r(t); return lo(e, n) }, (e) => (function (e, t, n) { if (no.test(t)) { const r = no.exec(t); return parseFloat(r[1]) } const o = $r(e); return lo(o, n) }(t, e, n))) }, getGenericWidth(e) { return ao(e).bind((e) => { if (to.test(e)) { const t = to.exec(e); return S.some({ width: C(t[1]), unit: C(t[3]) }) } return S.none() }) }, setGenericWidth(e, t, n) { en(e, 'width', t + n) }, getHeight(e) { return n = 'rowspan', uo(t = e) / co(t, n); let t, n }, getRawWidth: ao }; const so = function (n, r) { fo.getGenericWidth(n).each((e) => { const t = e.width() / 2; fo.setGenericWidth(n, t, e.unit()), fo.setGenericWidth(r, t, e.unit()) }) }; var mo = function (n, r) { return { left: C(n), top: C(r), translate(e, t) { return mo(n + e, r + t) } } }; const go = mo; const po = function (e, t) { return e !== undefined ? e : t !== undefined ? t : 0 }; const ho = function (e) { let t; let n; const r = e.dom().ownerDocument; const o = r.body; const i = (t = de.fromDom(r), (n = t.dom()) === n.window && t instanceof Window ? t : yt(t) ? n.defaultView || n.parentWindow : null); const u = r.documentElement; const c = po(i.pageYOffset, u.scrollTop); const a = po(i.pageXOffset, u.scrollLeft); const l = po(u.clientTop, o.clientTop); const f = po(u.clientLeft, o.clientLeft); return vo(e).translate(a - f, c - l) }; var vo = function (e) { let t; let n; let r; const o = e.dom(); const i = o.ownerDocument; const u = i.body; const c = de.fromDom(i.documentElement); return u === o ? go(u.offsetLeft, u.offsetTop) : (t = e, n = c || de.fromDom(document.documentElement), Wt(t, b(nt, n)).isSome() ? (r = o.getBoundingClientRect(), go(r.left, r.top)) : go(0, 0)) }; const bo = J('row', 'y'); const wo = J('col', 'x'); const yo = function (e) { return ho(e).left() + Jr(e) }; const xo = function (e) { return ho(e).left() }; const Co = function (e, t) { return wo(e, xo(t)) }; const So = function (e, t) { return wo(e, yo(t)) }; const Ro = function (e) { return ho(e).top() }; const To = function (n, t, r) { if (r.length === 0) return []; const e = N(r.slice(1), (e, t) => e.map((e) => n(t, e))); const o = r[r.length - 1].map((e) => t(r.length - 1, e)); return e.concat([o]) }; const Do = { delta: o, positions: b(To, (e, t) => bo(e, Ro(t)), (e, t) => bo(e, Ro(t) + Kr(t))), edge: Ro }; const Oo = { delta: o, edge: xo, positions: b(To, Co, So) }; const Ao = { height: Do, rtl: { delta(e, t) { return -e }, edge: yo, positions: b(To, So, Co) }, ltr: Oo }; const Eo = { ltr: Ao.ltr, rtl: Ao.rtl }; function No(t) { const n = function (e) { return t(e).isRtl() ? Eo.rtl : Eo.ltr }; return { delta(e, t) { return n(t).delta(e, t) }, edge(e) { return n(e).edge(e) }, positions(e, t) { return n(t).positions(e, t) } } } let ko; const Io = function (e) { const t = Yt(e); return Jt.generate(t).grid() }; var Po = function (e) { let t = e; const n = function () { return t }; return { get: n, set(e) { t = e }, clone() { return Po(n()) } } }; const Bo = function (r, o, i) { if (o.length === 0) throw new Error('You must specify at least one required field.'); return te('required', o), ne(o), function (t) { const n = q(t); H(o, (e) => A(n, e)) || Z(o, n), r(o, n); const e = I(o, (e) => !i.validate(t[e], e)); return e.length > 0 && (function (e, t) { throw new Error(`All values need to be of type: ${t}. Keys (${Q(e).join(', ')}) were not.`) }(e, i.label)), t } }; const Mo = function (t, e) { const n = I(e, (e) => !A(t, e)); n.length > 0 && ee(n) }; const Wo = function (e) { return Bo(Mo, e, { validate: T, label: 'function' }) }; const _o = function (e) { const t = Tt(e, 'colspan') ? parseInt(Rt(e, 'colspan'), 10) : 1; const n = Tt(e, 'rowspan') ? parseInt(Rt(e, 'rowspan'), 10) : 1; return { element: C(e), colspan: C(t), rowspan: C(n) } }; const Lo = Wo(['cell', 'row', 'replace', 'gap']); const jo = function (r, e) { Lo(r); const n = Po(S.none()); const o = e !== undefined ? e : _o; const i = function (e) { let t; const n = o(e); return t = n, r.cell(t) }; const u = function (e) { const t = i(e); return n.get().isNone() && n.set(S.some(t)), c = S.some({ item: e, replacement: t }), t }; var c = S.none(); return { getOrInit(t, n) { return c.fold(() => u(t), (e) => n(t, e.item) ? e.replacement : u(t)) }, cursor: n.get } }; const zo = function (o, c) { return function (n) { const r = Po(S.none()); Lo(n); const i = []; const u = function (e) { const t = n.replace(e, c, { scope: o }); return i.push({ item: e, sub: t }), r.get().isNone() && r.set(S.some(t)), t }; return { replaceOrInit(t, n) { return (r = t, o = n, M(i, (e) => o(e.item, r))).fold(() => u(t), (e) => n(t, e.item) ? e.sub : u(t)); let r, o }, cursor: r.get } } }; const Ho = function (n) { Lo(n); const e = Po(S.none()); return { combine(t) { return e.get().isNone() && e.set(S.some(t)), function () { const e = n.cell({ element: C(t), colspan: C(1), rowspan: C(1) }); return un(e, 'width'), un(t, 'width'), e } }, cursor: e.get } }; const Fo = ['body', 'p', 'div', 'article', 'aside', 'figcaption', 'figure', 'footer', 'header', 'nav', 'section', 'ol', 'ul', 'table', 'thead', 'tfoot', 'tbody', 'caption', 'tr', 'td', 'th', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'address']; const Uo = function (e, t) { const n = e.property().name(t); return A(Fo, n) }; const qo = function (e, t) { return A(['br', 'img', 'hr', 'input'], e.property().name(t)) }; const Vo = Uo; const Go = function (e, t) { const n = e.property().name(t); return A(['ol', 'ul'], n) }; const Yo = qo; const Ko = zn(); const Xo = function (e) { return Vo(Ko, e) }; const $o = function (e) { return Go(Ko, e) }; const Jo = function (e) { return Yo(Ko, e) }; const Qo = function (e) { let t; const i = function (e) { return gt(e) === 'br' }; const n = function (o) { return kn(o).bind((n) => { const r = lt(n).map((e) => !!Xo(e) || (Jo(e) ? gt(e) !== 'img' : void 0)).getOr(!1); return ut(n).map((e) => { return !0 === r || gt(t = e) === 'li' || Wt(t, $o).isSome() || i(n) || Xo(e) && !nt(o, e) ? [] : [de.fromTag('br')]; let t }) }).getOr([]) }; const r = (t = z(e, (e) => { const t = ft(e); return H(t, (e) => i(e) || wt(e) && Rn(e).trim().length === 0) ? [] : t.concat(n(e)) })).length === 0 ? [de.fromTag('br')] : t; gn(e[0]), mn(e[0], r) }; const Zo = Object.prototype.hasOwnProperty; const ei = (ko = function (e, t) { return t }, function () { for (var e = new Array(arguments.length), t = 0; t < e.length; t++)e[t] = arguments[t]; if (e.length === 0) throw new Error("Can't merge zero objects"); for (var n = {}, r = 0; r < e.length; r++) { const o = e[r]; for (const i in o)Zo.call(o, i) && (n[i] = ko(n[i], o[i])) } return n }); const ti = function (e) { for (var t = [], n = function (e) { t.push(e) }, r = 0; r < e.length; r++)e[r].each(n); return t }; const ni = function (e, t) { for (let n = 0; n < e.length; n++) { const r = t(e[n], n); if (r.isSome()) return r } return S.none() }; const ri = function (e, t) { return fe.rowcells(t, e.section()) }; const oi = function (e, t) { return e.cells()[t] }; const ii = { addCell(e, t, n) { const r = e.cells(); const o = r.slice(0, t); const i = r.slice(t); const u = o.concat([n]).concat(i); return ri(e, u) }, setCells: ri, mutateCell(e, t, n) { e.cells()[t] = n }, getCell: oi, getCellElement(e, t) { return oi(e, t).element() }, mapCells(e, t) { const n = e.cells(); const r = N(n, t); return fe.rowcells(r, e.section()) }, cellLength(e) { return e.cells().length } }; const ui = function (e, t) { if (e.length === 0) return 0; const n = e[0]; return W(e, (e) => !t(n.element(), e.element())).fold(() => e.length, (e) => e) }; const ci = function (e, t, n, r) { let o; let i; let u; let c; const a = (o = e, i = t, o[i]).cells().slice(n); const l = ui(a, r); const f = (u = e, c = n, N(u, (e) => ii.getCell(e, c))).slice(t); const s = ui(f, r); return { colspan: C(l), rowspan: C(s) } }; const ai = function (o, i) { const u = N(o, (e, t) => N(e.cells(), (e, t) => !1)); return N(o, (e, r) => { const t = z(e.cells(), (e, t) => { if (!1 !== u[r][t]) return []; const n = ci(o, r, t, i); return (function (e, t, n, r) { for (let o = e; o < e + n; o++) for (let i = t; i < t + r; i++)u[o][i] = !0 }(r, t, n.rowspan(), n.colspan())), [fe.detailnew(e.element(), n.rowspan(), n.colspan(), e.isNew())] }); return fe.rowdetails(t, e.section()) }) }; const li = function (e, t, n) { for (var r = [], o = 0; o < e.grid().rows(); o++) { for (var i = [], u = 0; u < e.grid().columns(); u++) { const c = Jt.getAt(e, o, u).map((e) => fe.elementnew(e.element(), n)).getOrThunk(() => fe.elementnew(t.gap(), !0)); i.push(c) } const a = fe.rowcells(i, e.all()[o].section()); r.push(a) } return r }; const fi = function (e, t, n, r) { n === r ? Dt(e, t) : Ct(e, t, n) }; const si = function (o, e) { const i = []; const u = []; const t = function (e, t) { e.length > 0 ? (function (e, t) { const n = Lt(o, t).getOrThunk(() => { const e = de.fromTag(t, it(o).dom()); return fn(o, e), e }); gn(n); const r = N(e, (e) => { e.isNew() && i.push(e.element()); const t = e.element(); return gn(t), k(e.cells(), (e) => { e.isNew() && u.push(e.element()), fi(e.element(), 'colspan', e.colspan(), 1), fi(e.element(), 'rowspan', e.rowspan(), 1), fn(t, e.element()) }), t }); mn(n, r) }(e, t)) : Lt(o, t).each(pn) }; const n = []; const r = []; const c = []; return k(e, (e) => { switch (e.section()) { case 'thead':n.push(e); break; case 'tbody':r.push(e); break; case 'tfoot':c.push(e) } }), t(n, 'thead'), t(r, 'tbody'), t(c, 'tfoot'), { newRows: C(i), newCells: C(u) } }; const di = function (e) { return N(e, (e) => { const n = yn(e.element()); return k(e.cells(), (e) => { const t = xn(e.element()); fi(t, 'colspan', e.colspan(), 1), fi(t, 'rowspan', e.rowspan(), 1), fn(n, t) }), n }) }; const mi = function (e, t) { for (var n = [], r = 0; r < e; r++)n.push(t(r)); return n }; const gi = function (e, t) { for (var n = [], r = e; r < t; r++)n.push(r); return n }; const pi = function (t, n) { if (n < 0 || n >= t.length - 1) return S.none(); const e = t[n].fold(() => { const e = U(t.slice(0, n)); return ni(e, (e, t) => e.map((e) => ({ value: e, delta: t + 1 }))) }, (e) => S.some({ value: e, delta: 0 })); const r = t[n + 1].fold(() => { const e = t.slice(n + 1); return ni(e, (e, t) => e.map((e) => ({ value: e, delta: t + 1 }))) }, (e) => S.some({ value: e, delta: 1 })); return e.bind((n) => r.map((e) => { const t = e.delta + n.delta; return Math.abs(e.value - n.value) / t })) }; const hi = function (e, t, n) { const r = e(); return M(r, t).orThunk(() => S.from(r[0]).orThunk(n)).map((e) => e.element()) }; const vi = function (n) { const e = n.grid(); const t = gi(0, e.columns()); const r = gi(0, e.rows()); return N(t, (t) => hi(() => z(r, (e) => Jt.getAt(n, e, t).filter((e) => e.column() === t).fold(C([]), (e) => [e])), (e) => e.colspan() === 1, () => Jt.getAt(n, 0, t))) }; const bi = function (n) { const e = n.grid(); const t = gi(0, e.rows()); const r = gi(0, e.columns()); return N(t, (t) => hi(() => z(r, (e) => Jt.getAt(n, t, e).filter((e) => e.row() === t).fold(C([]), (e) => [e])), (e) => e.rowspan() === 1, () => Jt.getAt(n, t, 0))) }; const wi = function (e, t, n, r, o) { const i = de.fromTag('div'); return tn(i, { position: 'absolute', left: `${t - r / 2}px`, top: `${n}px`, height: `${o}px`, width: `${r}px` }), St(i, { 'data-column': e, role: 'presentation' }), i }; const yi = function (e, t, n, r, o) { const i = de.fromTag('div'); return tn(i, { position: 'absolute', left: `${t}px`, top: `${n - o / 2}px`, height: `${o}px`, width: `${r}px` }), St(i, { 'data-row': e, role: 'presentation' }), i }; const xi = function (e) { const t = e.replace(/\./g, '-'); return { resolve(e) { return `${t}-${e}` } } }; const Ci = { resolve: xi('ephox-snooker').resolve }; const Si = function (e, t) { const n = Rt(e, t); return n === undefined || n === '' ? [] : n.split(' ') }; const Ri = function (e) { return e.dom().classList !== undefined }; const Ti = function (e, t) { return o = t, i = Si(n = e, r = 'class').concat([o]), Ct(n, r, i.join(' ')), !0; let n, r, o, i }; const Di = function (e, t) { return o = t, (i = I(Si(n = e, r = 'class'), (e) => e !== o)).length > 0 ? Ct(n, r, i.join(' ')) : Dt(n, r), !1; let n, r, o, i }; const Oi = function (e, t) { Ri(e) ? e.dom().classList.add(t) : Ti(e, t) }; const Ai = function (e) { (Ri(e) ? e.dom().classList : Si(e, 'class')).length === 0 && Dt(e, 'class') }; const Ei = function (e, t) { return Ri(e) && e.dom().classList.contains(t) }; const Ni = Ci.resolve('resizer-bar'); const ki = Ci.resolve('resizer-rows'); const Ii = Ci.resolve('resizer-cols'); const Pi = function (e) { const t = Bt(e.parent(), `.${Ni}`); k(t, pn) }; const Bi = function (n, e, r) { const o = n.origin(); k(e, (e, t) => { e.each((e) => { const t = r(o, e); Oi(t, Ni), fn(n.parent(), t) }) }) }; const Mi = function (e, t, n, r, o, i) { let u; let c; let a; let l; const f = ho(t); const s = n.length > 0 ? o.positions(n, t) : []; u = e, c = s, a = f, l = Jr(t), Bi(u, c, (e, t) => { const n = yi(t.row(), a.left() - e.left(), t.y() - e.top(), l, 7); return Oi(n, ki), n }); let d; let m; let g; let p; const h = r.length > 0 ? i.positions(r, t) : []; d = e, m = h, g = f, p = Kr(t), Bi(d, m, (e, t) => { const n = wi(t.col(), t.x() - e.left(), g.top() - e.top(), 7, p); return Oi(n, Ii), n }) }; const Wi = function (e, t) { const n = Bt(e.parent(), `.${Ni}`); k(n, t) }; const _i = { refresh(e, t, n, r) { Pi(e); const o = Yt(t); const i = Jt.generate(o); const u = bi(i); const c = vi(i); Mi(e, t, u, c, n, r) }, hide(e) { Wi(e, (e) => { en(e, 'display', 'none') }) }, show(e) { Wi(e, (e) => { en(e, 'display', 'block') }) }, destroy: Pi, isRowBar(e) { return Ei(e, ki) }, isColBar(e) { return Ei(e, Ii) } }; const Li = function (e, r) { return N(e, (e) => { let t; const n = (t = e.details(), ni(t, (e) => ut(e.element()).map((e) => { const t = ut(e).isNone(); return fe.elementnew(e, t) })).getOrThunk(() => fe.elementnew(r.row(), !0))); return fe.rowdatanew(n.element(), e.details(), e.section(), n.isNew()) }) }; const ji = function (e, t) { const n = ai(e, nt); return Li(n, t) }; const zi = function (e, t) { const n = j(N(e.all(), (e) => e.cells())); return M(n, (e) => nt(t, e.element())) }; const Hi = function (c, a, l, f, s) { return function (n, r, e, o, i) { const t = Yt(r); const u = Jt.generate(t); return a(u, e).map((e) => { const t = li(u, o, !1); const n = c(t, e, nt, s(o)); const r = ji(n.grid(), o); return { grid: C(r), cursor: n.cursor } }).fold(() => S.none(), (e) => { const t = si(r, e.grid()); return l(r, e.grid(), i), f(r), _i.refresh(n, r, Ao.height, i), S.some({ cursor: e.cursor, newRows: t.newRows, newCells: t.newCells }) }) } }; const Fi = ji; const Ui = function (t, e) { return Gt.cell(e.element()).bind((e) => zi(t, e)) }; const qi = function (t, e) { const n = N(e.selection(), (e) => Gt.cell(e).bind((e) => zi(t, e))); const r = ti(n); return r.length > 0 ? S.some(r) : S.none() }; const Vi = function (t, n) { return Gt.cell(n.element()).bind((e) => zi(t, e).map((e) => ei(e, { generators: n.generators, clipboard: n.clipboard }))) }; const Gi = function (t, e) { const n = N(e.selection(), (e) => Gt.cell(e).bind((e) => zi(t, e))); const r = ti(n); return r.length > 0 ? S.some(ei({ cells: r }, { generators: e.generators, clipboard: e.clipboard })) : S.none() }; const Yi = function (e, t) { return t.mergable() }; const Ki = function (e, t) { return t.unmergable() }; var Xi = function (n) { return { is(e) { return n === e }, isValue: l, isError: c, getOr: C(n), getOrThunk: C(n), getOrDie: C(n), or(e) { return Xi(n) }, orThunk(e) { return Xi(n) }, fold(e, t) { return t(n) }, map(e) { return Xi(e(n)) }, mapError(e) { return Xi(n) }, each(e) { e(n) }, bind(e) { return e(n) }, exists(e) { return e(n) }, forall(e) { return e(n) }, toOption() { return S.some(n) } } }; var $i = function (n) { return { is: c, isValue: c, isError: l, getOr: o, getOrThunk(e) { return e() }, getOrDie() { return e = String(n), (function () { throw new Error(e) }()); let e }, or(e) { return e }, orThunk(e) { return e() }, fold(e, t) { return e(n) }, map(e) { return $i(n) }, mapError(e) { return $i(e(n)) }, each: y, bind(e) { return $i(n) }, exists: c, forall: l, toOption: S.none } }; const Ji = { value: Xi, error: $i }; const Qi = function (e, t) { return N(e, () => fe.elementnew(t.cell(), !0)) }; const Zi = function (t, e, n) { return t.concat(mi(e, (e) => ii.setCells(t[t.length - 1], Qi(t[t.length - 1].cells(), n)))) }; const eu = function (e, t, n) { return N(e, (e) => ii.setCells(e, e.cells().concat(Qi(gi(0, t), n)))) }; const tu = function (e, t, n) { if (e.row() >= t.length || e.column() > ii.cellLength(t[0])) return Ji.error(`invalid start address out of table bounds, row: ${e.row()}, column: ${e.column()}`); const r = t.slice(e.row()); const o = r[0].cells().slice(e.column()); const i = ii.cellLength(n[0]); const u = n.length; return Ji.value({ rowDelta: C(r.length - u), colDelta: C(o.length - i) }) }; const nu = function (e, t) { const n = ii.cellLength(e[0]); const r = ii.cellLength(t[0]); return { rowDelta: C(0), colDelta: C(n - r) } }; const ru = function (e, t, n) { const r = t.colDelta() < 0 ? eu : o; return (t.rowDelta() < 0 ? Zi : o)(r(e, Math.abs(t.colDelta()), n), Math.abs(t.rowDelta()), n) }; const ou = function (e, t, n, r) { if (e.length === 0) return e; for (let o = t.startRow(); o <= t.finishRow(); o++) for (let i = t.startCol(); i <= t.finishCol(); i++)ii.mutateCell(e[o], i, fe.elementnew(r(), !1)); return e }; const iu = function (e, t, n, r) { for (let o = !0, i = 0; i < e.length; i++) for (let u = 0; u < ii.cellLength(e[0]); u++) { const c = n(ii.getCellElement(e[i], u), t); !0 === c && !1 === o ? ii.mutateCell(e[i], u, fe.elementnew(r(), !0)) : !0 === c && (o = !1) } return e }; const uu = function (i, u, c, a) { if (u > 0 && u < i.length) { const e = i[u - 1].cells(); const t = (n = c, B(e, (e, t) => E(e, (e) => n(e.element(), t.element())) ? e : e.concat([t]), [])); k(t, (e) => { for (var t = S.none(), n = u; n < i.length; n++) for (var r = 0; r < ii.cellLength(i[0]); r++) { const o = i[n].cells()[r]; c(o.element(), e.element()) && (t.isNone() && (t = S.some(a())), t.each((e) => { ii.mutateCell(i[n], r, fe.elementnew(e, !0)) })) } }) } let n; return i }; const cu = function (n, r, o, i, u) { return tu(n, r, o).map((e) => { const t = ru(r, e, i); return (function (e, t, n, r, o) { for (var i, u, c, a, l, f = e.row(), s = e.column(), d = f + n.length, m = s + ii.cellLength(n[0]), g = f; g < d; g++) for (let p = s; p < m; p++) { i = t, u = g, c = p, a = void 0, a = b(o, ii.getCell(i[u], c).element()), l = i[u], i.length > 1 && ii.cellLength(l) > 1 && (c > 0 && a(ii.getCellElement(l, c - 1)) || c < l.length - 1 && a(ii.getCellElement(l, c + 1)) || u > 0 && a(ii.getCellElement(i[u - 1], c)) || u < i.length - 1 && a(ii.getCellElement(i[u + 1], c))) && iu(t, ii.getCellElement(t[g], p), o, r.cell); const h = ii.getCellElement(n[g - f], p - s); const v = r.replace(h); ii.mutateCell(t[g], p, fe.elementnew(v, !0)) } return t }(n, t, o, i, u)) }) }; const au = function (e, t, n, r, o) { uu(t, e, o, r.cell); const i = nu(n, t); const u = ru(n, i, r); const c = nu(t, u); const a = ru(t, c, r); return a.slice(0, e).concat(u).concat(a.slice(e, a.length)) }; const lu = function (n, r, e, o, i) { const t = n.slice(0, r); const u = n.slice(r); const c = ii.mapCells(n[e], (e, t) => r > 0 && r < n.length && o(ii.getCellElement(n[r - 1], t), ii.getCellElement(n[r], t)) ? ii.getCell(n[r], t) : fe.elementnew(i(e.element(), o), !0)); return t.concat([c]).concat(u) }; const fu = function (e, n, r, o, i) { return N(e, (e) => { const t = n > 0 && n < ii.cellLength(e) && o(ii.getCellElement(e, n - 1), ii.getCellElement(e, n)) ? ii.getCell(e, n) : fe.elementnew(i(ii.getCellElement(e, r), o), !0); return ii.addCell(e, n, t) }) }; const su = function (e, r, o, i, u) { const c = o + 1; return N(e, (e, t) => { const n = t === r ? fe.elementnew(u(ii.getCellElement(e, o), i), !0) : ii.getCell(e, o); return ii.addCell(e, c, n) }) }; const du = function (e, t, n, r, o) { const i = t + 1; const u = e.slice(0, i); const c = e.slice(i); const a = ii.mapCells(e[t], (e, t) => t === n ? fe.elementnew(o(e.element(), r), !0) : e); return u.concat([a]).concat(c) }; const mu = function (e, t, n) { return e.slice(0, t).concat(e.slice(n + 1)) }; const gu = function (e, n, r) { const t = N(e, (e) => { const t = e.cells().slice(0, n).concat(e.cells().slice(r + 1)); return fe.rowcells(t, e.section()) }); return I(t, (e) => e.cells().length > 0) }; const pu = function (e, n, r, o) { return N(e, (e) => ii.mapCells(e, (e) => { return t = e, E(n, (e) => r(t.element(), e.element())) ? fe.elementnew(o(e.element(), r), !0) : e; let t })) }; const hu = function (e, t, n, r) { return ii.getCellElement(e[t], n) !== undefined && t > 0 && r(ii.getCellElement(e[t - 1], n), ii.getCellElement(e[t], n)) }; const vu = function (e, t, n) { return t > 0 && n(ii.getCellElement(e, t - 1), ii.getCellElement(e, t)) }; const bu = function (n, r, o, e) { const t = z(n, (e, t) => hu(n, t, r, o) || vu(e, r, o) ? [] : [ii.getCell(e, r)]); return pu(n, t, o, e) }; const wu = function (n, r, o, e) { const i = n[r]; const t = z(i.cells(), (e, t) => hu(n, r, t, o) || vu(i, t, o) ? [] : [e]); return pu(n, t, o, e) }; const yu = function (e) { return { fold: e } }; const xu = function () { return yu((e, t, n, r, o) => e()) }; const Cu = function (i) { return yu((e, t, n, r, o) => t(i)) }; const Su = function (i, u) { return yu((e, t, n, r, o) => n(i, u)) }; const Ru = function (i, u, c) { return yu((e, t, n, r, o) => r(i, u, c)) }; const Tu = function (i, u) { return yu((e, t, n, r, o) => o(i, u)) }; const Du = function (e, t, i, u) { let n; let r; const c = e.slice(0); const o = (r = t, (n = e).length === 0 ? xu() : n.length === 1 ? Cu(0) : r === 0 ? Su(0, 1) : r === n.length - 1 ? Tu(r - 1, r) : r > 0 && r < n.length - 1 ? Ru(r - 1, r, r + 1) : xu()); const a = function (e) { return N(e, C(0)) }; const l = C(a(c)); const f = function (e, t) { if (i >= 0) { const n = Math.max(u.minCellWidth(), c[t] - i); return a(c.slice(0, e)).concat([i, n - c[t]]).concat(a(c.slice(t + 1))) } const r = Math.max(u.minCellWidth(), c[e] + i); const o = c[e] - r; return a(c.slice(0, e)).concat([r - c[e], o]).concat(a(c.slice(t + 1))) }; const s = f; return o.fold(l, (e) => u.singleColumnWidth(c[e], i), s, (e, t, n) => f(t, n), (e, t) => { if (i >= 0) return a(c.slice(0, t)).concat([i]); const n = Math.max(u.minCellWidth(), c[t] + i); return a(c.slice(0, t)).concat([n - c[t]]) }) }; const Ou = function (e, t) { return Tt(e, t) && parseInt(Rt(e, t), 10) > 1 }; const Au = { hasColspan(e) { return Ou(e, 'colspan') }, hasRowspan(e) { return Ou(e, 'rowspan') }, minWidth: C(10), minHeight: C(10), getInt(e, t) { return parseInt(nn(e, t), 10) } }; const Eu = function (e, t, n) { return on(e, t).fold(() => `${n(e)}px`, (e) => e) }; const Nu = function (e) { return Eu(e, 'width', fo.getPixelWidth) }; const ku = function (e) { return Eu(e, 'height', fo.getHeight) }; const Iu = function (e, t, n, r, o) { const i = vi(e); const u = N(i, (e) => e.map(t.edge)); return N(i, (e, t) => e.filter(m(Au.hasColspan)).fold(() => { const e = pi(u, t); return r(e) }, (e) => n(e, o))) }; const Pu = function (e) { return e.map((e) => `${e}px`).getOr('') }; const Bu = function (e, t, n, r) { const o = bi(e); const i = N(o, (e) => e.map(t.edge)); return N(o, (e, t) => e.filter(m(Au.hasRowspan)).fold(() => { const e = pi(i, t); return r(e) }, (e) => n(e))) }; const Mu = { getRawWidths(e, t) { return Iu(e, t, Nu, Pu) }, getPixelWidths(e, t, n) { return Iu(e, t, fo.getPixelWidth, (e) => e.getOrThunk(n.minCellWidth), n) }, getPercentageWidths(e, t, n) { return Iu(e, t, fo.getPercentageWidth, (e) => e.fold(() => n.minCellWidth(), (e) => e / n.pixelWidth() * 100), n) }, getPixelHeights(e, t) { return Bu(e, t, fo.getHeight, (e) => e.getOrThunk(Au.minHeight)) }, getRawHeights(e, t) { return Bu(e, t, ku, Pu) } }; const Wu = function (e, t, n) { for (var r = 0, o = e; o < t; o++)r += n[o] !== undefined ? n[o] : 0; return r }; const _u = function (e, n) { const t = Jt.justCells(e); return N(t, (e) => { const t = Wu(e.column(), e.column() + e.colspan(), n); return { element: e.element, width: C(t), colspan: e.colspan } }) }; const Lu = function (e, n) { const t = Jt.justCells(e); return N(t, (e) => { const t = Wu(e.row(), e.row() + e.rowspan(), n); return { element: e.element, height: C(t), rowspan: e.rowspan } }) }; const ju = function (e, n) { return N(e.all(), (e, t) => ({ element: e.element, height: C(n[t]) })) }; const zu = function (e) { const t = parseInt(e, 10); const n = o; return { width: C(t), pixelWidth: C(t), getWidths: Mu.getPixelWidths, getCellDelta: n, singleColumnWidth(e, t) { return [Math.max(Au.minWidth(), e + t) - e] }, minCellWidth: Au.minWidth, setElementWidth: fo.setPixelWidth, setTableWidth(e, t, n) { const r = P(t, (e, t) => e + t, 0); fo.setPixelWidth(e, r) } } }; const Hu = function (e, t) { if (fo.percentageBasedSizeRegex().test(t)) { const n = fo.percentageBasedSizeRegex().exec(t); return o = n[1], i = e, u = parseFloat(o), c = $r(i), { width: C(u), pixelWidth: C(c), getWidths: Mu.getPercentageWidths, getCellDelta(e) { return e / c * 100 }, singleColumnWidth(e, t) { return [100 - e] }, minCellWidth() { return Au.minWidth() / c * 100 }, setElementWidth: fo.setPercentageWidth, setTableWidth(e, t, n) { const r = u + n; fo.setPercentageWidth(e, r) } } } if (fo.pixelBasedSizeRegex().test(t)) { const r = fo.pixelBasedSizeRegex().exec(t); return zu(r[1]) } let o; let i; let u; let c; const a = $r(e); return zu(a) }; const Fu = function (t) { return fo.getRawWidth(t).fold(() => { const e = $r(t); return zu(e) }, (e) => Hu(t, e)) }; const Uu = function (e) { return Jt.generate(e) }; const qu = function (e) { const t = Yt(e); return Uu(t) }; const Vu = function (e, t, n, r) { const o = Fu(e); const i = o.getCellDelta(t); const u = qu(e); const c = o.getWidths(u, r, o); const a = Du(c, n, i, o); const l = N(a, (e, t) => e + c[t]); const f = _u(u, l); k(f, (e) => { o.setElementWidth(e.element(), e.width()) }), n === u.grid().columns() - 1 && o.setTableWidth(e, l, i) }; const Gu = function (e, n, r, t) { const o = qu(e); const i = Mu.getPixelHeights(o, t); const u = N(i, (e, t) => r === t ? Math.max(n + e, Au.minHeight()) : e); const c = Lu(o, u); const a = ju(o, u); k(a, (e) => { fo.setHeight(e.element(), e.height()) }), k(c, (e) => { fo.setHeight(e.element(), e.height()) }); const l = P(u, (e, t) => e + t, 0); fo.setHeight(e, l) }; const Yu = function (e, t, n) { const r = Fu(e); const o = Uu(t); const i = r.getWidths(o, n, r); const u = _u(o, i); k(u, (e) => { r.setElementWidth(e.element(), e.width()) }); const c = P(i, (e, t) => t + e, 0); u.length > 0 && r.setTableWidth(e, c) }; const Ku = function (e) { Gt.cells(e).length === 0 && pn(e) }; const Xu = J('grid', 'cursor'); const $u = function (e, t, n) { return Ju(e, t, n).orThunk(() => Ju(e, 0, 0)) }; var Ju = function (e, t, n) { return S.from(e[t]).bind((e) => S.from(e.cells()[n]).bind((e) => S.from(e.element()))) }; const Qu = function (e, t, n) { return Xu(e, Ju(e, t, n)) }; const Zu = function (e) { return B(e, (e, t) => E(e, (e) => e.row() === t.row()) ? e : e.concat([t]), []).sort((e, t) => e.row() - t.row()) }; const ec = function (e) { return B(e, (e, t) => E(e, (e) => e.column() === t.column()) ? e : e.concat([t]), []).sort((e, t) => e.column() - t.column()) }; const tc = function (e, t, n) { const r = Kt(e, n); const o = Jt.generate(r); return li(o, t, !0) }; const nc = Yu; const rc = { insertRowBefore: Hi((e, t, n, r) => { const o = t.row(); const i = t.row(); const u = lu(e, i, o, n, r.getOrInit); return Qu(u, i, t.column()) }, Ui, y, y, jo), insertRowsBefore: Hi((e, t, n, r) => { const o = t[0].row(); const i = t[0].row(); const u = Zu(t); const c = B(u, (e, t) => lu(e, i, o, n, r.getOrInit), e); return Qu(c, i, t[0].column()) }, qi, y, y, jo), insertRowAfter: Hi((e, t, n, r) => { const o = t.row(); const i = t.row() + t.rowspan(); const u = lu(e, i, o, n, r.getOrInit); return Qu(u, i, t.column()) }, Ui, y, y, jo), insertRowsAfter: Hi((e, t, n, r) => { const o = Zu(t); const i = o[o.length - 1].row(); const u = o[o.length - 1].row() + o[o.length - 1].rowspan(); const c = B(o, (e, t) => lu(e, u, i, n, r.getOrInit), e); return Qu(c, u, t[0].column()) }, qi, y, y, jo), insertColumnBefore: Hi((e, t, n, r) => { const o = t.column(); const i = t.column(); const u = fu(e, i, o, n, r.getOrInit); return Qu(u, t.row(), i) }, Ui, nc, y, jo), insertColumnsBefore: Hi((e, t, n, r) => { const o = ec(t); const i = o[0].column(); const u = o[0].column(); const c = B(o, (e, t) => fu(e, u, i, n, r.getOrInit), e); return Qu(c, t[0].row(), u) }, qi, nc, y, jo), insertColumnAfter: Hi((e, t, n, r) => { const o = t.column(); const i = t.column() + t.colspan(); const u = fu(e, i, o, n, r.getOrInit); return Qu(u, t.row(), i) }, Ui, nc, y, jo), insertColumnsAfter: Hi((e, t, n, r) => { const o = t[t.length - 1].column(); const i = t[t.length - 1].column() + t[t.length - 1].colspan(); const u = ec(t); const c = B(u, (e, t) => fu(e, i, o, n, r.getOrInit), e); return Qu(c, t[0].row(), i) }, qi, nc, y, jo), splitCellIntoColumns: Hi((e, t, n, r) => { const o = su(e, t.row(), t.column(), n, r.getOrInit); return Qu(o, t.row(), t.column()) }, Ui, nc, y, jo), splitCellIntoRows: Hi((e, t, n, r) => { const o = du(e, t.row(), t.column(), n, r.getOrInit); return Qu(o, t.row(), t.column()) }, Ui, y, y, jo), eraseColumns: Hi((e, t, n, r) => { const o = ec(t); const i = gu(e, o[0].column(), o[o.length - 1].column()); const u = $u(i, t[0].row(), t[0].column()); return Xu(i, u) }, qi, nc, Ku, jo), eraseRows: Hi((e, t, n, r) => { const o = Zu(t); const i = mu(e, o[0].row(), o[o.length - 1].row()); const u = $u(i, t[0].row(), t[0].column()); return Xu(i, u) }, qi, y, Ku, jo), makeColumnHeader: Hi((e, t, n, r) => { const o = bu(e, t.column(), n, r.replaceOrInit); return Qu(o, t.row(), t.column()) }, Ui, y, y, zo('row', 'th')), unmakeColumnHeader: Hi((e, t, n, r) => { const o = bu(e, t.column(), n, r.replaceOrInit); return Qu(o, t.row(), t.column()) }, Ui, y, y, zo(null, 'td')), makeRowHeader: Hi((e, t, n, r) => { const o = wu(e, t.row(), n, r.replaceOrInit); return Qu(o, t.row(), t.column()) }, Ui, y, y, zo('col', 'th')), unmakeRowHeader: Hi((e, t, n, r) => { const o = wu(e, t.row(), n, r.replaceOrInit); return Qu(o, t.row(), t.column()) }, Ui, y, y, zo(null, 'td')), mergeCells: Hi((e, t, n, r) => { const o = t.cells(); Qo(o); const i = ou(e, t.bounds(), n, C(o[0])); return Xu(i, S.from(o[0])) }, Yi, y, y, Ho), unmergeCells: Hi((e, t, n, r) => { const o = P(t, (e, t) => iu(e, t, n, r.combine(t)), e); return Xu(o, S.from(t[0])) }, Ki, nc, y, Ho), pasteCells: Hi((e, n, t, r) => { let o; let i; let u; let c; const a = (o = n.clipboard(), i = n.generators(), u = Yt(o), c = Jt.generate(u), li(c, i, !0)); const l = fe.address(n.row(), n.column()); return cu(l, e, a, n.generators(), t).fold(() => Xu(e, S.some(n.element())), (e) => { const t = $u(e, n.row(), n.column()); return Xu(e, t) }) }, Vi, nc, y, jo), pasteRowsBefore: Hi((e, t, n, r) => { const o = e[t.cells[0].row()]; const i = t.cells[0].row(); const u = tc(t.clipboard(), t.generators(), o); const c = au(i, e, u, t.generators(), n); const a = $u(c, t.cells[0].row(), t.cells[0].column()); return Xu(c, a) }, Gi, y, y, jo), pasteRowsAfter: Hi((e, t, n, r) => { const o = e[t.cells[0].row()]; const i = t.cells[t.cells.length - 1].row() + t.cells[t.cells.length - 1].rowspan(); const u = tc(t.clipboard(), t.generators(), o); const c = au(i, e, u, t.generators(), n); const a = $u(c, t.cells[0].row(), t.cells[0].column()); return Xu(c, a) }, Gi, y, y, jo) }; const oc = function (e) { return de.fromDom(e.getBody()) }; const ic = function (e) { return e.getBoundingClientRect().width }; const uc = function (e) { return e.getBoundingClientRect().height }; const cc = function (t) { return function (e) { return nt(e, oc(t)) } }; const ac = function (e) { return /^[0-9]+$/.test(e) && (e += 'px'), e }; const lc = function (e) { const t = Bt(e, 'td[data-mce-style],th[data-mce-style]'); Dt(e, 'data-mce-style'), k(t, (e) => { Dt(e, 'data-mce-style') }) }; const fc = { isRtl: C(!1) }; const sc = { isRtl: C(!0) }; const dc = { directionAt(e) { return (nn(e, 'direction') === 'rtl' ? 'rtl' : 'ltr') == 'rtl' ? sc : fc } }; const mc = { 'border-collapse': 'collapse', width: '100%' }; const gc = { border: '1' }; const pc = function (e) { return e.getParam('table_default_attributes', gc, 'object') }; const hc = function (e) { return e.getParam('table_default_styles', mc, 'object') }; const vc = function (e) { return e.getParam('table_cell_advtab', !0, 'boolean') }; const bc = function (e) { return e.getParam('table_row_advtab', !0, 'boolean') }; const wc = function (e) { return e.getParam('table_advtab', !0, 'boolean') }; const yc = function (e) { return e.getParam('table_style_by_css', !1, 'boolean') }; const xc = function (e) { return e.getParam('table_class_list', [], 'array') }; const Cc = function (e) { return !1 === e.getParam('table_responsive_width') }; const Sc = function (e, t) { return e.fire('newrow', { node: t }) }; const Rc = function (e, t) { return e.fire('newcell', { node: t }) }; const Tc = function (e, t, n, r) { e.fire('ObjectResizeStart', { target: t, width: n, height: r }) }; const Dc = function (e, t, n, r) { e.fire('ObjectResized', { target: t, width: n, height: r }) }; const Oc = function (f, e) { let t; const n = function (e) { return gt(oc(e)) === 'table' }; const s = (t = f.getParam('table_clone_elements'), v(t) ? S.some(t.split(/[ ,]/)) : Array.isArray(t) ? S.some(t) : S.none()); const r = function (u, c, a, l) { return function (e, t) { lc(e); const n = l(); const r = de.fromDom(f.getDoc()); const o = No(dc.directionAt); const i = _n(a, r, s); return c(e) ? u(n, e, t, i, o).bind((e) => k(e.newRows(), (e) => { Sc(f, e.dom()) }), k(e.newCells(), (e) => { Rc(f, e.dom()) }), e.cursor().map((e) => { const t = f.dom.createRng(); return t.setStart(e.dom(), 0), t.setEnd(e.dom(), 0), t })) : S.none() } }; return { deleteRow: r(rc.eraseRows, (e) => { const t = Io(e); return !1 === n(f) || t.rows() > 1 }, y, e), deleteColumn: r(rc.eraseColumns, (e) => { const t = Io(e); return !1 === n(f) || t.columns() > 1 }, y, e), insertRowsBefore: r(rc.insertRowsBefore, l, y, e), insertRowsAfter: r(rc.insertRowsAfter, l, y, e), insertColumnsBefore: r(rc.insertColumnsBefore, l, so, e), insertColumnsAfter: r(rc.insertColumnsAfter, l, so, e), mergeCells: r(rc.mergeCells, l, y, e), unmergeCells: r(rc.unmergeCells, l, y, e), pasteRowsBefore: r(rc.pasteRowsBefore, l, y, e), pasteRowsAfter: r(rc.pasteRowsAfter, l, y, e), pasteCells: r(rc.pasteCells, l, y, e) } }; const Ac = function (e, t, r) { const n = Yt(e); const o = Jt.generate(n); return qi(o, t).map((e) => { const t = li(o, r, !1).slice(e[0].row(), e[e.length - 1].row() + e[e.length - 1].rowspan()); const n = Fi(t, r); return di(n) }) }; const Ec = tinymce.util.Tools.resolve('tinymce.util.Tools'); const Nc = function (e, t, n) { n && e.formatter.apply(`align${n}`, {}, t) }; const kc = function (e, t, n) { n && e.formatter.apply(`valign${n}`, {}, t) }; const Ic = function (t, n) { Ec.each('left center right'.split(' '), (e) => { t.formatter.remove(`align${e}`, {}, n) }) }; const Pc = function (t, n) { Ec.each('top middle bottom'.split(' '), (e) => { t.formatter.remove(`valign${e}`, {}, n) }) }; const Bc = function (o, e, i) { let t; return t = (function (e, t) { for (let n = 0; n < t.length; n++) { const r = o.getStyle(t[n], i); if (void 0 === e && (e = r), e !== r) return '' } return e }(t, o.select('td,th', e))) }; var Mc = function () { return (Mc = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++) for (const o in t = arguments[n])Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e }).apply(this, arguments) }; const Wc = function (t, e) { const n = function (e) { return Ke(e, 'rgb') ? t.toHex(e) : e }; return { borderstyle: on(de.fromDom(e), 'border-style').getOr(''), bordercolor: on(de.fromDom(e), 'border-color').map(n).getOr(''), backgroundcolor: on(de.fromDom(e), 'background-color').map(n).getOr('') } }; const _c = function (e, t, n, r, o) { const i = {}; return Ec.each(e.split(' '), (e) => { r.formatter.matchNode(o, t + e) && (i[n] = e) }), i[n] || (i[n] = ''), i }; const Lc = b(_c, 'left center right'); const jc = b(_c, 'top middle bottom'); const zc = function (e, r, t) { var o = function (e, n) { return n = n || [], Ec.each(e, (e) => { const t = { text: e.text || e.title }; e.menu ? t.menu = o(e.menu) : (t.value = e.value, r && r(t)), n.push(t) }), n }; return o(e, t || []) }; const Hc = function (e) { const i = e[0]; const t = e.slice(1); const n = q(i); return k(t, (e) => { k(n, (o) => { G(e, (e, t, n) => { const r = i[o]; r !== '' && o === t && r !== e && (i[o] = '') }) }) }), i }; const Fc = function () { return { title: 'Advanced', items: [{ name: 'borderstyle', type: 'selectbox', label: 'Border style', items: [{ text: 'Select...', value: '' }, { text: 'Solid', value: 'solid' }, { text: 'Dotted', value: 'dotted' }, { text: 'Dashed', value: 'dashed' }, { text: 'Double', value: 'double' }, { text: 'Groove', value: 'groove' }, { text: 'Ridge', value: 'ridge' }, { text: 'Inset', value: 'inset' }, { text: 'Outset', value: 'outset' }, { text: 'None', value: 'none' }, { text: 'Hidden', value: 'hidden' }] }, { name: 'bordercolor', type: 'colorinput', label: 'Border color' }, { name: 'backgroundcolor', type: 'colorinput', label: 'Background color' }] } }; const Uc = function (e, t, n) { let r; let o; let i; const u = e.dom; return Mc({ width: u.getStyle(t, 'width') || u.getAttrib(t, 'width'), height: u.getStyle(t, 'height') || u.getAttrib(t, 'height'), cellspacing: u.getStyle(t, 'border-spacing') || u.getAttrib(t, 'cellspacing'), cellpadding: u.getAttrib(t, 'cellpadding') || Bc(e.dom, t, 'padding'), border: (r = u, o = t, i = on(de.fromDom(o), 'border-width'), yc(e) && i.isSome() ? i.getOr('') : r.getAttrib(o, 'border') || Bc(e.dom, o, 'border-width') || Bc(e.dom, o, 'border')), caption: u.select('caption', t)[0] ? 'checked' : 'unchecked', class: u.getAttrib(t, 'class', '') }, Lc('align', 'align', e, t), n ? Wc(u, t) : {}) }; const qc = function (e, t, n) { const r = e.dom; return Mc({ height: r.getStyle(t, 'height') || r.getAttrib(t, 'height'), scope: r.getAttrib(t, 'scope'), class: r.getAttrib(t, 'class', ''), align: '', type: t.parentNode.nodeName.toLowerCase() }, Lc('align', 'align', e, t), n ? Wc(r, t) : {}) }; const Vc = function (e, t, n) { const r = e.dom; return Mc({ width: r.getStyle(t, 'width') || r.getAttrib(t, 'width'), height: r.getStyle(t, 'height') || r.getAttrib(t, 'height'), scope: r.getAttrib(t, 'scope'), celltype: t.nodeName.toLowerCase(), class: r.getAttrib(t, 'class', '') }, Lc('align', 'halign', e, t), jc('valign', 'valign', e, t), n ? Wc(r, t) : {}) }; const Gc = function (e, t) { let n; let r; let o; let i; let u; let c; let a; let l; const f = hc(e); const s = pc(e); const d = e.dom; const m = t ? (n = d, r = function (e) { return Ke(e, 'rgb') ? n.toHex(e) : e }, o = X(f, 'border-style').getOr(''), i = X(f, 'border-color').getOr(''), u = X(f, 'background-color').getOr(''), { borderstyle: o, bordercolor: r(i), backgroundcolor: r(u) }) : {}; return Mc({}, { height: '', width: '100%', cellspacing: '', cellpadding: '', caption: 'unchecked', class: '', align: '', border: '' }, f, s, m, (l = f['border-width'], yc(e) && l ? { border: l } : X(s, 'border').fold(() => ({}), (e) => ({ border: e }))), (c = X(f, 'border-spacing').or(X(s, 'cellspacing')).fold(() => ({}), (e) => ({ cellspacing: e })), a = X(f, 'border-padding').or(X(s, 'cellpadding')).fold(() => ({}), (e) => ({ cellpadding: e })), Mc({}, c, a))) }; const Yc = [{ name: 'width', type: 'input', label: 'Width' }, { name: 'height', type: 'input', label: 'Height' }, { name: 'celltype', type: 'selectbox', label: 'Cell type', items: [{ text: 'Cell', value: 'td' }, { text: 'Header cell', value: 'th' }] }, { name: 'scope', type: 'selectbox', label: 'Scope', items: [{ text: 'None', value: '' }, { text: 'Row', value: 'row' }, { text: 'Column', value: 'col' }, { text: 'Row group', value: 'rowgroup' }, { text: 'Column group', value: 'colgroup' }] }, { name: 'halign', type: 'selectbox', label: 'H Align', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }, { name: 'valign', type: 'selectbox', label: 'V Align', items: [{ text: 'None', value: '' }, { text: 'Top', value: 'top' }, { text: 'Middle', value: 'middle' }, { text: 'Bottom', value: 'bottom' }] }]; const Kc = function (e) { return (t = e, n = t.getParam('table_cell_class_list', [], 'array'), r = zc(n, (e) => { e.value && (e.textStyle = function () { return t.formatter.getCssText({ block: 'tr', classes: [e.value] }) }) }), n.length > 0 ? S.some({ name: 'class', type: 'selectbox', label: 'Class', items: r }) : S.none()).fold(() => Yc, (e) => Yc.concat(e)); let t, n, r }; const Xc = { normal(n, r) { return { setAttrib(e, t) { n.setAttrib(r, e, t) }, setStyle(e, t) { n.setStyle(r, e, t) } } }, ifTruthy(n, r) { return { setAttrib(e, t) { t && n.setAttrib(r, e, t) }, setStyle(e, t) { t && n.setStyle(r, e, t) } } } }; const $c = function (e, t) { e.setAttrib('scope', t.scope), e.setAttrib('class', t.class), e.setStyle('width', ac(t.width)), e.setStyle('height', ac(t.height)) }; const Jc = function (e, t) { e.setStyle('background-color', t.backgroundcolor), e.setStyle('border-color', t.bordercolor), e.setStyle('border-style', t.borderstyle) }; const Qc = function (e, t, n) { const r = e.dom; const o = n.celltype && t[0].nodeName.toLowerCase() !== n.celltype ? r.rename(t[0], n.celltype) : t[0]; const i = Xc.normal(r, o); $c(i, n), vc(e) && Jc(i, n), Ic(e, o), Pc(e, o), n.halign && Nc(e, o, n.halign), n.valign && kc(e, o, n.valign) }; const Zc = function (n, e, r) { const o = n.dom; Ec.each(e, (e) => { r.celltype && e.nodeName.toLowerCase() !== r.celltype && (e = o.rename(e, r.celltype)); const t = Xc.ifTruthy(o, e); $c(t, r), vc(n) && Jc(t, r), r.halign && Nc(n, e, r.halign), r.valign && kc(n, e, r.valign) }) }; const ea = function (e, t, n) { const r = n.getData(); n.close(), e.undoManager.transact(() => { (t.length === 1 ? Qc : Zc)(e, t, r), e.focus() }) }; const ta = function (t) { let e; let n = []; if (n = t.dom.select('td[data-mce-selected],th[data-mce-selected]'), e = t.dom.getParent(t.selection.getStart(), 'td,th'), !n.length && e && n.push(e), e = e || n[0]) { const r = Ec.map(n, (e) => Vc(t, e, vc(t))); const o = Hc(r); const i = { type: 'tabpanel', tabs: [{ title: 'General', items: Kc(t) }, Fc()] }; const u = { type: 'panel', items: [{ type: 'grid', columns: 2, items: Kc(t) }] }; t.windowManager.open({ title: 'Cell Properties', size: 'normal', body: vc(t) ? i : u, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: o, onSubmit: b(ea, t, n) }) } }; const na = [{ type: 'selectbox', name: 'type', label: 'Row type', items: [{ text: 'Header', value: 'thead' }, { text: 'Body', value: 'tbody' }, { text: 'Footer', value: 'tfoot' }] }, { type: 'selectbox', name: 'align', label: 'Alignment', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }, { label: 'Height', name: 'height', type: 'input' }]; const ra = function (e) { return (t = e, n = t.getParam('table_row_class_list', [], 'array'), r = zc(n, (e) => { e.value && (e.textStyle = function () { return t.formatter.getCssText({ block: 'tr', classes: [e.value] }) }) }), n.length > 0 ? S.some({ name: 'class', type: 'selectbox', label: 'Class', items: r }) : S.none()).fold(() => na, (e) => na.concat(e)); let t, n, r }; const oa = function (f, e, s, t) { const d = f.dom; const m = t.getData(); t.close(); const g = e.length === 1 ? Xc.normal : Xc.ifTruthy; f.undoManager.transact(() => { Ec.each(e, (e) => { let t, n, r, o, i, u; m.type !== e.parentNode.nodeName.toLowerCase() && (t = f.dom, n = e, r = m.type, o = t.getParent(n, 'table'), i = n.parentNode, (u = t.select(r, o)[0]) || (u = t.create(r), o.firstChild ? o.firstChild.nodeName === 'CAPTION' ? t.insertAfter(u, o.firstChild) : o.insertBefore(u, o.firstChild) : o.appendChild(u)), u.appendChild(n), i.hasChildNodes() || t.remove(i)); let c; let a; const l = g(d, e); l.setAttrib('scope', m.scope), l.setAttrib('class', m.class), l.setStyle('height', ac(m.height)), bc(f) && (a = m, (c = l).setStyle('background-color', a.backgroundcolor), c.setStyle('border-color', a.bordercolor), c.setStyle('border-style', a.borderstyle)), m.align !== s.align && (Ic(f, e), Nc(f, e, m.align)) }), f.focus() }) }; const ia = function (t) { let e; let n; const r = t.dom; const o = []; if ((e = r.getParent(t.selection.getStart(), 'table')) && (n = r.getParent(t.selection.getStart(), 'td,th'), Ec.each(e.rows, (t) => { Ec.each(t.cells, (e) => { if ((r.getAttrib(e, 'data-mce-selected') || e === n) && o.indexOf(t) < 0) return o.push(t), !1 }) }), o[0])) { const i = Ec.map(o, (e) => qc(t, e, bc(t))); const u = Hc(i); const c = { type: 'tabpanel', tabs: [{ title: 'General', items: ra(t) }, Fc()] }; const a = { type: 'panel', items: [{ type: 'grid', columns: 2, items: ra(t) }] }; t.windowManager.open({ title: 'Row Properties', size: 'normal', body: bc(t) ? c : a, buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: u, onSubmit: b(oa, t, o, u) }) } }; const ua = tinymce.util.Tools.resolve('tinymce.Env'); const ca = { styles: { 'border-collapse': 'collapse', width: '100%' }, attributes: { border: '1' }, percentages: !0 }; const aa = function (e, t, n, r, o) { void 0 === o && (o = ca); const i = de.fromTag('table'); tn(i, o.styles), St(i, o.attributes); const u = de.fromTag('tbody'); fn(i, u); for (var c = [], a = 0; a < e; a++) { for (var l = de.fromTag('tr'), f = 0; f < t; f++) { const s = a < n || f < r ? de.fromTag('th') : de.fromTag('td'); f < r && Ct(s, 'scope', 'row'), a < n && Ct(s, 'scope', 'col'), fn(s, de.fromTag('br')), o.percentages && en(s, 'width', `${100 / t}%`), fn(l, s) }c.push(l) } return mn(u, c), i }; const la = function (e, t) { e.selection.select(t.dom(), !0), e.selection.collapse(!0) }; const fa = function (r, e, t) { let n; const o = hc(r); const i = { styles: o, attributes: pc(r), percentages: (n = o.width, v(n) && n.indexOf('%') !== -1 && !Cc(r)) }; const u = aa(t, e, 0, 0, i); Ct(u, 'data-mce-id', '__mce'); let c; let a; let l; const f = (c = u, a = de.fromTag('div'), l = de.fromDom(c.dom().cloneNode(!0)), fn(a, l), a.dom().innerHTML); return r.insertContent(f), jt(oc(r), 'table[data-mce-id="__mce"]').map((e) => { let t, n; return Cc(r) && en(e, 'width', nn(e, 'width')), Dt(e, 'data-mce-id'), t = r, k(Bt(e, 'tr'), (e) => { Sc(t, e.dom()), k(Bt(e, 'th,td'), (e) => { Rc(t, e.dom()) }) }), n = r, jt(e, 'td,th').each(b(la, n)), e.dom() }).getOr(null) }; var sa = function (e, t, n, r) { if (t.tagName === 'TD' || t.tagName === 'TH')e.setStyle(t, n, r); else if (t.children) for (let o = 0; o < t.children.length; o++)sa(e, t.children[o], n, r) }; const da = function (n, r, e) { let o; const i = n.dom; const u = e.getData(); e.close(), u.class === '' && delete u.class, n.undoManager.transact(() => { if (!r) { const e = parseInt(u.cols, 10) || 1; const t = parseInt(u.rows, 10) || 1; r = fa(n, e, t) }!(function (e, t, n) { let r; const o = e.dom; const i = {}; const u = {}; if (i.class = n.class, u.height = ac(n.height), o.getAttrib(t, 'width') && !yc(e) ? i.width = (r = n.width) ? r.replace(/px$/, '') : '' : u.width = ac(n.width), yc(e) ? (u['border-width'] = ac(n.border), u['border-spacing'] = ac(n.cellspacing)) : (i.border = n.border, i.cellpadding = n.cellpadding, i.cellspacing = n.cellspacing), yc(e) && t.children) for (let c = 0; c < t.children.length; c++)sa(o, t.children[c], { 'border-width': ac(n.border), padding: ac(n.cellpadding) }), wc(e) && sa(o, t.children[c], { 'border-color': n.bordercolor }); wc(e) && (u['background-color'] = n.backgroundcolor, u['border-color'] = n.bordercolor, u['border-style'] = n.borderstyle), i.style = o.serializeStyle(ei(hc(e), u)), o.setAttribs(t, ei(pc(e), i)) }(n, r, u)), (o = i.select('caption', r)[0]) && u.caption !== 'checked' && i.remove(o), o || u.caption !== 'checked' || ((o = i.create('caption')).innerHTML = ua.ie ? '\xa0' : '<br data-mce-bogus="1"/>', r.insertBefore(o, r.firstChild)), u.align === '' ? Ic(n, r) : Nc(n, r, u.align), n.focus(), n.addVisual() }) }; const ma = function (t, e) { let n; const r = t.dom; let o = Gc(t, wc(t)); !1 === e ? (n = r.getParent(t.selection.getStart(), 'table')) ? o = Uc(t, n, wc(t)) : wc(t) && (o.borderstyle = '', o.bordercolor = '', o.backgroundcolor = '') : (o.cols = '1', o.rows = '1', wc(t) && (o.borderstyle = '', o.bordercolor = '', o.backgroundcolor = '')); const i = xc(t).length > 0; i && o.class && (o.class = o.class.replace(/\s*mce\-item\-table\s*/g, '')); const u = e ? [{ type: 'input', name: 'cols', label: 'Cols' }, { type: 'input', name: 'rows', label: 'Rows' }] : []; const c = t.getParam('table_appearance_options', !0, 'boolean') ? [{ type: 'input', name: 'cellspacing', label: 'Cell spacing' }, { type: 'input', name: 'cellpadding', label: 'Cell padding' }, { type: 'input', name: 'border', label: 'Border width' }, { type: 'label', label: 'Caption', items: [{ type: 'checkbox', name: 'caption', label: 'Show caption' }] }] : []; const a = i ? [{ type: 'selectbox', name: 'class', label: 'Class', items: zc(xc(t), (e) => { e.value && (e.textStyle = function () { return t.formatter.getCssText({ block: 'table', classes: [e.value] }) }) }) }] : []; const l = { type: 'grid', columns: 2, items: u.concat([{ type: 'input', name: 'width', label: 'Width' }, { type: 'input', name: 'height', label: 'Height' }]).concat(c).concat([{ type: 'selectbox', name: 'align', label: 'Alignment', items: [{ text: 'None', value: '' }, { text: 'Left', value: 'left' }, { text: 'Center', value: 'center' }, { text: 'Right', value: 'right' }] }]).concat(a) }; const f = { type: 'panel', items: [l] }; const s = { type: 'tabpanel', tabs: [{ title: 'General', items: [l] }, Fc()] }; const d = wc(t) ? s : f; t.windowManager.open({ title: 'Table Properties', size: 'normal', body: d, onSubmit: b(da, t, n), buttons: [{ type: 'cancel', name: 'cancel', text: 'Cancel' }, { type: 'submit', name: 'save', text: 'Save', primary: !0 }], initialData: o }) }; const ga = Ec.each; const pa = function (c, t, a, l, n) { const r = cc(c); const f = function () { return de.fromDom(c.dom.getParent(c.selection.getStart(), 'th,td')) }; const s = function (e) { return Gt.table(e, r) }; const d = function (e) { return { width: ic(e.dom()), height: ic(e.dom()) } }; const o = function (t) { const n = f(); s(n).each((i) => { const e = Ur.forMenu(l, i, n); const u = d(i); t(i, e).each((e) => { let t, n, r, o; t = c, n = u, o = d(r = i), n.width === o.width && n.height === o.height || (Tc(t, r.dom(), n.width, n.height), Dc(t, r.dom(), o.width, o.height)), c.selection.setRng(e), c.focus(), a.clear(i), lc(i) }) }) }; const i = function (e) { const o = f(); return s(o).bind((e) => { const t = de.fromDom(c.getDoc()); const n = Ur.forMenu(l, e, o); const r = _n(y, t, S.none()); return Ac(e, n, r) }) }; const u = function (u) { n.get().each((e) => { const o = N(e, (e) => xn(e)); const i = f(); s(i).bind((t) => { const e = de.fromDom(c.getDoc()); const n = Ln(e); const r = Ur.pasteRows(l, t, i, o, n); u(t, r).each((e) => { c.selection.setRng(e), c.focus(), a.clear(t) }) }) }) }; ga({ mceTableSplitCells() { o(t.unmergeCells) }, mceTableMergeCells() { o(t.mergeCells) }, mceTableInsertRowBefore() { o(t.insertRowsBefore) }, mceTableInsertRowAfter() { o(t.insertRowsAfter) }, mceTableInsertColBefore() { o(t.insertColumnsBefore) }, mceTableInsertColAfter() { o(t.insertColumnsAfter) }, mceTableDeleteCol() { o(t.deleteColumn) }, mceTableDeleteRow() { o(t.deleteRow) }, mceTableCutRow(e) { n.set(i()), o(t.deleteRow) }, mceTableCopyRow(e) { n.set(i()) }, mceTablePasteRowBefore(e) { u(t.pasteRowsBefore) }, mceTablePasteRowAfter(e) { u(t.pasteRowsAfter) }, mceTableDelete() { const e = de.fromDom(c.dom.getParent(c.selection.getStart(), 'th,td')); Gt.table(e, r).filter(m(r)).each((e) => { const t = de.fromText(''); an(e, t), pn(e); const n = c.dom.createRng(); n.setStart(t.dom(), 0), n.setEnd(t.dom(), 0), c.selection.setRng(n) }) } }, (e, t) => { c.addCommand(t, e) }), ga({ mceInsertTable: b(ma, c, !0), mceTableProps: b(ma, c, !1), mceTableRowProps: b(ia, c), mceTableCellProps: b(ta, c) }, (n, e) => { c.addCommand(e, (e, t) => { n(t) }) }) }; const ha = function (e) { const t = S.from(e.dom().documentElement).map(de.fromDom).getOr(e); return { parent: C(t), view: C(e), origin: C(go(0, 0)) } }; const va = function (e, t) { return { parent: C(t), view: C(e), origin: C(go(0, 0)) } }; function ba(e) { const n = J.apply(null, e); let r = []; return { bind(e) { if (e === undefined) throw 'Event bind error: undefined handler'; r.push(e) }, unbind(t) { r = I(r, (e) => e !== t) }, trigger() { const t = n.apply(null, arguments); k(r, (e) => { e(t) }) } } } const wa = { create(e) { return { registry: Y(e, (e) => ({ bind: e.bind, unbind: e.unbind })), trigger: Y(e, (e) => e.trigger) } } }; const ya = { mode: Wo(['compare', 'extract', 'mutate', 'sink']), sink: Wo(['element', 'start', 'stop', 'destroy']), api: Wo(['forceDrop', 'drop', 'move', 'delayDrop']) }; const xa = { resolve: xi('ephox-dragster').resolve }; const Ca = function (m, g) { return function (e) { if (m(e)) { let t; let n; let r; let o; let i; let u; let c; const a = de.fromDom(e.target); const l = function () { e.stopPropagation() }; const f = function () { e.preventDefault() }; const s = x(f, l); const d = (t = a, n = e.clientX, r = e.clientY, o = l, i = f, u = s, c = e, { target: C(t), x: C(n), y: C(r), stop: o, prevent: i, kill: u, raw: C(c) }); g(d) } } }; const Sa = function (e, t, n, r) { return o = e, i = t, u = !1, c = Ca(n, r), o.dom().addEventListener(i, c, u), { unbind: b(Ra, o, i, c, u) }; let o, i, u, c }; var Ra = function (e, t, n, r) { e.dom().removeEventListener(t, n, r) }; const Ta = C(!0); const Da = function (e, t, n) { return Sa(e, t, Ta, n) }; const Oa = ya.mode({ compare(e, t) { return go(t.left() - e.left(), t.top() - e.top()) }, extract(e) { return S.some(go(e.x(), e.y())) }, sink(e, t) { const n = (function c(e) { const t = ei({ layerClass: xa.resolve('blocker') }, e); const n = de.fromTag('div'); return Ct(n, 'role', 'presentation'), tn(n, { position: 'fixed', left: '0px', top: '0px', width: '100%', height: '100%' }), Oi(n, xa.resolve('blocker')), Oi(n, t.layerClass), { element() { return n }, destroy() { pn(n) } } }(t)); const r = Da(n.element(), 'mousedown', e.forceDrop); const o = Da(n.element(), 'mouseup', e.drop); const i = Da(n.element(), 'mousemove', e.move); const u = Da(n.element(), 'mouseout', e.delayDrop); return ya.sink({ element: n.element, start(e) { fn(e, n.element()) }, stop() { pn(n.element()) }, destroy() { n.destroy(), o.unbind(), i.unbind(), u.unbind(), r.unbind() } }) }, mutate(e, t) { e.mutate(t.left(), t.top()) } }); function Aa() { let i = S.none(); const u = wa.create({ move: ba(['info']) }); return { onEvent(e, o) { o.extract(e).each((e) => { let t, n, r; (t = o, n = e, r = i.map((e) => t.compare(e, n)), i = S.some(n), r).each((e) => { u.trigger.move(e) }) }) }, reset() { i = S.none() }, events: u.registry } } function Ea() { const e = (function r(e) { return { onEvent(e, t) {}, reset: y } }()); const t = Aa(); let n = e; return { on() { n.reset(), n = t }, off() { n.reset(), n = e }, isOn() { return n === t }, onEvent(e, t) { n.onEvent(e, t) }, events: t.events } } const Na = function (t, n, e) { let r; let o; let i; let u = !1; const c = wa.create({ start: ba([]), stop: ba([]) }); const a = Ea(); const l = function () { d.stop(), a.isOn() && (a.off(), c.trigger.stop()) }; const f = (r = l, o = 200, i = null, { cancel() { i !== null && (clearTimeout(i), i = null) }, throttle() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; i !== null && clearTimeout(i), i = setTimeout(() => { r.apply(null, e), i = null }, o) } }); a.events.move.bind((e) => { n.mutate(t, e.info()) }); const s = function (t) { return function () { const e = Array.prototype.slice.call(arguments, 0); if (u) return t.apply(null, e) } }; var d = n.sink(ya.api({ forceDrop: l, drop: s(l), move: s((e, t) => { f.cancel(), a.onEvent(e, n) }), delayDrop: s(f.throttle) }), e); return { element: d.element, go(e) { d.start(e), a.on(), c.trigger.start() }, on() { u = !0 }, off() { u = !1 }, destroy() { d.destroy() }, events: c.registry } }; const ka = { transform(e, t) { const n = t !== undefined ? t : {}; const r = n.mode !== undefined ? n.mode : Oa; return Na(e, r, t) } }; function Ia() { const n = wa.create({ drag: ba(['xDelta', 'yDelta', 'target']) }); let r = S.none(); const e = (function t() { const n = wa.create({ drag: ba(['xDelta', 'yDelta']) }); return { mutate(e, t) { n.trigger.drag(e, t) }, events: n.registry } }()); return e.events.drag.bind((t) => { r.each((e) => { n.trigger.drag(t.xDelta(), t.yDelta(), e) }) }), { assign(e) { r = S.some(e) }, get() { return r }, mutate: e.mutate, events: n.registry } } const Pa = function (e, t, n) { return zt(e, t, n).isSome() }; const Ba = Ci.resolve('resizer-bar-dragging'); function Ma(e, n) { const r = Ao.height; const t = (function m(o, t, i) { const n = Ia(); const r = ka.transform(n, {}); let u = S.none(); const e = function (e, t) { return S.from(Rt(e, t)) }; n.events.drag.bind((n) => { e(n.target(), 'data-row').each((e) => { const t = Au.getInt(n.target(), 'top'); en(n.target(), 'top', `${t + n.yDelta()}px`) }), e(n.target(), 'data-column').each((e) => { const t = Au.getInt(n.target(), 'left'); en(n.target(), 'left', `${t + n.xDelta()}px`) }) }); const c = function (e, t) { return Au.getInt(e, t) - parseInt(Rt(e, `data-initial-${t}`), 10) }; r.events.stop.bind(() => { n.get().each((r) => { u.each((n) => { e(r, 'data-row').each((e) => { const t = c(r, 'top'); Dt(r, 'data-initial-top'), d.trigger.adjustHeight(n, t, parseInt(e, 10)) }), e(r, 'data-column').each((e) => { const t = c(r, 'left'); Dt(r, 'data-initial-left'), d.trigger.adjustWidth(n, t, parseInt(e, 10)) }), _i.refresh(o, n, i, t) }) }) }); const a = function (e, t) { d.trigger.startAdjust(), n.assign(e), Ct(e, `data-initial-${t}`, parseInt(nn(e, t), 10)), Oi(e, Ba), en(e, 'opacity', '0.2'), r.go(o.parent()) }; const l = Da(o.parent(), 'mousedown', (e) => { _i.isRowBar(e.target()) && a(e.target(), 'top'), _i.isColBar(e.target()) && a(e.target(), 'left') }); const f = function (e) { return nt(e, o.view()) }; const s = Da(o.view(), 'mouseover', (e) => { gt(e.target()) === 'table' || Pa(e.target(), 'table', f) ? (u = gt(e.target()) === 'table' ? S.some(e.target()) : _t(e.target(), 'table', f)).each((e) => { _i.refresh(o, e, i, t) }) : At(e.target()) && _i.destroy(o) }); var d = wa.create({ adjustHeight: ba(['table', 'delta', 'row']), adjustWidth: ba(['table', 'delta', 'column']), startAdjust: ba([]) }); return { destroy() { l.unbind(), s.unbind(), r.destroy(), _i.destroy(o) }, refresh(e) { _i.refresh(o, e, i, t) }, on: r.on, off: r.off, hideBars: b(_i.hide, o), showBars: b(_i.show, o), events: d.registry } }(e, n, r)); const o = wa.create({ beforeResize: ba(['table']), afterResize: ba(['table']), startDrag: ba([]) }); return t.events.adjustHeight.bind((e) => { o.trigger.beforeResize(e.table()); const t = r.delta(e.delta(), e.table()); Gu(e.table(), t, e.row(), r), o.trigger.afterResize(e.table()) }), t.events.startAdjust.bind((e) => { o.trigger.startDrag() }), t.events.adjustWidth.bind((e) => { o.trigger.beforeResize(e.table()); const t = n.delta(e.delta(), e.table()); Vu(e.table(), t, e.column(), n), o.trigger.afterResize(e.table()) }), { on: t.on, off: t.off, hideBars: t.hideBars, showBars: t.showBars, destroy: t.destroy, events: o.registry } } const Wa = function (e, t) { return e.inline ? va(oc(e), (n = de.fromTag('div'), tn(n, { position: 'static', height: '0', width: '0', padding: '0', margin: '0', border: '0' }), fn(Et(), n), n)) : ha(de.fromDom(e.getDoc())); let n }; const _a = function (e, t) { e.inline && pn(t.parent()) }; const La = function (u) { let c; let a; let o = S.none(); let i = S.none(); let l = S.none(); const f = /(\d+(\.\d+)?)%/; const s = function (e) { return e.nodeName === 'TABLE' }; return u.on('init', () => { let e; const t = No(dc.directionAt); const n = Wa(u); if (l = S.some(n), ((e = u.getParam('object_resizing', !0)) === 'table' || e) && u.getParam('table_resize_bars', !0, 'boolean')) { const r = Ma(n, t); r.on(), r.events.startDrag.bind((e) => { o = S.some(u.selection.getRng()) }), r.events.beforeResize.bind((e) => { const t = e.table().dom(); Tc(u, t, ic(t), uc(t)) }), r.events.afterResize.bind((e) => { const t = e.table(); const n = t.dom(); lc(t), o.each((e) => { u.selection.setRng(e), u.focus() }), Dc(u, n, ic(n), uc(n)), u.undoManager.add() }), i = S.some(r) } }), u.on('ObjectResizeStart', (e) => { let t; const n = e.target; s(n) && (c = e.width, t = n, a = u.dom.getStyle(t, 'width') || u.dom.getAttrib(t, 'width')) }), u.on('ObjectResized', (e) => { const t = e.target; if (s(t)) { const n = t; if (f.test(a)) { const r = parseFloat(f.exec(a)[1]); const o = e.width * r / c; u.dom.setStyle(n, 'width', `${o}%`) } else { const i = []; Ec.each(n.rows, (e) => { Ec.each(e.cells, (e) => { const t = u.dom.getStyle(e, 'width', !0); i.push({ cell: e, width: t }) }) }), Ec.each(i, (e) => { u.dom.setStyle(e.cell, 'width', e.width), u.dom.setAttrib(e.cell, 'width', null) }) } } }), { lazyResize() { return i }, lazyWire() { return l.getOr(ha(de.fromDom(u.getBody()))) }, destroy() { i.each((e) => { e.destroy() }), l.each((e) => { _a(u, e) }) } } }; const ja = function (e) { return { fold: e } }; const za = function (o) { return ja((e, t, n, r) => e(o)) }; const Ha = function (o) { return ja((e, t, n, r) => t(o)) }; const Fa = function (o, i) { return ja((e, t, n, r) => n(o, i)) }; const Ua = function (o) { return ja((e, t, n, r) => r(o)) }; const qa = function (n, e) { return Gt.table(n, e).bind((e) => { const t = Gt.cells(e); return W(t, (e) => nt(n, e)).map((e) => ({ index: C(e), all: C(t) })) }) }; const Va = function (t, e) { return qa(t, e).fold(() => za(t), (e) => e.index() + 1 < e.all().length ? Fa(t, e.all()[e.index() + 1]) : Ua(t)) }; const Ga = function (t, e) { return qa(t, e).fold(() => za(), (e) => e.index() - 1 >= 0 ? Fa(t, e.all()[e.index() - 1]) : Ha(t)) }; const Ya = Br([{ before: ['element'] }, { on: ['element', 'offset'] }, { after: ['element'] }]); const Ka = { before: Ya.before, on: Ya.on, after: Ya.after, cata(e, t, n, r) { return e.fold(t, n, r) }, getStart(e) { return e.fold(o, o, o) } }; const Xa = Br([{ domRange: ['rng'] }, { relative: ['startSitu', 'finishSitu'] }, { exact: ['start', 'soffset', 'finish', 'foffset'] }]); const $a = J('start', 'soffset', 'finish', 'foffset'); const Ja = function (e) { let t; const n = e.match({ domRange(e) { return de.fromDom(e.startContainer) }, relative(e, t) { return Ka.getStart(e) }, exact(e, t, n, r) { return e } }); return t = n.dom().ownerDocument.defaultView, de.fromDom(t) }; const Qa = (Xa.domRange, Xa.relative); const Za = Xa.exact; const el = function (e, t, n, r) { let o; let i; let u; let c; let a; const l = (i = t, u = n, c = r, (a = it(o = e).dom().createRange()).setStart(o.dom(), i), a.setEnd(u.dom(), c), a); const f = nt(e, n) && t === r; return l.collapsed && !f }; const tl = function (e, t) { e.selectNodeContents(t.dom()) }; const nl = function (e, t, n) { let r; let o; const i = e.document.createRange(); return r = i, t.fold((e) => { r.setStartBefore(e.dom()) }, (e, t) => { r.setStart(e.dom(), t) }, (e) => { r.setStartAfter(e.dom()) }), o = i, n.fold((e) => { o.setEndBefore(e.dom()) }, (e, t) => { o.setEnd(e.dom(), t) }, (e) => { o.setEndAfter(e.dom()) }), i }; const rl = function (e, t, n, r, o) { const i = e.document.createRange(); return i.setStart(t.dom(), n), i.setEnd(r.dom(), o), i }; const ol = function (e) { return { left: C(e.left), top: C(e.top), right: C(e.right), bottom: C(e.bottom), width: C(e.width), height: C(e.height) } }; const il = Br([{ ltr: ['start', 'soffset', 'finish', 'foffset'] }, { rtl: ['start', 'soffset', 'finish', 'foffset'] }]); const ul = function (e, t, n) { return t(de.fromDom(n.startContainer), n.startOffset, de.fromDom(n.endContainer), n.endOffset) }; const cl = function (e, t) { let o; let n; let r; const i = (o = e, t.match({ domRange(e) { return { ltr: C(e), rtl: S.none } }, relative(e, t) { return { ltr: Oe(() => nl(o, e, t)), rtl: Oe(() => S.some(nl(o, t, e))) } }, exact(e, t, n, r) { return { ltr: Oe(() => rl(o, e, t, n, r)), rtl: Oe(() => S.some(rl(o, n, r, e, t))) } } })); return (r = (n = i).ltr()).collapsed ? n.rtl().filter((e) => !1 === e.collapsed).map((e) => il.rtl(de.fromDom(e.endContainer), e.endOffset, de.fromDom(e.startContainer), e.startOffset)).getOrThunk(() => ul(0, il.ltr, r)) : ul(0, il.ltr, r) }; const al = function (i, e) { return cl(i, e).match({ ltr(e, t, n, r) { const o = i.document.createRange(); return o.setStart(e.dom(), t), o.setEnd(n.dom(), r), o }, rtl(e, t, n, r) { const o = i.document.createRange(); return o.setStart(n.dom(), r), o.setEnd(e.dom(), t), o } }) }; const ll = (il.ltr, il.rtl, function (e, t, n) { return t >= e.left && t <= e.right && n >= e.top && n <= e.bottom }); const fl = function (n, r, e, t, o) { const i = function (e) { const t = n.dom().createRange(); return t.setStart(r.dom(), e), t.collapse(!0), t }; const u = Rn(r).length; const c = (function (e, t, n, r, o) { if (o === 0) return 0; if (t === r) return o - 1; for (let i = r, u = 1; u < o; u++) { const c = e(u); const a = Math.abs(t - c.left); if (n <= c.bottom) { if (n < c.top || i < a) return u - 1; i = a } } return 0 }((e) => i(e).getBoundingClientRect(), e, t, o.right, u)); return i(c) }; const sl = function (t, n, r, o) { const e = t.dom().createRange(); e.selectNode(n.dom()); const i = e.getClientRects(); return ni(i, (e) => ll(e, r, o) ? S.some(e) : S.none()).map((e) => fl(t, n, r, o, e)) }; const dl = function (t, e, n, r) { const o = t.dom().createRange(); const i = ft(e); return ni(i, (e) => o.selectNode(e.dom()), ll(o.getBoundingClientRect(), n, r) ? ml(t, e, n, r) : S.none()) }; var ml = function (e, t, n, r) { return (wt(t) ? sl : dl)(e, t, n, r) }; const gl = function (e, t) { return t - e.left < e.right - t }; const pl = function (e, t, n) { const r = e.dom().createRange(); return r.selectNode(t.dom()), r.collapse(n), r }; const hl = function (t, e, n) { const r = t.dom().createRange(); r.selectNode(e.dom()); const o = r.getBoundingClientRect(); const i = gl(o, n); return (!0 === i ? Nn : kn)(e).map((e) => pl(t, e, i)) }; const vl = function (e, t, n) { const r = t.dom().getBoundingClientRect(); const o = gl(r, n); return S.some(pl(e, t, o)) }; const bl = function (e, t, n, r) { const o = e.dom().createRange(); o.selectNode(t.dom()); const i = o.getBoundingClientRect(); return (function (e, t, n, r) { const o = e.dom().createRange(); o.selectNode(t.dom()); const i = o.getBoundingClientRect(); const u = Math.max(i.left, Math.min(i.right, n)); const c = Math.max(i.top, Math.min(i.bottom, r)); return ml(e, t, u, c) }(e, t, Math.max(i.left, Math.min(i.right, n)), Math.max(i.top, Math.min(i.bottom, r)))) }; const wl = document.caretPositionFromPoint ? function (n, e, t) { return S.from(n.dom().caretPositionFromPoint(e, t)).bind((e) => { if (e.offsetNode === null) return S.none(); const t = n.dom().createRange(); return t.setStart(e.offsetNode, e.offset), t.collapse(), S.some(t) }) } : document.caretRangeFromPoint ? function (e, t, n) { return S.from(e.dom().caretRangeFromPoint(t, n)) } : function (o, i, t) { return de.fromPoint(o, i, t).bind((r) => { const e = function () { return e = o, n = i, (ft(t = r).length === 0 ? vl : hl)(e, t, n); let e, t, n }; return ft(r).length === 0 ? e() : bl(o, r, i, t).orThunk(e) }) }; const yl = function (e, t) { const n = gt(e); return n === 'input' ? Ka.after(e) : A(['br', 'img'], n) ? t === 0 ? Ka.before(e) : Ka.after(e) : Ka.on(e, t) }; const xl = function (e, t) { const n = e.fold(Ka.before, yl, Ka.after); const r = t.fold(Ka.before, yl, Ka.after); return Qa(n, r) }; const Cl = function (e, t, n, r) { const o = yl(e, t); const i = yl(n, r); return Qa(o, i) }; const Sl = function (e, t) { S.from(e.getSelection()).each((e) => { e.removeAllRanges(), e.addRange(t) }) }; const Rl = function (e, t, n, r, o) { const i = rl(e, t, n, r, o); Sl(e, i) }; const Tl = function (s, e) { return cl(s, e).match({ ltr(e, t, n, r) { Rl(s, e, t, n, r) }, rtl(e, t, n, r) { let o; let i; let u; let c; let a; const l = s.getSelection(); if (l.setBaseAndExtent)l.setBaseAndExtent(e.dom(), t, n.dom(), r); else if (l.extend) try { i = e, u = t, c = n, a = r, (o = l).collapse(i.dom(), u), o.extend(c.dom(), a) } catch (f) { Rl(s, n, r, e, t) } else Rl(s, n, r, e, t) } }) }; const Dl = function (e) { const o = Ja(e).dom(); const t = function (e, t, n, r) { return rl(o, e, t, n, r) }; const n = e.match({ domRange(e) { const t = de.fromDom(e.startContainer); const n = de.fromDom(e.endContainer); return Cl(t, e.startOffset, n, e.endOffset) }, relative: xl, exact: Cl }); return cl(o, n).match({ ltr: t, rtl: t }) }; const Ol = function (e) { const t = de.fromDom(e.anchorNode); const n = de.fromDom(e.focusNode); return el(t, e.anchorOffset, n, e.focusOffset) ? S.some($a(de.fromDom(e.anchorNode), e.anchorOffset, de.fromDom(e.focusNode), e.focusOffset)) : (function (e) { if (e.rangeCount > 0) { const t = e.getRangeAt(0); const n = e.getRangeAt(e.rangeCount - 1); return S.some($a(de.fromDom(t.startContainer), t.startOffset, de.fromDom(n.endContainer), n.endOffset)) } return S.none() }(e)) }; const Al = function (e, t) { let n; let r; const o = (n = t, r = e.document.createRange(), tl(r, n), r); Sl(e, o) }; const El = function (e) { return (t = e, S.from(t.getSelection()).filter((e) => e.rangeCount > 0).bind(Ol)).map((e) => Za(e.start(), e.soffset(), e.finish(), e.foffset())); let t }; const Nl = function (e, t) { let n; let r; let o; const i = al(e, t); return r = (n = i).getClientRects(), (o = r.length > 0 ? r[0] : n.getBoundingClientRect()).width > 0 || o.height > 0 ? S.some(o).map(ol) : S.none() }; const kl = function (e, t, n) { return r = e, o = t, i = n, u = de.fromDom(r.document), wl(u, o, i).map((e) => $a(de.fromDom(e.startContainer), e.startOffset, de.fromDom(e.endContainer), e.endOffset)); let r, o, i, u }; const Il = tinymce.util.Tools.resolve('tinymce.util.VK'); const Pl = function (e, t, n, r) { return _l(e, t, Va(n), r) }; const Bl = function (e, t, n, r) { return _l(e, t, Ga(n), r) }; const Ml = function (e, t) { const n = Za(t, 0, t, 0); return Dl(n) }; const Wl = function (e, t) { let n; const r = Bt(t, 'tr'); return (n = r, n.length === 0 ? S.none() : S.some(n[n.length - 1])).bind((e) => jt(e, 'td,th').map((e) => Ml(0, e))) }; var _l = function (r, e, t, o, n) { return t.fold(S.none, S.none, (e, t) => Nn(t).map((e) => Ml(0, e)), (n) => Gt.table(n, e).bind((e) => { const t = Ur.noMenu(n); return r.undoManager.transact(() => { o.insertRowsAfter(e, t) }), Wl(0, e) })) }; const Ll = ['table', 'li', 'dl']; const jl = function (t, n, r, o) { if (t.keyCode === Il.TAB) { const i = oc(n); const u = function (e) { const t = gt(e); return nt(e, i) || A(Ll, t) }; const e = n.selection.getRng(); if (e.collapsed) { const c = de.fromDom(e.startContainer); Gt.cell(c, u).each((e) => { t.preventDefault(), (t.shiftKey ? Bl : Pl)(n, u, e, r, o).each((e) => { n.selection.setRng(e) }) }) } } }; const zl = { response: J('selection', 'kill') }; const Hl = function (t) { return function (e) { return e === t } }; const Fl = Hl(38); const Ul = Hl(40); const ql = { ltr: { isBackward: Hl(37), isForward: Hl(39) }, rtl: { isBackward: Hl(39), isForward: Hl(37) }, isUp: Fl, isDown: Ul, isNavigation(e) { return e >= 37 && e <= 40 } }; const Vl = function (e, t) { const n = al(e, t); return { start: C(de.fromDom(n.startContainer)), soffset: C(n.startOffset), finish: C(de.fromDom(n.endContainer)), foffset: C(n.endOffset) } }; const Gl = function (e, t, n, r) { return { start: C(Ka.on(e, t)), finish: C(Ka.on(n, r)) } }; function Yl(c) { return { elementFromPoint(e, t) { return de.fromPoint(de.fromDom(c.document), e, t) }, getRect(e) { return e.dom().getBoundingClientRect() }, getRangedRect(e, t, n, r) { const o = Za(e, t, n, r); return Nl(c, o).map((e) => Y(e, a)) }, getSelection() { return El(c).map((e) => Vl(c, e)) }, fromSitus(e) { const t = Qa(e.start(), e.finish()); return Vl(c, t) }, situsFromPoint(e, t) { return kl(c, e, t).map((e) => ({ start: C(Ka.on(e.start(), e.soffset())), finish: C(Ka.on(e.finish(), e.foffset())) })) }, clearSelection() { c.getSelection().removeAllRanges() }, setSelection(e) { let t, n, r, o, i, u; t = c, n = e.start(), r = e.soffset(), o = e.finish(), i = e.foffset(), u = Cl(n, r, o, i), Tl(t, u) }, setRelativeSelection(e, t) { let n, r; n = c, r = xl(e, t), Tl(n, r) }, selectContents(e) { Al(c, e) }, getInnerHeight() { return c.innerHeight }, getScrollY() { let e, t, n, r; return (e = de.fromDom(c.document), t = e !== undefined ? e.dom() : document, n = t.body.scrollLeft || t.documentElement.scrollLeft, r = t.body.scrollTop || t.documentElement.scrollTop, go(n, r)).top() }, scrollBy(e, t) { let n, r, o; n = e, r = t, ((o = de.fromDom(c.document)) !== undefined ? o.dom() : document).defaultView.scrollBy(n, r) } } }tt.detect().browser.isSafari(); const Kl = function (n, e, r, t, o) { return nt(r, t) ? S.none() : Rr(r, t, e).bind((e) => { const t = e.boxes().getOr([]); return t.length > 0 ? (o(n, t, e.start(), e.finish()), S.some(zl.response(S.some(Gl(r, 0, r, On(r))), !0))) : S.none() }) }; const Xl = { sync(n, r, e, t, o, i, u) { return nt(e, o) && t === i ? S.none() : zt(e, 'td,th', r).bind((t) => zt(o, 'td,th', r).bind((e) => Kl(n, r, t, e, u))) }, detect: Kl, update(e, t, n, r, o) { return Dr(r, e, t, o.firstSelectedSelector(), o.lastSelectedSelector()).map((e) => o.clear(n), o.selectRange(n, e.boxes(), e.start(), e.finish()), e.boxes()) } }; const $l = re(['left', 'top', 'right', 'bottom'], []); const Jl = { nu: $l, moveUp(e, t) { return $l({ left: e.left(), top: e.top() - t, right: e.right(), bottom: e.bottom() - t }) }, moveDown(e, t) { return $l({ left: e.left(), top: e.top() + t, right: e.right(), bottom: e.bottom() + t }) }, moveBottomTo(e, t) { const n = e.bottom() - e.top(); return $l({ left: e.left(), top: t - n, right: e.right(), bottom: t }) }, moveTopTo(e, t) { const n = e.bottom() - e.top(); return $l({ left: e.left(), top: t, right: e.right(), bottom: t + n }) }, getTop(e) { return e.top() }, getBottom(e) { return e.bottom() }, translate(e, t, n) { return $l({ left: e.left() + t, top: e.top() + n, right: e.right() + t, bottom: e.bottom() + n }) }, toString(e) { return `(${e.left()}, ${e.top()}) -> (${e.right()}, ${e.bottom()})` } }; const Ql = function (e) { return Jl.nu({ left: e.left, top: e.top, right: e.right, bottom: e.bottom }) }; const Zl = function (e, t) { return S.some(e.getRect(t)) }; const ef = function (e, t, n) { return bt(t) ? Zl(e, t).map(Ql) : wt(t) ? (r = e, o = t, i = n, i >= 0 && i < On(o) ? r.getRangedRect(o, i, o, i + 1) : i > 0 ? r.getRangedRect(o, i - 1, o, i) : S.none()).map(Ql) : S.none(); let r, o, i }; const tf = function (e, t) { return bt(t) ? Zl(e, t).map(Ql) : wt(t) ? e.getRangedRect(t, 0, t, On(t)).map(Ql) : S.none() }; const nf = J('item', 'mode'); const rf = function (e, t, n, r) { const o = r !== undefined ? r : of; return e.property().parent(t).map((e) => nf(e, o)) }; var of = function (e, t, n, r) { const o = r !== undefined ? r : uf; return n.sibling(e, t).map((e) => nf(e, o)) }; var uf = function (e, t, n, r) { const o = r !== undefined ? r : uf; const i = e.property().children(t); return n.first(i).map((e) => nf(e, o)) }; const cf = [{ current: rf, next: of, fallback: S.none() }, { current: of, next: uf, fallback: S.some(rf) }, { current: uf, next: uf, fallback: S.some(of) }]; var af = function (t, n, r, o, e) { return e = e !== undefined ? e : cf, M(e, (e) => e.current === r).bind((e) => e.current(t, n, o, e.next).orThunk(() => e.fallback.bind((e) => af(t, n, e, o)))) }; const lf = { backtrack: rf, sidestep: of, advance: uf, go: af }; const ff = { left() { return { sibling(e, t) { return e.query().prevSibling(t) }, first(e) { return e.length > 0 ? S.some(e[e.length - 1]) : S.none() } } }, right() { return { sibling(e, t) { return e.query().nextSibling(t) }, first(e) { return e.length > 0 ? S.some(e[0]) : S.none() } } } }; var sf = function (t, e, n, r, o, i) { return lf.go(t, e, r, o).bind((e) => i(e.item()) ? S.none() : n(e.item()) ? S.some(e.item()) : sf(t, e.item(), n, e.mode(), o, i)) }; const df = function (e, t, n, r) { return sf(e, t, n, lf.sidestep, ff.left(), r) }; const mf = function (e, t, n, r) { return sf(e, t, n, lf.sidestep, ff.right(), r) }; const gf = function (e, t) { return e.property().children(t).length === 0 }; const pf = function (e, t, n, r) { return df(e, t, n, r) }; const hf = function (e, t, n, r) { return mf(e, t, n, r) }; const vf = { before(e, t, n) { return pf(e, t, b(gf, e), n) }, after(e, t, n) { return hf(e, t, b(gf, e), n) }, seekLeft: pf, seekRight: hf, walkers() { return { left: ff.left, right: ff.right } }, walk(e, t, n, r, o) { return lf.go(e, t, n, r, o) }, backtrack: lf.backtrack, sidestep: lf.sidestep, advance: lf.advance }; const bf = zn(); const wf = { gather(e, t, n) { return vf.gather(bf, e, t, n) }, before(e, t) { return vf.before(bf, e, t) }, after(e, t) { return vf.after(bf, e, t) }, seekLeft(e, t, n) { return vf.seekLeft(bf, e, t, n) }, seekRight(e, t, n) { return vf.seekRight(bf, e, t, n) }, walkers() { return vf.walkers() }, walk(e, t, n, r) { return vf.walk(bf, e, t, n, r) } }; const yf = Br([{ none: [] }, { retry: ['caret'] }]); const xf = function (t, e, r) { return (n = e, o = Xo, Mt((e) => o(e), Wt, n, o, i)).fold(C(!1), (e) => tf(t, e).exists((e) => { return n = e, (t = r).left() < n.left() || Math.abs(n.right() - t.left()) < 1 || t.left() > n.right(); let t, n })); let n, o, i }; const Cf = { point: Jl.getTop, adjuster(e, t, n, r, o) { const i = Jl.moveUp(o, 5); return Math.abs(n.top() - r.top()) < 1 ? yf.retry(i) : n.bottom() < o.top() ? yf.retry(i) : n.bottom() === o.top() ? yf.retry(Jl.moveUp(o, 1)) : xf(e, t, o) ? yf.retry(Jl.translate(i, 5, 0)) : yf.none() }, move: Jl.moveUp, gather: wf.before }; const Sf = { point: Jl.getBottom, adjuster(e, t, n, r, o) { const i = Jl.moveDown(o, 5); return Math.abs(n.bottom() - r.bottom()) < 1 ? yf.retry(i) : n.top() > o.bottom() ? yf.retry(i) : n.top() === o.bottom() ? yf.retry(Jl.moveDown(o, 1)) : xf(e, t, o) ? yf.retry(Jl.translate(i, 5, 0)) : yf.none() }, move: Jl.moveDown, gather: wf.after }; var Rf = function (n, r, o, i, u) { return u === 0 ? S.some(i) : (a = n, l = i.left(), f = r.point(i), a.elementFromPoint(l, f).filter((e) => gt(e) === 'table').isSome() ? (t = i, c = u - 1, Rf(n, e = r, o, e.move(t, 5), c)) : n.situsFromPoint(i.left(), r.point(i)).bind((e) => e.start().fold(S.none, (t, e) => tf(n, t, e).bind((e) => r.adjuster(n, t, e, o, i).fold(S.none, (e) => Rf(n, r, o, e, u - 1))).orThunk(() => S.some(i)), S.none))); let e, t, c, a, l, f }; const Tf = function (t, n, e) { let r; let o; let i; const u = t.move(e, 5); const c = Rf(n, t, e, u, 100).getOr(u); return (r = t, o = c, i = n, r.point(o) > i.getInnerHeight() ? S.some(r.point(o) - i.getInnerHeight()) : r.point(o) < 0 ? S.some(-r.point(o)) : S.none()).fold(() => n.situsFromPoint(c.left(), t.point(c)), (e) => n.scrollBy(0, e), n.situsFromPoint(c.left(), t.point(c) - e)) }; const Df = { tryUp: b(Tf, Cf), tryDown: b(Tf, Sf), ieTryUp(e, t) { return e.situsFromPoint(t.left(), t.top() - 5) }, ieTryDown(e, t) { return e.situsFromPoint(t.left(), t.bottom() + 5) }, getJumpSize: C(5) }; const Of = Br([{ none: ['message'] }, { success: [] }, { failedUp: ['cell'] }, { failedDown: ['cell'] }]); const Af = function (e) { return zt(e, 'tr') }; const Ef = { verify(c, e, t, n, r, a, o) { return zt(n, 'td,th', o).bind((u) => zt(e, 'td,th', o).map((i) => nt(u, i) ? nt(n, u) && On(u) === r ? a(i) : Of.none('in same cell') : ur.sharedOne(Af, [u, i]).fold(() => { return t = i, n = u, r = (e = c).getRect(t), (o = e.getRect(n)).right > r.left && o.left < r.right ? Of.success() : a(i); let e, t, n, r, o }, (e) => a(i)))).getOr(Of.none('default')) }, cata(e, t, n, r, o) { return e.fold(t, n, r, o) }, adt: Of }; const Nf = { point: J('element', 'offset'), delta: J('element', 'deltaOffset'), range: J('element', 'start', 'finish'), points: J('begin', 'end'), text: J('element', 'text') }; const kf = (J('ancestor', 'descendants', 'element', 'index'), J('parent', 'children', 'element', 'index')); const If = function (e, t) { return W(e, b(nt, t)) }; const Pf = function (e) { return gt(e) === 'br' }; var Bf = function (e, t, n) { return t(e, n).bind((e) => wt(e) && Rn(e).trim().length === 0 ? Bf(e, t, n) : S.some(e)) }; const Mf = function (t, e, n, r) { return (o = e, i = n, st(o, i).filter(Pf).orThunk(() => st(o, i - 1).filter(Pf))).bind((e) => r.traverse(e).fold(() => Bf(e, r.gather, t).map(r.relative), (e) => { return (r = e, ut(r).bind((t) => { const n = ft(t); return If(n, r).map((e) => kf(t, n, r, e)) })).map((e) => Ka.on(e.parent(), e.index())); let r })); let o, i }; const Wf = function (e, t, n, r) { let o, i, u; return (Pf(t) ? (o = e, i = t, (u = r).traverse(i).orThunk(() => Bf(i, u.gather, o)).map(u.relative)) : Mf(e, t, n, r)).map((e) => ({ start: C(e), finish: C(e) })) }; const _f = function (e) { return Ef.cata(e, (e) => S.none(), () => S.none(), (e) => S.some(Nf.point(e, 0)), (e) => S.some(Nf.point(e, On(e)))) }; const Lf = tt.detect(); var jf = function (r, o, i, u, c, a) { return a === 0 ? S.none() : Ff(r, o, i, u, c).bind((e) => { const t = r.fromSitus(e); const n = Ef.verify(r, i, u, t.finish(), t.foffset(), c.failure, o); return Ef.cata(n, () => S.none(), () => S.some(e), (e) => nt(i, e) && u === 0 ? zf(r, i, u, Jl.moveUp, c) : jf(r, o, e, 0, c, a - 1), (e) => nt(i, e) && u === On(e) ? zf(r, i, u, Jl.moveDown, c) : jf(r, o, e, On(e), c, a - 1)) }) }; var zf = function (t, e, n, r, o) { return ef(t, e, n).bind((e) => Hf(t, o, r(e, Df.getJumpSize()))) }; var Hf = function (e, t, n) { return Lf.browser.isChrome() || Lf.browser.isSafari() || Lf.browser.isFirefox() || Lf.browser.isEdge() ? t.otherRetry(e, n) : Lf.browser.isIE() ? t.ieRetry(e, n) : S.none() }; var Ff = function (t, e, n, r, o) { return ef(t, n, r).bind((e) => Hf(t, o, e)) }; const Uf = function (t, n, r) { return (o = t, i = n, u = r, o.getSelection().bind((r) => Wf(i, r.finish(), r.foffset(), u).fold(() => S.some(Nf.point(r.finish(), r.foffset())), (e) => { const t = o.fromSitus(e); const n = Ef.verify(o, r.finish(), r.foffset(), t.finish(), t.foffset(), u.failure, i); return _f(n) }))).bind((e) => jf(t, n, e.element(), e.offset(), r, 20).map(t.fromSitus)); let o, i, u }; const qf = tt.detect(); const Vf = function (e, t) { return Wt(e, (e) => ut(e).exists((e) => nt(e, t)), n).isSome(); let n }; const Gf = function (t, r, o, e, i) { return zt(e, 'td,th', r).bind((n) => zt(n, 'table', r).bind((e) => Vf(i, e) ? Uf(t, r, o).bind((t) => zt(t.finish(), 'td,th', r).map((e) => ({ start: C(n), finish: C(e), range: C(t) }))) : S.none())) }; const Yf = function (e, t, n, r, o, i) { return qf.browser.isIE() ? S.none() : i(r, t).orThunk(() => Gf(e, t, n, r, o).map((e) => { const t = e.range(); return zl.response(S.some(Gl(t.start(), t.soffset(), t.finish(), t.foffset())), !0) })) }; const Kf = function (e, t, n, r, o, i, u) { return Gf(e, n, r, o, i).bind((e) => Xl.detect(t, n, e.start(), e.finish(), u)) }; const Xf = function (e, r) { return zt(e, 'tr', r).bind((n) => zt(n, 'table', r).bind((e) => { const t = Bt(e, 'tr'); return nt(n, t[0]) ? wf.seekLeft(e, (e) => kn(e).isSome(), r).map((e) => { const t = On(e); return zl.response(S.some(Gl(e, t, e, t)), !0) }) : S.none() })) }; const $f = function (e, r) { return zt(e, 'tr', r).bind((n) => zt(n, 'table', r).bind((e) => { const t = Bt(e, 'tr'); return nt(n, t[t.length - 1]) ? wf.seekRight(e, (e) => Nn(e).isSome(), r).map((e) => zl.response(S.some(Gl(e, 0, e, 0)), !0)) : S.none() })) }; const Jf = function (e, t) { return zt(e, 'td,th', t) }; const Qf = { down: { traverse: lt, gather: wf.after, relative: Ka.before, otherRetry: Df.tryDown, ieRetry: Df.ieTryDown, failure: Ef.adt.failedDown }, up: { traverse: at, gather: wf.before, relative: Ka.before, otherRetry: Df.tryUp, ieRetry: Df.ieTryUp, failure: Ef.adt.failedUp } }; const Zf = J('rows', 'cols'); const es = { mouse(e, t, n, r) { const o = (function c(o, i, t, u) { let n = S.none(); const e = function () { n = S.none() }; return { mousedown(e) { u.clear(i), n = Jf(e.target(), t) }, mouseover(e) { n.each((r) => { u.clear(i), Jf(e.target(), t).each((n) => { Rr(r, n, t).each((e) => { const t = e.boxes().getOr([]); (t.length > 1 || t.length === 1 && !nt(r, n)) && (u.selectRange(i, t, e.start(), e.finish()), o.selectContents(n)) }) }) }) }, mouseup() { n.each(e) } } }(Yl(e), t, n, r)); return { mousedown: o.mousedown, mouseover: o.mouseover, mouseup: o.mouseup } }, keyboard(e, a, l, f) { const s = Yl(e); const d = function () { return f.clear(a), S.none() }; return { keydown(e, t, n, r, o, i) { const u = e.raw().which; const c = !0 === e.raw().shiftKey; return Tr(a, f.selectedSelector()).fold(() => ql.isDown(u) && c ? b(Kf, s, a, l, Qf.down, r, t, f.selectRange) : ql.isUp(u) && c ? b(Kf, s, a, l, Qf.up, r, t, f.selectRange) : ql.isDown(u) ? b(Yf, s, l, Qf.down, r, t, $f) : ql.isUp(u) ? b(Yf, s, l, Qf.up, r, t, Xf) : S.none, (t) => { const e = function (e) { return function () { return ni(e, (e) => Xl.update(e.rows(), e.cols(), a, t, f)).fold(() => Or(a, f.firstSelectedSelector(), f.lastSelectedSelector()).map((e) => { const t = ql.isDown(u) || i.isForward(u) ? Ka.after : Ka.before; return s.setRelativeSelection(Ka.on(e.first(), 0), t(e.table())), f.clear(a), zl.response(S.none(), !0) }), (e) => S.some(zl.response(S.none(), !0))) } }; return ql.isDown(u) && c ? e([Zf(1, 0)]) : ql.isUp(u) && c ? e([Zf(-1, 0)]) : i.isBackward(u) && c ? e([Zf(0, -1), Zf(-1, 0)]) : i.isForward(u) && c ? e([Zf(0, 1), Zf(1, 0)]) : ql.isNavigation(u) && !1 === c ? d : S.none })() }, keyup(t, n, r, o, i) { return Tr(a, f.selectedSelector()).fold(() => { const e = t.raw().which; return (!0 === t.raw().shiftKey) == 0 ? S.none() : ql.isNavigation(e) ? Xl.sync(a, l, n, r, o, i, f.selectRange) : S.none() }, S.none) } } } }; const ts = function (r, e) { k(e, (e) => { let t, n; n = e, Ri(t = r) ? t.dom().classList.remove(n) : Di(t, n), Ai(t) }) }; const ns = { byClass(o) { let t; let n; const i = (t = o.selected(), function (e) { Oi(e, t) }); const r = (n = [o.selected(), o.lastSelected(), o.firstSelected()], function (e) { ts(e, n) }); const u = function (e) { const t = Bt(e, o.selectedSelector()); k(t, r) }; return { clear: u, selectRange(e, t, n, r) { u(e), k(t, i), Oi(n, o.firstSelected()), Oi(r, o.lastSelected()) }, selectedSelector: o.selectedSelector, firstSelectedSelector: o.firstSelectedSelector, lastSelectedSelector: o.lastSelectedSelector } }, byAttr(o) { const n = function (e) { Dt(e, o.selected()), Dt(e, o.firstSelected()), Dt(e, o.lastSelected()) }; const i = function (e) { Ct(e, o.selected(), '1') }; const u = function (e) { const t = Bt(e, o.selectedSelector()); k(t, n) }; return { clear: u, selectRange(e, t, n, r) { u(e), k(t, i), Ct(n, o.firstSelected(), '1'), Ct(r, o.lastSelected(), '1') }, selectedSelector: o.selectedSelector, firstSelectedSelector: o.firstSelectedSelector, lastSelectedSelector: o.lastSelectedSelector } } }; const rs = function (e) { return !1 === Ei(de.fromDom(e.target), 'ephox-snooker-resizer-bar') }; function os(p, h) { const v = re(['mousedown', 'mouseover', 'mouseup', 'keyup', 'keydown'], []); let b = S.none(); const w = ns.byAttr(Pr); return p.on('init', (e) => { const r = p.getWin(); const o = oc(p); const t = cc(p); const n = es.mouse(r, o, t, w); const c = es.keyboard(r, o, t, w); const a = function (e, t) { !0 === e.raw().shiftKey && (t.kill() && e.kill(), t.selection().each((e) => { const t = Qa(e.start(), e.finish()); const n = al(r, t); p.selection.setRng(n) })) }; const i = function (e) { const t = f(e); if (t.raw().shiftKey && ql.isNavigation(t.raw().which)) { const n = p.selection.getRng(); const r = de.fromDom(n.startContainer); const o = de.fromDom(n.endContainer); c.keyup(t, r, n.startOffset, o, n.endOffset).each((e) => { a(t, e) }) } }; const u = function (e) { const t = f(e); h().each((e) => { e.hideBars() }); const n = p.selection.getRng(); const r = de.fromDom(p.selection.getStart()); const o = de.fromDom(n.startContainer); const i = de.fromDom(n.endContainer); const u = dc.directionAt(r).isRtl() ? ql.rtl : ql.ltr; c.keydown(t, o, n.startOffset, i, n.endOffset, u).each((e) => { a(t, e) }), h().each((e) => { e.showBars() }) }; const l = function (e) { return e.hasOwnProperty('x') && e.hasOwnProperty('y') }; var f = function (e) { const t = de.fromDom(e.target); const n = function () { e.stopPropagation() }; const r = function () { e.preventDefault() }; const o = x(r, n); return { target: C(t), x: C(l(e) ? e.x : null), y: C(l(e) ? e.y : null), stop: n, prevent: r, kill: o, raw: C(e) } }; const s = function (e) { return e.button === 0 }; const d = function (e) { s(e) && rs(e) && n.mousedown(f(e)) }; const m = function (e) { let t; (t = e).buttons !== undefined && (1 & t.buttons) == 0 || !rs(e) || n.mouseover(f(e)) }; const g = function (e) { s(e) && rs(e) && n.mouseup(f(e)) }; p.on('mousedown', d), p.on('mouseover', m), p.on('mouseup', g), p.on('keyup', i), p.on('keydown', u), p.on('nodechange', () => { const e = p.selection; const t = de.fromDom(e.getStart()); const n = de.fromDom(e.getEnd()); ur.sharedOne(Gt.table, [t, n]).fold(() => { w.clear(o) }, y) }), b = S.some(v({ mousedown: d, mouseover: m, mouseup: g, keyup: i, keydown: u })) }), { clear: w.clear, destroy() { b.each((e) => {}) } } } const is = function (t) { t.ui.registry.addMenuButton('table', { tooltip: 'Table', icon: 'table', fetch(e) { return e('inserttable tableprops deletetable | cell row column') } }); const e = function (e) { return function () { return t.execCommand(e) } }; t.ui.registry.addButton('tableprops', { tooltip: 'Table properties', onAction: e('mceTableProps'), icon: 'table' }), t.ui.registry.addButton('tabledelete', { tooltip: 'Delete table', onAction: e('mceTableDelete'), icon: 'table-delete-table' }), t.ui.registry.addButton('tablecellprops', { tooltip: 'Cell properties', onAction: e('mceTableCellProps'), icon: 'table-cell-properties' }), t.ui.registry.addButton('tablemergecells', { tooltip: 'Merge cells', onAction: e('mceTableMergeCells'), icon: 'table-merge-cells' }), t.ui.registry.addButton('tablesplitcells', { tooltip: 'Split cell', onAction: e('mceTableSplitCells'), icon: 'table-split-cells' }), t.ui.registry.addButton('tableinsertrowbefore', { tooltip: 'Insert row before', onAction: e('mceTableInsertRowBefore'), icon: 'table-insert-row-above' }), t.ui.registry.addButton('tableinsertrowafter', { tooltip: 'Insert row after', onAction: e('mceTableInsertRowAfter'), icon: 'table-insert-row-after' }), t.ui.registry.addButton('tabledeleterow', { tooltip: 'Delete row', onAction: e('mceTableDeleteRow'), icon: 'table-delete-row' }), t.ui.registry.addButton('tablerowprops', { tooltip: 'Row properties', onAction: e('mceTableRowProps'), icon: 'table-row-properties' }), t.ui.registry.addButton('tableinsertcolbefore', { tooltip: 'Insert column before', onAction: e('mceTableInsertColBefore'), icon: 'table-insert-column-before' }), t.ui.registry.addButton('tableinsertcolafter', { tooltip: 'Insert column after', onAction: e('mceTableInsertColAfter'), icon: 'table-insert-column-after' }), t.ui.registry.addButton('tabledeletecol', { tooltip: 'Delete column', onAction: e('mceTableDeleteCol'), icon: 'table-delete-column' }), t.ui.registry.addButton('tablecutrow', { tooltip: 'Cut row', onAction: e('mceTableCutRow'), icon: 'temporary-placeholder' }), t.ui.registry.addButton('tablecopyrow', { tooltip: 'Copy row', onAction: e('mceTableCopyRow'), icon: 'temporary-placeholder' }), t.ui.registry.addButton('tablepasterowbefore', { tooltip: 'Paste row before', onAction: e('mceTablePasteRowBefore'), icon: 'temporary-placeholder' }), t.ui.registry.addButton('tablepasterowafter', { tooltip: 'Paste row after', onAction: e('mceTablePasteRowAfter'), icon: 'temporary-placeholder' }) }; const us = function (t) { const e = t.getParam('table_toolbar', 'tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol'); e.length > 0 && t.ui.registry.addContextToolbar('table', { predicate(e) { return t.dom.is(e, 'table') && t.getBody().contains(e) }, items: e, scope: 'node', position: 'node' }) }; const cs = function (r, n) { let e = S.none; const o = function (e) { e.setDisabled(!0) }; const t = function (t) { return e().fold(() => { o(t) }, (e) => { t.setDisabled(!1) }), function () {} }; const i = function (t) { return e().fold(() => { o(t) }, (e) => { t.setDisabled(e.mergable().isNone()) }), function () {} }; const u = function (t) { return e().fold(() => { o(t) }, (e) => { t.setDisabled(e.unmergable().isNone()) }), function () {} }; const c = function () { e = Oe(() => S.from(r.dom.getParent(r.selection.getStart(), 'th,td')).bind((e) => { const t = de.fromDom(e); return Gt.table(t).map((e) => Ur.forMenu(n, e, t)) })) }; r.on('nodechange', c); const a = function (e) { return function () { return r.execCommand(e) } }; const l = function (e) { const t = e.numRows; const n = e.numColumns; r.undoManager.transact(() => { fa(r, n, t) }), r.addVisual() }; const f = { text: 'Table properties', onSetup: t, onAction: a('mceTableProps') }; const s = { text: 'Delete table', icon: 'table-delete-table', onSetup: t, onAction: a('mceTableDelete') }; const d = { type: 'nestedmenuitem', text: 'Row', getSubmenuItems() { return [{ type: 'menuitem', text: 'Insert row before', icon: 'table-insert-row-above', onAction: a('mceTableInsertRowBefore'), onSetup: t }, { type: 'menuitem', text: 'Insert row after', icon: 'table-insert-row-after', onAction: a('mceTableInsertRowAfter'), onSetup: t }, { type: 'menuitem', text: 'Delete row', icon: 'table-delete-row', onAction: a('mceTableDeleteRow'), onSetup: t }, { type: 'menuitem', text: 'Row properties', icon: 'table-row-properties', onAction: a('mceTableRowProps'), onSetup: t }, { type: 'separator' }, { type: 'menuitem', text: 'Cut row', onAction: a('mceTableCutRow'), onSetup: t }, { type: 'menuitem', text: 'Copy row', onAction: a('mceTableCopyRow'), onSetup: t }, { type: 'menuitem', text: 'Paste row before', onAction: a('mceTablePasteRowBefore'), onSetup: t }, { type: 'menuitem', text: 'Paste row after', onAction: a('mceTablePasteRowAfter'), onSetup: t }] } }; const m = { type: 'nestedmenuitem', text: 'Column', getSubmenuItems() { return [{ type: 'menuitem', text: 'Insert column before', icon: 'table-insert-column-before', onAction: a('mceTableInsertColBefore'), onSetup: t }, { type: 'menuitem', text: 'Insert column after', icon: 'table-insert-column-after', onAction: a('mceTableInsertColAfter'), onSetup: t }, { type: 'menuitem', text: 'Delete column', icon: 'table-delete-column', onAction: a('mceTableDeleteCol'), onSetup: t }] } }; const g = { type: 'nestedmenuitem', text: 'Cell', getSubmenuItems() { return [{ type: 'menuitem', text: 'Cell properties', icon: 'table-cell-properties', onAction: a('mceTableCellProps'), onSetup: t }, { type: 'menuitem', text: 'Merge cells', icon: 'table-merge-cells', onAction: a('mceTableMergeCells'), onSetup: i }, { type: 'menuitem', text: 'Split cell', icon: 'table-split-cells', onAction: a('mceTableSplitCells'), onSetup: u }] } }; !1 === r.getParam('table_grid', !0, 'boolean') ? r.ui.registry.addMenuItem('inserttable', { text: 'Table', icon: 'table', onAction: a('mceInsertTable') }) : r.ui.registry.addNestedMenuItem('inserttable', { text: 'Table', icon: 'table', getSubmenuItems() { return [{ type: 'fancymenuitem', fancytype: 'inserttable', onAction: l }] } }), r.ui.registry.addMenuItem('tableprops', f), r.ui.registry.addMenuItem('deletetable', s), r.ui.registry.addNestedMenuItem('row', d), r.ui.registry.addNestedMenuItem('column', m), r.ui.registry.addNestedMenuItem('cell', g), r.ui.registry.addContextMenu('table', { update() { return c(), e().fold(() => '', () => 'cell row column | tableprops deletetable') } }) }; const as = function (n, r) { return { insertTable(e, t) { return fa(n, e, t) }, setClipboardRows(e) { return t = r, n = N(e, de.fromDom), void t.set(S.from(n)); let t, n }, getClipboardRows() { return r.get().fold(() => {}, (e) => N(e, (e) => e.dom())) } } }; e.add('table', (t) => { let n; const r = La(t); const e = os(t, r.lazyResize); const o = Oc(t, r.lazyWire); const i = (n = t, { get() { const e = oc(n); return Ar(e, Pr.selectedSelector()).fold(() => n.selection.getStart() === undefined ? Wr.none() : Wr.single(n.selection), (e) => Wr.multiple(e)) } }); const u = Po(S.none()); return pa(t, o, e, i, u), qr(t, i, o, e), cs(t, i), is(t), us(t), t.on('PreInit', () => { t.serializer.addTempAttr(Pr.firstSelected()), t.serializer.addTempAttr(Pr.lastSelected()) }), t.getParam('table_tab_navigation', !0, 'boolean') && t.on('keydown', (e) => { jl(e, t, o, r.lazyWire) }), t.on('remove', () => { r.destroy(), e.destroy() }), as(t, u) }), function ss() {}
}())
