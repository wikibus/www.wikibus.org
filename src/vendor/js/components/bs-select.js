/*!
 * Bootstrap-select v1.13.5 (https://developer.snapappointments.com/bootstrap-select)
 *
 * Copyright 2012-2018 SnapAppointments, LLC
 * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)
 */

!(function (e, t) { void 0 === e && void 0 !== window && (e = window), typeof define === 'function' && define.amd ? define(['jquery'], (e) => t(e)) : typeof module === 'object' && module.exports ? module.exports = t(require('jquery')) : t(e.jQuery) }(this, (e) => {
  !(function (G) {
    'classList' in document.createElement('_') || (function (e) { if ('Element' in e) { const t = 'classList'; const i = 'prototype'; const n = e.Element[i]; const s = Object; const o = function () { const i = G(this); return { add(e) { return i.addClass(e) }, remove(e) { return i.removeClass(e) }, toggle(e, t) { return i.toggleClass(e, t) }, contains(e) { return i.hasClass(e) } } }; if (s.defineProperty) { const l = { get: o, enumerable: !0, configurable: !0 }; try { s.defineProperty(n, t, l) } catch (e) { void 0 !== e.number && e.number !== -2146823252 || (l.enumerable = !1, s.defineProperty(n, t, l)) } } else s[i].__defineGetter__ && n.__defineGetter__(t, o) } }(window)); let e; let c; let t; let i = document.createElement('_'); if (i.classList.toggle('c3', !1), i.classList.contains('c3')) { const n = DOMTokenList.prototype.toggle; DOMTokenList.prototype.toggle = function (e, t) { return 1 in arguments && !this.contains(e) == !t ? t : n.call(this, e) } } function S(e) { let t; let i = []; const n = e && e.options; if (e.multiple) for (let s = 0, o = n.length; s < o; s++)(t = n[s]).selected && i.push(t.value || t.text); else i = e.value; return i }i = null, String.prototype.startsWith || (e = (function () { try { const e = {}; const t = Object.defineProperty; var i = t(e, e, e) && t } catch (e) {} return i }()), c = {}.toString, t = function (e) { if (this == null) throw new TypeError(); const t = String(this); if (e && c.call(e) == '[object RegExp]') throw new TypeError(); const i = t.length; const n = String(e); const s = n.length; const o = arguments.length > 1 ? arguments[1] : void 0; let l = o ? Number(o) : 0; l != l && (l = 0); const r = Math.min(Math.max(l, 0), i); if (i < s + r) return !1; for (let a = -1; ++a < s;) if (t.charCodeAt(r + a) != n.charCodeAt(a)) return !1; return !0 }, e ? e(String.prototype, 'startsWith', { value: t, configurable: !0, writable: !0 }) : String.prototype.startsWith = t), Object.keys || (Object.keys = function (e, t, i) { for (t in i = [], e)i.hasOwnProperty.call(e, t) && i.push(t); return i }); const s = { useDefault: !1, _set: G.valHooks.select.set }; G.valHooks.select.set = function (e, t) { return t && !s.useDefault && G(e).data('selected', !0), s._set.apply(this, arguments) }; let y = null; const o = (function () { try { return new Event('change'), !0 } catch (e) { return !1 } }()); function $(e, t, i, n) { for (var s = ['content', 'subtext', 'tokens'], o = !1, l = 0; l < s.length; l++) { const r = s[l]; let a = e[r]; if (a && (a = a.toString(), r === 'content' && (a = a.replace(/<[^>]+>/g, '')), n && (a = m(a)), a = a.toUpperCase(), o = i === 'contains' ? a.indexOf(t) >= 0 : a.startsWith(t))) break } return o } function z(e) { return parseInt(e, 10) || 0 }G.fn.triggerNative = function (e) { let t; const i = this[0]; i.dispatchEvent ? (o ? t = new Event(e, { bubbles: !0 }) : (t = document.createEvent('Event')).initEvent(e, !0, !1), i.dispatchEvent(t)) : i.fireEvent ? ((t = document.createEventObject()).eventType = e, i.fireEvent(`on${e}`, t)) : this.trigger(e) }; const l = { À: 'A', Á: 'A', Â: 'A', Ã: 'A', Ä: 'A', Å: 'A', à: 'a', á: 'a', â: 'a', ã: 'a', ä: 'a', å: 'a', Ç: 'C', ç: 'c', Ð: 'D', ð: 'd', È: 'E', É: 'E', Ê: 'E', Ë: 'E', è: 'e', é: 'e', ê: 'e', ë: 'e', Ì: 'I', Í: 'I', Î: 'I', Ï: 'I', ì: 'i', í: 'i', î: 'i', ï: 'i', Ñ: 'N', ñ: 'n', Ò: 'O', Ó: 'O', Ô: 'O', Õ: 'O', Ö: 'O', Ø: 'O', ò: 'o', ó: 'o', ô: 'o', õ: 'o', ö: 'o', ø: 'o', Ù: 'U', Ú: 'U', Û: 'U', Ü: 'U', ù: 'u', ú: 'u', û: 'u', ü: 'u', Ý: 'Y', ý: 'y', ÿ: 'y', Æ: 'Ae', æ: 'ae', Þ: 'Th', þ: 'th', ß: 'ss', Ā: 'A', Ă: 'A', Ą: 'A', ā: 'a', ă: 'a', ą: 'a', Ć: 'C', Ĉ: 'C', Ċ: 'C', Č: 'C', ć: 'c', ĉ: 'c', ċ: 'c', č: 'c', Ď: 'D', Đ: 'D', ď: 'd', đ: 'd', Ē: 'E', Ĕ: 'E', Ė: 'E', Ę: 'E', Ě: 'E', ē: 'e', ĕ: 'e', ė: 'e', ę: 'e', ě: 'e', Ĝ: 'G', Ğ: 'G', Ġ: 'G', Ģ: 'G', ĝ: 'g', ğ: 'g', ġ: 'g', ģ: 'g', Ĥ: 'H', Ħ: 'H', ĥ: 'h', ħ: 'h', Ĩ: 'I', Ī: 'I', Ĭ: 'I', Į: 'I', İ: 'I', ĩ: 'i', ī: 'i', ĭ: 'i', į: 'i', ı: 'i', Ĵ: 'J', ĵ: 'j', Ķ: 'K', ķ: 'k', ĸ: 'k', Ĺ: 'L', Ļ: 'L', Ľ: 'L', Ŀ: 'L', Ł: 'L', ĺ: 'l', ļ: 'l', ľ: 'l', ŀ: 'l', ł: 'l', Ń: 'N', Ņ: 'N', Ň: 'N', Ŋ: 'N', ń: 'n', ņ: 'n', ň: 'n', ŋ: 'n', Ō: 'O', Ŏ: 'O', Ő: 'O', ō: 'o', ŏ: 'o', ő: 'o', Ŕ: 'R', Ŗ: 'R', Ř: 'R', ŕ: 'r', ŗ: 'r', ř: 'r', Ś: 'S', Ŝ: 'S', Ş: 'S', Š: 'S', ś: 's', ŝ: 's', ş: 's', š: 's', Ţ: 'T', Ť: 'T', Ŧ: 'T', ţ: 't', ť: 't', ŧ: 't', Ũ: 'U', Ū: 'U', Ŭ: 'U', Ů: 'U', Ű: 'U', Ų: 'U', ũ: 'u', ū: 'u', ŭ: 'u', ů: 'u', ű: 'u', ų: 'u', Ŵ: 'W', ŵ: 'w', Ŷ: 'Y', ŷ: 'y', Ÿ: 'Y', Ź: 'Z', Ż: 'Z', Ž: 'Z', ź: 'z', ż: 'z', ž: 'z', Ĳ: 'IJ', ĳ: 'ij', Œ: 'Oe', œ: 'oe', ŉ: "'n", ſ: 's' }; const r = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g; const a = RegExp('[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\u1ab0-\\u1aff\\u1dc0-\\u1dff]', 'g'); function d(e) { return l[e] } function m(e) { return (e = e.toString()) && e.replace(r, d).replace(a, '') } const h = function (t) { const i = function (e) { return t[e] }; const e = `(?:${Object.keys(t).join('|')})`; const n = RegExp(e); const s = RegExp(e, 'g'); return function (e) { return e = e == null ? '' : `${e}`, n.test(e) ? e.replace(s, i) : e } }; const q = h({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;' }); const v = h({ '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&#x27;': "'", '&#x60;': '`' }); const E = { 32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 96: '0', 97: '1', 98: '2', 99: '3', 100: '4', 101: '5', 102: '6', 103: '7', 104: '8', 105: '9' }; const C = 27; const O = 13; const T = 32; const H = 9; const D = 38; const L = 40; const K = { success: !1, major: '3' }; try { K.full = (G.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.'), K.major = K.full[0], K.success = !0 } catch (e) { console.warn("There was an issue retrieving Bootstrap's version. Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.", e) } let p = 0; const A = '.bs.select'; const Y = { DISABLED: 'disabled', DIVIDER: 'divider', SHOW: 'open', DROPUP: 'dropup', MENU: 'dropdown-menu', MENURIGHT: 'dropdown-menu-right', MENULEFT: 'dropdown-menu-left', BUTTONCLASS: 'btn-default', POPOVERHEADER: 'popover-title' }; const N = { MENU: `.${Y.MENU}` }; K.major === '4' && (Y.DIVIDER = 'dropdown-divider', Y.SHOW = 'show', Y.BUTTONCLASS = 'btn-light', Y.POPOVERHEADER = 'popover-header'); const P = new RegExp(`${D}|${L}`); const R = new RegExp(`^${H}$|${C}`); var u = function (e, t) { const i = this; s.useDefault || (G.valHooks.select.set = s._set, s.useDefault = !0), this.$element = G(e), this.$newElement = null, this.$button = null, this.$menu = null, this.options = t, this.selectpicker = { main: { map: { newIndex: {}, originalIndex: {} } }, current: { map: {} }, search: { map: {} }, view: {}, keydown: { keyHistory: '', resetKeyHistory: { start() { return setTimeout(() => { i.selectpicker.keydown.keyHistory = '' }, 800) } } } }, this.options.title === null && (this.options.title = this.$element.attr('title')); const n = this.options.windowPadding; typeof n === 'number' && (this.options.windowPadding = [n, n, n, n]), this.val = u.prototype.val, this.render = u.prototype.render, this.refresh = u.prototype.refresh, this.setStyle = u.prototype.setStyle, this.selectAll = u.prototype.selectAll, this.deselectAll = u.prototype.deselectAll, this.destroy = u.prototype.destroy, this.remove = u.prototype.remove, this.show = u.prototype.show, this.hide = u.prototype.hide, this.init() }; function f(e) { let o; const l = arguments; const r = e; if ([].shift.apply(l), !K.success) { try { K.full = (G.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.') } catch (e) { K.full = u.BootstrapVersion.split(' ')[0].split('.') }K.major = K.full[0], K.success = !0, K.major === '4' && (Y.DIVIDER = 'dropdown-divider', Y.SHOW = 'show', Y.BUTTONCLASS = 'btn-light', u.DEFAULTS.style = Y.BUTTONCLASS = 'btn-light', Y.POPOVERHEADER = 'popover-header') } const t = this.each(function () { const e = G(this); if (e.is('select')) { let t = e.data('selectpicker'); const i = typeof r === 'object' && r; if (t) { if (i) for (const n in i)i.hasOwnProperty(n) && (t.options[n] = i[n]) } else { const s = G.extend({}, u.DEFAULTS, G.fn.selectpicker.defaults || {}, e.data(), i); s.template = G.extend({}, u.DEFAULTS.template, G.fn.selectpicker.defaults ? G.fn.selectpicker.defaults.template : {}, e.data().template, i.template), e.data('selectpicker', t = new u(this, s)) } typeof r === 'string' && (o = t[r] instanceof Function ? t[r].apply(t, l) : t.options[r]) } }); return void 0 !== o ? o : t }u.VERSION = '1.13.5', u.BootstrapVersion = K.major, u.DEFAULTS = { noneSelectedText: 'Nothing selected', noneResultsText: 'No results matched {0}', countSelectedText(e, t) { return e == 1 ? '{0} item selected' : '{0} items selected' }, maxOptionsText(e, t) { return [e == 1 ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)', t == 1 ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'] }, selectAllText: 'Select All', deselectAllText: 'Deselect All', doneButton: !1, doneButtonText: 'Close', multipleSeparator: ', ', styleBase: 'btn', style: Y.BUTTONCLASS, size: 'auto', title: null, selectedTextFormat: 'values', width: !1, container: !1, hideDisabled: !1, showSubtext: !1, showIcon: !0, showContent: !0, dropupAuto: !0, header: !1, liveSearch: !1, liveSearchPlaceholder: null, liveSearchNormalize: !1, liveSearchStyle: 'contains', actionsBox: !1, iconBase: 'glyphicon', tickIcon: 'glyphicon-ok', showTick: !1, template: { caret: '<span class="caret"></span>' }, maxOptions: !1, mobile: !1, selectOnTab: !1, dropdownAlignRight: !1, windowPadding: 0, virtualScroll: 600, display: !1 }, K.major === '4' && (u.DEFAULTS.style = 'btn-light', u.DEFAULTS.iconBase = '', u.DEFAULTS.tickIcon = 'bs-ok-default'), u.prototype = { constructor: u, init() { const i = this; const e = this.$element.attr('id'); this.selectId = p++, this.$element.addClass('bs-select-hidden'), this.multiple = this.$element.prop('multiple'), this.autofocus = this.$element.prop('autofocus'), this.$newElement = this.createDropdown(), this.createLi(), this.$element.after(this.$newElement).prependTo(this.$newElement), this.$button = this.$newElement.children('button'), this.$menu = this.$newElement.children(N.MENU), this.$menuInner = this.$menu.children('.inner'), this.$searchbox = this.$menu.find('input'), this.$element.removeClass('bs-select-hidden'), !0 === this.options.dropdownAlignRight && this.$menu.addClass(Y.MENURIGHT), void 0 !== e && this.$button.attr('data-id', e), this.checkDisabled(), this.clickListener(), this.options.liveSearch && this.liveSearchListener(), this.render(), this.setStyle(), this.setWidth(), this.options.container ? this.selectPosition() : this.$element.on(`hide${A}`, () => { if (i.isVirtual()) { const e = i.$menuInner[0]; const t = e.firstChild.cloneNode(!1); e.replaceChild(t, e.firstChild), e.scrollTop = 0 } }), this.$menu.data('this', this), this.$newElement.data('this', this), this.options.mobile && this.mobile(), this.$newElement.on({ 'hide.bs.dropdown': function (e) { i.$menuInner.attr('aria-expanded', !1), i.$element.trigger(`hide${A}`, e) }, 'hidden.bs.dropdown': function (e) { i.$element.trigger(`hidden${A}`, e) }, 'show.bs.dropdown': function (e) { i.$menuInner.attr('aria-expanded', !0), i.$element.trigger(`show${A}`, e) }, 'shown.bs.dropdown': function (e) { i.$element.trigger(`shown${A}`, e) } }), i.$element[0].hasAttribute('required') && this.$element.on('invalid', () => { i.$button.addClass('bs-invalid'), i.$element.on(`shown${A}.invalid`, () => { i.$element.val(i.$element.val()).off(`shown${A}.invalid`) }).on(`rendered${A}`, function () { this.validity.valid && i.$button.removeClass('bs-invalid'), i.$element.off(`rendered${A}`) }), i.$button.on(`blur${A}`, () => { i.$element.focus().blur(), i.$button.off(`blur${A}`) }) }), setTimeout(() => { i.$element.trigger(`loaded${A}`) }) }, createDropdown() { let e; const t = this.multiple || this.options.showTick ? ' show-tick' : ''; const i = this.autofocus ? ' autofocus' : ''; let n = ''; let s = ''; let o = ''; let l = ''; return this.options.header && (n = `<div class="${Y.POPOVERHEADER}"><button type="button" class="close" aria-hidden="true">&times;</button>${this.options.header}</div>`), this.options.liveSearch && (s = `<div class="bs-searchbox"><input type="text" class="form-control" autocomplete="off"${this.options.liveSearchPlaceholder === null ? '' : ` placeholder="${q(this.options.liveSearchPlaceholder)}"`} role="textbox" aria-label="Search"></div>`), this.multiple && this.options.actionsBox && (o = `<div class="bs-actionsbox"><div class="btn-group btn-group-sm btn-block"><button type="button" class="actions-btn bs-select-all btn ${Y.BUTTONCLASS}">${this.options.selectAllText}</button><button type="button" class="actions-btn bs-deselect-all btn ${Y.BUTTONCLASS}">${this.options.deselectAllText}</button></div></div>`), this.multiple && this.options.doneButton && (l = `<div class="bs-donebutton"><div class="btn-group btn-block"><button type="button" class="btn btn-sm ${Y.BUTTONCLASS}">${this.options.doneButtonText}</button></div></div>`), e = `<div class="dropdown bootstrap-select${t}"><button type="button" class="${this.options.styleBase} dropdown-toggle" ${this.options.display === 'static' ? 'data-display="static"' : ''}data-toggle="dropdown"${i} role="button"><div class="filter-option"><div class="filter-option-inner"><div class="filter-option-inner-inner"></div></div> </div>${K.major === '4' ? '' : `<span class="bs-caret">${this.options.template.caret}</span>`}</button><div class="${Y.MENU} ${K.major === '4' ? '' : Y.SHOW}" role="combobox">${n}${s}${o}<div class="inner ${Y.SHOW}" role="listbox" aria-expanded="false" tabindex="-1"><ul class="${Y.MENU} inner ${K.major === '4' ? Y.SHOW : ''}"></ul></div>${l}</div></div>`, G(e) }, setPositionData() { this.selectpicker.view.canHighlight = []; for (let e = 0; e < this.selectpicker.current.data.length; e++) { const t = this.selectpicker.current.data[e]; let i = !0; t.type === 'divider' ? (i = !1, t.height = this.sizeInfo.dividerHeight) : t.type === 'optgroup-label' ? (i = !1, t.height = this.sizeInfo.dropdownHeaderHeight) : t.height = this.sizeInfo.liHeight, t.disabled && (i = !1), this.selectpicker.view.canHighlight.push(i), t.position = (e === 0 ? 0 : this.selectpicker.current.data[e - 1].position) + t.height } }, isVirtual() { return !1 !== this.options.virtualScroll && this.selectpicker.main.elements.length >= this.options.virtualScroll || !0 === this.options.virtualScroll }, createView(C, e) { e = e || 0; const O = this; this.selectpicker.current = C ? this.selectpicker.search : this.selectpicker.main; let z; let T; let H = []; function i(e, t) { let i; let n; let s; let o; let l; let r; let a; let c; let d; let h; const p = O.selectpicker.current.elements.length; const u = []; let f = !0; const m = O.isVirtual(); O.selectpicker.view.scrollTop = e, !0 === m && O.sizeInfo.hasScrollBar && O.$menu[0].offsetWidth > O.sizeInfo.totalMenuWidth && (O.sizeInfo.menuWidth = O.$menu[0].offsetWidth, O.sizeInfo.totalMenuWidth = O.sizeInfo.menuWidth + O.sizeInfo.scrollBarWidth, O.$menu.css('min-width', O.sizeInfo.menuWidth)), i = Math.ceil(O.sizeInfo.menuInnerHeight / O.sizeInfo.liHeight * 1.5), n = Math.round(p / i) || 1; for (var v = 0; v < n; v++) { let g = (v + 1) * i; if (v === n - 1 && (g = p), u[v] = [v * i + (v ? 1 : 0), g], !p) break; void 0 === l && e <= O.selectpicker.current.data[g - 1].position - O.sizeInfo.menuInnerHeight && (l = v) } if (void 0 === l && (l = 0), r = [O.selectpicker.view.position0, O.selectpicker.view.position1], s = Math.max(0, l - 1), o = Math.min(n - 1, l + 1), O.selectpicker.view.position0 = Math.max(0, u[s][0]) || 0, O.selectpicker.view.position1 = Math.min(p, u[o][1]) || 0, a = r[0] !== O.selectpicker.view.position0 || r[1] !== O.selectpicker.view.position1, void 0 !== O.activeIndex && (T = O.selectpicker.current.elements[O.selectpicker.current.map.newIndex[O.prevActiveIndex]], H = O.selectpicker.current.elements[O.selectpicker.current.map.newIndex[O.activeIndex]], z = O.selectpicker.current.elements[O.selectpicker.current.map.newIndex[O.selectedIndex]], t && (O.activeIndex !== O.selectedIndex && (H.classList.remove('active'), H.firstChild && H.firstChild.classList.remove('active')), O.activeIndex = void 0), O.activeIndex && O.activeIndex !== O.selectedIndex && z && z.length && (z.classList.remove('active'), z.firstChild && z.firstChild.classList.remove('active'))), void 0 !== O.prevActiveIndex && O.prevActiveIndex !== O.activeIndex && O.prevActiveIndex !== O.selectedIndex && T && T.length && (T.classList.remove('active'), T.firstChild && T.firstChild.classList.remove('active')), (t || a) && (c = O.selectpicker.view.visibleElements ? O.selectpicker.view.visibleElements.slice() : [], O.selectpicker.view.visibleElements = O.selectpicker.current.elements.slice(O.selectpicker.view.position0, O.selectpicker.view.position1), O.setOptionStatus(), (C || !1 === m && t) && (d = c, h = O.selectpicker.view.visibleElements, f = !(d.length === h.length && d.every((e, t) => e === h[t]))), (t || !0 === m) && f)) { let b; let w; const I = O.$menuInner[0]; const x = document.createDocumentFragment(); const k = I.firstChild.cloneNode(!1); const $ = !0 === m ? O.selectpicker.view.visibleElements : O.selectpicker.current.elements; I.replaceChild(k, I.firstChild); v = 0; for (let E = $.length; v < E; v++)x.appendChild($[v]); !0 === m && (b = O.selectpicker.view.position0 === 0 ? 0 : O.selectpicker.current.data[O.selectpicker.view.position0 - 1].position, w = O.selectpicker.view.position1 > p - 1 ? 0 : O.selectpicker.current.data[p - 1].position - O.selectpicker.current.data[O.selectpicker.view.position1 - 1].position, I.firstChild.style.marginTop = `${b}px`, I.firstChild.style.marginBottom = `${w}px`), I.firstChild.appendChild(x) } if (O.prevActiveIndex = O.activeIndex, O.options.liveSearch) { if (C && t) { let S; let y = 0; O.selectpicker.view.canHighlight[y] || (y = 1 + O.selectpicker.view.canHighlight.slice(1).indexOf(!0)), S = O.selectpicker.view.visibleElements[y], O.selectpicker.view.currentActive && (O.selectpicker.view.currentActive.classList.remove('active'), O.selectpicker.view.currentActive.firstChild && O.selectpicker.view.currentActive.firstChild.classList.remove('active')), S && (S.classList.add('active'), S.firstChild && S.firstChild.classList.add('active')), O.activeIndex = O.selectpicker.current.map.originalIndex[y] } } else O.$menuInner.focus() } this.setPositionData(), i(e, !0), this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, t) { O.noScroll || i(this.scrollTop, t), O.noScroll = !1 }), G(window).off(`resize${A}.${this.selectId}.createView`).on(`resize${A}.${this.selectId}.createView`, () => { O.$newElement.hasClass(Y.SHOW) && i(O.$menuInner[0].scrollTop) }) }, createLi() { let T; const H = this; const D = []; const L = {}; let A = 0; let N = 0; const P = []; let R = 0; let W = 0; let B = -1; this.selectpicker.view.titleOption || (this.selectpicker.view.titleOption = document.createElement('option')); let e; const M = { span: document.createElement('span'), subtext: document.createElement('small'), a: document.createElement('a'), li: document.createElement('li'), whitespace: document.createTextNode('\xa0') }; const U = document.createDocumentFragment(); (H.options.showTick || H.multiple) && ((e = M.span.cloneNode(!1)).className = `${H.options.iconBase} ${H.options.tickIcon} check-mark`, M.a.appendChild(e)), M.a.setAttribute('role', 'option'), M.subtext.className = 'text-muted', M.text = M.span.cloneNode(!1), M.text.className = 'text'; const V = function (e, t, i) { const n = M.li.cloneNode(!1); return e && (e.nodeType === 1 || e.nodeType === 11 ? n.appendChild(e) : n.innerHTML = e), void 0 !== t && t !== '' && (n.className = t), i != null && n.classList.add(`optgroup-${i}`), n }; const j = function (e, t, i) { const n = M.a.cloneNode(!0); return e && (e.nodeType === 11 ? n.appendChild(e) : n.insertAdjacentHTML('beforeend', e)), void 0 !== t && t !== '' && (n.className = t), K.major === '4' && n.classList.add('dropdown-item'), i && n.setAttribute('style', i), n }; const _ = function (e) { let t; let i; const n = M.text.cloneNode(!1); if (e.optionContent)n.innerHTML = e.optionContent; else { if (n.textContent = e.text, e.optionIcon) { const s = M.whitespace.cloneNode(!1); (i = M.span.cloneNode(!1)).className = `${H.options.iconBase} ${e.optionIcon}`, U.appendChild(i), U.appendChild(s) }e.optionSubtext && ((t = M.subtext.cloneNode(!1)).innerHTML = e.optionSubtext, n.appendChild(t)) } return U.appendChild(n), U }; if (this.options.title && !this.multiple) { B--; const t = this.$element[0]; let i = !1; const n = !this.selectpicker.view.titleOption.parentNode; if (n) this.selectpicker.view.titleOption.className = 'bs-title-option', this.selectpicker.view.titleOption.value = '', i = void 0 === G(t.options[t.selectedIndex]).attr('selected') && void 0 === this.$element.data('selected'); (n || this.selectpicker.view.titleOption.index !== 0) && t.insertBefore(this.selectpicker.view.titleOption, t.firstChild), i && (t.selectedIndex = 0) } const F = this.$element.find('option'); F.each(function (e) { const t = G(this); if (B++, !t.hasClass('bs-title-option')) { let i; let n; let s; let o; const l = t.data(); const r = this.className || ''; const a = q(this.style.cssText); const c = l.content; const d = this.textContent; const h = l.tokens; const p = l.subtext; const u = l.icon; const f = t.parent(); const m = f[0]; const v = m.tagName === 'OPTGROUP'; const g = v && m.disabled; const b = this.disabled || g; let w = this.previousElementSibling && this.previousElementSibling.tagName === 'OPTGROUP'; const I = f.data(); if (!0 === l.hidden || this.hidden || H.options.hideDisabled && (b || g)) return i = l.prevHiddenIndex, t.next().data('prevHiddenIndex', void 0 !== i ? i : e), B--, L[e] = { type: 'hidden', data: l }, w || void 0 !== i && (o = F[i].previousElementSibling) && o.tagName === 'OPTGROUP' && !o.disabled && (w = !0), void (w && P[P.length - 1].type !== 'divider' && (B++, D.push(V(!1, Y.DIVIDER, `${R}div`)), P.push({ type: 'divider', optID: R }))); if (v && !0 !== l.divider) { if (H.options.hideDisabled && b) { if (void 0 === I.allOptionsDisabled) { const x = f.children(); f.data('allOptionsDisabled', x.filter(':disabled').length === x.length) } if (f.data('allOptionsDisabled')) return void B-- } const k = ` ${m.className}` || ''; let $ = this.previousElementSibling; if (void 0 !== (i = l.prevHiddenIndex) && ($ = F[i].previousElementSibling), !$) { R += 1; const E = m.label; const S = q(E); const y = I.subtext; const C = I.icon; e !== 0 && D.length > 0 && (B++, D.push(V(!1, Y.DIVIDER, `${R}div`)), P.push({ type: 'divider', optID: R })), B++, s = (function (e) { let t; let i; const n = M.text.cloneNode(!1); if (n.innerHTML = e.labelEscaped, e.labelIcon) { const s = M.whitespace.cloneNode(!1); (i = M.span.cloneNode(!1)).className = `${H.options.iconBase} ${e.labelIcon}`, U.appendChild(i), U.appendChild(s) } return e.labelSubtext && ((t = M.subtext.cloneNode(!1)).textContent = e.labelSubtext, n.appendChild(t)), U.appendChild(n), U }({ labelEscaped: S, labelSubtext: y, labelIcon: C })), D.push(V(s, `dropdown-header${k}`, R)), P.push({ content: S, subtext: y, type: 'optgroup-label', optID: R }), W = B - 1 }n = _({ text: d, optionContent: c, optionSubtext: p, optionIcon: u }), D.push(V(j(n, `opt ${r}${k}`, a), '', R)), P.push({ content: c || d, subtext: p, tokens: h, type: 'option', optID: R, headerIndex: W, lastIndex: W + m.childElementCount, originalIndex: e, data: l }), A++ } else !0 === l.divider ? (D.push(V(!1, Y.DIVIDER)), P.push({ type: 'divider', originalIndex: e, data: l })) : (!w && H.options.hideDisabled && void 0 !== (i = l.prevHiddenIndex) && (o = F[i].previousElementSibling) && o.tagName === 'OPTGROUP' && !o.disabled && (w = !0), w && P[P.length - 1].type !== 'divider' && (B++, D.push(V(!1, Y.DIVIDER, `${R}div`)), P.push({ type: 'divider', optID: R })), n = _({ text: d, optionContent: c, optionSubtext: p, optionIcon: u }), D.push(V(j(n, r, a))), P.push({ content: c || d, subtext: p, tokens: h, type: 'option', originalIndex: e, data: l }), A++); H.selectpicker.main.map.newIndex[e] = B, H.selectpicker.main.map.originalIndex[B] = e; const O = P[P.length - 1]; O.disabled = b; let z = 0; O.content && (z += O.content.length), O.subtext && (z += O.subtext.length), u && (z += 1), N < z && (N = z, T = D[D.length - 1]) } }), this.selectpicker.main.elements = D, this.selectpicker.main.data = P, this.selectpicker.main.hidden = L, this.selectpicker.current = this.selectpicker.main, this.selectpicker.view.widestOption = T, this.selectpicker.view.availableOptionsCount = A }, findLis() { return this.$menuInner.find('.inner > li') }, render() { const e = this; const t = this.$element.find('option'); const i = []; const n = []; this.togglePlaceholder(), this.tabIndex(); for (let s = 0, o = t.length; s < o; s++) { const l = e.selectpicker.main.map.newIndex[s]; const r = t[s]; const a = e.selectpicker.main.data[l] || e.selectpicker.main.hidden[s]; if (r && r.selected && a && (i.push(r), n.length < 100 && e.options.selectedTextFormat !== 'count' || i.length === 1)) { var c; var d; const h = a.data; const p = h.icon && e.options.showIcon ? `<i class="${e.options.iconBase} ${h.icon}"></i> ` : ''; c = e.options.showSubtext && h.subtext && !e.multiple ? ` <small class="text-muted">${h.subtext}</small>` : '', d = r.title ? r.title : h.content && e.options.showContent ? h.content.toString() : p + r.innerHTML.trim() + c, n.push(d) } } let u = this.multiple ? n.join(this.options.multipleSeparator) : n[0]; if (i.length > 50 && (u += '...'), this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1) { const f = this.options.selectedTextFormat.split('>'); if (f.length > 1 && i.length > f[1] || f.length === 1 && i.length >= 2) { const m = this.selectpicker.view.availableOptionsCount; u = (typeof this.options.countSelectedText === 'function' ? this.options.countSelectedText(i.length, m) : this.options.countSelectedText).replace('{0}', i.length.toString()).replace('{1}', m.toString()) } } this.options.title == null && (this.options.title = this.$element.attr('title')), this.options.selectedTextFormat == 'static' && (u = this.options.title), u || (u = void 0 !== this.options.title ? this.options.title : this.options.noneSelectedText), this.$button[0].title = v(u.replace(/<[^>]*>?/g, '').trim()), this.$button.find('.filter-option-inner-inner')[0].innerHTML = u, this.$element.trigger(`rendered${A}`) }, setStyle(e, t) { this.$element.attr('class') && this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, '')); const i = e || this.options.style; t == 'add' ? this.$button.addClass(i) : t == 'remove' ? this.$button.removeClass(i) : (this.$button.removeClass(this.options.style), this.$button.addClass(i)) }, liHeight(e) { if (e || !1 !== this.options.size && !this.sizeInfo) { this.sizeInfo || (this.sizeInfo = {}); const t = document.createElement('div'); const i = document.createElement('div'); const n = document.createElement('div'); const s = document.createElement('ul'); const o = document.createElement('li'); const l = document.createElement('li'); const r = document.createElement('li'); const a = document.createElement('a'); const c = document.createElement('span'); const d = this.options.header && this.$menu.find(`.${Y.POPOVERHEADER}`).length > 0 ? this.$menu.find(`.${Y.POPOVERHEADER}`)[0].cloneNode(!0) : null; const h = this.options.liveSearch ? document.createElement('div') : null; const p = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(!0) : null; const u = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(!0) : null; const f = this.$element.find('option')[0]; if (this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth, c.className = 'text', a.className = `dropdown-item ${f ? f.className : ''}`, t.className = `${this.$menu[0].parentNode.className} ${Y.SHOW}`, t.style.width = `${this.sizeInfo.selectWidth}px`, this.options.width === 'auto' && (i.style.minWidth = 0), i.className = `${Y.MENU} ${Y.SHOW}`, n.className = `inner ${Y.SHOW}`, s.className = `${Y.MENU} inner ${K.major === '4' ? Y.SHOW : ''}`, o.className = Y.DIVIDER, l.className = 'dropdown-header', c.appendChild(document.createTextNode('\u200b')), a.appendChild(c), r.appendChild(a), l.appendChild(c.cloneNode(!0)), this.selectpicker.view.widestOption && s.appendChild(this.selectpicker.view.widestOption.cloneNode(!0)), s.appendChild(r), s.appendChild(o), s.appendChild(l), d && i.appendChild(d), h) { const m = document.createElement('input'); h.className = 'bs-searchbox', m.className = 'form-control', h.appendChild(m), i.appendChild(h) }p && i.appendChild(p), n.appendChild(s), i.appendChild(n), u && i.appendChild(u), t.appendChild(i), document.body.appendChild(t); let v; const g = a.offsetHeight; const b = l ? l.offsetHeight : 0; const w = d ? d.offsetHeight : 0; const I = h ? h.offsetHeight : 0; const x = p ? p.offsetHeight : 0; const k = u ? u.offsetHeight : 0; const $ = G(o).outerHeight(!0); const E = !!window.getComputedStyle && window.getComputedStyle(i); const S = i.offsetWidth; const y = E ? null : G(i); const C = { vert: z(E ? E.paddingTop : y.css('paddingTop')) + z(E ? E.paddingBottom : y.css('paddingBottom')) + z(E ? E.borderTopWidth : y.css('borderTopWidth')) + z(E ? E.borderBottomWidth : y.css('borderBottomWidth')), horiz: z(E ? E.paddingLeft : y.css('paddingLeft')) + z(E ? E.paddingRight : y.css('paddingRight')) + z(E ? E.borderLeftWidth : y.css('borderLeftWidth')) + z(E ? E.borderRightWidth : y.css('borderRightWidth')) }; const O = { vert: C.vert + z(E ? E.marginTop : y.css('marginTop')) + z(E ? E.marginBottom : y.css('marginBottom')) + 2, horiz: C.horiz + z(E ? E.marginLeft : y.css('marginLeft')) + z(E ? E.marginRight : y.css('marginRight')) + 2 }; n.style.overflowY = 'scroll', v = i.offsetWidth - S, document.body.removeChild(t), this.sizeInfo.liHeight = g, this.sizeInfo.dropdownHeaderHeight = b, this.sizeInfo.headerHeight = w, this.sizeInfo.searchHeight = I, this.sizeInfo.actionsHeight = x, this.sizeInfo.doneButtonHeight = k, this.sizeInfo.dividerHeight = $, this.sizeInfo.menuPadding = C, this.sizeInfo.menuExtras = O, this.sizeInfo.menuWidth = S, this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth, this.sizeInfo.scrollBarWidth = v, this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight, this.setPositionData() } }, getSelectPosition() { let e; const t = G(window); const i = this.$newElement.offset(); const n = G(this.options.container); this.options.container && !n.is('body') ? ((e = n.offset()).top += parseInt(n.css('borderTopWidth')), e.left += parseInt(n.css('borderLeftWidth'))) : e = { top: 0, left: 0 }; const s = this.options.windowPadding; this.sizeInfo.selectOffsetTop = i.top - e.top - t.scrollTop(), this.sizeInfo.selectOffsetBot = t.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - e.top - s[2], this.sizeInfo.selectOffsetLeft = i.left - e.left - t.scrollLeft(), this.sizeInfo.selectOffsetRight = t.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - e.left - s[1], this.sizeInfo.selectOffsetTop -= s[0], this.sizeInfo.selectOffsetLeft -= s[3] }, setMenuSize(e) { this.getSelectPosition(); let t; let i; let n; let s; let o; let l; let r; const a = this.sizeInfo.selectWidth; const c = this.sizeInfo.liHeight; const d = this.sizeInfo.headerHeight; const h = this.sizeInfo.searchHeight; const p = this.sizeInfo.actionsHeight; const u = this.sizeInfo.doneButtonHeight; const f = this.sizeInfo.dividerHeight; const m = this.sizeInfo.menuPadding; let v = 0; if (this.options.dropupAuto && (r = c * this.selectpicker.current.elements.length + m.vert, this.$newElement.toggleClass(Y.DROPUP, this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && r + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot)), this.options.size === 'auto')s = this.selectpicker.current.elements.length > 3 ? 3 * this.sizeInfo.liHeight + this.sizeInfo.menuExtras.vert - 2 : 0, i = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert, n = s + d + h + p + u, l = Math.max(s - m.vert, 0), this.$newElement.hasClass(Y.DROPUP) && (i = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert), t = (o = i) - d - h - p - u - m.vert; else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) { for (let g = 0; g < this.options.size; g++) this.selectpicker.current.data[g].type === 'divider' && v++; t = (i = c * this.options.size + v * f + m.vert) - m.vert, o = i + d + h + p + u, n = l = '' } this.options.dropdownAlignRight === 'auto' && this.$menu.toggleClass(Y.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < this.sizeInfo.totalMenuWidth - a), this.$menu.css({ 'max-height': `${o}px`, overflow: 'hidden', 'min-height': `${n}px` }), this.$menuInner.css({ 'max-height': `${t}px`, 'overflow-y': 'auto', 'min-height': `${l}px` }), this.sizeInfo.menuInnerHeight = t, this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight && (this.sizeInfo.hasScrollBar = !0, this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth, this.$menu.css('min-width', this.sizeInfo.totalMenuWidth)), this.dropdown && this.dropdown._popper && this.dropdown._popper.update() }, setSize(e) { if (this.liHeight(e), this.options.header && this.$menu.css('padding-top', 0), !1 !== this.options.size) { let t; const i = this; const n = G(window); let s = 0; this.setMenuSize(), this.options.size === 'auto' ? (this.$searchbox.off('input.setMenuSize propertychange.setMenuSize').on('input.setMenuSize propertychange.setMenuSize', () => i.setMenuSize()), n.off(`resize${A}.${this.selectId}.setMenuSize scroll${A}.${this.selectId}.setMenuSize`).on(`resize${A}.${this.selectId}.setMenuSize scroll${A}.${this.selectId}.setMenuSize`, () => i.setMenuSize())) : this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size && (this.$searchbox.off('input.setMenuSize propertychange.setMenuSize'), n.off(`resize${A}.${this.selectId}.setMenuSize scroll${A}.${this.selectId}.setMenuSize`)), e ? s = this.$menuInner[0].scrollTop : i.multiple || typeof (t = i.selectpicker.main.map.newIndex[i.$element[0].selectedIndex]) === 'number' && !1 !== i.options.size && (s = (s = i.sizeInfo.liHeight * t) - i.sizeInfo.menuInnerHeight / 2 + i.sizeInfo.liHeight / 2), i.createView(!1, s) } }, setWidth() { const i = this; this.options.width === 'auto' ? requestAnimationFrame(() => { i.$menu.css('min-width', '0'), i.liHeight(), i.setMenuSize(); const e = i.$newElement.clone().appendTo('body'); const t = e.css('width', 'auto').children('button').outerWidth(); e.remove(), i.sizeInfo.selectWidth = Math.max(i.sizeInfo.totalMenuWidth, t), i.$newElement.css('width', `${i.sizeInfo.selectWidth}px`) }) : this.options.width === 'fit' ? (this.$menu.css('min-width', ''), this.$newElement.css('width', '').addClass('fit-width')) : this.options.width ? (this.$menu.css('min-width', ''), this.$newElement.css('width', this.options.width)) : (this.$menu.css('min-width', ''), this.$newElement.css('width', '')), this.$newElement.hasClass('fit-width') && this.options.width !== 'fit' && this.$newElement.removeClass('fit-width') }, selectPosition() { this.$bsContainer = G('<div class="bs-container" />'); let n; let s; let o; const l = this; const r = G(this.options.container); const e = function (e) { const t = {}; const i = l.options.display || !!G.fn.dropdown.Constructor.Default && G.fn.dropdown.Constructor.Default.display; l.$bsContainer.addClass(e.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(Y.DROPUP, e.hasClass(Y.DROPUP)), n = e.offset(), r.is('body') ? s = { top: 0, left: 0 } : ((s = r.offset()).top += parseInt(r.css('borderTopWidth')) - r.scrollTop(), s.left += parseInt(r.css('borderLeftWidth')) - r.scrollLeft()), o = e.hasClass(Y.DROPUP) ? 0 : e[0].offsetHeight, (K.major < 4 || i === 'static') && (t.top = n.top - s.top + o, t.left = n.left - s.left), t.width = e[0].offsetWidth, l.$bsContainer.css(t) }; this.$button.on('click.bs.dropdown.data-api', () => { l.isDisabled() || (e(l.$newElement), l.$bsContainer.appendTo(l.options.container).toggleClass(Y.SHOW, !l.$button.hasClass(Y.SHOW)).append(l.$menu)) }), G(window).off(`resize${A}.${this.selectId} scroll${A}.${this.selectId}`).on(`resize${A}.${this.selectId} scroll${A}.${this.selectId}`, () => { l.$newElement.hasClass(Y.SHOW) && e(l.$newElement) }), this.$element.on(`hide${A}`, () => { l.$menu.data('height', l.$menu.height()), l.$bsContainer.detach() }) }, setOptionStatus() { const e = this; const t = this.$element.find('option'); if (e.noScroll = !1, e.selectpicker.view.visibleElements && e.selectpicker.view.visibleElements.length) for (let i = 0; i < e.selectpicker.view.visibleElements.length; i++) { const n = e.selectpicker.current.map.originalIndex[i + e.selectpicker.view.position0]; const s = t[n]; if (s) { const o = this.selectpicker.main.map.newIndex[n]; const l = this.selectpicker.main.elements[o]; e.setDisabled(n, s.disabled || s.parentNode.tagName === 'OPTGROUP' && s.parentNode.disabled, o, l), e.setSelected(n, s.selected, o, l) } } }, setSelected(e, t, i, n) { let s; let o; let l; const r = void 0 !== this.activeIndex; const a = this.activeIndex === e || t && !this.multiple && !r; i || (i = this.selectpicker.main.map.newIndex[e]), n || (n = this.selectpicker.main.elements[i]), l = n.firstChild, t && (this.selectedIndex = e), n.classList.toggle('selected', t), n.classList.toggle('active', a), a && (this.selectpicker.view.currentActive = n, this.activeIndex = e), l && (l.classList.toggle('selected', t), l.classList.toggle('active', a), l.setAttribute('aria-selected', t)), a || !r && t && void 0 !== this.prevActiveIndex && (s = this.selectpicker.main.map.newIndex[this.prevActiveIndex], (o = this.selectpicker.main.elements[s]).classList.remove('active'), o.firstChild && o.firstChild.classList.remove('active')) }, setDisabled(e, t, i, n) { let s; i || (i = this.selectpicker.main.map.newIndex[e]), n || (n = this.selectpicker.main.elements[i]), s = n.firstChild, n.classList.toggle(Y.DISABLED, t), s && (K.major === '4' && s.classList.toggle(Y.DISABLED, t), s.setAttribute('aria-disabled', t), t ? s.setAttribute('tabindex', -1) : s.setAttribute('tabindex', 0)) }, isDisabled() { return this.$element[0].disabled }, checkDisabled() { const e = this; this.isDisabled() ? (this.$newElement.addClass(Y.DISABLED), this.$button.addClass(Y.DISABLED).attr('tabindex', -1).attr('aria-disabled', !0)) : (this.$button.hasClass(Y.DISABLED) && (this.$newElement.removeClass(Y.DISABLED), this.$button.removeClass(Y.DISABLED).attr('aria-disabled', !1)), this.$button.attr('tabindex') != -1 || this.$element.data('tabindex') || this.$button.removeAttr('tabindex')), this.$button.click(() => !e.isDisabled()) }, togglePlaceholder() { const e = this.$element[0]; const t = e.selectedIndex; let i = t === -1; i || e.options[t].value || (i = !0), this.$button.toggleClass('bs-placeholder', i) }, tabIndex() { this.$element.data('tabindex') !== this.$element.attr('tabindex') && this.$element.attr('tabindex') !== -98 && this.$element.attr('tabindex') !== '-98' && (this.$element.data('tabindex', this.$element.attr('tabindex')), this.$button.attr('tabindex', this.$element.data('tabindex'))), this.$element.attr('tabindex', -98) }, clickListener() { const E = this; const t = G(document); function e() { E.options.liveSearch ? E.$searchbox.focus() : E.$menuInner.focus() } function i() { E.dropdown && E.dropdown._popper && E.dropdown._popper.state.isCreated ? e() : requestAnimationFrame(i) }t.data('spaceSelect', !1), this.$button.on('keyup', (e) => { /(32)/.test(e.keyCode.toString(10)) && t.data('spaceSelect') && (e.preventDefault(), t.data('spaceSelect', !1)) }), this.$newElement.on('show.bs.dropdown', () => { K.major > 3 && !E.dropdown && (E.dropdown = E.$button.data('bs.dropdown'), E.dropdown._menu = E.$menu[0]) }), this.$button.on('click.bs.dropdown.data-api', () => { E.$newElement.hasClass(Y.SHOW) || E.setSize() }), this.$element.on(`shown${A}`, () => { E.$menuInner[0].scrollTop !== E.selectpicker.view.scrollTop && (E.$menuInner[0].scrollTop = E.selectpicker.view.scrollTop), K.major > 3 ? requestAnimationFrame(i) : e() }), this.$menuInner.on('click', 'li a', function (e, t) { const i = G(this); const n = E.isVirtual() ? E.selectpicker.view.position0 : 0; const s = E.selectpicker.current.map.originalIndex[i.parent().index() + n]; const o = S(E.$element[0]); const l = E.$element.prop('selectedIndex'); let r = !0; if (E.multiple && E.options.maxOptions !== 1 && e.stopPropagation(), e.preventDefault(), !E.isDisabled() && !i.parent().hasClass(Y.DISABLED)) { const a = E.$element.find('option'); const c = a.eq(s); const d = c.prop('selected'); const h = c.parent('optgroup'); const p = h.find('option'); const u = E.options.maxOptions; const f = h.data('maxOptions') || !1; if (s === E.activeIndex && (t = !0), t || (E.prevActiveIndex = E.activeIndex, E.activeIndex = void 0), E.multiple) { if (c.prop('selected', !d), E.setSelected(s, !d), i.blur(), !1 !== u || !1 !== f) { const m = u < a.filter(':selected').length; const v = f < h.find('option:selected').length; if (u && m || f && v) if (u && u == 1) { a.prop('selected', !1), c.prop('selected', !0); for (var g = 0; g < a.length; g++)E.setSelected(g, !1); E.setSelected(s, !0) } else if (f && f == 1) { h.find('option:selected').prop('selected', !1), c.prop('selected', !0); for (g = 0; g < p.length; g++) { const b = p[g]; E.setSelected(a.index(b), !1) }E.setSelected(s, !0) } else { const w = typeof E.options.maxOptionsText === 'string' ? [E.options.maxOptionsText, E.options.maxOptionsText] : E.options.maxOptionsText; const I = typeof w === 'function' ? w(u, f) : w; let x = I[0].replace('{n}', u); let k = I[1].replace('{n}', f); const $ = G('<div class="notify"></div>'); I[2] && (x = x.replace('{var}', I[2][u > 1 ? 0 : 1]), k = k.replace('{var}', I[2][f > 1 ? 0 : 1])), c.prop('selected', !1), E.$menu.append($), u && m && ($.append(G(`<div>${x}</div>`)), r = !1, E.$element.trigger(`maxReached${A}`)), f && v && ($.append(G(`<div>${k}</div>`)), r = !1, E.$element.trigger(`maxReachedGrp${A}`)), setTimeout(() => { E.setSelected(s, !1) }, 10), $.delay(750).fadeOut(300, function () { G(this).remove() }) } } } else a.prop('selected', !1), c.prop('selected', !0), E.setSelected(s, !0); !E.multiple || E.multiple && E.options.maxOptions === 1 ? E.$button.focus() : E.options.liveSearch && E.$searchbox.focus(), r && (o != S(E.$element[0]) && E.multiple || l != E.$element.prop('selectedIndex') && !E.multiple) && (y = [s, c.prop('selected'), o], E.$element.triggerNative('change')) } }), this.$menu.on('click', `li.${Y.DISABLED} a, .${Y.POPOVERHEADER}, .${Y.POPOVERHEADER} :not(.close)`, function (e) { e.currentTarget == this && (e.preventDefault(), e.stopPropagation(), E.options.liveSearch && !G(e.target).hasClass('close') ? E.$searchbox.focus() : E.$button.focus()) }), this.$menuInner.on('click', '.divider, .dropdown-header', (e) => { e.preventDefault(), e.stopPropagation(), E.options.liveSearch ? E.$searchbox.focus() : E.$button.focus() }), this.$menu.on('click', `.${Y.POPOVERHEADER} .close`, () => { E.$button.click() }), this.$searchbox.on('click', (e) => { e.stopPropagation() }), this.$menu.on('click', '.actions-btn', function (e) { E.options.liveSearch ? E.$searchbox.focus() : E.$button.focus(), e.preventDefault(), e.stopPropagation(), G(this).hasClass('bs-select-all') ? E.selectAll() : E.deselectAll() }), this.$element.on({ change() { E.render(), E.$element.trigger(`changed${A}`, y), y = null }, focus() { E.options.mobile || E.$button.focus() } }) }, liveSearchListener() { const u = this; const f = document.createElement('li'); this.$button.on('click.bs.dropdown.data-api', () => { u.$searchbox.val() && u.$searchbox.val('') }), this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', (e) => { e.stopPropagation() }), this.$searchbox.on('input propertychange', () => { const e = u.$searchbox.val(); if (u.selectpicker.search.map.newIndex = {}, u.selectpicker.search.map.originalIndex = {}, u.selectpicker.search.elements = [], u.selectpicker.search.data = [], e) { const t = []; let i = e.toUpperCase(); const n = {}; const s = []; const o = u._searchStyle(); const l = u.options.liveSearchNormalize; l && (i = m(i)), u._$lisSelected = u.$menuInner.find('.selected'); for (var r = 0; r < u.selectpicker.main.data.length; r++) { var a = u.selectpicker.main.data[r]; n[r] || (n[r] = $(a, i, o, l)), n[r] && void 0 !== a.headerIndex && s.indexOf(a.headerIndex) === -1 && (a.headerIndex > 0 && (n[a.headerIndex - 1] = !0, s.push(a.headerIndex - 1)), n[a.headerIndex] = !0, s.push(a.headerIndex), n[a.lastIndex + 1] = !0), n[r] && a.type !== 'optgroup-label' && s.push(r) }r = 0; for (let c = s.length; r < c; r++) { const d = s[r]; const h = s[r - 1]; const p = (a = u.selectpicker.main.data[d], u.selectpicker.main.data[h]); (a.type !== 'divider' || a.type === 'divider' && p && p.type !== 'divider' && c - 1 !== r) && (u.selectpicker.search.data.push(a), t.push(u.selectpicker.main.elements[d]), a.hasOwnProperty('originalIndex') && (u.selectpicker.search.map.newIndex[a.originalIndex] = t.length - 1, u.selectpicker.search.map.originalIndex[t.length - 1] = a.originalIndex)) }u.activeIndex = void 0, u.noScroll = !0, u.$menuInner.scrollTop(0), u.selectpicker.search.elements = t, u.createView(!0), t.length || (f.className = 'no-results', f.innerHTML = u.options.noneResultsText.replace('{0}', `"${q(e)}"`), u.$menuInner[0].firstChild.appendChild(f)) } else u.$menuInner.scrollTop(0), u.createView(!1) }) }, _searchStyle() { return this.options.liveSearchStyle || 'contains' }, val(e) { return void 0 !== e ? (this.$element.val(e).triggerNative('change'), this.$element) : this.$element.val() }, changeAll(e) { if (this.multiple) { void 0 === e && (e = !0); const t = this.$element.find('option'); let i = 0; let n = 0; const s = S(this.$element[0]); this.$element.addClass('bs-select-hidden'); for (let o = 0; o < this.selectpicker.current.elements.length; o++) { const l = this.selectpicker.current.data[o]; const r = t[this.selectpicker.current.map.originalIndex[o]]; r && !r.disabled && l.type !== 'divider' && (r.selected && i++, r.selected = e, r.selected && n++) } this.$element.removeClass('bs-select-hidden'), i !== n && (this.setOptionStatus(), this.togglePlaceholder(), y = [null, null, s], this.$element.triggerNative('change')) } }, selectAll() { return this.changeAll(!0) }, deselectAll() { return this.changeAll(!1) }, toggle(e) { (e = e || window.event) && e.stopPropagation(), this.$button.trigger('click.bs.dropdown.data-api') }, keydown(e) { let t; let i; let n; let s; let o; const l = G(this); const r = l.hasClass('dropdown-toggle'); const a = (r ? l.closest('.dropdown') : l.closest(N.MENU)).data('this'); const c = a.findLis(); let d = !1; const h = e.which === H && !r && !a.options.selectOnTab; const p = P.test(e.which) || h; const u = a.$menuInner[0].scrollTop; const f = a.isVirtual(); const m = !0 === f ? a.selectpicker.view.position0 : 0; if (!(i = a.$newElement.hasClass(Y.SHOW)) && (p || e.which >= 48 && e.which <= 57 || e.which >= 96 && e.which <= 105 || e.which >= 65 && e.which <= 90) && a.$button.trigger('click.bs.dropdown.data-api'), e.which === C && i && (e.preventDefault(), a.$button.trigger('click.bs.dropdown.data-api').focus()), p) { if (!c.length) return; void 0 === (t = !0 === f ? c.index(c.filter('.active')) : a.selectpicker.current.map.newIndex[a.activeIndex]) && (t = -1), t !== -1 && ((n = a.selectpicker.current.elements[t + m]).classList.remove('active'), n.firstChild && n.firstChild.classList.remove('active')), e.which === D ? (t !== -1 && t--, t + m < 0 && (t += c.length), a.selectpicker.view.canHighlight[t + m] || (t = a.selectpicker.view.canHighlight.slice(0, t + m).lastIndexOf(!0) - m) === -1 && (t = c.length - 1)) : (e.which === L || h) && (++t + m >= a.selectpicker.view.canHighlight.length && (t = 0), a.selectpicker.view.canHighlight[t + m] || (t = t + 1 + a.selectpicker.view.canHighlight.slice(t + m + 1).indexOf(!0))), e.preventDefault(); let v = m + t; e.which === D ? m === 0 && t === c.length - 1 ? (a.$menuInner[0].scrollTop = a.$menuInner[0].scrollHeight, v = a.selectpicker.current.elements.length - 1) : d = (o = (s = a.selectpicker.current.data[v]).position - s.height) < u : (e.which === L || h) && (t === 0 ? v = a.$menuInner[0].scrollTop = 0 : d = u < (o = (s = a.selectpicker.current.data[v]).position - a.sizeInfo.menuInnerHeight)), (n = a.selectpicker.current.elements[v]) && (n.classList.add('active'), n.firstChild && n.firstChild.classList.add('active')), a.activeIndex = a.selectpicker.current.map.originalIndex[v], a.selectpicker.view.currentActive = n, d && (a.$menuInner[0].scrollTop = o), a.options.liveSearch ? a.$searchbox.focus() : l.focus() } else if (!l.is('input') && !R.test(e.which) || e.which === T && a.selectpicker.keydown.keyHistory) { let g; let b; const w = []; e.preventDefault(), a.selectpicker.keydown.keyHistory += E[e.which], a.selectpicker.keydown.resetKeyHistory.cancel && clearTimeout(a.selectpicker.keydown.resetKeyHistory.cancel), a.selectpicker.keydown.resetKeyHistory.cancel = a.selectpicker.keydown.resetKeyHistory.start(), b = a.selectpicker.keydown.keyHistory, /^(.)\1+$/.test(b) && (b = b.charAt(0)); for (let I = 0; I < a.selectpicker.current.data.length; I++) { const x = a.selectpicker.current.data[I]; $(x, b, 'startsWith', !0) && a.selectpicker.view.canHighlight[I] && (x.index = I, w.push(x.originalIndex)) } if (w.length) { let k = 0; c.removeClass('active').find('a').removeClass('active'), b.length === 1 && ((k = w.indexOf(a.activeIndex)) === -1 || k === w.length - 1 ? k = 0 : k++), g = a.selectpicker.current.map.newIndex[w[k]], u - (s = a.selectpicker.current.data[g]).position > 0 ? (o = s.position - s.height, d = !0) : (o = s.position - a.sizeInfo.menuInnerHeight, d = s.position > u + a.sizeInfo.menuInnerHeight), (n = a.selectpicker.current.elements[g]).classList.add('active'), n.firstChild && n.firstChild.classList.add('active'), a.activeIndex = w[k], n.firstChild.focus(), d && (a.$menuInner[0].scrollTop = o), l.focus() } }i && (e.which === T && !a.selectpicker.keydown.keyHistory || e.which === O || e.which === H && a.options.selectOnTab) && (e.which !== T && e.preventDefault(), a.options.liveSearch && e.which === T || (a.$menuInner.find('.active a').trigger('click', !0), l.focus(), a.options.liveSearch || (e.preventDefault(), G(document).data('spaceSelect', !0)))) }, mobile() { this.$element.addClass('mobile-device') }, refresh() { const e = G.extend({}, this.options, this.$element.data()); this.options = e, this.selectpicker.main.map.newIndex = {}, this.selectpicker.main.map.originalIndex = {}, this.createLi(), this.checkDisabled(), this.render(), this.setStyle(), this.setWidth(), this.setSize(!0), this.$element.trigger(`refreshed${A}`) }, hide() { this.$newElement.hide() }, show() { this.$newElement.show() }, remove() { this.$newElement.remove(), this.$element.remove() }, destroy() { this.$newElement.before(this.$element).remove(), this.$bsContainer ? this.$bsContainer.remove() : this.$menu.remove(), this.$element.off(A).removeData('selectpicker').removeClass('bs-select-hidden selectpicker'), G(window).off(`${A}.${this.selectId}`) } }; const g = G.fn.selectpicker; G.fn.selectpicker = f, G.fn.selectpicker.Constructor = u, G.fn.selectpicker.noConflict = function () { return G.fn.selectpicker = g, this }, G(document).off('keydown.bs.dropdown.data-api').on(`keydown${A}`, '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', u.prototype.keydown).on('focusin.modal', '.bootstrap-select [data-toggle="dropdown"], .bootstrap-select [role="listbox"], .bootstrap-select .bs-searchbox input', (e) => { e.stopPropagation() }), G(window).on(`load${A}.data-api`, () => { G('.selectpicker').each(function () { const e = G(this); f.call(e, e.data()) }) })
  }(e))
}))
